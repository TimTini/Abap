#!/usr/bin/env python3
from __future__ import annotations

import argparse
import re
import sys
from pathlib import Path


ATTR_RE = re.compile(
    r"""(?ix)
    (?P<key>[a-z_:][-a-z0-9_:.]*)
    \s*=\s*
    (?:
      "(?P<dq>[^"]*)"
      |
      '(?P<sq>[^']*)'
      |
      (?P<bare>[^\s"'<>=`]+)
    )
    """
)


def _read_text(path: Path) -> str:
    return path.read_text(encoding="utf-8")


def _write_text(path: Path, text: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(text, encoding="utf-8")


def _parse_attrs(open_tag: str) -> dict[str, str]:
    attrs: dict[str, str] = {}
    for m in ATTR_RE.finditer(open_tag):
        key = (m.group("key") or "").strip().lower()
        val = m.group("dq")
        if val is None:
            val = m.group("sq")
        if val is None:
            val = m.group("bare")
        if key:
            attrs[key] = val or ""
    return attrs


def _is_remote_url(url: str) -> bool:
    u = url.strip().lower()
    return u.startswith("http://") or u.startswith("https://") or u.startswith("//")


def _escape_inline_script(js: str) -> str:
    # Prevent accidentally terminating the <script> tag.
    return js.replace("</script>", "<\\/script>")


LINK_TAG_RE = re.compile(r"(?is)<link\b[^>]*>")
SCRIPT_BLOCK_RE = re.compile(r"(?is)<script\b[^>]*>.*?</script>")
SCRIPT_OPEN_RE = re.compile(r"(?is)<script\b[^>]*>")


def inline_stylesheet_links(html: str, base_dir: Path, warnings: list[str]) -> tuple[str, int]:
    replaced = 0

    def repl(m: re.Match[str]) -> str:
        nonlocal replaced
        tag = m.group(0)
        attrs = _parse_attrs(tag)
        rel = (attrs.get("rel") or "").strip().lower()
        href = (attrs.get("href") or "").strip()

        if rel != "stylesheet" or not href:
            return tag
        if _is_remote_url(href):
            warnings.append(f"Skip remote stylesheet: {href}")
            return tag

        css_path = (base_dir / href).resolve()
        if not css_path.exists():
            warnings.append(f"Missing stylesheet: {href}")
            return tag

        css = _read_text(css_path)
        replaced += 1
        return "\n".join(
            [
                "<style>",
                f"/* inlined from: {href} */",
                css.rstrip(),
                "</style>",
            ]
        )

    return LINK_TAG_RE.sub(repl, html), replaced


def inline_script_src(html: str, base_dir: Path, warnings: list[str]) -> tuple[str, int]:
    replaced = 0

    def repl(m: re.Match[str]) -> str:
        nonlocal replaced
        block = m.group(0)

        open_m = SCRIPT_OPEN_RE.match(block)
        if not open_m:
            return block

        open_tag = open_m.group(0)
        attrs = _parse_attrs(open_tag)
        src = (attrs.get("src") or "").strip()
        if not src:
            return block
        if _is_remote_url(src):
            warnings.append(f"Skip remote script: {src}")
            return block

        script_path = (base_dir / src).resolve()
        if not script_path.exists():
            warnings.append(f"Missing script: {src}")
            return block

        js = _read_text(script_path)
        js = _escape_inline_script(js)
        replaced += 1
        return "\n".join(
            [
                "<script>",
                f"// inlined from: {src}",
                js.rstrip(),
                "</script>",
            ]
        )

    return SCRIPT_BLOCK_RE.sub(repl, html), replaced


def main() -> int:
    repo_root = Path(__file__).resolve().parent.parent
    default_in = repo_root / "viewer" / "index.html"
    default_out = repo_root / "viewer" / "index.inline.html"

    parser = argparse.ArgumentParser(description="Inline viewer HTML into a single file (offline).")
    parser.add_argument("--input", type=Path, default=default_in, help="Path to viewer index.html")
    parser.add_argument("--output", type=Path, default=default_out, help="Output HTML file path")
    args = parser.parse_args()

    input_path: Path = args.input
    output_path: Path = args.output

    if not input_path.exists():
        print(f"Input not found: {input_path}", file=sys.stderr)
        return 2

    base_dir = input_path.resolve().parent
    html = _read_text(input_path)

    warnings: list[str] = []
    html, css_count = inline_stylesheet_links(html, base_dir, warnings)
    html, js_count = inline_script_src(html, base_dir, warnings)

    banner = "\n".join(
        [
            "<!--",
            "  AUTO-GENERATED FILE",
            f"  Source: {input_path.as_posix()}",
            "  Generator: scripts/build-inline-viewer.py",
            "  Do not edit this file directly. Regenerate instead.",
            "-->",
            "",
        ]
    )

    _write_text(output_path, banner + html)

    print(f"Generated: {output_path} (inlined {js_count} scripts, {css_count} stylesheets)")
    for w in warnings:
        print(f"WARNING: {w}", file=sys.stderr)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

