<!--
  AUTO-GENERATED FILE
  Source: E:/Documents/MyGitProject/Abap/viewer/index.html
  Generator: scripts/build-inline-viewer.py
  Do not edit this file directly. Regenerate instead.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="abap-viewer-version" content="v2026.02.26-r1">
  <meta name="abap-viewer-updated-at" content="2026-02-26 23:02:10">
  <meta name="abap-viewer-updated-note" content="AI note: Added PATH_DECL synthetic fallback for Viewer/XML values and extras; finalDesc tech-id fallback order is declRef > identifier > value > name. Manual metadata only. Offline only.">
  <title>ABAP Parser Viewer</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b1220;
      --panel: #0f172a;
      --border: #22324a;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --hover: #1e293b;
      --gutter-bg: #0b1526;
      --code-bg: #0b1526;
      --pill-bg: #1e293b;
      --pill-text: #bfdbfe;
      --selected-row-bg: #1e293b;
      --tab-active-bg: #1e293b;
      --tab-active-border: #334155;
      --tab-active-text: #bfdbfe;
      --danger: #fca5a5;
      --overlay: rgba(0, 0, 0, 0.55);
      --layout-left-pane: 48%;
      --layout-splitter-size: 12px;
    }

    :root[data-theme="light"] {
      color-scheme: light;
      --bg: #f6f7f9;
      --panel: #ffffff;
      --border: #d8dde6;
      --text: #222b3a;
      --muted: #6b7280;
      --accent: #1f7ae0;
      --hover: #f3f4f6;
      --gutter-bg: #f8fafc;
      --code-bg: #f8fafc;
      --pill-bg: #eef2ff;
      --pill-text: #3730a3;
      --selected-row-bg: #eef2ff;
      --tab-active-bg: #eef2ff;
      --tab-active-border: #c7d2fe;
      --tab-active-text: #3730a3;
      --danger: #b42318;
      --overlay: rgba(15, 23, 42, 0.5);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, sans-serif;
      color: var(--text);
      background: var(--bg);
      height: 100vh;
      overflow: hidden;
    }

    .container {
      width: 100%;
      max-width: none;
      margin: 0;
      padding: 16px clamp(12px, 2vw, 24px);
      height: 100vh;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    header {
      margin-bottom: 20px;
    }

    header h1 {
      margin: 0 0 6px 0;
      font-size: 22px;
    }

    header p {
      margin: 0;
      color: var(--muted);
    }

    header .build-info {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
      font-family: Consolas, "Courier New", monospace;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }

    .controls input[type="file"] {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 6px;
      border-radius: 6px;
    }

    .controls button {
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
    }

    .controls input[type="search"],
    .controls select {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 13px;
      min-width: 220px;
    }

    .controls .toggle {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      color: var(--muted);
      font-size: 13px;
      user-select: none;
    }

    .controls .secondary {
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .controls .secondary:hover {
      background: var(--hover);
    }

    .secondary {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
    }

    .secondary:hover {
      background: var(--hover);
    }

    .controls .hint {
      flex-basis: 100%;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(320px, var(--layout-left-pane)) var(--layout-splitter-size) minmax(320px, 1fr);
      gap: 0;
      flex: 1;
      min-height: 0;
      align-items: stretch;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      min-height: 300px;
      display: flex;
      flex-direction: column;
      min-height: 0;
      min-width: 0;
    }

    .splitter {
      position: relative;
      touch-action: none;
      cursor: col-resize;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      background-clip: padding-box;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .splitter::before {
      content: "";
      width: 3px;
      height: min(72px, 40%);
      border-radius: 999px;
      background: var(--border);
      transition: background 0.15s ease;
    }

    .splitter:hover::before,
    .splitter:focus-visible::before,
    .layout.is-resizing .splitter::before {
      background: var(--accent);
    }

    .splitter:focus-visible {
      outline: none;
    }

    .layout.is-resizing,
    .layout.is-resizing * {
      cursor: col-resize !important;
      user-select: none;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .panel-header h2 {
      margin: 0;
      font-size: 18px;
    }

    .panel-tabs {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .tab-btn.active {
      background: var(--tab-active-bg);
      border-color: var(--tab-active-border);
      color: var(--tab-active-text);
    }

    .panel > h2 {
      margin: 0 0 10px 0;
      font-size: 18px;
    }

    #inputText {
      width: 100%;
      min-height: 360px;
      padding: 10px;
      font-family: Consolas, monospace;
      font-size: 13px;
      line-height: 18px;
      resize: none;
      flex: 1;
      min-height: 0;
      border: none;
      outline: none;
      white-space: pre;
      overflow-wrap: normal;
      background: transparent;
      color: var(--text);
    }

    .input-editor {
      width: 100%;
      display: flex;
      flex: 1;
      min-height: 0;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      background: var(--panel);
    }

    #inputGutter {
      width: 68px;
      flex: none;
      border-right: 1px solid var(--border);
      background: var(--gutter-bg);
      color: var(--muted);
      font-family: Consolas, monospace;
      font-size: 12px;
      line-height: 18px;
      position: relative;
      overflow: hidden;
      user-select: none;
    }

    #inputGutterContent {
      padding: 10px 6px;
      will-change: transform;
    }

    .gutter-line {
      height: 18px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .gutter-num {
      flex: 1;
      text-align: right;
    }

    .gutter-jump {
      border: 1px solid transparent;
      background: transparent;
      color: var(--muted);
      padding: 0 4px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      line-height: 1.2;
    }

    .gutter-jump:hover {
      background: var(--hover);
      border-color: var(--border);
      color: var(--text);
    }

    .gutter-jump:focus {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }

    .modal textarea {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      font-family: Consolas, monospace;
      font-size: 13px;
      resize: vertical;
      min-height: 140px;
      max-height: 40vh;
      background: var(--panel);
      color: var(--text);
    }

    .error {
      color: var(--danger);
      font-size: 13px;
      margin-top: 8px;
      white-space: pre-wrap;
    }

    #output {
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding-right: 6px;
    }

    #declDescPanel {
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding-right: 6px;
    }

    #templatePreviewPanel {
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding-right: 6px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #output[hidden],
    #templatePreviewPanel[hidden],
    #declDescPanel[hidden] {
      display: none !important;
    }

    .template-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .template-key-mode {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
      margin-right: auto;
    }

    .template-key-badge {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 2px 8px;
      background: var(--pill-bg);
      color: var(--pill-text);
      font-family: Consolas, monospace;
      font-size: 11px;
    }

    .template-config-json {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      font-family: Consolas, monospace;
      font-size: 12px;
      resize: vertical;
      min-height: 180px;
      max-height: 42vh;
      background: var(--panel);
      color: var(--text);
    }

    .template-preview-output {
      flex: 1;
      min-height: 220px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: var(--code-bg);
    }

    .template-block {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 10px;
      background: var(--panel);
    }

    .template-block.selected {
      border-color: var(--accent);
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--accent) 38%, transparent);
    }

    .template-block:last-child {
      margin-bottom: 0;
    }

    .template-block-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
    }

    .template-block-title {
      margin: 0;
      font-size: 14px;
      line-height: 1.3;
    }

    .template-block-meta {
      color: var(--muted);
      font-size: 12px;
    }

    .template-block-actions {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .template-preview-table {
      width: max-content;
      min-width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
      border: 1px solid #c8c8c8;
      background: #ffffff;
      color: #111111;
    }

    .template-preview-table td {
      min-width: 56px;
      max-width: 360px;
      border: 1px solid #d3d3d3;
      padding: 4px 6px;
      vertical-align: top;
      white-space: pre-wrap;
      font-size: 10pt;
      font-family: "MS PGothic", "MS UI Gothic", Meiryo, sans-serif;
      color: #111111;
      background: #ffffff;
    }

    .template-empty {
      color: var(--muted);
      font-size: 13px;
    }

    .template-error {
      color: var(--danger);
      font-size: 13px;
      white-space: pre-wrap;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .card.block {
      border-left: 4px solid var(--accent);
    }

    .card.selected {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }

    .card-title {
      margin: 0;
      font-size: 16px;
      line-height: 1.2;
    }

    .card-actions {
      display: inline-flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .btn-ghost {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 4px 8px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .btn-ghost:hover {
      background: var(--hover);
    }

    .muted {
      color: var(--muted);
      font-size: 13px;
    }

    .raw {
      margin-top: 8px;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--code-bg);
      font-family: Consolas, monospace;
      font-size: 13px;
      white-space: pre-wrap;
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--pill-bg);
      color: var(--pill-text);
      font-size: 12px;
      margin: 2px 4px 2px 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 13px;
    }

    th, td {
      text-align: left;
      border-bottom: 1px solid var(--border);
      padding: 6px 4px;
      vertical-align: top;
    }

    tr.desc-selected td {
      background: var(--selected-row-bg);
    }

    .decl-desc,
    .decl-desc-line {
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .decl-desc-text {
      flex: 1;
      min-width: 0;
      white-space: pre-wrap;
    }

    .icon-btn {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
      padding: 2px 6px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      line-height: 1.1;
    }

    .icon-btn:hover {
      background: var(--hover);
      color: var(--text);
    }

    .icon-btn:focus {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }

    th {
      color: var(--muted);
      font-weight: 600;
    }

    .children {
      margin-top: 12px;
      padding-left: 12px;
      border-left: 2px solid var(--border);
    }

    .extras {
      margin-top: 10px;
      padding-top: 8px;
      border-top: 1px dashed var(--border);
    }

    pre {
      white-space: pre-wrap;
      margin: 6px 0 0 0;
    }

    .modal[hidden] {
      display: none;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: var(--overlay);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 1000;
    }

    .modal-content {
      width: min(1000px, 100%);
      max-height: 85vh;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      gap: 10px;
    }

    .modal-header .modal-actions {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .modal-body {
      padding: 12px;
      overflow: auto;
      min-height: 0;
    }

    .modal-body pre {
      white-space: pre;
      font-family: Consolas, monospace;
      font-size: 12px;
    }

    #editModal,
    #jsonModal {
      z-index: 1100;
    }

    @media (max-width: 980px) {
      .container {
        padding: 12px;
      }

      .layout {
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .splitter {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ABAP Parser Viewer</h1>
      <p>Paste ABAP code (or JSON output) and click Render.</p>
      <p class="build-info" id="buildInfo">Updated: manual timestamp not set.</p>
    </header>

    <div class="controls">
      <input type="file" id="fileInput" accept=".abap,.txt,.json,application/json,text/plain">
      <button type="button" id="parseBtn">Render</button>
      <input type="search" id="searchInput" placeholder="Search (raw/comment/value/decl)…">
      <select id="typeFilter">
        <option value="">All types</option>
      </select>
      <label class="toggle"><input type="checkbox" id="showRaw" checked>raw</label>
      <label class="toggle"><input type="checkbox" id="showKeywords" checked>keywords</label>
      <label class="toggle"><input type="checkbox" id="showValues" checked>values</label>
      <label class="toggle"><input type="checkbox" id="showExtras">extras</label>
      <label class="toggle"><input type="checkbox" id="themeToggle" checked>dark</label>
      <button type="button" id="expandAllBtn" class="secondary">Expand all</button>
      <button type="button" id="collapseAllBtn" class="secondary">Collapse all</button>
      <button type="button" id="clearFiltersBtn" class="secondary">Clear</button>
      <button type="button" id="descBtn" class="secondary">Descriptions</button>
      <button type="button" id="rulesBtn" class="secondary">Rules</button>
      <button type="button" id="settingsBtn" class="secondary">Settings</button>
      <button type="button" id="exportXmlBtn" class="secondary">Export XML</button>
      <span class="muted hint">Tip: click “Code” on a card to select the corresponding lines in the input; click “JSON” to inspect the raw object.</span>
    </div>

    <div class="layout" id="mainLayout">
      <div class="panel">
        <h2>Input (ABAP / JSON)</h2>
        <div class="input-editor" id="inputEditor">
          <div id="inputGutter"><div id="inputGutterContent"></div></div>
          <textarea id="inputText" placeholder="Paste ABAP code here" wrap="off"></textarea>
        </div>
        <div class="error" id="error"></div>
      </div>

      <div
        class="splitter"
        id="panelSplitter"
        role="separator"
        aria-label="Resize code and output panels"
        aria-orientation="vertical"
        tabindex="0"
      ></div>

      <div class="panel">
        <div class="panel-header">
          <h2 id="rightPanelTitle">Output</h2>
          <div class="panel-tabs">
            <button type="button" id="rightTabOutputBtn" class="secondary tab-btn active">Output</button>
            <button type="button" id="rightTabTemplateBtn" class="secondary tab-btn">Template</button>
            <button type="button" id="rightTabDescBtn" class="secondary tab-btn">Descriptions</button>
            <button type="button" id="declDescJsonBtn" class="secondary" hidden>Storage JSON</button>
          </div>
        </div>
        <div id="output" class="muted">No data loaded.</div>
        <div id="templatePreviewPanel" hidden>
          <div class="template-controls">
            <span class="template-key-mode">
              Template key mode
              <span id="templateKeyMode" class="template-key-badge">AUTO: objectType -&gt; DEFAULT</span>
            </span>
            <button type="button" id="templateCopyAllBtn" class="secondary">Copy All</button>
            <button type="button" id="templateResetBtn" class="secondary">Reset default</button>
            <button type="button" id="templateExportBtn" class="secondary">Export config</button>
            <button type="button" id="templateImportBtn" class="secondary">Import config</button>
            <button type="button" id="templateApplyBtn" class="secondary">Apply JSON</button>
            <input type="file" id="templateImportInput" accept=".json,application/json,text/plain" hidden>
          </div>
          <div id="templateConfigError" class="template-error"></div>
          <textarea id="templateConfigJson" class="template-config-json" spellcheck="false" placeholder="Template config JSON..."></textarea>
          <div id="templatePreviewOutput" class="template-preview-output muted">No data loaded.</div>
        </div>
        <div id="declDescPanel" hidden>
          <div class="controls" style="margin-bottom:8px">
            <input type="search" id="declDescSearch" placeholder="Search (type/scope/id/desc)…">
            <label class="toggle"><input type="checkbox" id="declDescMissingOnly" checked>missing only</label>
          </div>
          <div class="muted" style="margin-bottom:6px">Declaration types</div>
          <div id="declDescTypes" class="controls" style="margin-bottom:8px"></div>
          <div class="muted" id="declDescSummary" style="margin-bottom:8px"></div>
          <div id="declDescTable"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="modal" id="jsonModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <strong id="jsonTitle">Object JSON</strong>
        <div class="modal-actions">
          <button type="button" id="jsonCopyBtn" class="secondary">Copy</button>
          <button type="button" id="jsonCloseBtn" class="secondary">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <pre id="jsonPre"></pre>
      </div>
    </div>
  </div>

  <div class="modal" id="editModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <strong>Edit description</strong>
        <div class="modal-actions">
          <button type="button" id="editSaveBtn" class="secondary">Save</button>
          <button type="button" id="editClearBtn" class="secondary">Clear</button>
          <button type="button" id="editCancelBtn" class="secondary">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <div class="muted" id="editLabel" style="margin-bottom:8px"></div>
        <div class="muted" id="editHint" style="margin-bottom:8px"></div>
        <div id="editSingleWrap">
          <textarea id="editDesc" placeholder="Enter description…"></textarea>
        </div>
        <div id="editStructWrap" hidden>
          <div class="muted" style="margin-bottom:6px">Struct description</div>
          <textarea id="editStructDesc" placeholder="Enter struct description…"></textarea>
          <div class="muted" style="margin:8px 0 6px">Item description</div>
          <textarea id="editItemDesc" placeholder="Enter item description…"></textarea>
        </div>
        <div style="margin-top:8px">
          <label class="toggle"><input type="checkbox" id="editSkipNormalize">Skip normalization for this user description</label>
        </div>
        <div class="muted" style="margin-top:8px">Tip: Ctrl+Enter to save, Esc to close.</div>
      </div>
    </div>
  </div>

  <div class="modal" id="rulesModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <strong>Rules</strong>
        <div class="modal-actions">
          <button type="button" id="rulesNewBtn" class="secondary">New</button>
          <button type="button" id="rulesSaveBtn" class="secondary">Save</button>
          <button type="button" id="rulesDeleteBtn" class="secondary">Delete</button>
          <button type="button" id="rulesDownloadBtn" class="secondary">Download</button>
          <button type="button" id="rulesCloseBtn" class="secondary">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <div class="controls" style="margin-bottom:8px">
          <select id="rulesSelect" style="min-width:320px">
            <option value="">(New rule)</option>
          </select>
          <select id="rulesTemplate" style="min-width:220px">
            <option value="startKeyword">Template: startKeyword</option>
            <option value="startPhrase">Template: startPhrase</option>
            <option value="assignment">Template: assignment</option>
          </select>
          <span class="muted">Saved in browser (localStorage). Custom rules take priority when parsing.</span>
        </div>
        <div class="error" id="rulesError"></div>
        <textarea id="rulesJson" placeholder="Paste or edit config JSON here…"></textarea>
        <div class="muted" style="margin-top:8px">Tip: click Save, then Render to test; Download creates a .json you can add into /configs.</div>
      </div>
    </div>
  </div>

  <div class="modal" id="settingsModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <strong>Settings</strong>
        <div class="modal-actions">
          <button type="button" id="settingsSaveBtn" class="secondary">Save</button>
          <button type="button" id="settingsResetBtn" class="secondary">Reset</button>
          <button type="button" id="settingsCloseBtn" class="secondary">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <div class="muted" style="margin-bottom:8px">
          Placeholders:
          <code>{{struct}}</code>, <code>{{item}}</code>, <code>{{desc}}</code>
        </div>

        <div style="margin-bottom:16px">
          <label class="toggle"><input type="checkbox" id="settingsNormalizeDesc">Normalize decl <code>desc</code> (apply templates)</label>
        </div>

        <div style="margin-bottom:16px">
          <div class="muted" style="margin-bottom:6px">Declaration types shown in Descriptions modal</div>
          <div id="settingsDeclTypes" class="controls" style="margin-bottom:0"></div>
        </div>

        <div style="margin-bottom:16px">
          <div class="muted" style="margin-bottom:6px">Struct desc template (used for struct fields)</div>
          <input type="text" id="settingsStructTemplate" placeholder="{{struct}}-{{item}}" style="width:100%">
        </div>

        <div style="margin-bottom:8px">
          <div class="muted" style="margin-bottom:6px">Name normalization templates (use {{desc}})</div>
          <div id="settingsNameTemplates"></div>
        </div>

        <div class="muted" style="margin-top:8px">
          Prefix match: 1 char + CODE (e.g. <code>GCN_TOTAL</code>). If no description, keep technical ID.
        </div>
      </div>
    </div>
  </div>

  <script>
// inlined from: ../shared/abap-parser.js
(function (root, factory) {
  if (typeof module === "object" && module.exports) {
    module.exports = factory();
    return;
  }

  root.AbapParser = factory();
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this), function () {
  "use strict";

  class AbapObject {
    constructor({
      id = null,
      parent = null,
      objectType,
      file,
      lineStart,
      raw,
      block = null,
      extras = null,
      comment,
      keywords,
      values,
      children = []
    }) {
      this.id = id;
      this.parent = parent;
      this.objectType = objectType;
      this.file = file;
      this.lineStart = lineStart;
      this.raw = raw;
      this.block = block;
      this.extras = extras;
      this.comment = comment;
      if (keywords && Object.keys(keywords).length) {
        this.keywords = keywords;
      }
      if (values && Object.keys(values).length) {
        this.values = values;
      }
      this.children = children;
    }
  }

  const registeredConfigs = [];

  function registerConfig(config) {
    registeredConfigs.push(normalizeConfig(config));
  }

  function getConfigs() {
    return registeredConfigs.slice();
  }

  function normalizeConfig(config) {
    const normalized = {
      ...config,
      match: config.match || {},
      block: config.block || null,
      keywordLabels: normalizeMapKeys(config.keywordLabels),
      keywordPhrases: normalizeMapKeys(config.keywordPhrases),
      captureRules: normalizeCaptureRules(config.captureRules),
      valueDescriptions: normalizeValueDescriptions(config.valueDescriptions)
    };

    if (normalized.match.startKeyword) {
      normalized.match.startKeyword = String(normalized.match.startKeyword).toUpperCase();
    }

    if (normalized.match.startPhrase) {
      normalized.match.startTokens = String(normalized.match.startPhrase)
        .trim()
        .toUpperCase()
        .split(/\s+/)
        .filter(Boolean);
    } else {
      normalized.match.startTokens = [];
    }

    if (normalized.block && normalized.block.endKeyword) {
      normalized.block = {
        ...normalized.block,
        endKeyword: String(normalized.block.endKeyword).toUpperCase()
      };
    }

    return normalized;
  }

  function normalizeMapKeys(map) {
    if (!map) {
      return {};
    }

    const output = {};
    for (const key of Object.keys(map)) {
      output[String(key).toUpperCase()] = map[key];
    }
    return output;
  }

  function normalizeCaptureRules(rules) {
    if (!Array.isArray(rules)) {
      return [];
    }

    return rules.map((rule) => {
      const after = rule.after || "";
      const afterTokens = String(after)
        .trim()
        .toUpperCase()
        .split(/\s+/)
        .filter(Boolean);

      const stopTokensUpper = Array.isArray(rule.stopTokens)
        ? rule.stopTokens
            .map((token) => String(token).trim().toUpperCase())
            .filter(Boolean)
        : [];

      return {
        ...rule,
        afterTokens,
        capture: rule.capture || "next",
        stopTokensUpper
      };
    });
  }

  function normalizeValueDescriptions(desc) {
    if (!desc) {
      return {};
    }

    const output = {};
    for (const key of Object.keys(desc)) {
      output[key] = normalizeMapKeys(desc[key]);
    }
    return output;
  }

  function parseAbapText(content, configs, fileName) {
    const lines = String(content || "").split(/\r?\n/);
    const statements = collectStatements(lines);
    const list = Array.isArray(configs) ? configs : registeredConfigs;
    const objects = parseStatements(statements, list, fileName || "");

    const decls = attachDeclarationRefs({ statements, objects, fileName: fileName || "" });

    return {
      file: fileName || "",
      objects,
      decls
    };
  }

  function pickPreferredStatementComment(statementBuffer) {
    if (!statementBuffer || typeof statementBuffer !== "object") {
      return "";
    }

    const lineEntries = Array.isArray(statementBuffer.lineEntries) ? statementBuffer.lineEntries : [];
    for (const entry of lineEntries) {
      const inline = entry && typeof entry.comment === "string" ? entry.comment.trim() : "";
      if (inline) {
        return inline;
      }
    }

    const leading = Array.isArray(statementBuffer.leadingCommentLines) ? statementBuffer.leadingCommentLines : [];
    if (leading.length !== 1) {
      return "";
    }

    const candidate = leading[0];
    const text = candidate && typeof candidate.text === "string" ? candidate.text.trim() : "";
    const line = candidate ? Number(candidate.line || 0) || 0 : 0;
    const lineStart = Number(statementBuffer.lineStart || 0) || 0;

    if (!text || !lineStart || line !== lineStart - 1) {
      return "";
    }

    return text;
  }

  function collectStatements(lines) {
    const statements = [];
    let current = null;
    let pendingComments = [];

    for (let index = 0; index < lines.length; index += 1) {
      const lineNumber = index + 1;
      const rawLine = lines[index];
      const trimmed = rawLine.trim();

      if (!trimmed) {
        if (!current) {
          pendingComments = [];
        }
        continue;
      }

      if (isCommentLine(trimmed)) {
        const commentText = normalizeComment(trimmed);
        if (commentText) {
          if (current) {
            current.comments.push(commentText);
          } else {
            pendingComments.push({ line: lineNumber, text: commentText });
          }
        } else if (!current) {
          // Decorative comment-only lines behave like blank separators.
          pendingComments = [];
        }
        continue;
      }

      const { code, comment } = splitCodeAndInlineComment(rawLine);
      const codeTrim = code.trim();

      if (!codeTrim) {
        if (comment) {
          pendingComments.push({ line: lineNumber, text: comment });
        } else if (!current) {
          // Decorative inline-only comment (e.g. `"----"`) is treated as blank.
          pendingComments = [];
        }
        continue;
      }

      if (!current) {
        const leadingCommentLines = pendingComments.slice();
        const leadingComments = leadingCommentLines
          .map((entry) => (entry && typeof entry.text === "string" ? entry.text : ""))
          .filter(Boolean);

        current = {
          lineStart: lineNumber,
          rawParts: [],
          comments: leadingComments.slice(),
          leadingComments,
          leadingCommentLines,
          lineEntries: []
        };
        pendingComments = [];
      }

      current.rawParts.push(codeTrim);
      if (comment) {
        current.comments.push(comment);
      }
      current.lineEntries.push({ line: lineNumber, code: codeTrim, comment: comment || "" });

      if (codeTrim.endsWith(".")) {
        const raw = current.rawParts.join(" ").replace(/\s+/g, " ").trim();
        const commentText = pickPreferredStatementComment(current);

        statements.push({
          lineStart: current.lineStart,
          raw,
          comment: commentText,
          commentLines: current.comments.filter(Boolean),
          leadingComments: current.leadingComments ? current.leadingComments.slice() : [],
          lineEntries: current.lineEntries.slice()
        });

        current = null;
      }
    }

    return statements;
  }

  function isCommentLine(trimmedLine) {
    return trimmedLine.startsWith("*") || trimmedLine.startsWith('"');
  }

  function normalizeComment(trimmedLine) {
    const normalizeText = (text) => {
      const trimmed = String(text || "").trim();
      if (!trimmed) {
        return "";
      }

      // Treat separator-only comment content as empty.
      if (
        !/[A-Za-z0-9\u00C0-\u024F\u1E00-\u1EFF]/.test(trimmed) &&
        /^[\s*&\-_=~#|\\/.:;,+(){}\[\]<>]+$/.test(trimmed)
      ) {
        return "";
      }

      return trimmed;
    };

    if (trimmedLine.startsWith("*") || trimmedLine.startsWith('"')) {
      return normalizeText(trimmedLine.slice(1));
    }
    return normalizeText(trimmedLine);
  }

  function splitCodeAndInlineComment(line) {
    const text = String(line || "");
    let inSingleQuote = false;
    let inPipe = false;

    for (let index = 0; index < text.length; index += 1) {
      const char = text[index];
      const next = index + 1 < text.length ? text[index + 1] : "";

      if (char === "'" && !inPipe) {
        if (inSingleQuote && next === "'") {
          index += 1;
          continue;
        }
        inSingleQuote = !inSingleQuote;
        continue;
      }

      if (char === "|" && !inSingleQuote) {
        if (inPipe && next === "|") {
          index += 1;
          continue;
        }
        inPipe = !inPipe;
        continue;
      }

      if (char === '"' && !inSingleQuote && !inPipe) {
        const code = text.slice(0, index);
        const comment = normalizeComment(text.slice(index + 1));
        return { code, comment };
      }
    }

    return { code: text, comment: "" };
  }

  function parseStatements(statements, configs, fileName) {
    const roots = [];
    const stack = [];
    let nextId = 1;

    for (const statement of statements) {
      const statementStart = getStatementStartKeyword(statement.raw);
      const currentFrame = stack.length ? stack[stack.length - 1] : null;

      if (currentFrame && statementStart === currentFrame.endKeyword) {
        currentFrame.node.block.endRaw = statement.raw;
        currentFrame.node.block.lineEnd = statement.lineStart;
        stack.pop();
        continue;
      }

      const parentId = currentFrame ? currentFrame.node.id : null;
      const parsedList = parseStatement(statement, configs, fileName, parentId, () => nextId++);
      if (!parsedList || !parsedList.length) {
        continue;
      }

      const targetList = currentFrame ? currentFrame.node.children : roots;
      for (const node of parsedList) {
        targetList.push(node);
        if (node.block && node.block.endKeyword) {
          stack.push({ node, endKeyword: node.block.endKeyword });
        }
      }
    }

    return roots;
  }

  function getStatementStartKeyword(raw) {
    const tokens = tokenize(raw);
    if (!tokens.length) {
      return "";
    }
    return tokens[0].upper;
  }

  function parseStatement(statement, configs, fileName, parentId, nextId) {
    const tokens = tokenize(statement.raw);
    if (tokens.length === 0) {
      return null;
    }

    for (const config of configs) {
      if (!matchesConfig(tokens, config, statement.raw)) {
        continue;
      }

      const startKeyword = config.match && config.match.startKeyword;
      if (startKeyword && isChainedStatementStart(statement.raw, startKeyword)) {
        const chainedStatements = splitChainedStatementWithMeta(statement, startKeyword);
        const chainedObjects = [];
        const structStack = [];

        for (const segment of chainedStatements) {
          const raw = segment && typeof segment === "object" ? segment.raw : segment;
          const overrides = segment && typeof segment === "object"
            ? {
                lineStart: segment.lineStart || null,
                comment: segment.comment || "",
                commentLines: Array.isArray(segment.commentLines) ? segment.commentLines : []
              }
            : null;

          const obj = buildObjectFromRaw(raw, config, statement, fileName, nextId(), parentId, overrides);
          if (!obj) {
            continue;
          }

          const segTokens = tokenize(raw);
          const marker = detectStructMarkerFromTokens(segTokens, startKeyword);
          if (marker) {
            const normalizedName = normalizeIdentifierCandidate(marker.name);
            const nameUpper = normalizedName ? normalizedName.toUpperCase() : "";
            const rootUpper = structStack.length ? structStack[0].nameUpper : nameUpper;
            const isRootBegin = marker.kind === "BEGIN" && structStack.length === 0;

            if (marker.kind === "BEGIN") {
              structStack.push({ nameUpper, name: normalizedName || marker.name });
            } else if (marker.kind === "END") {
              // Pop 1 level when names match; otherwise just pop once (best-effort).
              if (structStack.length) {
                const top = structStack[structStack.length - 1];
                if (top && top.nameUpper && top.nameUpper === nameUpper) {
                  structStack.pop();
                } else {
                  structStack.pop();
                }
              }
            }

            attachStructMeta(obj, {
              kind: marker.kind,
              rootNameUpper: rootUpper || nameUpper,
              depth: marker.kind === "BEGIN" ? structStack.length : structStack.length + 1,
              isDecl: isRootBegin
            });
          } else if (structStack.length) {
            attachStructMeta(obj, {
              kind: "FIELD",
              rootNameUpper: structStack[0].nameUpper,
              depth: structStack.length,
              isDecl: false
            });
          } else {
            attachStructMeta(obj, null);
          }

          chainedObjects.push(obj);
        }

        return chainedObjects.length ? chainedObjects : null;
      }

      const object = buildObjectFromRaw(statement.raw, config, statement, fileName, nextId(), parentId);
      if (object && startKeyword) {
        const marker = detectStructMarkerFromTokens(tokenize(statement.raw), startKeyword);
        if (marker) {
          const normalizedName = normalizeIdentifierCandidate(marker.name);
          const nameUpper = normalizedName ? normalizedName.toUpperCase() : "";
          attachStructMeta(object, {
            kind: marker.kind,
            rootNameUpper: nameUpper,
            depth: 1,
            isDecl: marker.kind === "BEGIN"
          });
        } else {
          attachStructMeta(object, null);
        }
      }
      return object ? [object] : null;
    }

    return null;
  }

  function detectStructMarkerFromTokens(tokens, startKeyword) {
    if (!startKeyword || !Array.isArray(tokens) || tokens.length < 4) {
      return null;
    }

    if (!tokens[0] || tokens[0].upper !== String(startKeyword).toUpperCase()) {
      return null;
    }

    const t1 = tokens[1] ? tokens[1].upper : "";
    const t2 = tokens[2] ? tokens[2].upper : "";
    const t3 = tokens[3] ? tokens[3].raw : "";

    if (t1 === "BEGIN" && t2 === "OF" && t3) {
      return { kind: "BEGIN", name: t3 };
    }

    if (t1 === "END" && t2 === "OF" && t3) {
      return { kind: "END", name: t3 };
    }

    return null;
  }

  function attachStructMeta(obj, meta) {
    if (!obj) {
      return;
    }

    if (!meta) {
      return;
    }

    const existingExtras = obj.extras && typeof obj.extras === "object" ? obj.extras : null;
    obj.extras = {
      ...(existingExtras || {}),
      structDef: {
        kind: meta.kind || "",
        rootNameUpper: meta.rootNameUpper || "",
        depth: Number(meta.depth || 0) || 0,
        isDecl: Boolean(meta.isDecl)
      }
    };
  }

  function matchesConfig(tokens, config, raw) {
    const match = config.match || {};
    const matchType = match.type ? String(match.type).trim().toLowerCase() : "";
    if (matchType === "assignment") {
      return isAssignmentStatement(tokens) && !isMethodCallExpressionStatement(raw);
    }
    if (matchType === "methodcallexpr") {
      return isMethodCallExpressionStatement(raw);
    }
    if (match.startTokens && match.startTokens.length) {
      return matchesTokens(tokens, 0, match.startTokens);
    }

    const startKeyword = match.startKeyword;
    if (startKeyword) {
      return tokens[0].upper === startKeyword;
    }

    return false;
  }

  function buildObjectFromRaw(raw, config, statement, fileName, id, parentId, overrides) {
    return buildObjectFromRawWithOverrides(raw, config, statement, fileName, id, parentId, overrides || null);
  }

  function buildObjectFromRawWithOverrides(raw, config, statement, fileName, id, parentId, overrides) {
    const tokens = tokenize(raw);
    if (tokens.length === 0) {
      return null;
    }

    const commentText = overrides && typeof overrides.comment === "string" ? overrides.comment : statement.comment;
    const commentLines = overrides && Array.isArray(overrides.commentLines)
      ? overrides.commentLines
      : statement.commentLines || [];
    const lineStart = overrides && overrides.lineStart ? Number(overrides.lineStart) || null : statement.lineStart;

    const keywordEntries = detectKeywords(tokens, config);
    const match = config.match || {};
    const matchType = match.type ? String(match.type).trim().toLowerCase() : "";
    let valueEntries = [];
    if (matchType === "assignment") {
      valueEntries = captureAssignmentValues(tokens, commentText);
    } else if (matchType === "methodcallexpr") {
      valueEntries = captureMethodCallExpressionValues(raw, commentText);
    } else {
      valueEntries = captureValues(tokens, config, commentText);
    }

    const keywords = groupEntriesByKey(keywordEntries, "label");
    const values = groupEntriesByKey(valueEntries, "name");

    const extras = buildExtras(config, {
      raw,
      values,
      commentLines
    });
    const block = config.block && config.block.endKeyword
      ? {
          endKeyword: config.block.endKeyword,
          endRaw: "",
          lineEnd: null
        }
      : null;

    return new AbapObject({
      id,
      parent: parentId,
      objectType: config.object,
      file: fileName,
      lineStart,
      raw,
      block,
      extras,
      comment: commentText,
      keywords,
      values,
      children: []
    });
  }

  function isAssignmentStatement(tokens) {
    if (!Array.isArray(tokens) || tokens.length < 3) {
      return false;
    }

    const op = tokens[1] && tokens[1].upper ? tokens[1].upper : "";
    const assignmentOps = new Set(["=", "+=", "-=", "*=", "/=", "?="]);
    return assignmentOps.has(op);
  }

  function isMethodCallExpressionStatement(raw) {
    return Boolean(parseMethodCallExpressionFromRaw(raw));
  }

  function buildExtras(config, context) {
    const extrasConfig = config.extras || null;
    if (!extrasConfig || !extrasConfig.type) {
      return null;
    }

    if (extrasConfig.type === "form") {
      return buildFormExtras(context);
    }

    if (extrasConfig.type === "callFunction") {
      return buildCallFunctionExtras(context);
    }

    if (extrasConfig.type === "callMethod") {
      return buildCallMethodExtras(context);
    }

    if (extrasConfig.type === "callMethodExpr") {
      return buildCallMethodExprExtras(context);
    }

    if (extrasConfig.type === "methodSignature") {
      return buildMethodSignatureExtras(context);
    }

    if (extrasConfig.type === "performCall") {
      return buildPerformCallExtras(context);
    }

    if (extrasConfig.type === "ifCondition") {
      return buildIfConditionExtras(context);
    }

    if (extrasConfig.type === "selectStatement") {
      return buildSelectExtras(context);
    }

    if (extrasConfig.type === "readTable") {
      return buildReadTableExtras(context);
    }

    if (extrasConfig.type === "loopAtItab") {
      return buildLoopAtItabExtras(context);
    }

    if (extrasConfig.type === "modifyItab") {
      return buildModifyItabExtras(context);
    }

    if (extrasConfig.type === "deleteItab") {
      return buildDeleteItabExtras(context);
    }

    return null;
  }

  function buildFormExtras({ raw, values, commentLines }) {
    const map = valuesToFirstValueMap(values);
    const formName = map.name || "";

    const commentInfo = parseFormDocComment(commentLines || []);
    const signature = parseFormSignature(map);

    const docsByNameUpper = new Map(
      commentInfo.params.map((param) => [param.name.toUpperCase(), param])
    );

    const params = signature.params.map((param) => {
      const doc = docsByNameUpper.get(param.name.toUpperCase());
      return {
        ...param,
        doc: doc ? { direction: doc.direction, text: doc.text } : null
      };
    });

    const docOnly = commentInfo.params
      .filter((param) => !signature.namesUpper.has(param.name.toUpperCase()))
      .map((param) => ({
        name: param.name,
        section: "DOC_ONLY",
        typing: null,
        doc: { direction: param.direction, text: param.text }
      }));

    return {
      form: {
        name: formName,
        nameFromComment: commentInfo.formName || "",
        params: [...params, ...docOnly],
        exceptions: signature.exceptions
      }
    };
  }

  function buildCallFunctionExtras({ values }) {
    const map = valuesToFirstValueMap(values);

    return {
      callFunction: {
        name: map.name || "",
        destination: map.destination || "",
        exporting: parseAssignments(map.exportingRaw || ""),
        importing: parseAssignments(map.importingRaw || ""),
        changing: parseAssignments(map.changingRaw || ""),
        tables: parseAssignments(map.tablesRaw || ""),
        exceptions: parseAssignments(map.exceptionsRaw || "")
      }
    };
  }

  function buildCallMethodExtras({ values }) {
    const map = valuesToFirstValueMap(values);

    return {
      callMethod: {
        target: map.target || "",
        exporting: parseAssignments(map.exportingRaw || ""),
        importing: parseAssignments(map.importingRaw || ""),
        changing: parseAssignments(map.changingRaw || ""),
        receiving: parseAssignments(map.receivingRaw || ""),
        exceptions: parseAssignments(map.exceptionsRaw || "")
      }
    };
  }

  function buildCallMethodExprExtras({ raw, values }) {
    const map = valuesToFirstValueMap(values);
    const parsed = parseMethodCallExpressionFromRaw(raw);
    const sections = parsed ? parsed.sectionRawByName : {
      exportingRaw: "",
      importingRaw: "",
      changingRaw: "",
      receivingRaw: "",
      exceptionsRaw: ""
    };

    const receivingRaw = map.receivingRaw
      || sections.receivingRaw
      || (parsed && parsed.receivingTarget ? `result = ${parsed.receivingTarget}` : "");

    return {
      callMethod: {
        target: map.target || (parsed ? parsed.callTarget : ""),
        exporting: parseAssignments(map.exportingRaw || sections.exportingRaw || ""),
        importing: parseAssignments(map.importingRaw || sections.importingRaw || ""),
        changing: parseAssignments(map.changingRaw || sections.changingRaw || ""),
        receiving: parseAssignments(receivingRaw),
        exceptions: parseAssignments(map.exceptionsRaw || sections.exceptionsRaw || "")
      }
    };
  }

  function buildMethodSignatureExtras({ values }) {
    const map = valuesToFirstValueMap(values);
    const signature = parseMethodSignature(map);

    return {
      methodSignature: signature
    };
  }

  function parseMethodSignature(valueMap) {
    const importingParams = parseFormParamDefs("IMPORTING", valueMap.importingRaw || "");
    const exportingParams = parseFormParamDefs("EXPORTING", valueMap.exportingRaw || "");
    const changingParams = parseFormParamDefs("CHANGING", valueMap.changingRaw || "");
    const returningParams = parseFormParamDefs("RETURNING", valueMap.returningRaw || "");
    const exceptions = parseFormExceptions(valueMap.raisingRaw || "");

    return {
      name: valueMap.name || "",
      params: [...importingParams, ...exportingParams, ...changingParams, ...returningParams],
      exceptions
    };
  }

  function buildPerformCallExtras({ values }) {
    const map = valuesToFirstValueMap(values);
    const ifCondition = map.ifCondition || "";

    return {
      performCall: {
        form: map.form || "",
        program: map.program || "",
        ifCondition,
        ifConditions: parseConditionClauses(ifCondition, { allowImplicitAnd: false }),
        using: parseArgumentTokens(map.usingRaw || "").map((value) => ({ value })),
        changing: parseArgumentTokens(map.changingRaw || "").map((value) => ({ value })),
        tables: parseArgumentTokens(map.tablesRaw || "").map((value) => ({ value }))
      }
    };
  }

  function buildIfConditionExtras({ values }) {
    const map = valuesToFirstValueMap(values);
    const conditionRaw = map.condition || "";

    return {
      ifCondition: {
        conditionRaw,
        conditions: parseConditionClauses(conditionRaw, { allowImplicitAnd: false })
      }
    };
  }

  function buildSelectExtras({ values }) {
    const map = valuesToFirstValueMap(values);
    const whereRaw = map.where || "";
    const havingRaw = map.having || "";

    return {
      select: {
        whereRaw,
        whereConditions: parseConditionClauses(whereRaw, { allowImplicitAnd: false }),
        havingRaw,
        havingConditions: parseConditionClauses(havingRaw, { allowImplicitAnd: false })
      }
    };
  }

  function buildReadTableExtras({ values }) {
    const map = valuesToFirstValueMap(values);
    const withKeyRaw = map.withKey || "";
    const withTableKeyRaw = map.withTableKey || "";

    const normalizedWithTableKey = normalizeReadTableKeyConditionSource(withTableKeyRaw);
    const conditionSource = withTableKeyRaw ? normalizedWithTableKey : withKeyRaw;

    return {
      readTable: {
        itab: map.itab || "",
        index: map.index || "",
        into: map.into || "",
        assigning: map.assigning || "",
        refInto: map.refInto || "",
        withKeyRaw,
        withTableKeyRaw,
        conditions: parseConditionClauses(conditionSource, { allowImplicitAnd: true })
      }
    };
  }

  function buildLoopAtItabExtras({ values }) {
    const map = valuesToFirstValueMap(values);
    const whereRaw = map.where || "";

    return {
      loopAtItab: {
        itab: map.itab || "",
        into: map.into || "",
        assigning: map.assigning || "",
        refInto: map.refInto || "",
        from: map.from || "",
        to: map.to || "",
        whereRaw,
        conditions: parseConditionClauses(whereRaw, { allowImplicitAnd: false })
      }
    };
  }

  function buildModifyItabExtras({ values }) {
    const map = valuesToFirstValueMap(values);
    const whereRaw = map.where || "";

    return {
      modifyItab: {
        itab: map.itab || map.itabOrDbtab || "",
        from: map.from || "",
        index: map.index || "",
        transporting: map.transporting || "",
        whereRaw,
        conditions: parseConditionClauses(whereRaw, { allowImplicitAnd: false })
      }
    };
  }

  function buildDeleteItabExtras({ values }) {
    const map = valuesToFirstValueMap(values);
    const whereRaw = map.where || "";

    return {
      deleteItab: {
        target: map.target || "",
        from: map.from || "",
        index: map.index || "",
        whereRaw,
        conditions: parseConditionClauses(whereRaw, { allowImplicitAnd: false })
      }
    };
  }

  function attachDeclarationRefs({ statements, objects, fileName }) {
    const allObjects = collectAllObjects(objects);
    const idToObject = new Map(allObjects.filter((obj) => obj && obj.id).map((obj) => [obj.id, obj]));
    const procedureBlocks = allObjects
      .filter((obj) => obj && ["FORM", "METHOD"].includes(obj.objectType))
      .filter((obj) => obj.block && obj.block.lineEnd);
    const classBlocks = allObjects
      .filter((obj) => obj && obj.objectType === "CLASS")
      .filter((obj) => obj.block && obj.block.lineEnd);

    const classInfo = buildClassInfo(allObjects);
    const scopeInfoById = buildScopeInfoById({ idToObject });

    const declByScope = new Map();
    ensureScopeMap(declByScope, 0);

    for (const obj of allObjects) {
      const scopeId = getDeclarationScopeId(obj, idToObject, procedureBlocks, classBlocks);
      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);
      const declaredNames = getDeclaredNamesFromObject(obj);
      for (const name of declaredNames) {
        addDecl(declByScope, scopeId, name, buildDeclInfoFromObject(obj, name, scopeInfo));
      }

      if (obj.objectType === "FORM" && obj.extras && obj.extras.form && Array.isArray(obj.extras.form.params)) {
        const formScopeInfo = scopeInfoById.get(obj.id) || buildFallbackScopeInfo(obj.id);
        for (const param of obj.extras.form.params) {
          if (!param || !param.name) {
            continue;
          }
          addDecl(declByScope, obj.id, param.name, {
            id: obj.id,
            objectType: "FORM_PARAM",
            name: param.name,
            file: obj.file || fileName || "",
            lineStart: obj.lineStart || null,
            raw: obj.raw || "",
            comment: param.doc ? param.doc.text || "" : "",
            scopeId: obj.id,
            scopeLabel: formScopeInfo.scopeLabel,
            scopeType: formScopeInfo.scopeType,
            scopeName: formScopeInfo.scopeName
          });
        }
      }
    }

    for (const statement of statements || []) {
      const inlineNames = extractInlineDeclarations(statement.raw || "");
      if (!inlineNames.length) {
        continue;
      }

      const scopeId = getStatementScopeId(statement.lineStart, procedureBlocks, classBlocks);
      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);
      for (const name of inlineNames) {
        addDecl(declByScope, scopeId, name, {
          id: null,
          objectType: "INLINE",
          name,
          file: fileName || "",
          lineStart: statement.lineStart || null,
          raw: statement.raw || "",
          comment: statement.comment || "",
          scopeId,
          scopeLabel: scopeInfo.scopeLabel,
          scopeType: scopeInfo.scopeType,
          scopeName: scopeInfo.scopeName
        });
      }
    }

    const structDefs = buildStructDefsFromStatements({
      statements,
      procedureBlocks,
      classBlocks,
      scopeInfoById,
      fileName: fileName || ""
    });

    attachStructFieldDecls({
      allObjects,
      idToObject,
      declByScope,
      scopeInfoById,
      procedureBlocks,
      classBlocks,
      classInfo,
      fileName: fileName || "",
      structDefs
    });

    for (const obj of allObjects) {
      const resolveContext = buildResolveContext(obj, idToObject, declByScope, classInfo);
      annotateValuesWithDecls(obj.values, resolveContext);
      annotateExtrasWithDecls(obj.extras, resolveContext);
    }

    attachPerformOriginDecls({ allObjects, formsByNameUpper: buildFormsByNameUpper(allObjects), scopeInfoById });

    const decls = [];
    for (const scopeMap of declByScope.values()) {
      for (const decl of scopeMap.values()) {
        decls.push(decl);
      }
    }
    return decls;
  }

  function ensureStructDefScopeMap(mapByScope, scopeId) {
    if (!mapByScope.has(scopeId)) {
      mapByScope.set(scopeId, new Map());
    }
  }

  function buildStructDefsFromStatements({ statements, procedureBlocks, classBlocks, scopeInfoById, fileName }) {
    const dataByScope = new Map();
    const typeByScope = new Map();

    for (const statement of statements || []) {
      const startKeyword = getStatementStartKeyword(statement.raw || "");
      if (startKeyword !== "DATA" && startKeyword !== "TYPES") {
        continue;
      }

      const lineEntries = Array.isArray(statement.lineEntries) ? statement.lineEntries : [];
      if (!lineEntries.length) {
        continue;
      }

      const scopeId = getStatementScopeId(statement.lineStart, procedureBlocks, classBlocks);
      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);

      const defs = parseStructDefsFromLineEntries({
        kind: startKeyword,
        lineEntries,
        leadingComments: Array.isArray(statement.leadingComments) ? statement.leadingComments : [],
        fileName: fileName || "",
        scopeId,
        scopeInfo
      });

      const target = startKeyword === "DATA" ? dataByScope : typeByScope;
      ensureStructDefScopeMap(target, scopeId);
      const scopeMap = target.get(scopeId);

      for (const def of defs) {
        if (!def || !def.nameUpper) {
          continue;
        }
        if (!scopeMap.has(def.nameUpper)) {
          scopeMap.set(def.nameUpper, def);
        }
      }
    }

    return { dataByScope, typeByScope };
  }

  function parseStructDefsFromLineEntries({ kind, lineEntries, leadingComments, fileName, scopeId, scopeInfo }) {
    const defs = [];
    let current = null;
    const stack = [];
    const leadingText = Array.isArray(leadingComments) ? leadingComments.filter(Boolean).join(" ").trim() : "";

    function currentNestedPrefix() {
      if (stack.length <= 1) {
        return "";
      }
      return stack
        .slice(1)
        .map((ctx) => ctx.name)
        .filter(Boolean)
        .join("-");
    }

    function addField(path, info) {
      if (!current || !path) {
        return;
      }

      const normalized = normalizeIdentifierCandidate(path);
      if (!normalized) {
        return;
      }

      const pathUpper = normalized.toUpperCase();
      if (!current.fields.has(pathUpper)) {
        current.fields.set(pathUpper, {
          path: normalized,
          pathUpper,
          file: fileName || "",
          lineStart: info && info.lineStart ? info.lineStart : null,
          raw: info && info.raw ? info.raw : "",
          comment: info && info.comment ? info.comment : ""
        });
      }
    }

    for (const entry of lineEntries) {
      const code = String(entry && entry.code ? entry.code : "").trim();
      if (!code) {
        continue;
      }

      const comment = entry && entry.comment ? String(entry.comment || "") : "";
      const lineStart = entry && entry.line ? Number(entry.line || 0) || null : null;

      const withoutDot = code.replace(/\.$/, "").trim();
      const segments = splitByCommaOutsideQuotes(withoutDot)
        .map((segment) => segment.trim())
        .filter(Boolean);

      for (const segment of segments) {
        const marker = parseStructMarker(segment);
        if (marker && marker.kind === "BEGIN") {
          const name = normalizeIdentifierCandidate(marker.name);
          if (!name) {
            continue;
          }
          const nameUpper = name.toUpperCase();

          if (!stack.length) {
            current = {
              kind,
              name,
              nameUpper,
              file: fileName || "",
              scopeId,
              scopeLabel: scopeInfo ? scopeInfo.scopeLabel : "",
              lineStart,
              rawStart: segment,
              comment: String(comment || "").trim() || leadingText,
              fields: new Map()
            };
            stack.push({ name, nameUpper });
            continue;
          }

          const prefix = currentNestedPrefix();
          const path = prefix ? `${prefix}-${name}` : name;
          addField(path, { lineStart, raw: segment, comment: String(comment || "").trim() });
          stack.push({ name, nameUpper });
          continue;
        }

        if (marker && marker.kind === "END") {
          const name = normalizeIdentifierCandidate(marker.name);
          const nameUpper = name ? name.toUpperCase() : "";

          if (stack.length) {
            const top = stack[stack.length - 1];
            if (top && top.nameUpper && nameUpper && top.nameUpper === nameUpper) {
              stack.pop();
            } else {
              stack.pop();
            }
          }

          if (!stack.length && current) {
            defs.push(current);
            current = null;
          }
          continue;
        }

        if (!stack.length || !current) {
          continue;
        }

        const fieldName = extractStructFieldName(segment);
        if (!fieldName) {
          continue;
        }

        const prefix = currentNestedPrefix();
        const path = prefix ? `${prefix}-${fieldName}` : fieldName;
        addField(path, { lineStart, raw: segment, comment: String(comment || "").trim() });
      }
    }

    return defs;
  }

  function parseStructMarker(segment) {
    const text = String(segment || "");
    const beginMatch = text.match(/\bBEGIN\s+OF\s+([A-Za-z_][A-Za-z0-9_]*)/i);
    if (beginMatch) {
      return { kind: "BEGIN", name: beginMatch[1] };
    }

    const endMatch = text.match(/\bEND\s+OF\s+([A-Za-z_][A-Za-z0-9_]*)/i);
    if (endMatch) {
      return { kind: "END", name: endMatch[1] };
    }

    return null;
  }

  function extractStructFieldName(segment) {
    const text = String(segment || "").trim();
    if (!text) {
      return "";
    }

    const match = text.match(/^([A-Za-z_][A-Za-z0-9_]*)/);
    if (!match) {
      return "";
    }

    const candidate = match[1] || "";
    const upper = candidate.toUpperCase();
    if (["BEGIN", "END", "INCLUDE"].includes(upper)) {
      return "";
    }

    return normalizeIdentifierCandidate(candidate) || "";
  }

  function resolveStructDefByContext(typeUpper, context, typeStructDefsByScope) {
    if (!typeUpper || !typeStructDefsByScope) {
      return null;
    }

    const procMap = context && context.procId ? typeStructDefsByScope.get(context.procId) : null;
    if (procMap && procMap.has(typeUpper)) {
      return procMap.get(typeUpper);
    }

    const classMap = context && context.classDefId ? typeStructDefsByScope.get(context.classDefId) : null;
    if (classMap && classMap.has(typeUpper)) {
      return classMap.get(typeUpper);
    }

    const globalMap = typeStructDefsByScope.get(0);
    if (globalMap && globalMap.has(typeUpper)) {
      return globalMap.get(typeUpper);
    }

    return null;
  }

  function getStructTypeCandidateFromDeclObject(obj) {
    if (!obj) {
      return "";
    }

    const type = getFirstValue(obj.values, "type");
    const like = getFirstValue(obj.values, "like");
    const structure = getFirstValue(obj.values, "structure");

    const candidate = type || like || structure;
    const normalized = normalizeIdentifierCandidate(candidate);
    return normalized || "";
  }

  function patchDeclComment(declByScope, scopeId, nameUpper, comment) {
    const trimmed = String(comment || "").trim();
    if (!declByScope || !declByScope.has(scopeId)) {
      return;
    }

    const scopeMap = declByScope.get(scopeId);
    if (!scopeMap || !scopeMap.has(nameUpper)) {
      return;
    }

    const decl = scopeMap.get(nameUpper);
    if (decl && String(decl.comment || "").trim() !== trimmed) {
      decl.comment = trimmed;
    }
  }

  function attachStructFieldDecls({
    allObjects,
    idToObject,
    declByScope,
    scopeInfoById,
    procedureBlocks,
    classBlocks,
    classInfo,
    fileName,
    structDefs
  }) {
    const dataByScope = structDefs && structDefs.dataByScope ? structDefs.dataByScope : new Map();
    const typeByScope = structDefs && structDefs.typeByScope ? structDefs.typeByScope : new Map();

    // 1) DATA inline structs: create `${var}-${field}` decls with per-field comments.
    for (const [scopeId, defsByName] of dataByScope.entries()) {
      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);

      for (const def of defsByName.values()) {
        if (!def || !def.name || !def.nameUpper) {
          continue;
        }

        patchDeclComment(declByScope, scopeId, def.nameUpper, def.comment || "");

        for (const field of def.fields.values()) {
          const fullName = `${def.name}-${field.path}`;
          addDecl(declByScope, scopeId, fullName, {
            id: null,
            objectType: "STRUCT_FIELD",
            name: fullName,
            file: fileName || "",
            lineStart: field.lineStart || null,
            raw: field.raw || "",
            comment: field.comment || "",
            scopeId,
            scopeLabel: scopeInfo.scopeLabel,
            scopeType: scopeInfo.scopeType,
            scopeName: scopeInfo.scopeName,
            structName: def.name,
            fieldPath: field.path,
            structObjectType: def.kind || "DATA",
            structLineStart: def.lineStart || null,
            structRaw: def.rawStart || "",
            structComment: def.comment || ""
          });
        }
      }
    }

    // 2) Typed declarations: `DATA ls_s TYPE ty_s.` -> create `ls_s-field` from `TYPES ... BEGIN OF ty_s`.
    for (const obj of allObjects || []) {
      if (!obj || !obj.objectType || !obj.values) {
        continue;
      }

      const structMeta = obj.extras && typeof obj.extras === "object" ? obj.extras.structDef : null;
      if (structMeta && structMeta.isDecl === false) {
        continue;
      }

      const declName = getFirstValue(obj.values, "name");
      const normalizedDeclName = normalizeIdentifierCandidate(declName);
      if (!normalizedDeclName) {
        continue;
      }

      const scopeId = getDeclarationScopeId(obj, idToObject, procedureBlocks, classBlocks);
      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);

      // Skip if already an inline DATA struct in the same scope (DATA wins; addDecl also protects).
      const dataScopeMap = dataByScope.get(scopeId);
      if (dataScopeMap && dataScopeMap.has(normalizedDeclName.toUpperCase())) {
        continue;
      }

      const typeName = getStructTypeCandidateFromDeclObject(obj);
      if (!typeName) {
        continue;
      }

      const typeUpper = typeName.toUpperCase();
      const context = buildResolveContext(obj, idToObject, declByScope, classInfo);
      const typeDef = resolveStructDefByContext(typeUpper, context, typeByScope);
      if (!typeDef) {
        continue;
      }

      patchDeclComment(declByScope, typeDef.scopeId || scopeId, typeUpper, typeDef.comment || "");

      for (const field of typeDef.fields.values()) {
        const fullName = `${normalizedDeclName}-${field.path}`;
        addDecl(declByScope, scopeId, fullName, {
          id: null,
          objectType: "STRUCT_FIELD",
          name: fullName,
          file: fileName || "",
          lineStart: field.lineStart || null,
          raw: field.raw || "",
          comment: field.comment || "",
          scopeId,
          scopeLabel: scopeInfo.scopeLabel,
          scopeType: scopeInfo.scopeType,
          scopeName: scopeInfo.scopeName,
          structName: normalizedDeclName,
          fieldPath: field.path,
          structObjectType: obj.objectType || "DATA",
          structId: obj.id || null,
          structLineStart: obj.lineStart || null,
          structRaw: obj.raw || "",
          structComment: obj.comment || "",
          structTypeName: typeDef.name || typeName,
          structTypeLineStart: typeDef.lineStart || null,
          structTypeRaw: typeDef.rawStart || "",
          structTypeComment: typeDef.comment || ""
        });
      }
    }
  }

  function collectAllObjects(roots) {
    const list = [];
    for (const root of roots || []) {
      walkObject(root, list);
    }
    return list;
  }

  function walkObject(node, list) {
    if (!node) {
      return;
    }

    list.push(node);
    if (Array.isArray(node.children)) {
      for (const child of node.children) {
        walkObject(child, list);
      }
    }
  }

  function buildClassInfo(allObjects) {
    const byName = new Map();
    for (const obj of allObjects) {
      if (!obj || obj.objectType !== "CLASS") {
        continue;
      }
      const className = getFirstValue(obj.values, "name");
      if (!className) {
        continue;
      }
      const classNameUpper = className.toUpperCase();
      const kind = classifyClassBlock(obj.raw || "");
      if (!byName.has(classNameUpper)) {
        byName.set(classNameUpper, { definition: null, implementation: null });
      }
      const entry = byName.get(classNameUpper);
      if (kind === "DEFINITION") {
        entry.definition = obj;
      } else if (kind === "IMPLEMENTATION") {
        entry.implementation = obj;
      }
    }

    const methodParamsByClassAndName = new Map();
    for (const [classNameUpper, entry] of byName.entries()) {
      const classDef = entry.definition;
      if (!classDef || !Array.isArray(classDef.children)) {
        continue;
      }

      for (const child of classDef.children) {
        if (!child || !["METHODS", "CLASS-METHODS"].includes(child.objectType)) {
          continue;
        }

        const methodName = getFirstValue(child.values, "name");
        if (!methodName) {
          continue;
        }

        const signature = child.extras && child.extras.methodSignature ? child.extras.methodSignature : null;
        const params = signature && Array.isArray(signature.params) ? signature.params : [];
        const paramsByNameUpper = new Map();

        for (const param of params) {
          if (!param || !param.name) {
            continue;
          }
          paramsByNameUpper.set(param.name.toUpperCase(), {
            id: child.id,
            objectType: "METHOD_PARAM",
            name: param.name,
            file: child.file || "",
            lineStart: child.lineStart || null,
            raw: child.raw || "",
            comment: "",
            scopeId: child.id,
            scopeLabel: `METHODSIG:${classNameUpper}=>${methodName.toUpperCase()}`,
            scopeType: "METHODSIG",
            scopeName: methodName
          });
        }

        methodParamsByClassAndName.set(`${classNameUpper}:${methodName.toUpperCase()}`, {
          classNameUpper,
          methodNameUpper: methodName.toUpperCase(),
          paramsByNameUpper,
          signatureId: child.id
        });
      }
    }

    return {
      byName,
      methodParamsByClassAndName
    };
  }

  function classifyClassBlock(raw) {
    const upper = String(raw || "").toUpperCase();
    if (upper.includes(" DEFINITION")) {
      return "DEFINITION";
    }
    if (upper.includes(" IMPLEMENTATION")) {
      return "IMPLEMENTATION";
    }
    return "";
  }

  function getFirstValue(values, name) {
    if (!values) {
      return "";
    }

    if (Array.isArray(values)) {
      for (const entry of values) {
        if (entry && entry.name === name) {
          return entry.value || "";
        }
      }
      return "";
    }

    if (typeof values !== "object") {
      return "";
    }

    const entryOrList = values[name];
    if (!entryOrList) {
      return "";
    }

    const entry = Array.isArray(entryOrList) ? entryOrList[0] : entryOrList;
    return entry && entry.value ? entry.value || "" : "";
  }

  function ensureScopeMap(declByScope, scopeId) {
    if (!declByScope.has(scopeId)) {
      declByScope.set(scopeId, new Map());
    }
  }

  function addDecl(declByScope, scopeId, name, declInfo) {
    const normalized = normalizeIdentifierCandidate(name);
    if (!normalized) {
      return;
    }
    const upper = normalized.toUpperCase();
    ensureScopeMap(declByScope, scopeId);
    const map = declByScope.get(scopeId);
    if (!map.has(upper)) {
      map.set(upper, declInfo);
    }
  }

  function getDeclarationScopeId(obj, idToObject, procedureBlocks, classBlocks) {
    if (!obj) {
      return 0;
    }
    const procId = getProcedureScopeId(obj, idToObject);
    if (procId) {
      return procId;
    }
    const line = obj.lineStart || 0;
    return getStatementScopeId(line, [], classBlocks);
  }

  function getProcedureScopeId(obj, idToObject) {
    let current = obj;
    while (current) {
      if (current.objectType === "FORM" || current.objectType === "METHOD") {
        return current.id || 0;
      }
      current = current.parent ? idToObject.get(current.parent) : null;
    }
    return 0;
  }

  function getStatementScopeId(lineStart, procedureBlocks, classBlocks) {
    const proc = findInnermostBlock(lineStart, procedureBlocks);
    if (proc) {
      return proc.id || 0;
    }
    const cls = findInnermostBlock(lineStart, classBlocks);
    if (cls) {
      return cls.id || 0;
    }
    return 0;
  }

  function findInnermostBlock(line, blocks) {
    let best = null;
    let bestSize = Infinity;
    const currentLine = Number(line || 0);

    for (const block of blocks || []) {
      const start = Number(block.lineStart || 0);
      const end = Number(block.block && block.block.lineEnd ? block.block.lineEnd : 0);
      if (!start || !end) {
        continue;
      }
      if (currentLine < start || currentLine > end) {
        continue;
      }
      const size = end - start;
      if (size < bestSize) {
        best = block;
        bestSize = size;
      }
    }

    return best;
  }

  function getDeclaredNamesFromObject(obj) {
    if (!obj || !obj.objectType) {
      return [];
    }

    const structMeta = obj.extras && typeof obj.extras === "object" ? obj.extras.structDef : null;
    if (structMeta && structMeta.isDecl === false) {
      return [];
    }

    const type = obj.objectType;
    if (["DATA", "CONSTANTS", "PARAMETERS", "SELECT-OPTIONS", "TYPES", "RANGES", "STATICS", "CLASS-DATA", "FIELD-SYMBOLS"].includes(type)) {
      const name = getFirstValue(obj.values, "name");
      return name ? [name] : [];
    }

    return [];
  }

  function buildDeclInfoFromObject(obj, name, scopeInfo) {
    const scope = scopeInfo || buildFallbackScopeInfo(0);
    return {
      id: obj.id || null,
      objectType: obj.objectType || "",
      name: normalizeIdentifierCandidate(name) || name || "",
      file: obj.file || "",
      lineStart: obj.lineStart || null,
      raw: obj.raw || "",
      comment: obj.comment || "",
      scopeId: scope.scopeId,
      scopeLabel: scope.scopeLabel,
      scopeType: scope.scopeType,
      scopeName: scope.scopeName
    };
  }

  function buildFallbackScopeInfo(scopeId) {
    const id = Number(scopeId || 0) || 0;
    if (!id) {
      return { scopeId: 0, scopeType: "GLOBAL", scopeLabel: "GLOBAL", scopeName: "" };
    }
    return { scopeId: id, scopeType: "SCOPE", scopeLabel: `SCOPE:${id}`, scopeName: "" };
  }

  function buildScopeInfoById({ idToObject }) {
    const map = new Map();
    map.set(0, buildFallbackScopeInfo(0));

    for (const [id, obj] of idToObject.entries()) {
      if (!obj || !obj.objectType) {
        continue;
      }

      const type = obj.objectType;
      if (!["FORM", "METHOD", "CLASS", "METHODS", "CLASS-METHODS"].includes(type)) {
        continue;
      }

      if (type === "FORM") {
        const formName = getFirstValue(obj.values, "name") || "";
        const upper = formName ? formName.toUpperCase() : "";
        map.set(id, {
          scopeId: id,
          scopeType: "FORM",
          scopeLabel: upper ? `FORM:${upper}` : `FORM:${id}`,
          scopeName: formName
        });
        continue;
      }

      if (type === "METHOD") {
        const methodName = getFirstValue(obj.values, "name") || "";
        const methodUpper = methodName ? methodName.toUpperCase() : "";
        const classUpper = findAncestorNameUpper(obj, idToObject, "CLASS");
        const label = classUpper && methodUpper
          ? `METHOD:${classUpper}=>${methodUpper}`
          : methodUpper
              ? `METHOD:${methodUpper}`
              : `METHOD:${id}`;

        map.set(id, {
          scopeId: id,
          scopeType: "METHOD",
          scopeLabel: label,
          scopeName: methodName
        });
        continue;
      }

      if (type === "CLASS") {
        const className = getFirstValue(obj.values, "name") || "";
        const classUpper = className ? className.toUpperCase() : "";
        map.set(id, {
          scopeId: id,
          scopeType: "CLASS",
          scopeLabel: classUpper ? `CLASS:${classUpper}` : `CLASS:${id}`,
          scopeName: className
        });
        continue;
      }

      if (type === "METHODS" || type === "CLASS-METHODS") {
        const methodName = getFirstValue(obj.values, "name") || "";
        const methodUpper = methodName ? methodName.toUpperCase() : "";
        const classUpper = findAncestorNameUpper(obj, idToObject, "CLASS");
        const label = classUpper && methodUpper
          ? `METHODSIG:${classUpper}=>${methodUpper}`
          : methodUpper
              ? `METHODSIG:${methodUpper}`
              : `METHODSIG:${id}`;

        map.set(id, {
          scopeId: id,
          scopeType: "METHODSIG",
          scopeLabel: label,
          scopeName: methodName
        });
      }
    }

    return map;
  }

  function findAncestorNameUpper(obj, idToObject, objectType) {
    let current = obj;
    while (current) {
      if (current.objectType === objectType) {
        const name = getFirstValue(current.values, "name") || "";
        return name ? name.toUpperCase() : "";
      }
      current = current.parent ? idToObject.get(current.parent) : null;
    }
    return "";
  }

  function buildFormsByNameUpper(allObjects) {
    const map = new Map();
    for (const obj of allObjects || []) {
      if (!obj || obj.objectType !== "FORM") {
        continue;
      }

      const name = getFirstValue(obj.values, "name") || (obj.extras && obj.extras.form ? obj.extras.form.name : "");
      if (!name) {
        continue;
      }

      const upper = String(name).toUpperCase();
      if (!map.has(upper)) {
        map.set(upper, obj);
      }
    }
    return map;
  }

  function declIdentityKey(decl) {
    if (!decl) {
      return "";
    }
    const objectType = decl.objectType || "";
    const scopeLabel = decl.scopeLabel || "";
    const name = decl.name || "";
    const file = decl.file || "";
    const line = decl.lineStart || "";
    return `${objectType}|${scopeLabel}|${name}|${file}|${line}`;
  }

  function attachPerformOriginDecls({ allObjects, formsByNameUpper }) {
    const formParamSections = new Set(["USING", "CHANGING", "TABLES"]);

    const forms = Array.from(formsByNameUpper.values())
      .filter((obj) => obj && obj.id && obj.extras && obj.extras.form && Array.isArray(obj.extras.form.params));

    const formParamsByFormId = new Map();
    const originsByFormIdAndParamUpper = new Map();

    for (const form of forms) {
      const params = form.extras.form.params.filter((param) => param && formParamSections.has(param.section));
      const byNameUpper = new Map(params.map((param) => [param.name.toUpperCase(), param]));
      const bySection = { USING: [], CHANGING: [], TABLES: [] };
      for (const param of params) {
        bySection[param.section].push(param);
      }

      formParamsByFormId.set(form.id, { form, byNameUpper, bySection });

      const originByParam = new Map();
      for (const param of params) {
        originByParam.set(param.name.toUpperCase(), new Map());
      }
      originsByFormIdAndParamUpper.set(form.id, originByParam);
    }

    const performCalls = (allObjects || []).filter(
      (obj) => obj && obj.objectType === "PERFORM" && obj.extras && obj.extras.performCall
    );

    function getOriginsForFormParamDecl(decl) {
      if (!decl || decl.objectType !== "FORM_PARAM" || !decl.id || !decl.name) {
        return new Map();
      }
      const byParam = originsByFormIdAndParamUpper.get(decl.id);
      if (!byParam) {
        return new Map();
      }
      return byParam.get(decl.name.toUpperCase()) || new Map();
    }

    function originsFromValueDecl(valueDecl) {
      if (!valueDecl) {
        return new Map();
      }
      if (valueDecl.objectType === "FORM_PARAM") {
        return new Map(getOriginsForFormParamDecl(valueDecl));
      }
      const key = declIdentityKey(valueDecl);
      return key ? new Map([[key, valueDecl]]) : new Map();
    }

    function unionInto(target, source) {
      if (!target || !source) {
        return false;
      }
      let changed = false;
      for (const [key, decl] of source.entries()) {
        if (!target.has(key)) {
          target.set(key, decl);
          changed = true;
        }
      }
      return changed;
    }

    const maxIterations = 50;
    for (let iter = 0; iter < maxIterations; iter += 1) {
      let changed = false;

      for (const callObj of performCalls) {
        const call = callObj.extras.performCall;
        const formNameUpper = String(call.form || "").toUpperCase();
        if (!formNameUpper) {
          continue;
        }

        const calleeForm = formsByNameUpper.get(formNameUpper);
        if (!calleeForm || !calleeForm.id) {
          continue;
        }

        const calleeInfo = formParamsByFormId.get(calleeForm.id);
        if (!calleeInfo) {
          continue;
        }

        const calleeOrigins = originsByFormIdAndParamUpper.get(calleeForm.id);
        if (!calleeOrigins) {
          continue;
        }

        for (const section of ["USING", "CHANGING", "TABLES"]) {
          const formalParams = calleeInfo.bySection[section] || [];
          const actualArgs = Array.isArray(call[section.toLowerCase()]) ? call[section.toLowerCase()] : [];
          const max = Math.min(formalParams.length, actualArgs.length);

          for (let index = 0; index < max; index += 1) {
            const formal = formalParams[index];
            const actual = actualArgs[index];
            if (!formal || !formal.name || !actual) {
              continue;
            }

            const target = calleeOrigins.get(formal.name.toUpperCase());
            if (!target) {
              continue;
            }

            const sourceOrigins = originsFromValueDecl(actual.valueDecl);
            if (unionInto(target, sourceOrigins)) {
              changed = true;
            }
          }
        }
      }

      if (!changed) {
        break;
      }
    }

    for (const form of forms) {
      const originByParam = originsByFormIdAndParamUpper.get(form.id);
      if (!originByParam) {
        continue;
      }

      for (const param of form.extras.form.params) {
        if (!param || !param.name || !formParamSections.has(param.section)) {
          continue;
        }
        const originMap = originByParam.get(param.name.toUpperCase());
        param.originDecls = originMap ? Array.from(originMap.values()) : [];
      }
    }

    for (const callObj of performCalls) {
      const call = callObj.extras.performCall;
      for (const sectionName of ["using", "changing", "tables"]) {
        const list = Array.isArray(call[sectionName]) ? call[sectionName] : [];
        for (const entry of list) {
          entry.originDecls = Array.from(originsFromValueDecl(entry.valueDecl).values());
        }
      }
    }

    for (const obj of allObjects || []) {
      if (!obj || !obj.extras) {
        continue;
      }

      if (obj.extras.callFunction) {
        for (const sectionName of ["exporting", "importing", "changing", "tables", "exceptions"]) {
          const list = Array.isArray(obj.extras.callFunction[sectionName]) ? obj.extras.callFunction[sectionName] : [];
          for (const entry of list) {
            entry.originDecls = Array.from(originsFromValueDecl(entry.valueDecl).values());
          }
        }
      }

      if (obj.extras.callMethod) {
        for (const sectionName of ["exporting", "importing", "changing", "receiving", "exceptions"]) {
          const list = Array.isArray(obj.extras.callMethod[sectionName]) ? obj.extras.callMethod[sectionName] : [];
          for (const entry of list) {
            entry.originDecls = Array.from(originsFromValueDecl(entry.valueDecl).values());
          }
        }
      }
    }
  }

  function extractInlineDeclarations(raw) {
    const text = String(raw || "");
    const results = [];

    [
      /@?DATA\s*\(\s*([^)]+)\s*\)/gi,
      /@?FINAL\s*\(\s*([^)]+)\s*\)/gi,
      /FIELD-SYMBOL\s*\(\s*(<[^>]+>)\s*\)/gi
    ].forEach((regex) => {
      let match = null;
      while ((match = regex.exec(text))) {
        const candidate = normalizeIdentifierCandidate(match[1]);
        if (candidate) {
          results.push(candidate);
        }
      }
    });

    return Array.from(new Set(results));
  }

  function normalizeIdentifierCandidate(raw) {
    const trimmed = String(raw || "").trim();
    if (!trimmed) {
      return "";
    }
    if (/^<[^>]+>$/.test(trimmed)) {
      return trimmed;
    }
    if (/^SY-[A-Za-z_][A-Za-z0-9_]*$/i.test(trimmed)) {
      return trimmed.toUpperCase();
    }
    if (/^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(-[A-Za-z_][A-Za-z0-9_]*)+$/i.test(trimmed)) {
      return trimmed;
    }
    if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(trimmed)) {
      return trimmed;
    }
    return "";
  }

  function buildResolveContext(obj, idToObject, declByScope, classInfo) {
    const procId = getProcedureScopeId(obj, idToObject);
    const methodBlock = findAncestor(obj, idToObject, "METHOD");
    const classBlock = findAncestor(obj, idToObject, "CLASS");

    const classNameUpper = classBlock ? getFirstValue(classBlock.values, "name").toUpperCase() : "";
    const methodNameUpper = methodBlock ? getFirstValue(methodBlock.values, "name").toUpperCase() : "";
    const classDef = classNameUpper && classInfo.byName.get(classNameUpper)
      ? classInfo.byName.get(classNameUpper).definition
      : null;

    const methodParamsEntry = classNameUpper && methodNameUpper
      ? classInfo.methodParamsByClassAndName.get(`${classNameUpper}:${methodNameUpper}`)
      : null;

    return {
      obj,
      procId,
      classNameUpper,
      methodNameUpper,
      classDefId: classDef ? classDef.id : 0,
      declByScope,
      methodParamsByNameUpper: methodParamsEntry ? methodParamsEntry.paramsByNameUpper : null
    };
  }

  function findAncestor(obj, idToObject, objectType) {
    let current = obj;
    while (current) {
      if (current.objectType === objectType) {
        return current;
      }
      current = current.parent ? idToObject.get(current.parent) : null;
    }
    return null;
  }

  function annotateValuesWithDecls(values, context) {
    const annotateEntry = (entry) => {
      if (!entry || !entry.value) {
        return;
      }
      const ref = extractFirstIdentifierFromExpression(entry.value);
      if (!ref) {
        return;
      }
      const decl = resolveDecl(ref, context);
      if (!decl) {
        return;
      }
      entry.declRef = ref;
      entry.decl = decl;
    };

    if (Array.isArray(values)) {
      for (const entry of values) {
        annotateEntry(entry);
      }
      return;
    }

    if (!values || typeof values !== "object") {
      return;
    }

    for (const key of Object.keys(values)) {
      const entryOrList = values[key];
      if (Array.isArray(entryOrList)) {
        for (const entry of entryOrList) {
          annotateEntry(entry);
        }
        continue;
      }
      annotateEntry(entryOrList);
    }
  }

  function annotateExtrasWithDecls(extras, context) {
    if (!extras || typeof extras !== "object") {
      return;
    }

    if (extras.callFunction) {
      annotateCallFunctionExtras(extras.callFunction, context);
    }

    if (extras.callMethod) {
      annotateCallMethodExtras(extras.callMethod, context);
    }

    if (extras.performCall) {
      annotatePerformCallExtras(extras.performCall, context);
    }

    if (extras.ifCondition) {
      annotateIfConditionExtras(extras.ifCondition, context);
    }

    if (extras.select) {
      annotateSelectExtras(extras.select, context);
    }

    if (extras.readTable) {
      annotateReadTableExtras(extras.readTable, context);
    }

    if (extras.loopAtItab) {
      annotateLoopAtItabExtras(extras.loopAtItab, context);
    }

    if (extras.modifyItab) {
      annotateModifyItabExtras(extras.modifyItab, context);
    }

    if (extras.deleteItab) {
      annotateDeleteItabExtras(extras.deleteItab, context);
    }
  }

  function annotateCallFunctionExtras(callFunction, context) {
    for (const sectionName of ["exporting", "importing", "changing", "tables", "exceptions"]) {
      const list = callFunction && Array.isArray(callFunction[sectionName]) ? callFunction[sectionName] : [];
      for (const entry of list) {
        if (!entry || !entry.value) {
          continue;
        }
        const ref = extractFirstIdentifierFromExpression(entry.value);
        if (!ref) {
          continue;
        }
        entry.valueRef = ref;
        entry.valueDecl = resolveDecl(ref, context);
      }
    }
  }

  function annotateCallMethodExtras(callMethod, context) {
    for (const sectionName of ["exporting", "importing", "changing", "receiving", "exceptions"]) {
      const list = callMethod && Array.isArray(callMethod[sectionName]) ? callMethod[sectionName] : [];
      for (const entry of list) {
        if (!entry || !entry.value) {
          continue;
        }
        const ref = extractFirstIdentifierFromExpression(entry.value);
        if (!ref) {
          continue;
        }
        entry.valueRef = ref;
        entry.valueDecl = resolveDecl(ref, context);
      }
    }
  }

  function annotatePerformCallExtras(performCall, context) {
    for (const sectionName of ["using", "changing", "tables"]) {
      const list = performCall && Array.isArray(performCall[sectionName]) ? performCall[sectionName] : [];
      for (const entry of list) {
        if (!entry || !entry.value) {
          continue;
        }
        const ref = extractFirstIdentifierFromExpression(entry.value);
        if (!ref) {
          continue;
        }
        entry.valueRef = ref;
        entry.valueDecl = resolveDecl(ref, context);
      }
    }

    annotateConditionClausesWithDecls(performCall ? performCall.ifConditions : null, context);
  }

  function annotateIfConditionExtras(ifCondition, context) {
    if (!ifCondition || typeof ifCondition !== "object") {
      return;
    }
    annotateConditionClausesWithDecls(ifCondition.conditions, context);
  }

  function annotateSelectExtras(selectExtras, context) {
    if (!selectExtras || typeof selectExtras !== "object") {
      return;
    }
    annotateConditionClausesWithDecls(selectExtras.whereConditions, context);
    annotateConditionClausesWithDecls(selectExtras.havingConditions, context);
  }

  function annotateConditionClausesWithDecls(conditions, context) {
    const list = Array.isArray(conditions) ? conditions : [];
    for (const clause of list) {
      if (!clause || typeof clause !== "object") {
        continue;
      }

      const leftRef = extractFirstIdentifierFromExpression(clause.leftOperand);
      if (leftRef) {
        clause.leftOperandRef = leftRef;
        clause.leftOperandDecl = resolveDecl(leftRef, context) || buildSyntheticConditionOperandDeclInfo(clause.leftOperand, leftRef);
      } else {
        clause.leftOperandDecl = buildSyntheticConditionOperandDeclInfo(clause.leftOperand, "");
      }

      const operatorUpper = String(clause.comparisonOperator || "").toUpperCase();
      const skipRightAnnotation = operatorUpper === "IS" && isUnaryIsPredicate(clause.rightOperand);
      const rightRef = skipRightAnnotation ? "" : extractFirstIdentifierFromExpression(clause.rightOperand);
      if (rightRef) {
        clause.rightOperandRef = rightRef;
        clause.rightOperandDecl = resolveDecl(rightRef, context) || buildSyntheticConditionOperandDeclInfo(clause.rightOperand, rightRef);
      } else if (skipRightAnnotation) {
        clause.rightOperandDecl = buildUnaryIsPredicateDeclInfo(clause.rightOperand);
      } else {
        clause.rightOperandDecl = buildSyntheticConditionOperandDeclInfo(clause.rightOperand, "");
      }
    }
  }

  function isUnaryIsPredicate(value) {
    const text = String(value || "").trim();
    if (!text) {
      return false;
    }
    return /^(?:NOT\s+)?(?:INITIAL|ASSIGNED|BOUND|SUPPLIED|REQUESTED)$/i.test(text);
  }

  function buildUnaryIsPredicateDeclInfo(value) {
    const text = String(value || "").trim().toUpperCase().replace(/\s+/g, " ");
    if (!text) {
      return null;
    }
    return {
      id: null,
      objectType: "SYSTEM",
      name: text,
      file: "",
      lineStart: null,
      raw: "",
      comment: "",
      scopeId: 0,
      scopeLabel: "SYSTEM",
      scopeType: "SYSTEM",
      scopeName: ""
    };
  }

  function buildSyntheticConditionOperandDeclInfo(rawValue, preferredName) {
    const rawText = String(rawValue || "").trim();
    const preferredText = String(preferredName || "").trim();
    const name = preferredText || rawText;
    if (!name) {
      return null;
    }
    return {
      id: null,
      objectType: "CONDITION_VALUE",
      name,
      file: "",
      lineStart: null,
      raw: rawText,
      comment: "",
      scopeId: 0,
      scopeLabel: "CONDITION",
      scopeType: "SYSTEM",
      scopeName: ""
    };
  }

  function annotateReadTableExtras(readTable, context) {
    if (!readTable || typeof readTable !== "object") {
      return;
    }
    annotateConditionClausesWithDecls(readTable.conditions, context);
  }

  function annotateLoopAtItabExtras(loopAtItab, context) {
    if (!loopAtItab || typeof loopAtItab !== "object") {
      return;
    }
    annotateConditionClausesWithDecls(loopAtItab.conditions, context);
  }

  function annotateModifyItabExtras(modifyItab, context) {
    if (!modifyItab || typeof modifyItab !== "object") {
      return;
    }
    annotateConditionClausesWithDecls(modifyItab.conditions, context);
  }

  function annotateDeleteItabExtras(deleteItab, context) {
    if (!deleteItab || typeof deleteItab !== "object") {
      return;
    }
    annotateConditionClausesWithDecls(deleteItab.conditions, context);
  }

  function resolveDecl(identifier, context) {
    const normalized = normalizeIdentifierCandidate(identifier);
    if (!normalized) {
      return null;
    }
    const upper = normalized.toUpperCase();

    const procMap = context.procId ? context.declByScope.get(context.procId) : null;
    if (procMap && procMap.has(upper)) {
      return procMap.get(upper);
    }

    const methodParams = context.methodParamsByNameUpper;
    if (methodParams && methodParams.has(upper)) {
      return methodParams.get(upper);
    }

    const classMap = context.classDefId ? context.declByScope.get(context.classDefId) : null;
    if (classMap && classMap.has(upper)) {
      return classMap.get(upper);
    }

    const globalMap = context.declByScope.get(0);
    if (globalMap && globalMap.has(upper)) {
      return globalMap.get(upper);
    }

    const systemDecl = buildSystemDeclInfo(normalized);
    if (systemDecl) {
      return systemDecl;
    }

    return null;
  }

  function buildSystemDeclInfo(identifier) {
    const upper = String(identifier || "").trim().toUpperCase();
    if (!upper) {
      return null;
    }

    const known = new Set([
      "ABAP_TRUE",
      "ABAP_FALSE",
      "ABAP_UNDEFINED",
      "SPACE",
      "SY-SUBRC",
      "SY-TABIX",
      "SY-UNAME",
      "SY-REPID"
    ]);

    if (!upper.startsWith("SY-") && !known.has(upper)) {
      return null;
    }

    return {
      id: null,
      objectType: "SYSTEM",
      name: upper,
      file: "",
      lineStart: null,
      raw: "",
      comment: "",
      scopeId: 0,
      scopeLabel: "SYSTEM",
      scopeType: "SYSTEM",
      scopeName: ""
    };
  }

  function extractFirstIdentifierFromExpression(expression) {
    const text = String(expression || "").trim();
    if (!text) {
      return "";
    }
    if (text.startsWith("'") || text.startsWith("|")) {
      return "";
    }
    if (/^[+-]?\d/.test(text)) {
      return "";
    }

    const sysMatch = text.match(/^SY-[A-Za-z_][A-Za-z0-9_]*/i);
    if (sysMatch) {
      return sysMatch[0].toUpperCase();
    }

    const fieldPath = extractFirstFieldPathFromExpression(text);
    if (fieldPath) {
      return fieldPath;
    }

    const inline = extractFirstInlineDeclaration(text);
    if (inline) {
      return inline;
    }

    const matches = text.matchAll(/<[^>]+>|[A-Za-z_][A-Za-z0-9_]*/g);
    for (const match of matches) {
      const candidate = normalizeIdentifierCandidate(match[0]);
      if (candidate) {
        return candidate;
      }
    }

    return "";
  }

  function extractFirstFieldPathFromExpression(text) {
    const match = String(text || "").match(/^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(?:-[A-Za-z_][A-Za-z0-9_]*)+/);
    if (!match) {
      return "";
    }
    const candidate = normalizeIdentifierCandidate(match[0]);
    return candidate || "";
  }

  function extractFirstInlineDeclaration(text) {
    const patterns = [
      { regex: /@?DATA\s*\(\s*([^)]+)\s*\)/i, group: 1 },
      { regex: /@?FINAL\s*\(\s*([^)]+)\s*\)/i, group: 1 },
      { regex: /FIELD-SYMBOL\s*\(\s*(<[^>]+>)\s*\)/i, group: 1 }
    ];

    let best = null;
    for (const pattern of patterns) {
      const match = pattern.regex.exec(text);
      if (!match) {
        continue;
      }
      const candidate = normalizeIdentifierCandidate(match[pattern.group]);
      if (!candidate) {
        continue;
      }
      if (!best || match.index < best.index) {
        best = { index: match.index, name: candidate };
      }
    }

    return best ? best.name : "";
  }

  const CONDITION_OPERATORS = new Set([
    "=",
    "<>",
    "<",
    ">",
    "<=",
    ">=",
    "EQ",
    "NE",
    "LT",
    "GT",
    "LE",
    "GE",
    "CO",
    "CN",
    "CA",
    "NA",
    "CS",
    "NS",
    "CP",
    "NP",
    "IN",
    "IS",
    "BT",
    "NB"
  ]);

  const CONDITION_CONNECTORS = new Set(["AND", "OR"]);

  function isConditionOperator(tokenUpper) {
    return CONDITION_OPERATORS.has(String(tokenUpper || "").toUpperCase());
  }

  function isConditionConnector(tokenUpper) {
    return CONDITION_CONNECTORS.has(String(tokenUpper || "").toUpperCase());
  }

  function normalizeReadTableKeyConditionSource(segmentRaw) {
    const raw = String(segmentRaw || "").trim();
    if (!raw) {
      return "";
    }

    const match = raw.match(/^(?:[A-Za-z_][A-Za-z0-9_]*\s+)?COMPONENTS\s+(.+)$/i);
    if (!match) {
      return raw;
    }
    return String(match[1] || "").trim();
  }

  function parseConditionClauses(segmentRaw, options) {
    const raw = String(segmentRaw || "").trim();
    if (!raw) {
      return [];
    }

    const allowImplicitAnd = !options || options.allowImplicitAnd !== false;
    const tokens = tokenize(`${raw}.`);
    if (!tokens.length) {
      return [];
    }

    const clauses = [];
    let index = 0;

    while (index < tokens.length) {
      while (index < tokens.length && isConditionConnector(tokens[index].upper)) {
        index += 1;
      }
      if (index >= tokens.length) {
        break;
      }

      let opIndex = -1;
      for (let i = index; i < tokens.length; i += 1) {
        if (isConditionConnector(tokens[i].upper)) {
          break;
        }
        if (isConditionOperator(tokens[i].upper)) {
          opIndex = i;
          break;
        }
      }
      if (opIndex <= index) {
        break;
      }

      const leftTokens = tokens.slice(index, opIndex);
      if (!leftTokens.length) {
        index = opIndex + 1;
        continue;
      }

      const rightStart = opIndex + 1;
      if (rightStart >= tokens.length) {
        break;
      }

      let rightEnd = tokens.length - 1;
      let explicitConnectorIndex = -1;
      let implicitNextClauseIndex = -1;
      const operatorUpper = String(tokens[opIndex].upper || "").toUpperCase();
      const expectsRangeBounds = operatorUpper === "BT" || operatorUpper === "NB";
      let rangeConnectorConsumed = false;

      for (let i = rightStart; i < tokens.length; i += 1) {
        if (isConditionConnector(tokens[i].upper)) {
          if (expectsRangeBounds && !rangeConnectorConsumed && String(tokens[i].upper || "").toUpperCase() === "AND") {
            rangeConnectorConsumed = true;
            continue;
          }
          explicitConnectorIndex = i;
          rightEnd = i - 1;
          break;
        }

        const next = tokens[i + 1];
        if (allowImplicitAnd && i > rightStart && next && isConditionOperator(next.upper)) {
          implicitNextClauseIndex = i;
          rightEnd = i - 1;
          break;
        }
      }

      const rightTokens = tokens.slice(rightStart, rightEnd + 1);
      if (!rightTokens.length) {
        if (explicitConnectorIndex >= 0) {
          index = explicitConnectorIndex + 1;
          continue;
        }
        break;
      }

      const leftOperand = leftTokens.map((token) => token.raw).join(" ").trim();
      const rightOperand = rightTokens.map((token) => token.raw).join(" ").trim();
      const comparisonOperator = String(tokens[opIndex].raw || "").trim();
      if (!leftOperand || !rightOperand || !comparisonOperator) {
        break;
      }

      let logicalConnector = "";
      if (explicitConnectorIndex >= 0) {
        logicalConnector = String(tokens[explicitConnectorIndex].upper || "").trim();
      } else if (implicitNextClauseIndex >= 0) {
        logicalConnector = "AND";
      }

      clauses.push({
        leftOperand,
        rightOperand,
        comparisonOperator,
        logicalConnector
      });

      if (explicitConnectorIndex >= 0) {
        index = explicitConnectorIndex + 1;
      } else if (implicitNextClauseIndex >= 0) {
        index = implicitNextClauseIndex;
      } else {
        break;
      }
    }

    return clauses;
  }

  function parseArgumentTokens(segmentRaw) {
    const trimmed = String(segmentRaw || "").trim();
    if (!trimmed) {
      return [];
    }

    const tokens = tokenize(`${trimmed}.`);
    return tokens.map((token) => token.raw).filter(Boolean);
  }

  function parseAssignments(segmentRaw) {
    const trimmed = String(segmentRaw || "").trim();
    if (!trimmed) {
      return [];
    }

    const tokens = tokenize(`${trimmed}.`).map((token) => token.raw).filter(Boolean);
    const assignments = [];

    function findNextAssignmentStart(startIndex) {
      for (let index = startIndex; index < tokens.length; index += 1) {
        const token = tokens[index];
        if (token === "=") {
          continue;
        }

        if (tokens[index + 1] === "=" && normalizeFormParamName(token)) {
          return index;
        }

        const equalIndex = token.indexOf("=");
        if (equalIndex > 0) {
          const left = token.slice(0, equalIndex).trim();
          if (normalizeFormParamName(left)) {
            return index;
          }
        }
      }
      return tokens.length;
    }

    for (let index = 0; index < tokens.length;) {
      const token = tokens[index];
      let name = "";
      let valueStartIndex = -1;
      let inlineFirstValue = "";

      if (token !== "=") {
        const equalIndex = token.indexOf("=");
        if (equalIndex > 0) {
          const left = token.slice(0, equalIndex).trim();
          const rightInline = token.slice(equalIndex + 1).trim();
          const parsedName = normalizeFormParamName(left);
          if (parsedName) {
            name = parsedName;
            inlineFirstValue = rightInline;
            valueStartIndex = index + 1;
            index += 1;
          }
        } else if (tokens[index + 1] === "=") {
          const parsedName = normalizeFormParamName(token);
          if (parsedName) {
            name = parsedName;
            valueStartIndex = index + 2;
            index += 2;
          }
        }
      }

      if (!name) {
        index += 1;
        continue;
      }

      const nextAssignmentIndex = findNextAssignmentStart(valueStartIndex);
      const valueParts = [];
      if (inlineFirstValue) {
        valueParts.push(inlineFirstValue);
      }
      for (let valueIndex = valueStartIndex; valueIndex < nextAssignmentIndex; valueIndex += 1) {
        valueParts.push(tokens[valueIndex]);
      }

      assignments.push({ name, value: valueParts.join(" ").trim() });
      index = nextAssignmentIndex;
    }

    return assignments;
  }

  function valuesToFirstValueMap(values) {
    const map = {};

    if (Array.isArray(values)) {
      for (const entry of values) {
        if (!entry || !entry.name) {
          continue;
        }
        if (map[entry.name] === undefined) {
          map[entry.name] = entry.value || "";
        }
      }
      return map;
    }

    if (!values || typeof values !== "object") {
      return map;
    }

    for (const [name, entryOrList] of Object.entries(values)) {
      const entry = Array.isArray(entryOrList) ? entryOrList[0] : entryOrList;
      if (!entry) {
        continue;
      }
      map[name] = entry.value || "";
    }

    return map;
  }

  function groupEntriesByKey(entries, key) {
    const map = {};
    for (const entry of entries || []) {
      if (!entry || entry[key] === undefined || entry[key] === null) {
        continue;
      }

      const name = String(entry[key]).trim();
      if (!name) {
        continue;
      }

      const current = map[name];
      if (current === undefined) {
        map[name] = entry;
        continue;
      }

      if (Array.isArray(current)) {
        current.push(entry);
        continue;
      }

      map[name] = [current, entry];
    }
    return map;
  }

  function parseFormSignature(valueMap) {
    const usingParams = parseFormParamDefs("USING", valueMap.usingRaw || "");
    const changingParams = parseFormParamDefs("CHANGING", valueMap.changingRaw || "");
    const tablesParams = parseFormParamDefs("TABLES", valueMap.tablesRaw || "");
    const exceptions = parseFormExceptions(valueMap.raisingRaw || "");

    const params = [...usingParams, ...changingParams, ...tablesParams];
    const namesUpper = new Set(params.map((param) => param.name.toUpperCase()));

    return {
      params,
      exceptions,
      namesUpper
    };
  }

  function parseFormParamDefs(section, segmentRaw) {
    const trimmed = String(segmentRaw || "").trim();
    if (!trimmed) {
      return [];
    }

    const tokens = tokenize(`${trimmed}.`);
    const params = [];
    const seen = new Set();

    for (let index = 0; index < tokens.length; index += 1) {
      const tokenUpper = tokens[index].upper;
      if (!["TYPE", "LIKE", "STRUCTURE"].includes(tokenUpper)) {
        continue;
      }

      const nameToken = tokens[index - 1];
      if (!nameToken) {
        continue;
      }

      const name = normalizeFormParamName(nameToken.raw);
      if (!name) {
        continue;
      }

      const key = `${section}:${name.toUpperCase()}`;
      if (seen.has(key)) {
        continue;
      }

      const typing = readTyping(tokens, index);
      params.push({
        section,
        name,
        typing
      });

      seen.add(key);
    }

    if (params.length) {
      return params;
    }

    for (const token of tokens) {
      const name = normalizeFormParamName(token.raw);
      if (!name) {
        continue;
      }
      const key = `${section}:${name.toUpperCase()}`;
      if (seen.has(key)) {
        continue;
      }
      params.push({
        section,
        name,
        typing: null
      });
      seen.add(key);
    }

    return params;
  }

  function readTyping(tokens, keywordIndex) {
    const kind = tokens[keywordIndex].upper;
    const next = tokens[keywordIndex + 1];
    const next2 = tokens[keywordIndex + 2];
    const next3 = tokens[keywordIndex + 3];

    if ((kind === "TYPE" || kind === "LIKE") && next && next.upper === "REF" && next2 && next2.upper === "TO" && next3) {
      return { kind: `${kind} REF TO`, value: next3.raw };
    }

    if (next) {
      return { kind, value: next.raw };
    }

    return { kind, value: "" };
  }

  function parseFormExceptions(segmentRaw) {
    const trimmed = String(segmentRaw || "").trim();
    if (!trimmed) {
      return [];
    }

    const tokens = tokenize(`${trimmed}.`);
    return tokens
      .map((token) => token.raw)
      .filter(Boolean)
      .map((name) => ({ name }));
  }

  function normalizeFormParamName(raw) {
    const trimmed = String(raw || "").trim();
    if (!trimmed) {
      return "";
    }

    const valueMatch = trimmed.match(/^VALUE\(([^)]+)\)$/i);
    const candidate = valueMatch ? valueMatch[1] : trimmed;
    const cleaned = candidate.replace(/^[([{]+/, "").replace(/[)\]}]+$/, "").trim();

    if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(cleaned)) {
      return "";
    }

    return cleaned;
  }

  function parseFormDocComment(commentLines) {
    const params = [];
    let formName = "";

    for (const line of commentLines || []) {
      const text = String(line || "").trim();
      if (!text) {
        continue;
      }

      if (!formName) {
        const match = text.match(/\bForm\s+([A-Za-z_][A-Za-z0-9_]*)\b/i);
        if (match) {
          formName = match[1];
        }
      }

      const paramMatch = text.match(/^(-->|<--|<->)\s+([A-Za-z_][A-Za-z0-9_]*)\s*(.*)$/);
      if (!paramMatch) {
        continue;
      }

      const direction = decodeArrowDirection(paramMatch[1]);
      const name = paramMatch[2];
      const desc = String(paramMatch[3] || "").trim();

      params.push({
        direction,
        name,
        text: desc
      });
    }

    return {
      formName,
      params
    };
  }

  function decodeArrowDirection(symbol) {
    if (symbol === "-->") {
      return "in";
    }
    if (symbol === "<--") {
      return "out";
    }
    return "inout";
  }

  function isChainedStatementStart(raw, startKeyword) {
    if (!startKeyword) {
      return false;
    }

    const pattern = new RegExp(`^\\s*${escapeRegExp(startKeyword)}\\s*:`, "i");
    return pattern.test(raw);
  }

  function splitChainedStatementWithMeta(statement, startKeyword) {
    const raw = statement && typeof statement.raw === "string" ? statement.raw : "";
    const baseLineStart = statement && statement.lineStart ? Number(statement.lineStart) || null : null;
    const lineEntries = statement && Array.isArray(statement.lineEntries) ? statement.lineEntries : [];

    if (!lineEntries.length) {
      const parts = splitChainedStatement(raw, startKeyword);
      return parts.map((partRaw) => ({
        raw: partRaw,
        lineStart: baseLineStart,
        comment: statement && typeof statement.comment === "string" ? statement.comment : "",
        commentLines: statement && Array.isArray(statement.commentLines) ? statement.commentLines.slice() : []
      }));
    }

    const prefixPattern = new RegExp(`^\\s*${escapeRegExp(startKeyword)}\\s*:\\s*`, "i");
    const segments = [];

    let current = "";
    let currentStartLine = null;
    let inSingleQuote = false;
    let inPipe = false;

    const pushSegment = ({ comment, endLine }) => {
      const text = current.replace(/\s+/g, " ").trim();
      if (!text) {
        current = "";
        currentStartLine = null;
        return;
      }

      const commentText = String(comment || "").trim();
      segments.push({
        raw: `${startKeyword} ${text}.`,
        lineStart: currentStartLine || endLine || baseLineStart,
        comment: commentText,
        commentLines: commentText ? [commentText] : []
      });
      current = "";
      currentStartLine = null;
    };

    for (const entry of lineEntries) {
      const lineNumber = entry && entry.line ? Number(entry.line || 0) || null : null;
      const lineComment = entry && entry.comment ? String(entry.comment || "").trim() : "";
      let code = entry && entry.code ? String(entry.code || "") : "";
      code = code.trim();
      if (!code) {
        continue;
      }
      code = code.replace(prefixPattern, "").trim();
      if (!code) {
        continue;
      }

      if (current.trim()) {
        current += " ";
      }

      for (let index = 0; index < code.length; index += 1) {
        const char = code[index];
        const next = index + 1 < code.length ? code[index + 1] : "";

        if (char === "'" && !inPipe) {
          if (inSingleQuote && next === "'") {
            if (!currentStartLine && current.trim().length === 0) {
              currentStartLine = lineNumber || baseLineStart;
            }
            current += "''";
            index += 1;
            continue;
          }
          inSingleQuote = !inSingleQuote;
          if (!currentStartLine && current.trim().length === 0 && char.trim()) {
            currentStartLine = lineNumber || baseLineStart;
          }
          current += char;
          continue;
        }

        if (char === "|" && !inSingleQuote) {
          if (inPipe && next === "|") {
            if (!currentStartLine && current.trim().length === 0) {
              currentStartLine = lineNumber || baseLineStart;
            }
            current += "||";
            index += 1;
            continue;
          }
          inPipe = !inPipe;
          if (!currentStartLine && current.trim().length === 0 && char.trim()) {
            currentStartLine = lineNumber || baseLineStart;
          }
          current += char;
          continue;
        }

        if (char === "," && !inSingleQuote && !inPipe) {
          const rest = code.slice(index + 1).trim();
          const commentForSegment = rest ? "" : lineComment;
          pushSegment({ comment: commentForSegment, endLine: lineNumber });
          continue;
        }

        if (char === "." && !inSingleQuote && !inPipe) {
          const rest = code.slice(index + 1).trim();
          if (!rest) {
            pushSegment({ comment: lineComment, endLine: lineNumber });
            break;
          }
        }

        if (!currentStartLine && current.trim().length === 0 && char.trim()) {
          currentStartLine = lineNumber || baseLineStart;
        }
        current += char;
      }
    }

    if (current.trim()) {
      pushSegment({ comment: "", endLine: null });
    }

    if (!segments.length) {
      return splitChainedStatement(raw, startKeyword).map((partRaw) => ({
        raw: partRaw,
        lineStart: baseLineStart,
        comment: "",
        commentLines: []
      }));
    }

    return segments;
  }

  function splitChainedStatement(raw, startKeyword) {
    const pattern = new RegExp(`^\\s*${escapeRegExp(startKeyword)}\\s*:\\s*`, "i");
    const match = raw.match(pattern);
    if (!match) {
      return [raw];
    }

    let body = raw.slice(match[0].length).trim();
    body = body.replace(/\.$/, "").trim();
    if (!body) {
      return [];
    }

    const parts = splitByCommaOutsideQuotes(body)
      .map((part) => part.trim())
      .filter(Boolean);

    return parts.map((part) => `${startKeyword} ${part}.`);
  }

  function splitByCommaOutsideQuotes(text) {
    const parts = [];
    let current = "";
    let inSingleQuote = false;
    let inPipe = false;

    for (let index = 0; index < text.length; index += 1) {
      const char = text[index];
      const next = index + 1 < text.length ? text[index + 1] : "";

      if (char === "'" && !inPipe) {
        if (inSingleQuote && next === "'") {
          current += "''";
          index += 1;
          continue;
        }
        inSingleQuote = !inSingleQuote;
        current += char;
        continue;
      }

      if (char === "|" && !inSingleQuote) {
        if (inPipe && next === "|") {
          current += "||";
          index += 1;
          continue;
        }
        inPipe = !inPipe;
        current += char;
        continue;
      }

      if (char === "," && !inSingleQuote && !inPipe) {
        parts.push(current.trim());
        current = "";
        continue;
      }

      current += char;
    }

    if (current.trim()) {
      parts.push(current.trim());
    }

    return parts;
  }

  function escapeRegExp(text) {
    return String(text).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function tokenize(statementRaw) {
    const trimmed = statementRaw.trim();
    if (!trimmed) {
      return [];
    }

    const withoutDot = trimmed.replace(/\.$/, "").trim();
    const tokens = [];
    let index = 0;

    while (index < withoutDot.length) {
      const char = withoutDot[index];

      if (/\s/.test(char)) {
        index += 1;
        continue;
      }

      if (char === "'" || char === "|") {
        const quoteChar = char;
        let end = index + 1;
        while (end < withoutDot.length) {
          const current = withoutDot[end];
          const next = end + 1 < withoutDot.length ? withoutDot[end + 1] : "";
          if (current === quoteChar) {
            if ((quoteChar === "'" || quoteChar === "|") && next === quoteChar) {
              end += 2;
              continue;
            }
            end += 1;
            break;
          }
          end += 1;
        }
        const token = withoutDot.slice(index, end);
        tokens.push(token);
        index = end;
        continue;
      }

      let end = index + 1;
      while (end < withoutDot.length && !/\s/.test(withoutDot[end])) {
        end += 1;
      }
      const token = withoutDot.slice(index, end);
      tokens.push(token);
      index = end;
    }

    return tokens
      .map((token) => token.replace(/[,:\u00A0]+$/, ""))
      .filter(Boolean)
      .map((token) => ({
        raw: token,
        upper: token.toUpperCase()
      }));
  }

  function detectKeywords(tokens, config) {
    const keywords = [];
    const phraseEntries = buildPhraseEntries(config.keywordPhrases);

    for (let i = 0; i < tokens.length; i += 1) {
      const match = matchPhraseAt(tokens, i, phraseEntries);
      if (match) {
        const phraseText = tokens
          .slice(i, i + match.length)
          .map((token) => token.raw)
          .join(" ");

        keywords.push({ text: phraseText, label: match.label });
        i += match.length - 1;
        continue;
      }

      const label = config.keywordLabels[tokens[i].upper];
      if (label) {
        keywords.push({ text: tokens[i].raw, label });
      }
    }

    return keywords;
  }

  function buildPhraseEntries(phraseMap) {
    return Object.entries(phraseMap || {})
      .map(([phrase, label]) => ({
        phrase,
        label,
        tokens: phrase.split(/\s+/)
      }))
      .sort((a, b) => b.tokens.length - a.tokens.length);
  }

  function matchPhraseAt(tokens, index, phraseEntries) {
    for (const entry of phraseEntries) {
      if (index + entry.tokens.length > tokens.length) {
        continue;
      }

      let matches = true;
      for (let offset = 0; offset < entry.tokens.length; offset += 1) {
        if (tokens[index + offset].upper !== entry.tokens[offset]) {
          matches = false;
          break;
        }
      }

      if (matches) {
        return {
          phrase: entry.phrase,
          label: entry.label,
          length: entry.tokens.length
        };
      }
    }

    return null;
  }

  function captureValues(tokens, config, commentText) {
    const values = [];
    const descMap = config.valueDescriptions || {};
    const rules = (config.captureRules || []).filter(
      (rule) => rule.afterTokens && rule.afterTokens.length
    );
    const statementDesc = commentText || "";

    for (let index = 0; index < tokens.length; index += 1) {
      let bestRule = null;

      for (const rule of rules) {
        if (!matchesTokens(tokens, index, rule.afterTokens)) {
          continue;
        }

        if (!bestRule || rule.afterTokens.length > bestRule.afterTokens.length) {
          bestRule = rule;
        }
      }

      if (!bestRule) {
        continue;
      }

      const valueIndex = index + bestRule.afterTokens.length;
      if (valueIndex < tokens.length) {
        const captured = captureValue(tokens, valueIndex, bestRule);
        const userDesc = resolveUserDesc(descMap, bestRule.descKey, captured.upper);

        values.push({
          name: bestRule.name,
          value: captured.raw,
          label: bestRule.label || bestRule.name,
          userDesc: userDesc || "",
          codeDesc: statementDesc
        });
      }

      index += bestRule.afterTokens.length - 1;
    }

    return values;
  }

  function captureAssignmentValues(tokens, commentText) {
    if (!Array.isArray(tokens) || tokens.length < 3) {
      return [];
    }

    const statementDesc = commentText || "";
    const target = tokens[0] ? tokens[0].raw : "";
    const op = tokens[1] ? tokens[1].raw : "";
    const expr = tokens
      .slice(2)
      .map((t) => t.raw)
      .join(" ")
      .trim();

    return [
      { name: "target", value: target, label: "target", userDesc: "", codeDesc: statementDesc },
      { name: "op", value: op, label: "op", userDesc: "", codeDesc: statementDesc },
      { name: "expr", value: expr, label: "expr", userDesc: "", codeDesc: statementDesc }
    ];
  }

  function captureMethodCallExpressionValues(raw, commentText) {
    const parsed = parseMethodCallExpressionFromRaw(raw);
    if (!parsed) {
      return [];
    }

    const statementDesc = commentText || "";
    const values = [];
    const addEntry = (name, value, label) => {
      const text = String(value || "").trim();
      if (!text) {
        return;
      }
      values.push({
        name,
        value: text,
        label: label || name,
        userDesc: "",
        codeDesc: statementDesc
      });
    };

    addEntry("target", parsed.callTarget, "target");

    if (parsed.receivingTarget && !parsed.sectionRawByName.receivingRaw) {
      addEntry("receivingRaw", `result = ${parsed.receivingTarget}`, "receiving");
    }

    for (const sectionName of ["exporting", "importing", "changing", "receiving", "exceptions"]) {
      const rawKey = `${sectionName}Raw`;
      addEntry(rawKey, parsed.sectionRawByName[rawKey], sectionName);
    }

    return values;
  }

  function parseMethodCallExpressionFromRaw(raw) {
    const textRaw = String(raw || "").trim();
    if (!textRaw) {
      return null;
    }

    const text = textRaw.endsWith(".")
      ? textRaw.slice(0, -1).trim()
      : textRaw;

    if (!text || /^CALL\s+METHOD\b/i.test(text)) {
      return null;
    }

    let receivingTarget = "";
    let callExpr = text;

    const assignmentMatch = text.match(
      /^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*(?:-[A-Za-z_][A-Za-z0-9_]*)*)\s*=\s*(.+)$/i
    );
    if (assignmentMatch) {
      receivingTarget = assignmentMatch[1].trim();
      callExpr = assignmentMatch[2].trim();
    }

    const targetMatch = callExpr.match(
      /^((?:<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(?:->|=>)(?:[A-Za-z_][A-Za-z0-9_]*~)?[A-Za-z_][A-Za-z0-9_]*)\s*\(/i
    );
    if (!targetMatch) {
      return null;
    }

    const callTarget = targetMatch[1].trim();
    const openIndex = callExpr.indexOf("(");
    const closeIndex = callExpr.lastIndexOf(")");
    if (openIndex < 0 || closeIndex <= openIndex || closeIndex !== callExpr.length - 1) {
      return null;
    }
    const argsRaw = callExpr.slice(openIndex + 1, closeIndex).trim();

    return {
      receivingTarget,
      callExpr,
      callTarget,
      argsRaw,
      sectionRawByName: parseMethodCallExpressionSectionRaw(argsRaw)
    };
  }

  function parseMethodCallExpressionSectionRaw(argsRaw) {
    const output = {
      exportingRaw: "",
      importingRaw: "",
      changingRaw: "",
      receivingRaw: "",
      exceptionsRaw: ""
    };

    const trimmed = String(argsRaw || "").trim();
    if (!trimmed) {
      return output;
    }

    const tokens = tokenize(`${trimmed}.`);
    if (!tokens.length) {
      return output;
    }

    const sectionByUpper = {
      EXPORTING: "exportingRaw",
      IMPORTING: "importingRaw",
      CHANGING: "changingRaw",
      RECEIVING: "receivingRaw",
      EXCEPTIONS: "exceptionsRaw"
    };
    const sectionSet = new Set(Object.keys(sectionByUpper));
    const markers = [];
    for (let index = 0; index < tokens.length; index += 1) {
      if (sectionSet.has(tokens[index].upper)) {
        markers.push({ sectionUpper: tokens[index].upper, startIndex: index });
      }
    }

    if (!markers.length) {
      output.exportingRaw = trimmed;
      return output;
    }

    for (let index = 0; index < markers.length; index += 1) {
      const marker = markers[index];
      const next = markers[index + 1];
      const segmentStart = marker.startIndex + 1;
      const segmentEnd = next ? next.startIndex : tokens.length;
      const segmentRaw = tokens
        .slice(segmentStart, segmentEnd)
        .map((token) => token.raw)
        .join(" ")
        .trim();
      const key = sectionByUpper[marker.sectionUpper];
      if (!key || !segmentRaw) {
        continue;
      }
      output[key] = output[key]
        ? `${output[key]} ${segmentRaw}`
        : segmentRaw;
    }

    return output;
  }

  function captureValue(tokens, startIndex, rule) {
    if (rule.capture === "rest") {
      const stopTokens = rule.stopTokensUpper || [];
      const parts = [];
      for (let i = startIndex; i < tokens.length; i += 1) {
        if (stopTokens.length && stopTokens.includes(tokens[i].upper)) {
          break;
        }
        parts.push(tokens[i].raw);
      }
      const raw = parts.join(" ").trim();
      return { raw, upper: raw.toUpperCase() };
    }

    const token = tokens[startIndex];
    return token ? { raw: token.raw, upper: token.upper } : { raw: "", upper: "" };
  }

  function matchesTokens(tokens, startIndex, expectedTokens) {
    if (startIndex + expectedTokens.length > tokens.length) {
      return false;
    }

    for (let offset = 0; offset < expectedTokens.length; offset += 1) {
      if (tokens[startIndex + offset].upper !== expectedTokens[offset]) {
        return false;
      }
    }

    return true;
  }

  function resolveUserDesc(descMap, descKey, valueUpper) {
    if (!descKey) {
      return "";
    }

    const map = descMap[descKey];
    if (!map) {
      return "";
    }

    return map[valueUpper] || "";
  }

  return {
    AbapObject,
    normalizeConfig,
    registerConfig,
    getConfigs,
    parseAbapText
  };
});
</script>
  <!-- abap-parser-configs:start -->
  <script>
// inlined from: ./configs.generated/append.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: append.json");
    return;
  }

  const config = {
    "_sourceFile": "append.json",
    "object": "APPEND",
    "match": {
      "startKeyword": "APPEND"
    },
    "keywordLabels": {
      "APPEND": "stmt",
      "TO": "to",
      "LINES": "lines",
      "OF": "of",
      "INITIAL": "initial",
      "LINE": "line",
      "ASSIGNING": "assigning",
      "REFERENCE": "reference",
      "INTO": "into"
    },
    "keywordPhrases": {
      "LINES OF": "lines-of",
      "INITIAL LINE": "initial-line",
      "REFERENCE INTO": "reference-into"
    },
    "captureRules": [
      {
        "after": "APPEND",
        "name": "what",
        "label": "what"
      },
      {
        "after": "APPEND LINES OF",
        "name": "source",
        "label": "source-itab"
      },
      {
        "after": "TO",
        "name": "to",
        "label": "to-itab"
      },
      {
        "after": "ASSIGNING",
        "name": "assigning",
        "label": "assigning"
      },
      {
        "after": "REFERENCE INTO",
        "name": "refInto",
        "label": "reference-into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/assignment.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: assignment.json");
    return;
  }

  const config = {
    "_sourceFile": "assignment.json",
    "object": "ASSIGNMENT",
    "match": {
      "type": "assignment"
    },
    "keywordLabels": {
      "=": "assign",
      "+=": "add-assign",
      "-=": "sub-assign",
      "*=": "mul-assign",
      "/=": "div-assign",
      "?=": "cast"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/call-function.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: call-function.json");
    return;
  }

  const config = {
    "_sourceFile": "call-function.json",
    "object": "CALL_FUNCTION",
    "match": {
      "startPhrase": "CALL FUNCTION"
    },
    "extras": {
      "type": "callFunction"
    },
    "keywordLabels": {
      "CALL": "stmt",
      "FUNCTION": "function",
      "DESTINATION": "destination",
      "IN": "in",
      "BACKGROUND": "background",
      "TASK": "task",
      "EXPORTING": "exporting",
      "IMPORTING": "importing",
      "CHANGING": "changing",
      "TABLES": "tables",
      "EXCEPTIONS": "exceptions"
    },
    "keywordPhrases": {
      "CALL FUNCTION": "call-function",
      "IN BACKGROUND TASK": "in-background-task"
    },
    "captureRules": [
      {
        "after": "CALL FUNCTION",
        "name": "name",
        "label": "function-name",
        "descKey": "name"
      },
      {
        "after": "DESTINATION",
        "name": "destination",
        "label": "destination"
      },
      {
        "after": "EXPORTING",
        "name": "exportingRaw",
        "label": "exporting",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "CHANGING",
          "TABLES",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "IMPORTING",
        "name": "importingRaw",
        "label": "importing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "CHANGING",
          "TABLES",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "TABLES",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "TABLES",
        "name": "tablesRaw",
        "label": "tables",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "CHANGING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "EXCEPTIONS",
        "name": "exceptionsRaw",
        "label": "exceptions",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/call-method-expression.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: call-method-expression.json");
    return;
  }

  const config = {
    "_sourceFile": "call-method-expression.json",
    "object": "CALL_METHOD",
    "match": {
      "type": "methodCallExpr"
    },
    "extras": {
      "type": "callMethodExpr"
    },
    "keywordLabels": {
      "EXPORTING": "exporting",
      "IMPORTING": "importing",
      "CHANGING": "changing",
      "RECEIVING": "receiving",
      "EXCEPTIONS": "exceptions"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/call-method.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: call-method.json");
    return;
  }

  const config = {
    "_sourceFile": "call-method.json",
    "object": "CALL_METHOD",
    "match": {
      "startPhrase": "CALL METHOD"
    },
    "extras": {
      "type": "callMethod"
    },
    "keywordLabels": {
      "CALL": "stmt",
      "METHOD": "method",
      "EXPORTING": "exporting",
      "IMPORTING": "importing",
      "CHANGING": "changing",
      "RECEIVING": "receiving",
      "EXCEPTIONS": "exceptions"
    },
    "keywordPhrases": {
      "CALL METHOD": "call-method"
    },
    "captureRules": [
      {
        "after": "CALL METHOD",
        "name": "target",
        "label": "target",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "CHANGING",
          "RECEIVING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "EXPORTING",
        "name": "exportingRaw",
        "label": "exporting",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "CHANGING",
          "RECEIVING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "IMPORTING",
        "name": "importingRaw",
        "label": "importing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "CHANGING",
          "RECEIVING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "RECEIVING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "RECEIVING",
        "name": "receivingRaw",
        "label": "receiving",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "CHANGING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "EXCEPTIONS",
        "name": "exceptionsRaw",
        "label": "exceptions",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/call-transaction.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: call-transaction.json");
    return;
  }

  const config = {
    "_sourceFile": "call-transaction.json",
    "object": "CALL_TRANSACTION",
    "match": {
      "startPhrase": "CALL TRANSACTION"
    },
    "keywordLabels": {
      "CALL": "stmt",
      "TRANSACTION": "transaction",
      "USING": "using",
      "SKIP": "skip",
      "FIRST": "first",
      "SCREEN": "screen",
      "AND": "and",
      "RETURN": "return",
      "MODE": "mode",
      "UPDATE": "update",
      "MESSAGES": "messages",
      "INTO": "into"
    },
    "keywordPhrases": {
      "CALL TRANSACTION": "call-transaction",
      "SKIP FIRST SCREEN": "skip-first-screen",
      "AND RETURN": "and-return",
      "MESSAGES INTO": "messages-into"
    },
    "captureRules": [
      {
        "after": "CALL TRANSACTION",
        "name": "tcode",
        "label": "tcode",
        "descKey": "tcode"
      },
      {
        "after": "USING",
        "name": "using",
        "label": "using"
      },
      {
        "after": "MODE",
        "name": "mode",
        "label": "mode"
      },
      {
        "after": "UPDATE",
        "name": "update",
        "label": "update"
      },
      {
        "after": "MESSAGES INTO",
        "name": "messagesInto",
        "label": "messages-into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/case.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: case.json");
    return;
  }

  const config = {
    "_sourceFile": "case.json",
    "object": "CASE",
    "match": {
      "startKeyword": "CASE"
    },
    "block": {
      "endKeyword": "ENDCASE"
    },
    "keywordLabels": {
      "CASE": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "CASE",
        "name": "expr",
        "label": "expression",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/catch.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: catch.json");
    return;
  }

  const config = {
    "_sourceFile": "catch.json",
    "object": "CATCH",
    "match": {
      "startKeyword": "CATCH"
    },
    "keywordLabels": {
      "CATCH": "stmt",
      "INTO": "into"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "CATCH",
        "name": "exception",
        "label": "exception",
        "capture": "rest",
        "stopTokens": [
          "INTO"
        ]
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/class-data.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: class-data.json");
    return;
  }

  const config = {
    "_sourceFile": "class-data.json",
    "object": "CLASS-DATA",
    "match": {
      "startKeyword": "CLASS-DATA"
    },
    "keywordLabels": {
      "CLASS-DATA": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to",
      "VALUE": "value",
      "LENGTH": "length",
      "DECIMALS": "decimals",
      "READ-ONLY": "read-only"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "CLASS-DATA",
        "name": "name",
        "label": "attr-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like-name",
        "descKey": "like"
      },
      {
        "after": "VALUE",
        "name": "value",
        "label": "value",
        "descKey": "value"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/class-methods.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: class-methods.json");
    return;
  }

  const config = {
    "_sourceFile": "class-methods.json",
    "object": "CLASS-METHODS",
    "match": {
      "startKeyword": "CLASS-METHODS"
    },
    "extras": {
      "type": "methodSignature"
    },
    "keywordLabels": {
      "CLASS-METHODS": "stmt",
      "IMPORTING": "importing",
      "EXPORTING": "exporting",
      "CHANGING": "changing",
      "RETURNING": "returning",
      "RAISING": "raising"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "CLASS-METHODS",
        "name": "name",
        "label": "method-name",
        "descKey": "name"
      },
      {
        "after": "IMPORTING",
        "name": "importingRaw",
        "label": "importing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "CHANGING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "EXPORTING",
        "name": "exportingRaw",
        "label": "exporting",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "CHANGING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "EXPORTING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "RETURNING",
        "name": "returningRaw",
        "label": "returning",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "EXPORTING",
          "CHANGING",
          "RAISING"
        ]
      },
      {
        "after": "RAISING",
        "name": "raisingRaw",
        "label": "raising",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/class.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: class.json");
    return;
  }

  const config = {
    "_sourceFile": "class.json",
    "object": "CLASS",
    "match": {
      "startKeyword": "CLASS"
    },
    "block": {
      "endKeyword": "ENDCLASS"
    },
    "keywordLabels": {
      "CLASS": "stmt",
      "DEFINITION": "definition",
      "IMPLEMENTATION": "implementation",
      "PUBLIC": "public",
      "PROTECTED": "protected",
      "PRIVATE": "private",
      "SECTION": "section",
      "CREATE": "create"
    },
    "keywordPhrases": {
      "PUBLIC SECTION": "public-section",
      "PROTECTED SECTION": "protected-section",
      "PRIVATE SECTION": "private-section",
      "CREATE PUBLIC": "create-public"
    },
    "captureRules": [
      {
        "after": "CLASS",
        "name": "name",
        "label": "class-name",
        "descKey": "name"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/cleanup.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: cleanup.json");
    return;
  }

  const config = {
    "_sourceFile": "cleanup.json",
    "object": "CLEANUP",
    "match": {
      "startKeyword": "CLEANUP"
    },
    "keywordLabels": {
      "CLEANUP": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/clear.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: clear.json");
    return;
  }

  const config = {
    "_sourceFile": "clear.json",
    "object": "CLEAR",
    "match": {
      "startKeyword": "CLEAR"
    },
    "keywordLabels": {
      "CLEAR": "stmt",
      "WITH": "with"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "CLEAR",
        "name": "target",
        "label": "target"
      },
      {
        "after": "WITH",
        "name": "with",
        "label": "with"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/constants.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: constants.json");
    return;
  }

  const config = {
    "_sourceFile": "constants.json",
    "object": "CONSTANTS",
    "match": {
      "startKeyword": "CONSTANTS"
    },
    "keywordLabels": {
      "CONSTANTS": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to",
      "VALUE": "value",
      "LENGTH": "length",
      "DECIMALS": "decimals"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "CONSTANTS",
        "name": "name",
        "label": "const-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like-name",
        "descKey": "like"
      },
      {
        "after": "VALUE",
        "name": "value",
        "label": "value",
        "descKey": "value"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/data.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: data.json");
    return;
  }

  const config = {
    "_sourceFile": "data.json",
    "object": "DATA",
    "match": {
      "startKeyword": "DATA"
    },
    "keywordLabels": {
      "DATA": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "BEGIN": "begin",
      "OF": "of",
      "END": "end",
      "REF": "ref",
      "TO": "to",
      "VALUE": "value",
      "LENGTH": "length",
      "DECIMALS": "decimals",
      "READ-ONLY": "read-only"
    },
    "keywordPhrases": {
      "BEGIN OF": "begin-of",
      "END OF": "end-of",
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "DATA BEGIN OF",
        "name": "name",
        "label": "struct-name",
        "descKey": "name"
      },
      {
        "after": "DATA END OF",
        "name": "name",
        "label": "struct-name",
        "descKey": "name"
      },
      {
        "after": "DATA",
        "name": "name",
        "label": "var-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like-name",
        "descKey": "like"
      },
      {
        "after": "VALUE",
        "name": "value",
        "label": "value",
        "descKey": "value"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/delete-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: delete-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "delete-itab.json",
    "object": "DELETE_ITAB",
    "match": {
      "startKeyword": "DELETE"
    },
    "extras": {
      "type": "deleteItab"
    },
    "keywordLabels": {
      "DELETE": "stmt",
      "FROM": "from",
      "INDEX": "index",
      "WHERE": "where",
      "ADJACENT": "adjacent",
      "DUPLICATES": "duplicates",
      "COMPARING": "comparing"
    },
    "keywordPhrases": {
      "ADJACENT DUPLICATES": "adjacent-duplicates",
      "DELETE ADJACENT DUPLICATES": "delete-adjacent-duplicates"
    },
    "captureRules": [
      {
        "after": "DELETE",
        "name": "target",
        "label": "target"
      },
      {
        "after": "FROM",
        "name": "from",
        "label": "from"
      },
      {
        "after": "INDEX",
        "name": "index",
        "label": "index"
      },
      {
        "after": "WHERE",
        "name": "where",
        "label": "where",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/do.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: do.json");
    return;
  }

  const config = {
    "_sourceFile": "do.json",
    "object": "DO",
    "match": {
      "startKeyword": "DO"
    },
    "block": {
      "endKeyword": "ENDDO"
    },
    "keywordLabels": {
      "DO": "stmt",
      "TIMES": "times"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "DO",
        "name": "times",
        "label": "times"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/else.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: else.json");
    return;
  }

  const config = {
    "_sourceFile": "else.json",
    "object": "ELSE",
    "match": {
      "startKeyword": "ELSE"
    },
    "keywordLabels": {
      "ELSE": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/elseif.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: elseif.json");
    return;
  }

  const config = {
    "_sourceFile": "elseif.json",
    "object": "ELSEIF",
    "match": {
      "startKeyword": "ELSEIF"
    },
    "extras": {
      "type": "ifCondition"
    },
    "keywordLabels": {
      "ELSEIF": "stmt",
      "AND": "and",
      "OR": "or",
      "NOT": "not",
      "IS": "is",
      "INITIAL": "initial"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "ELSEIF",
        "name": "condition",
        "label": "condition",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/field-symbols.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: field-symbols.json");
    return;
  }

  const config = {
    "_sourceFile": "field-symbols.json",
    "object": "FIELD-SYMBOLS",
    "match": {
      "startKeyword": "FIELD-SYMBOLS"
    },
    "keywordLabels": {
      "FIELD-SYMBOLS": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to",
      "STRUCTURE": "structure"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "FIELD-SYMBOLS",
        "name": "name",
        "label": "fs-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like",
        "descKey": "like"
      },
      {
        "after": "STRUCTURE",
        "name": "structure",
        "label": "structure",
        "descKey": "structure"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/form.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: form.json");
    return;
  }

  const config = {
    "_sourceFile": "form.json",
    "object": "FORM",
    "match": {
      "startKeyword": "FORM"
    },
    "block": {
      "endKeyword": "ENDFORM"
    },
    "extras": {
      "type": "form"
    },
    "keywordLabels": {
      "FORM": "stmt",
      "USING": "using",
      "CHANGING": "changing",
      "TABLES": "tables",
      "RAISING": "raising"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "FORM",
        "name": "name",
        "label": "form-name",
        "descKey": "name"
      },
      {
        "after": "USING",
        "name": "usingRaw",
        "label": "using",
        "capture": "rest",
        "stopTokens": [
          "CHANGING",
          "TABLES",
          "RAISING"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "USING",
          "TABLES",
          "RAISING"
        ]
      },
      {
        "after": "TABLES",
        "name": "tablesRaw",
        "label": "tables",
        "capture": "rest",
        "stopTokens": [
          "USING",
          "CHANGING",
          "RAISING"
        ]
      },
      {
        "after": "RAISING",
        "name": "raisingRaw",
        "label": "raising",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/if.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: if.json");
    return;
  }

  const config = {
    "_sourceFile": "if.json",
    "object": "IF",
    "match": {
      "startKeyword": "IF"
    },
    "extras": {
      "type": "ifCondition"
    },
    "block": {
      "endKeyword": "ENDIF"
    },
    "keywordLabels": {
      "IF": "stmt",
      "AND": "and",
      "OR": "or",
      "NOT": "not",
      "IS": "is",
      "INITIAL": "initial"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "IF",
        "name": "condition",
        "label": "condition",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/insert-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: insert-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "insert-itab.json",
    "object": "INSERT_ITAB",
    "match": {
      "startKeyword": "INSERT"
    },
    "keywordLabels": {
      "INSERT": "stmt",
      "INTO": "into",
      "TABLE": "table",
      "LINES": "lines",
      "OF": "of",
      "INDEX": "index",
      "ASSIGNING": "assigning",
      "REFERENCE": "reference"
    },
    "keywordPhrases": {
      "INTO TABLE": "into-table",
      "LINES OF": "lines-of",
      "REFERENCE INTO": "reference-into"
    },
    "captureRules": [
      {
        "after": "INSERT",
        "name": "what",
        "label": "what"
      },
      {
        "after": "INSERT LINES OF",
        "name": "source",
        "label": "source-itab"
      },
      {
        "after": "INTO TABLE",
        "name": "intoTable",
        "label": "into-table"
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      },
      {
        "after": "INDEX",
        "name": "index",
        "label": "index"
      },
      {
        "after": "ASSIGNING",
        "name": "assigning",
        "label": "assigning"
      },
      {
        "after": "REFERENCE INTO",
        "name": "refInto",
        "label": "reference-into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/loop-at-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: loop-at-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "loop-at-itab.json",
    "object": "LOOP_AT_ITAB",
    "match": {
      "startPhrase": "LOOP AT"
    },
    "extras": {
      "type": "loopAtItab"
    },
    "block": {
      "endKeyword": "ENDLOOP"
    },
    "keywordLabels": {
      "LOOP": "stmt",
      "AT": "at",
      "INTO": "into",
      "ASSIGNING": "assigning",
      "REFERENCE": "reference",
      "WHERE": "where",
      "FROM": "from",
      "TO": "to"
    },
    "keywordPhrases": {
      "LOOP AT": "loop-at",
      "REFERENCE INTO": "reference-into"
    },
    "captureRules": [
      {
        "after": "LOOP AT",
        "name": "itab",
        "label": "itab",
        "descKey": "itab"
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      },
      {
        "after": "ASSIGNING",
        "name": "assigning",
        "label": "assigning"
      },
      {
        "after": "REFERENCE INTO",
        "name": "refInto",
        "label": "reference-into"
      },
      {
        "after": "FROM",
        "name": "from",
        "label": "from"
      },
      {
        "after": "TO",
        "name": "to",
        "label": "to"
      },
      {
        "after": "WHERE",
        "name": "where",
        "label": "where",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/method.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: method.json");
    return;
  }

  const config = {
    "_sourceFile": "method.json",
    "object": "METHOD",
    "match": {
      "startKeyword": "METHOD"
    },
    "block": {
      "endKeyword": "ENDMETHOD"
    },
    "keywordLabels": {
      "METHOD": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "METHOD",
        "name": "name",
        "label": "method-name",
        "descKey": "name"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/methods.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: methods.json");
    return;
  }

  const config = {
    "_sourceFile": "methods.json",
    "object": "METHODS",
    "match": {
      "startKeyword": "METHODS"
    },
    "extras": {
      "type": "methodSignature"
    },
    "keywordLabels": {
      "METHODS": "stmt",
      "IMPORTING": "importing",
      "EXPORTING": "exporting",
      "CHANGING": "changing",
      "RETURNING": "returning",
      "RAISING": "raising"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "METHODS",
        "name": "name",
        "label": "method-name",
        "descKey": "name"
      },
      {
        "after": "IMPORTING",
        "name": "importingRaw",
        "label": "importing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "CHANGING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "EXPORTING",
        "name": "exportingRaw",
        "label": "exporting",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "CHANGING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "EXPORTING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "RETURNING",
        "name": "returningRaw",
        "label": "returning",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "EXPORTING",
          "CHANGING",
          "RAISING"
        ]
      },
      {
        "after": "RAISING",
        "name": "raisingRaw",
        "label": "raising",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/modify-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: modify-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "modify-itab.json",
    "object": "MODIFY_ITAB",
    "match": {
      "startKeyword": "MODIFY"
    },
    "extras": {
      "type": "modifyItab"
    },
    "keywordLabels": {
      "MODIFY": "stmt",
      "TABLE": "table",
      "FROM": "from",
      "INDEX": "index",
      "TRANSPORTING": "transporting",
      "WHERE": "where"
    },
    "keywordPhrases": {
      "MODIFY TABLE": "modify-table"
    },
    "captureRules": [
      {
        "after": "MODIFY TABLE",
        "name": "itab",
        "label": "itab"
      },
      {
        "after": "MODIFY",
        "name": "itabOrDbtab",
        "label": "target"
      },
      {
        "after": "FROM",
        "name": "from",
        "label": "from"
      },
      {
        "after": "INDEX",
        "name": "index",
        "label": "index"
      },
      {
        "after": "TRANSPORTING",
        "name": "transporting",
        "label": "transporting",
        "capture": "rest",
        "stopTokens": [
          "WHERE"
        ]
      },
      {
        "after": "WHERE",
        "name": "where",
        "label": "where",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/move-corresponding.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: move-corresponding.json");
    return;
  }

  const config = {
    "_sourceFile": "move-corresponding.json",
    "object": "MOVE-CORRESPONDING",
    "match": {
      "startKeyword": "MOVE-CORRESPONDING"
    },
    "keywordLabels": {
      "MOVE-CORRESPONDING": "stmt",
      "TO": "to",
      "EXPANDING": "expanding",
      "NESTED": "nested",
      "TABLES": "tables",
      "KEEPING": "keeping",
      "TARGET": "target",
      "LINES": "lines"
    },
    "keywordPhrases": {
      "EXPANDING NESTED TABLES": "expanding-nested-tables",
      "KEEPING TARGET LINES": "keeping-target-lines"
    },
    "captureRules": [
      {
        "after": "MOVE-CORRESPONDING",
        "name": "source",
        "label": "source"
      },
      {
        "after": "TO",
        "name": "target",
        "label": "target"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/move.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: move.json");
    return;
  }

  const config = {
    "_sourceFile": "move.json",
    "object": "MOVE",
    "match": {
      "startKeyword": "MOVE"
    },
    "keywordLabels": {
      "MOVE": "stmt",
      "TO": "to"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "MOVE",
        "name": "source",
        "label": "source",
        "capture": "rest",
        "stopTokens": [
          "TO"
        ]
      },
      {
        "after": "TO",
        "name": "target",
        "label": "target",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/parameters.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: parameters.json");
    return;
  }

  const config = {
    "_sourceFile": "parameters.json",
    "object": "PARAMETERS",
    "match": {
      "startKeyword": "PARAMETERS"
    },
    "keywordLabels": {
      "PARAMETERS": "stmt",
      "TYPE": "type",
      "DEFAULT": "default",
      "OBLIGATORY": "obligatory",
      "AS": "as",
      "CHECKBOX": "checkbox",
      "RADIOBUTTON": "radiobutton",
      "LISTBOX": "listbox",
      "VISIBLE": "visible",
      "LENGTH": "length",
      "NO-DISPLAY": "no-display",
      "LOWER": "lower",
      "CASE": "case",
      "MEMORY": "memory",
      "ID": "id",
      "MODIF": "modif",
      "GROUP": "group",
      "DECIMALS": "decimals",
      "NO-EXTENSION": "no-extension"
    },
    "keywordPhrases": {
      "LOWER CASE": "lower-case",
      "NO-DISPLAY": "no-display",
      "AS CHECKBOX": "as-checkbox",
      "AS RADIOBUTTON": "as-radiobutton",
      "AS LISTBOX": "as-listbox",
      "MEMORY ID": "memory-id",
      "MODIF ID": "modif-id",
      "NO-EXTENSION": "no-extension"
    },
    "captureRules": [
      {
        "after": "PARAMETERS",
        "name": "name",
        "label": "param-name",
        "descKey": "name"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "DEFAULT",
        "name": "default",
        "label": "default-value",
        "descKey": "default"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      },
      {
        "after": "GROUP",
        "name": "group",
        "label": "group-name"
      },
      {
        "after": "MEMORY ID",
        "name": "memoryId",
        "label": "memory-id"
      },
      {
        "after": "MODIF ID",
        "name": "modifId",
        "label": "modif-id"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/perform.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: perform.json");
    return;
  }

  const config = {
    "_sourceFile": "perform.json",
    "object": "PERFORM",
    "match": {
      "startKeyword": "PERFORM"
    },
    "extras": {
      "type": "performCall"
    },
    "keywordLabels": {
      "PERFORM": "stmt",
      "IN": "in",
      "PROGRAM": "program",
      "USING": "using",
      "CHANGING": "changing",
      "TABLES": "tables",
      "IF": "if"
    },
    "keywordPhrases": {
      "IN PROGRAM": "in-program"
    },
    "captureRules": [
      {
        "after": "PERFORM",
        "name": "form",
        "label": "form-name",
        "descKey": "form"
      },
      {
        "after": "IN PROGRAM",
        "name": "program",
        "label": "program"
      },
      {
        "after": "USING",
        "name": "usingRaw",
        "label": "using",
        "capture": "rest",
        "stopTokens": [
          "CHANGING",
          "TABLES",
          "IF"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "USING",
          "TABLES",
          "IF"
        ]
      },
      {
        "after": "TABLES",
        "name": "tablesRaw",
        "label": "tables",
        "capture": "rest",
        "stopTokens": [
          "USING",
          "CHANGING",
          "IF"
        ]
      },
      {
        "after": "IF",
        "name": "ifCondition",
        "label": "if",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/ranges.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: ranges.json");
    return;
  }

  const config = {
    "_sourceFile": "ranges.json",
    "object": "RANGES",
    "match": {
      "startKeyword": "RANGES"
    },
    "keywordLabels": {
      "RANGES": "stmt",
      "FOR": "for",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "RANGES",
        "name": "name",
        "label": "range-name",
        "descKey": "name"
      },
      {
        "after": "FOR",
        "name": "for",
        "label": "for",
        "descKey": "for"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like",
        "descKey": "like"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/read-table.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: read-table.json");
    return;
  }

  const config = {
    "_sourceFile": "read-table.json",
    "object": "READ_TABLE",
    "match": {
      "startPhrase": "READ TABLE"
    },
    "extras": {
      "type": "readTable"
    },
    "keywordLabels": {
      "READ": "stmt",
      "TABLE": "table",
      "WITH": "with",
      "KEY": "key",
      "INDEX": "index",
      "INTO": "into",
      "ASSIGNING": "assigning",
      "REFERENCE": "reference",
      "TRANSPORTING": "transporting",
      "NO": "no",
      "FIELDS": "fields",
      "BINARY": "binary",
      "SEARCH": "search"
    },
    "keywordPhrases": {
      "READ TABLE": "read-table",
      "WITH TABLE KEY": "with-table-key",
      "WITH KEY": "with-key",
      "TRANSPORTING NO FIELDS": "transporting-no-fields",
      "BINARY SEARCH": "binary-search",
      "REFERENCE INTO": "reference-into"
    },
    "captureRules": [
      {
        "after": "READ TABLE",
        "name": "itab",
        "label": "itab"
      },
      {
        "after": "INDEX",
        "name": "index",
        "label": "index"
      },
      {
        "after": "WITH TABLE KEY",
        "name": "withTableKey",
        "label": "with-table-key",
        "capture": "rest",
        "stopTokens": [
          "INTO",
          "ASSIGNING",
          "REFERENCE",
          "TRANSPORTING",
          "BINARY"
        ]
      },
      {
        "after": "WITH KEY",
        "name": "withKey",
        "label": "with-key",
        "capture": "rest",
        "stopTokens": [
          "INTO",
          "ASSIGNING",
          "REFERENCE",
          "TRANSPORTING",
          "BINARY"
        ]
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      },
      {
        "after": "ASSIGNING",
        "name": "assigning",
        "label": "assigning"
      },
      {
        "after": "REFERENCE INTO",
        "name": "refInto",
        "label": "reference-into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/select-options.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: select-options.json");
    return;
  }

  const config = {
    "_sourceFile": "select-options.json",
    "object": "SELECT-OPTIONS",
    "match": {
      "startKeyword": "SELECT-OPTIONS"
    },
    "keywordLabels": {
      "SELECT-OPTIONS": "stmt",
      "FOR": "for",
      "DEFAULT": "default",
      "OBLIGATORY": "obligatory",
      "NO-EXTENSION": "no-extension",
      "NO": "no",
      "INTERVALS": "intervals",
      "LOWER": "lower",
      "CASE": "case",
      "MEMORY": "memory",
      "ID": "id",
      "MODIF": "modif",
      "VISIBLE": "visible",
      "LENGTH": "length"
    },
    "keywordPhrases": {
      "LOWER CASE": "lower-case",
      "NO-EXTENSION": "no-extension",
      "NO INTERVALS": "no-intervals",
      "MEMORY ID": "memory-id",
      "MODIF ID": "modif-id"
    },
    "captureRules": [
      {
        "after": "SELECT-OPTIONS",
        "name": "name",
        "label": "selopt-name",
        "descKey": "name"
      },
      {
        "after": "FOR",
        "name": "for",
        "label": "for"
      },
      {
        "after": "DEFAULT",
        "name": "default",
        "label": "default"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "MEMORY ID",
        "name": "memoryId",
        "label": "memory-id"
      },
      {
        "after": "MODIF ID",
        "name": "modifId",
        "label": "modif-id"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/select.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: select.json");
    return;
  }

  const config = {
    "_sourceFile": "select.json",
    "object": "SELECT",
    "match": {
      "startKeyword": "SELECT"
    },
    "extras": {
      "type": "selectStatement"
    },
    "keywordLabels": {
      "SELECT": "stmt",
      "SINGLE": "single",
      "DISTINCT": "distinct",
      "FROM": "from",
      "INTO": "into",
      "APPENDING": "appending",
      "TABLE": "table",
      "WHERE": "where",
      "ORDER": "order",
      "BY": "by",
      "GROUP": "group",
      "HAVING": "having",
      "UP": "up",
      "TO": "to",
      "ROWS": "rows"
    },
    "keywordPhrases": {
      "INTO TABLE": "into-table",
      "APPENDING TABLE": "appending-table",
      "ORDER BY": "order-by",
      "GROUP BY": "group-by",
      "UP TO": "up-to"
    },
    "captureRules": [
      {
        "after": "SELECT",
        "name": "fields",
        "label": "fields",
        "capture": "rest",
        "stopTokens": [
          "FROM"
        ]
      },
      {
        "after": "FROM",
        "name": "from",
        "label": "from"
      },
      {
        "after": "INTO TABLE",
        "name": "intoTable",
        "label": "into-table"
      },
      {
        "after": "APPENDING TABLE",
        "name": "appendingTable",
        "label": "appending-table"
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      },
      {
        "after": "WHERE",
        "name": "where",
        "label": "where",
        "capture": "rest",
        "stopTokens": [
          "ORDER",
          "GROUP",
          "HAVING",
          "UP"
        ]
      },
      {
        "after": "HAVING",
        "name": "having",
        "label": "having",
        "capture": "rest",
        "stopTokens": [
          "ORDER",
          "UP"
        ]
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/sort-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: sort-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "sort-itab.json",
    "object": "SORT_ITAB",
    "match": {
      "startKeyword": "SORT"
    },
    "keywordLabels": {
      "SORT": "stmt",
      "BY": "by",
      "ASCENDING": "ascending",
      "DESCENDING": "descending",
      "AS": "as",
      "TEXT": "text",
      "USING": "using",
      "KEY": "key"
    },
    "keywordPhrases": {
      "USING KEY": "using-key",
      "AS TEXT": "as-text"
    },
    "captureRules": [
      {
        "after": "SORT",
        "name": "itab",
        "label": "itab"
      },
      {
        "after": "BY",
        "name": "by",
        "label": "by",
        "capture": "rest",
        "stopTokens": [
          "ASCENDING",
          "DESCENDING",
          "USING"
        ]
      },
      {
        "after": "USING KEY",
        "name": "usingKey",
        "label": "using-key"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/statics.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: statics.json");
    return;
  }

  const config = {
    "_sourceFile": "statics.json",
    "object": "STATICS",
    "match": {
      "startKeyword": "STATICS"
    },
    "keywordLabels": {
      "STATICS": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to",
      "VALUE": "value",
      "LENGTH": "length",
      "DECIMALS": "decimals"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "STATICS",
        "name": "name",
        "label": "var-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like-name",
        "descKey": "like"
      },
      {
        "after": "VALUE",
        "name": "value",
        "label": "value",
        "descKey": "value"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/try.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: try.json");
    return;
  }

  const config = {
    "_sourceFile": "try.json",
    "object": "TRY",
    "match": {
      "startKeyword": "TRY"
    },
    "block": {
      "endKeyword": "ENDTRY"
    },
    "keywordLabels": {
      "TRY": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/types.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: types.json");
    return;
  }

  const config = {
    "_sourceFile": "types.json",
    "object": "TYPES",
    "match": {
      "startKeyword": "TYPES"
    },
    "keywordLabels": {
      "TYPES": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "BEGIN": "begin",
      "OF": "of",
      "END": "end"
    },
    "keywordPhrases": {
      "BEGIN OF": "begin-of",
      "END OF": "end-of"
    },
    "captureRules": [
      {
        "after": "TYPES BEGIN OF",
        "name": "name",
        "label": "type-name"
      },
      {
        "after": "TYPES END OF",
        "name": "name",
        "label": "type-name"
      },
      {
        "after": "TYPES",
        "name": "name",
        "label": "type-name"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/when.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: when.json");
    return;
  }

  const config = {
    "_sourceFile": "when.json",
    "object": "WHEN",
    "match": {
      "startKeyword": "WHEN"
    },
    "keywordLabels": {
      "WHEN": "stmt",
      "OTHERS": "others"
    },
    "keywordPhrases": {
      "WHEN OTHERS": "when-others"
    },
    "captureRules": [
      {
        "after": "WHEN",
        "name": "branch",
        "label": "branch",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <!-- abap-parser-configs:end -->
  <script>
// inlined from: ./variable-descriptions.js
(function () {
  "use strict";

  // Variable/system descriptions registry
  // - Mô tả dùng để hiển thị ở cột `declDesc` (nguồn khai báo).
  // - Không ảnh hưởng parse đúng/sai.
  //
  // Priority (cao -> thấp):
  // 1) Override từ UI (localStorage)  ✅ (bạn edit trực tiếp trong viewer)
  // 2) customByScope / customGlobal  ✅ (file này)
  // 3) comment trên dòng khai báo     ✅ (VD: DATA lv_a TYPE i. "desc)
  //
  // Key gợi ý:
  // - System: "SY-UNAME", "SY-REPID", "SY-SUBRC", "ABAP_TRUE", ...
  // - Custom theo scope: `${scopeLabel}:${NAME}` (đều UPPERCASE)
  //   VD: "GLOBAL:GV_USER"
  //       "FORM:MAIN:LV_B"
  //       "FORM:STEP_B:CV_OUT"

  window.AbapVarDescriptions = {
    system: {
      "SY-UNAME": "Current user name",
      "SY-REPID": "Current program name",
      "SY-SUBRC": "Return code of last ABAP statement",
      "SY-TABIX": "Current table index",

      ABAP_TRUE: "Boolean true",
      ABAP_FALSE: "Boolean false",
      ABAP_UNDEFINED: "Boolean undefined",
      SPACE: "Single space character"
    },

    // Fallback theo name (mọi scope). Key phải là UPPERCASE.
    customGlobal: {
      // "GT_LOG": "Global log table",
    },

    // Ưu tiên theo scopeLabel (phân biệt theo scope). Key + name đều UPPERCASE.
    customByScope: {
      // GLOBAL: {
      //   GV_USER: "User name (source for iv_user)"
      // },
      // "FORM:MAIN": {
      //   LV_B: "Output buffer"
      // }
    }
  };
})();
</script>
  <script>
// inlined from: ./app/01-core.js
"use strict";

window.AbapViewerModules = window.AbapViewerModules || {};
window.AbapViewerModules.parts = window.AbapViewerModules.parts || {};
window.AbapViewerRuntime = window.AbapViewerRuntime || {};
window.AbapViewerRuntime.api = window.AbapViewerRuntime.api || {};

  const els = {
    fileInput: document.getElementById("fileInput"),
    parseBtn: document.getElementById("parseBtn"),
    searchInput: document.getElementById("searchInput"),
    typeFilter: document.getElementById("typeFilter"),
    showRaw: document.getElementById("showRaw"),
    showKeywords: document.getElementById("showKeywords"),
    showValues: document.getElementById("showValues"),
    showExtras: document.getElementById("showExtras"),
    themeToggle: document.getElementById("themeToggle"),
    expandAllBtn: document.getElementById("expandAllBtn"),
    collapseAllBtn: document.getElementById("collapseAllBtn"),
    clearFiltersBtn: document.getElementById("clearFiltersBtn"),
    descBtn: document.getElementById("descBtn"),
    settingsBtn: document.getElementById("settingsBtn"),
    exportXmlBtn: document.getElementById("exportXmlBtn"),
    inputText: document.getElementById("inputText"),
    inputGutter: document.getElementById("inputGutter"),
    inputGutterContent: document.getElementById("inputGutterContent"),
    mainLayout: document.getElementById("mainLayout"),
    panelSplitter: document.getElementById("panelSplitter"),
    output: document.getElementById("output"),
    buildInfo: document.getElementById("buildInfo"),
    rightPanelTitle: document.getElementById("rightPanelTitle"),
    rightTabOutputBtn: document.getElementById("rightTabOutputBtn"),
    rightTabTemplateBtn: document.getElementById("rightTabTemplateBtn"),
    rightTabDescBtn: document.getElementById("rightTabDescBtn"),
    templatePreviewPanel: document.getElementById("templatePreviewPanel"),
    templateKeyMode: document.getElementById("templateKeyMode"),
    templateCopyAllBtn: document.getElementById("templateCopyAllBtn"),
    templateResetBtn: document.getElementById("templateResetBtn"),
    templateExportBtn: document.getElementById("templateExportBtn"),
    templateImportBtn: document.getElementById("templateImportBtn"),
    templateApplyBtn: document.getElementById("templateApplyBtn"),
    templateImportInput: document.getElementById("templateImportInput"),
    templateConfigError: document.getElementById("templateConfigError"),
    templateConfigJson: document.getElementById("templateConfigJson"),
    templatePreviewOutput: document.getElementById("templatePreviewOutput"),
    declDescJsonBtn: document.getElementById("declDescJsonBtn"),
    declDescPanel: document.getElementById("declDescPanel"),
    error: document.getElementById("error"),
    jsonModal: document.getElementById("jsonModal"),
    jsonTitle: document.getElementById("jsonTitle"),
    jsonPre: document.getElementById("jsonPre"),
    jsonCopyBtn: document.getElementById("jsonCopyBtn"),
    jsonCloseBtn: document.getElementById("jsonCloseBtn"),
    declDescSearch: document.getElementById("declDescSearch"),
    declDescMissingOnly: document.getElementById("declDescMissingOnly"),
    declDescTypes: document.getElementById("declDescTypes"),
    declDescSummary: document.getElementById("declDescSummary"),
    declDescTable: document.getElementById("declDescTable"),
    editModal: document.getElementById("editModal"),
    editLabel: document.getElementById("editLabel"),
    editHint: document.getElementById("editHint"),
    editSingleWrap: document.getElementById("editSingleWrap"),
    editDesc: document.getElementById("editDesc"),
    editStructWrap: document.getElementById("editStructWrap"),
    editStructDesc: document.getElementById("editStructDesc"),
    editItemDesc: document.getElementById("editItemDesc"),
    editSkipNormalize: document.getElementById("editSkipNormalize"),
    editSaveBtn: document.getElementById("editSaveBtn"),
    editClearBtn: document.getElementById("editClearBtn"),
    editCancelBtn: document.getElementById("editCancelBtn"),
    rulesBtn: document.getElementById("rulesBtn"),
    rulesModal: document.getElementById("rulesModal"),
    rulesSelect: document.getElementById("rulesSelect"),
    rulesTemplate: document.getElementById("rulesTemplate"),
    rulesError: document.getElementById("rulesError"),
    rulesJson: document.getElementById("rulesJson"),
    rulesNewBtn: document.getElementById("rulesNewBtn"),
    rulesSaveBtn: document.getElementById("rulesSaveBtn"),
    rulesDeleteBtn: document.getElementById("rulesDeleteBtn"),
    rulesDownloadBtn: document.getElementById("rulesDownloadBtn"),
    rulesCloseBtn: document.getElementById("rulesCloseBtn"),
    settingsModal: document.getElementById("settingsModal"),
    settingsNormalizeDesc: document.getElementById("settingsNormalizeDesc"),
    settingsDeclTypes: document.getElementById("settingsDeclTypes"),
    settingsStructTemplate: document.getElementById("settingsStructTemplate"),
    settingsNameTemplates: document.getElementById("settingsNameTemplates"),
    settingsSaveBtn: document.getElementById("settingsSaveBtn"),
    settingsResetBtn: document.getElementById("settingsResetBtn"),
    settingsCloseBtn: document.getElementById("settingsCloseBtn")
  };

  const state = {
    data: null,
    renderObjects: [],
    inputMode: "abap",
    inputLineCount: 0,
    inputGutterButtonsByLine: new Map(),
    inputGutterTargetsByLine: new Map(),
    theme: "dark",
    query: "",
    type: "",
    showRaw: true,
    showKeywords: true,
    showValues: true,
    showExtras: false,
    rightTab: "output",
    templateConfig: null,
    templateConfigDraft: "",
    templatePreviewCache: null,
    collapsedIds: new Set(),
    selectedId: "",
    selectedTemplateIndex: "",
    selectedDeclKey: "",
    descOverrides: {},
    descOverridesLegacy: {},
    activeEdit: null,
    haystackById: new Map(),
    inputLineOffsets: [],
    customRules: [],
    activeRuleId: "",
    settings: null,
    layoutLeftPane: 48
  };

  const DESC_STORAGE_KEY_V2 = "abap-parser-viewer.declDescOverrides.v2";
  const DESC_STORAGE_KEY_LEGACY_V1 = "abap-parser-viewer.descOverrides.v1";
  const RULES_STORAGE_KEY_V1 = "abap-parser-viewer.customConfigs.v1";
  const SETTINGS_STORAGE_KEY_V1 = "abap-parser-viewer.settings.v1";
  const TEMPLATE_CONFIG_STORAGE_KEY_V1 = "abap-parser-viewer.templateConfig.v1";
  const THEME_STORAGE_KEY_V1 = "abap-parser-viewer.theme.v1";
  const LAYOUT_SPLIT_STORAGE_KEY_V1 = "abap-parser-viewer.layoutSplit.v1";
  const LAYOUT_SPLIT_DEFAULT = 48;
  const LAYOUT_SPLIT_MIN = 28;
  const LAYOUT_SPLIT_MAX = 72;
  const MOBILE_LAYOUT_QUERY = "(max-width: 980px)";
  const RENDER_TREE_OPTIONS = Object.freeze({
    expandPerformForms: true,
    hideFormRoots: true,
    maxExpandDepth: Number.POSITIVE_INFINITY
  });

  const DECL_TYPE_OPTIONS = [
    "DATA",
    "TYPES",
    "PARAMETERS",
    "SELECT-OPTIONS",
    "CONSTANTS",
    "RANGES",
    "STATICS",
    "CLASS-DATA",
    "FIELD-SYMBOLS"
  ];

  const NAME_CODE_OPTIONS = [
    { code: "CN", label: "HẰNG" },
    { code: "DS", label: "STRUCT" },
    { code: "DT", label: "TABLE" },
    { code: "DR", label: "RANGETABLE" },
    { code: "DF", label: "BIẾN" },
    { code: "FL", label: "CỜ" },
    { code: "FS", label: "FIELDSYMBOL" }
  ];

  const DEFAULT_SETTINGS = {
    normalizeDeclDesc: true,
    declFilterTypes: ["DATA", "TYPES", "PARAMETERS"],
    structDescTemplate: "{{struct}}-{{item}}",
    nameTemplatesByCode: {
      CN: "HẰNG:{{desc}}",
      DS: "STRUCT:{{desc}}",
      DT: "TABLE:{{desc}}",
      DR: "RANGETABLE:{{desc}}",
      DF: "BIẾN:{{desc}}",
      FL: "CỜ:{{desc}}",
      FS: "FIELDSYMBOL:{{desc}}"
    }
  };

  const SAMPLE_ABAP = [
    "* ABAP Parser Viewer - richer offline demo",
    "REPORT zabap_parser_demo.",
    "",
    "* Selection screen",
    "PARAMETERS p_user TYPE syuname DEFAULT sy-uname OBLIGATORY. \"User name input",
    "PARAMETERS p_flag TYPE abap_bool DEFAULT abap_true AS CHECKBOX. \"Enable branch",
    "SELECT-OPTIONS s_bukrs FOR t001-bukrs.",
    "",
    "* Types + declarations",
    "TYPES: BEGIN OF ty_row,",
    "         bukrs TYPE t001-bukrs,",
    "         butxt TYPE t001-butxt,",
    "       END OF ty_row.",
    "TYPES: BEGIN OF ty_user,",
    "         uname TYPE syuname,",
    "         active TYPE abap_bool,",
    "         role TYPE string,",
    "       END OF ty_user.",
    "TYPES ty_rows TYPE STANDARD TABLE OF ty_row.",
    "TYPES ty_users TYPE STANDARD TABLE OF ty_user.",
    "",
    "DATA: gt_rows TYPE ty_rows,",
    "      gs_row  TYPE ty_row,",
    "      lt_users TYPE ty_users,",
    "      ls_user TYPE ty_user,",
    "      gv_total TYPE i VALUE 0,",
    "      lv_active TYPE abap_bool VALUE abap_true,",
    "      lv_role TYPE string VALUE 'ADMIN',",
    "      lv_text TYPE string,",
    "      lo_demo TYPE REF TO lcl_demo.",
    "CONSTANTS gc_default_bukrs TYPE t001-bukrs VALUE '1000'.",
    "FIELD-SYMBOLS <fs_row> TYPE ty_row.",
    "",
    "* Open SQL + table ops",
    "SELECT bukrs butxt FROM t001 INTO TABLE gt_rows WHERE bukrs IN s_bukrs.",
    "READ TABLE gt_rows WITH KEY bukrs = gc_default_bukrs INTO gs_row.",
    "READ TABLE gt_rows WITH TABLE KEY primary_key COMPONENTS bukrs = gc_default_bukrs INTO gs_row.",
    "READ TABLE lt_users WITH KEY uname = p_user active = lv_active INTO ls_user.",
    "READ TABLE lt_users WITH KEY uname = p_user active = lv_active role = lv_role INTO ls_user.",
    "MODIFY gt_rows FROM gs_row TRANSPORTING butxt WHERE bukrs = gc_default_bukrs.",
    "DELETE gt_rows WHERE bukrs = gc_default_bukrs.",
    "",
    "LOOP AT gt_rows ASSIGNING <fs_row> WHERE bukrs = gc_default_bukrs.",
    "  gv_total = gv_total + 1.",
    "ENDLOOP.",
    "LOOP AT lt_users INTO ls_user",
    "  WHERE uname = p_user",
    "    AND active = lv_active",
    "    AND role = lv_role.",
    "  gv_total = gv_total + 1.",
    "ENDLOOP.",
    "",
    "* Conditions",
    "IF gv_total > 0 AND p_flag = abap_true.",
    "  lv_text = p_user.",
    "ELSEIF gv_total IS INITIAL.",
    "  lv_text = 'EMPTY'.",
    "ELSE.",
    "  lv_text = 'OTHER'.",
    "ENDIF.",
    "",
    "* Classic calls",
    "CALL FUNCTION 'Z_DEMO_FM'",
    "  EXPORTING",
    "    iv_user = p_user",
    "  IMPORTING",
    "    ev_text = lv_text",
    "  CHANGING",
    "    cv_cnt = gv_total",
    "  TABLES",
    "    et_rows = gt_rows",
    "  EXCEPTIONS",
    "    text_error = 2",
    "    error_message = 3",
    "    OTHERS = 1.",
    "",
    "CALL METHOD lo_demo->do_something",
    "  EXPORTING",
    "    iv_user = p_user",
    "  IMPORTING",
    "    ev_text = lv_text.",
    "",
    "* New method-call expressions (=> and ->)",
    "lv_text = lcl_demo=>get_default( ).",
    "lo_demo->do_something( EXPORTING iv_user = p_user IMPORTING ev_text = lv_text ).",
    "",
    "* MESSAGE demo (class/number/type/display like/with/into)",
    "MESSAGE ID '00' TYPE 'S' NUMBER '001' WITH p_user lv_role gv_total lv_text DISPLAY LIKE 'I' INTO lv_text.",
    "",
    "* PERFORM + FORM",
    "PERFORM main USING p_user p_flag CHANGING lv_text IF p_flag = abap_true.",
    "PERFORM main IN PROGRAM sy-repid USING p_user p_flag CHANGING lv_text IF p_flag = abap_true.",
    "",
    "FORM main",
    "  USING iv_user TYPE syuname",
    "        iv_flag TYPE abap_bool",
    "  CHANGING cv_text TYPE string.",
    "  cv_text = iv_user.",
    "ENDFORM.",
    "",
    "* Local class",
    "CLASS lcl_demo DEFINITION.",
    "  PUBLIC SECTION.",
    "    METHODS do_something IMPORTING iv_user TYPE syuname EXPORTING ev_text TYPE string.",
    "    CLASS-METHODS get_default RETURNING VALUE(rv_text) TYPE string.",
    "ENDCLASS.",
    "",
    "CLASS lcl_demo IMPLEMENTATION.",
    "  METHOD do_something.",
    "    ev_text = iv_user.",
    "  ENDMETHOD.",
    "",
    "  METHOD get_default.",
    "    rv_text = 'DEFAULT'.",
    "  ENDMETHOD.",
    "ENDCLASS."
  ].join("\n");

  function createTemplateBaseStyle(background) {
    return {
      background: background || "default",
      border: "outside-thin",
      font: "MS PGothic",
      "font color": "#111111",
      "font size": 10,
      "font family": "default",
      bold: false,
      italic: false,
      underline: false,
      merge: false,
      align: "left",
      valign: "top",
      wrap: false
    };
  }

  function createGenericStatementTemplate(templateKey) {
    const keyText = String(templateKey || "").trim();
    return {
      _options: {
        hideEmptyRows: true,
        hideRowsWithoutValues: true,
        expandMultilineRows: true
      },
      "A1:G1": createTemplateBaseStyle("#dbeef4"),
      A1: {
        text: "Câu lệnh"
      },
      "H1:AY1": createTemplateBaseStyle("default"),
      H1: {
        text: "{keywords.stmt.text}{objectType}"
      },
      "A2:G2": createTemplateBaseStyle("#dbeef4"),
      A2: {
        text: "Đối tượng"
      },
      "H2:AY2": createTemplateBaseStyle("default"),
      H2: {
        text: "{values.name.finalDesc}{values.target.finalDesc}{values.form.finalDesc}{values.itab.finalDesc}{values.itabOrDbtab.finalDesc}"
      },
      "A3:G3": createTemplateBaseStyle("#dbeef4"),
      A3: {
        text: "Nguồn / Đích"
      },
      "H3:AY3": createTemplateBaseStyle("default"),
      H3: {
        text: "{values.into.finalDesc}{values.from.finalDesc}{values.index.value}"
      },
      "A4:G4": createTemplateBaseStyle("#dbeef4"),
      A4: {
        text: "Điều kiện"
      },
      "H4:AY4": createTemplateBaseStyle("default"),
      H4: {
        text: "{values.condition.finalDesc}{values.where.finalDesc}{values.withKey.finalDesc}{values.withTableKey.finalDesc}"
      },
      "A5:G5": createTemplateBaseStyle("#dbeef4"),
      A5: {
        text: "Chi tiết"
      },
      "H5:AY5": createTemplateBaseStyle("default"),
      H5: {
        text: "{extras}"
      },
      "A6:G6": createTemplateBaseStyle("#dbeef4"),
      A6: {
        text: "Template key"
      },
      "H6:AY6": createTemplateBaseStyle("default"),
      H6: {
        text: keyText
      }
    };
  }

  const TEMPLATE_DEFAULT_CONFIG_V1 = {
    version: 1,
    templates: {
      DEFAULT: {
        _options: {
          hideEmptyRows: true,
          hideRowsWithoutValues: true,
          expandMultilineRows: false
        },
        "A1:F1": {
          background: "mau xanh nhat",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A1: {
          text: "{keywords.stmt.text}"
        },
        "G1:W1": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        G1: {
          text: "{values.name.finalDesc}"
        }
      },
      ASSIGNMENT: {
        "A1:F1": {
          background: "mau xanh nhat",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A1: {
          text: "Đích"
        },
        "A2:F2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A2: {
          text: "{values.target.decl.finalDesc}"
        },
        "G1:W1": {
          background: "mau xanh nhat",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        G1: {
          text: "Nguồn"
        },
        "G2:W2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        G2: {
          text: "{values.expr.decl.finalDesc}"
        }
      },
      CALL_FUNCTION: {
        _options: {
          hideEmptyRows: true,
          hideRowsWithoutValues: true,
          expandMultilineRows: true
        },
        "A1:H1": createTemplateBaseStyle("#dbeef4"),
        A1: {
          text: "Function Module"
        },
        "I1:BG1": createTemplateBaseStyle("#ffffff"),
        I1: {
          text: "{values.name.finalDesc}"
        },
        "A2:H2": createTemplateBaseStyle("#dbeef4"),
        A2: {
          text: "Exporting"
        },
        "I2:P2": createTemplateBaseStyle("#ffffff"),
        I2: {
          text: "{extras.callFunction.exporting.name}"
        },
        "Q2:X2": createTemplateBaseStyle("#ffffff"),
        Q2: {
          text: "="
        },
        "Y2:BG2": createTemplateBaseStyle("#ffffff"),
        Y2: {
          text: "{extras.callFunction.exporting.valueDecl.finalDesc}"
        },
        "A3:H3": createTemplateBaseStyle("#dbeef4"),
        A3: {
          text: "Importing"
        },
        "I3:P3": createTemplateBaseStyle("#ffffff"),
        I3: {
          text: "{extras.callFunction.importing.name}"
        },
        "Q3:X3": createTemplateBaseStyle("#ffffff"),
        Q3: {
          text: "="
        },
        "Y3:BG3": createTemplateBaseStyle("#ffffff"),
        Y3: {
          text: "{extras.callFunction.importing.valueDecl.finalDesc}"
        },
        "A4:H4": createTemplateBaseStyle("#dbeef4"),
        A4: {
          text: "Tables"
        },
        "I4:P4": createTemplateBaseStyle("#ffffff"),
        I4: {
          text: "{extras.callFunction.tables.name}"
        },
        "Q4:X4": createTemplateBaseStyle("#ffffff"),
        Q4: {
          text: "="
        },
        "Y4:BG4": createTemplateBaseStyle("#ffffff"),
        Y4: {
          text: "{extras.callFunction.tables.valueDecl.finalDesc}"
        },
        "A5:H5": createTemplateBaseStyle("#dbeef4"),
        A5: {
          text: "Changing"
        },
        "I5:P5": createTemplateBaseStyle("#ffffff"),
        I5: {
          text: "{extras.callFunction.changing.name}"
        },
        "Q5:X5": createTemplateBaseStyle("#ffffff"),
        Q5: {
          text: "="
        },
        "Y5:BG5": createTemplateBaseStyle("#ffffff"),
        Y5: {
          text: "{extras.callFunction.changing.valueDecl.finalDesc}"
        },
        "A6:H6": createTemplateBaseStyle("#dbeef4"),
        A6: {
          text: "Exceptions"
        },
        "I6:P6": createTemplateBaseStyle("#ffffff"),
        I6: {
          text: "{extras.callFunction.exceptions.name}"
        },
        "Q6:X6": createTemplateBaseStyle("#ffffff"),
        Q6: {
          text: "="
        },
        "Y6:BG6": createTemplateBaseStyle("#ffffff"),
        Y6: {
          text: "{extras.callFunction.exceptions.valueDecl.finalDesc}"
        }
      },
      APPEND: {
        "A1:G1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A1: {
          text: "Append"
        },
        "H1:Y1": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        H1: {
          text: "{values.what.decl.finalDesc}"
        },
        "Z1:AD1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        Z1: {
          text: "To"
        },
        "AE1:AY1": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        AE1: {
          text: "{values.to.decl.finalDesc}"
        },
        "A2:G2": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A2: {
          text: "{labels.sortedBy}"
        },
        "H2:AB2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        H2: {
          text: "{extras}"
        }
      },
      READ_TABLE: {
        _options: {
          hideEmptyRows: true,
          hideRowsWithoutValues: true,
          expandMultilineRows: true
        },
        "A1:G1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A1: {
          text: "ReadTable"
        },
        "H1:AB1": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        H1: {
          text: "{values.itab.decl.finalDesc}"
        },
        "A2:G2": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A2: {
          text: "To"
        },
        "H2:AB2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        H2: {
          text: "{values.into.decl.finalDesc}"
        },
        "A3:G3": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A3: {
          text: "Điều kiện"
        },
        "H3:T3": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        H3: {
          text: "{extras.readTable.conditions.leftOperand}"
        },
        "U3:W3": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        U3: {
          text: "{extras.readTable.conditions.comparisonOperator}"
        },
        "X3:AR3": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        X3: {
          text: "{extras.readTable.conditions.rightOperandDecl.finalDesc}"
        },
        "A4:U4": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A4: {
          text: "{keywords.binary-search.text}"
        }
      },
      MODIFY_ITAB: {
        _options: {
          hideEmptyRows: true,
          hideRowsWithoutValues: true,
          expandMultilineRows: true
        },
        "A1:G1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A1: {
          text: "Modify Table"
        },
        "H1:AB1": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        H1: {
          text: "{values.itab.finalDesc}{values.itabOrDbtab.finalDesc}"
        },
        "A2:G2": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A2: {
          text: "From"
        },
        "H2:AB2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        H2: {
          text: "{values.from.finalDesc}"
        },
        "A3:G3": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A3: {
          text: "Transporting / Index"
        },
        "H3:AB3": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        H3: {
          text: "{extras.modifyItab.transporting}{values.index.value}"
        },
        "A4:T4": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A4: {
          text: "Điều kiện trái"
        },
        "U4:W4": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        U4: {
          text: "Điều kiện"
        },
        "X4:AD4": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        X4: {
          text: "Điều kiện phải"
        },
        "AE4:AY4": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        AE4: {
          text: "Logic connector"
        },
        "A5:T5": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A5: {
          text: "{extras.modifyItab.conditions.leftOperandDecl.finalDesc}"
        },
        "U5:W5": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        U5: {
          text: "{extras.modifyItab.conditions.comparisonOperator}"
        },
        "X5:AD5": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        X5: {
          text: "{extras.modifyItab.conditions.rightOperandDecl.finalDesc}"
        },
        "AE5:AY5": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        AE5: {
          text: "{extras.modifyItab.conditions.logicalConnector}"
        }
      },
      DELETE_ITAB: {
        _options: {
          hideEmptyRows: true,
          hideRowsWithoutValues: true,
          expandMultilineRows: true
        },
        "A1:G1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A1: {
          text: "Delete Table"
        },
        "H1:AB1": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        H1: {
          text: "{values.target.finalDesc}"
        },
        "A2:G2": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A2: {
          text: "From / Index"
        },
        "H2:AB2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        H2: {
          text: "{values.from.finalDesc}{values.index.value}"
        },
        "A3:T3": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A3: {
          text: "Điều kiện trái"
        },
        "U3:W3": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        U3: {
          text: "Điều kiện"
        },
        "X3:AD3": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        X3: {
          text: "Điều kiện phải"
        },
        "AE3:AY3": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        AE3: {
          text: "Logic connector"
        },
        "A4:T4": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A4: {
          text: "{extras.deleteItab.conditions.leftOperandDecl.finalDesc}"
        },
        "U4:W4": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        U4: {
          text: "{extras.deleteItab.conditions.comparisonOperator}"
        },
        "X4:AD4": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        X4: {
          text: "{extras.deleteItab.conditions.rightOperandDecl.finalDesc}"
        },
        "AE4:AY4": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        AE4: {
          text: "{extras.deleteItab.conditions.logicalConnector}"
        }
      },
      LOOP_AT_ITAB: {
        _options: {
          hideEmptyRows: true,
          hideRowsWithoutValues: true,
          expandMultilineRows: true
        },
        "A1:X1": createTemplateBaseStyle("#dbeef4"),
        A1: {
          text: "Loop At"
        },
        "Y1:BA1": createTemplateBaseStyle("#dbeef4"),
        Y1: {
          text: "Into"
        },
        "BB1:BG1": createTemplateBaseStyle("#dbeef4"),
        BB1: {
          text: "Connection"
        },
        "A2:H2": createTemplateBaseStyle("#dbeef4"),
        A2: {
          text: "Điều kiện"
        },
        "I2:V2": createTemplateBaseStyle("#ffffff"),
        I2: {
          text: "{extras.loopAtItab.conditions.leftOperandDecl.finalDesc}"
        },
        "W2:X2": createTemplateBaseStyle("#dbeef4"),
        W2: {
          text: "{extras.loopAtItab.conditions.comparisonOperator}"
        },
        "Y2:BA2": createTemplateBaseStyle("#ffffff"),
        Y2: {
          text: "{extras.loopAtItab.conditions.rightOperandDecl.finalDesc}"
        },
        "BB2:BG2": createTemplateBaseStyle("#ffffff"),
        BB2: {
          text: "{extras.loopAtItab.conditions.logicalConnector}"
        }
      },
      IF: {
        _options: {
          hideEmptyRows: true,
          hideRowsWithoutValues: true,
          expandMultilineRows: true
        },
        "A1:T1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A1: {
          text: "Điều kiện trái"
        },
        "U1:W1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        U1: {
          text: "Điều kiện"
        },
        "X1:AD1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        X1: {
          text: "Điều kiện phải"
        },
        "AE1:AY1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        AE1: {
          text: "Logic connector"
        },
        "A2:T2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A2: {
          text: "{extras.ifCondition.conditions.leftOperandDecl.finalDesc}"
        },
        "U2:W2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        U2: {
          text: "{extras.ifCondition.conditions.comparisonOperator}"
        },
        "X2:AD2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        X2: {
          text: "{extras.ifCondition.conditions.rightOperandDecl.finalDesc}"
        },
        "AE2:AY2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        AE2: {
          text: "{extras.ifCondition.conditions.logicalConnector}"
        }
      },
      ELSEIF: {
        _options: {
          hideEmptyRows: true,
          hideRowsWithoutValues: true,
          expandMultilineRows: true
        },
        "A1:T1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A1: {
          text: "Điều kiện trái"
        },
        "U1:W1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        U1: {
          text: "Điều kiện"
        },
        "X1:AD1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        X1: {
          text: "Điều kiện phải"
        },
        "AE1:AY1": {
          background: "#dbeef4",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        AE1: {
          text: "Logic connector"
        },
        "A2:T2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        A2: {
          text: "{extras.ifCondition.conditions.leftOperandDecl.finalDesc}"
        },
        "U2:W2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        U2: {
          text: "{extras.ifCondition.conditions.comparisonOperator}"
        },
        "X2:AD2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        X2: {
          text: "{extras.ifCondition.conditions.rightOperandDecl.finalDesc}"
        },
        "AE2:AY2": {
          background: "#ffffff",
          border: "outside-thin",
          font: "MS PGothic",
          "font color": "#111111",
          "font size": 10,
          "font family": "default",
          bold: false,
          italic: false,
          underline: false,
          merge: false,
          align: "left",
          valign: "top",
          wrap: false
        },
        AE2: {
          text: "{extras.ifCondition.conditions.logicalConnector}"
        }
      },
      PERFORM: {
        _options: {
          hideEmptyRows: true,
          hideRowsWithoutValues: true,
          expandMultilineRows: true
        },
        "J1:X1": createTemplateBaseStyle("#dbeef4"),
        J1: {
          text: "ID"
        },
        "Y1:BG1": createTemplateBaseStyle("#dbeef4"),
        Y1: {
          text: "Text"
        },
        "A2:I2": createTemplateBaseStyle("#dbeef4"),
        A2: {
          text: "Subroutine"
        },
        "J2:X2": createTemplateBaseStyle("#ffffff"),
        J2: {
          text: "{values.form.decl.name}"
        },
        "Y2:BG2": createTemplateBaseStyle("#ffffff"),
        Y2: {
          text: "{values.form.finalDesc}"
        },
        "A3:I3": createTemplateBaseStyle("#dbeef4"),
        A3: {
          text: "Using"
        },
        "J3:X3": createTemplateBaseStyle("#ffffff"),
        J3: {
          text: "{extras.performCall.using.valueDecl.name}"
        },
        "Y3:BG3": createTemplateBaseStyle("#ffffff"),
        Y3: {
          text: "{extras.performCall.using.valueDecl.finalDesc}"
        },
        "A4:I4": createTemplateBaseStyle("#dbeef4"),
        A4: {
          text: "Changing"
        },
        "J4:X4": createTemplateBaseStyle("#ffffff"),
        J4: {
          text: "{extras.performCall.changing.valueDecl.name}"
        },
        "Y4:BG4": createTemplateBaseStyle("#ffffff"),
        Y4: {
          text: "{extras.performCall.changing.valueDecl.finalDesc}"
        },
        "A5:I5": createTemplateBaseStyle("#dbeef4"),
        A5: {
          text: "Tables"
        },
        "J5:X5": createTemplateBaseStyle("#ffffff"),
        J5: {
          text: "{extras.performCall.tables.valueDecl.name}"
        },
        "Y5:BG5": createTemplateBaseStyle("#ffffff"),
        Y5: {
          text: "{extras.performCall.tables.valueDecl.finalDesc}"
        },
        "A6:I6": createTemplateBaseStyle("#dbeef4"),
        A6: {
          text: "Raising"
        },
        "J6:X6": createTemplateBaseStyle("#ffffff"),
        J6: {
          text: "{extras.performCall.raising.name}"
        },
        "Y6:BG6": createTemplateBaseStyle("#ffffff"),
        Y6: {
          text: "{extras.performCall.raising.valueDecl.finalDesc}"
        },
        "A7:I7": createTemplateBaseStyle("#dbeef4"),
        A7: {
          text: "In Program"
        },
        "J7:X7": createTemplateBaseStyle("#ffffff"),
        J7: {
          text: "{values.program.decl.name}"
        },
        "Y7:BG7": createTemplateBaseStyle("#ffffff"),
        Y7: {
          text: "{values.program.finalDesc}"
        }
      },
      MESSAGE: {
        _options: {
          hideEmptyRows: true,
          hideRowsWithoutValues: true,
          expandMultilineRows: true
        },
        "A1:I1": createTemplateBaseStyle("#dbeef4"),
        A1: {
          text: "Message Class"
        },
        "J1:V1": createTemplateBaseStyle("#ffffff"),
        J1: {
          text: "{values.messageClass.finalDesc}"
        },
        "W1:AB1": createTemplateBaseStyle("#dbeef4"),
        W1: {
          text: "Message Number"
        },
        "AC1:AJ1": createTemplateBaseStyle("#ffffff"),
        AC1: {
          text: "{values.messageNumber.finalDesc}"
        },
        "AK1:AQ1": createTemplateBaseStyle("#dbeef4"),
        AK1: {
          text: "Message Type"
        },
        "AR1:AX1": createTemplateBaseStyle("#ffffff"),
        AR1: {
          text: "{values.messageType.finalDesc}"
        },
        "AY1:BG1": createTemplateBaseStyle("#dbeef4"),
        AY1: {
          text: "Display Like"
        },
        "BH1:BZ1": createTemplateBaseStyle("#ffffff"),
        BH1: {
          text: "{values.displayLike.finalDesc}"
        },
        "A2:I2": createTemplateBaseStyle("#dbeef4"),
        A2: {
          text: "Message Text &1"
        },
        "J2:BZ2": createTemplateBaseStyle("#ffffff"),
        J2: {
          text: "{values.messageText1.finalDesc}"
        },
        "A3:I3": createTemplateBaseStyle("#dbeef4"),
        A3: {
          text: "Message Text &2"
        },
        "J3:BZ3": createTemplateBaseStyle("#ffffff"),
        J3: {
          text: "{values.messageText2.finalDesc}"
        },
        "A4:I4": createTemplateBaseStyle("#dbeef4"),
        A4: {
          text: "Message Text &3"
        },
        "J4:BZ4": createTemplateBaseStyle("#ffffff"),
        J4: {
          text: "{values.messageText3.finalDesc}"
        },
        "A5:I5": createTemplateBaseStyle("#dbeef4"),
        A5: {
          text: "Message Text &4"
        },
        "J5:BZ5": createTemplateBaseStyle("#ffffff"),
        J5: {
          text: "{values.messageText4.finalDesc}"
        },
        "A6:I6": createTemplateBaseStyle("#dbeef4"),
        A6: {
          text: "Message Display"
        },
        "J6:BZ6": createTemplateBaseStyle("#ffffff"),
        J6: {
          text: "{values.messageDisplay.finalDesc}"
        },
        "A7:I7": createTemplateBaseStyle("#dbeef4"),
        A7: {
          text: "Đích lưu"
        },
        "J7:BZ7": createTemplateBaseStyle("#ffffff"),
        J7: {
          text: "{values.messageDestination.finalDesc}"
        }
      }
    }
  };

  const TEMPLATE_GENERIC_KEYS = [
    "CALL_FUNCTION",
    "CALL_METHOD",
    "CALL_TRANSACTION",
    "CASE",
    "CATCH",
    "CLASS",
    "CLASS-DATA",
    "CLASS-METHODS",
    "CLEANUP",
    "CLEAR",
    "CONSTANTS",
    "DATA",
    "DO",
    "ELSE",
    "FIELD-SYMBOLS",
    "FORM",
    "INSERT_ITAB",
    "LOOP_AT_ITAB",
    "METHOD",
    "METHODS",
    "MOVE",
    "MOVE-CORRESPONDING",
    "PARAMETERS",
    "PERFORM",
    "RANGES",
    "SELECT",
    "SELECT-OPTIONS",
    "SORT_ITAB",
    "STATICS",
    "TRY",
    "TYPES",
    "WHEN"
  ];

  for (const key of TEMPLATE_GENERIC_KEYS) {
    if (!Object.prototype.hasOwnProperty.call(TEMPLATE_DEFAULT_CONFIG_V1.templates, key)) {
      TEMPLATE_DEFAULT_CONFIG_V1.templates[key] = createGenericStatementTemplate(key);
    }
  }

  function setError(message) {
    els.error.textContent = message ? String(message) : "";
  }

  function setOutputMessage(message) {
    els.output.classList.add("muted");
    els.output.replaceChildren();
    els.output.textContent = message || "";
  }

  function parseDateCandidate(value) {
    const raw = String(value || "").trim();
    if (!raw) {
      return null;
    }
    const date = new Date(raw);
    return Number.isNaN(date.getTime()) ? null : date;
  }

  function formatDateTime(value) {
    const date = value instanceof Date ? value : parseDateCandidate(value);
    if (!date) {
      return "";
    }
    try {
      return new Intl.DateTimeFormat(undefined, {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      }).format(date);
    } catch {
      return date.toLocaleString();
    }
  }

  function getMetaContent(name) {
    try {
      const el = document.querySelector(`meta[name="${name}"]`);
      if (!el) {
        return "";
      }
      return String(el.getAttribute("content") || "").trim();
    } catch {
      return "";
    }
  }

  function renderBuildInfo() {
    if (!els.buildInfo) {
      return;
    }

    const manualVersion = getMetaContent("abap-viewer-version");
    const manualUpdatedAt = getMetaContent("abap-viewer-updated-at");
    const manualNote = getMetaContent("abap-viewer-updated-note");
    const parsedManualDate = parseDateCandidate(manualUpdatedAt);
    const fallbackDate = parseDateCandidate(document.lastModified);
    const versionPrefix = manualVersion ? `${manualVersion} | ` : "";

    if (manualUpdatedAt || manualVersion) {
      const display = parsedManualDate ? formatDateTime(parsedManualDate) : manualUpdatedAt;
      const updatedText = display || "manual timestamp not set";
      els.buildInfo.textContent = `Updated: ${versionPrefix}${updatedText} (manual)`;
      els.buildInfo.title = manualNote || "Manual timestamp from <meta name=\"abap-viewer-updated-at\">.";
      return;
    }

    if (fallbackDate) {
      els.buildInfo.textContent = `Updated: ${formatDateTime(fallbackDate)} (from document.lastModified)`;
      els.buildInfo.title = "No manual timestamp found. Showing document.lastModified.";
      return;
    }

    els.buildInfo.textContent = "Updated: unknown";
    els.buildInfo.title = "No manual timestamp and no document.lastModified available.";
  }

  function normalizeId(id) {
    if (id === null || id === undefined) {
      return "";
    }
    return String(id);
  }

  function flattenEntryMap(map) {
    if (!map || typeof map !== "object") {
      return [];
    }

    const out = [];
    for (const key of Object.keys(map)) {
      const entryOrList = map[key];
      if (Array.isArray(entryOrList)) {
        for (const entry of entryOrList) {
          if (entry && typeof entry === "object") {
            out.push(entry);
          }
        }
        continue;
      }
      if (entryOrList && typeof entryOrList === "object") {
        out.push(entryOrList);
      }
    }
    return out;
  }

  function getKeywordEntries(obj) {
    if (!obj) {
      return [];
    }
    if (Array.isArray(obj.keywords)) {
      return obj.keywords;
    }
    return flattenEntryMap(obj.keywords);
  }

  function getValueEntries(obj) {
    if (!obj) {
      return [];
    }
    if (Array.isArray(obj.values)) {
      return obj.values;
    }
    return flattenEntryMap(obj.values);
  }

  function getFirstValueFromValues(values, key) {
    if (!values) {
      return "";
    }

    if (Array.isArray(values)) {
      const match = values.find((v) => v && v.name === key && v.value);
      return match ? String(match.value) : "";
    }

    if (typeof values !== "object") {
      return "";
    }

    const entryOrList = values[key];
    const entry = Array.isArray(entryOrList) ? entryOrList[0] : entryOrList;
    return entry && entry.value ? String(entry.value) : "";
  }

  function loadStorageObject(key) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) {
        return {};
      }
      const parsed = JSON.parse(raw);
      return parsed && typeof parsed === "object" ? parsed : {};
    } catch {
      return {};
    }
  }

  function loadDescOverrides() {
    return loadStorageObject(DESC_STORAGE_KEY_V2);
  }

  function loadLegacyDescOverrides() {
    return loadStorageObject(DESC_STORAGE_KEY_LEGACY_V1);
  }

  function saveDescOverrides() {
    try {
      localStorage.setItem(DESC_STORAGE_KEY_V2, JSON.stringify(state.descOverrides || {}));
    } catch {
      // ignore
    }
  }

  function loadStorageArray(key) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) {
        return [];
      }
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed : [];
    } catch {
      return [];
    }
  }

  function normalizeSettings(value) {
    const input = value && typeof value === "object" && !Array.isArray(value) ? value : {};

    const normalizeDeclDesc = typeof input.normalizeDeclDesc === "boolean"
      ? input.normalizeDeclDesc
      : DEFAULT_SETTINGS.normalizeDeclDesc;

    const declFilterTypes = Array.isArray(input.declFilterTypes)
      ? input.declFilterTypes
          .map((t) => String(t || "").trim().toUpperCase())
          .filter((t) => t && DECL_TYPE_OPTIONS.includes(t))
      : [];

    const structDescTemplate = typeof input.structDescTemplate === "string" && input.structDescTemplate.trim()
      ? input.structDescTemplate
      : DEFAULT_SETTINGS.structDescTemplate;

    const nameTemplatesByCode = {};
    const inputNameTemplates = input.nameTemplatesByCode && typeof input.nameTemplatesByCode === "object"
      ? input.nameTemplatesByCode
      : {};

    for (const opt of NAME_CODE_OPTIONS) {
      const code = opt.code;
      const rawTemplate = Object.prototype.hasOwnProperty.call(inputNameTemplates, code)
        ? inputNameTemplates[code]
        : DEFAULT_SETTINGS.nameTemplatesByCode[code];

      const template = typeof rawTemplate === "string" && rawTemplate.trim()
        ? rawTemplate
        : DEFAULT_SETTINGS.nameTemplatesByCode[code];

      nameTemplatesByCode[code] = template;
    }

    return {
      normalizeDeclDesc,
      declFilterTypes: declFilterTypes.length ? declFilterTypes : DEFAULT_SETTINGS.declFilterTypes.slice(),
      structDescTemplate,
      nameTemplatesByCode
    };
  }

  function loadSettings() {
    return normalizeSettings(loadStorageObject(SETTINGS_STORAGE_KEY_V1));
  }

  function saveSettings(settings) {
    try {
      localStorage.setItem(SETTINGS_STORAGE_KEY_V1, JSON.stringify(settings || {}));
    } catch {
      // ignore
    }
  }

  function setTemplateConfigError(message) {
    if (!els.templateConfigError) {
      return;
    }
    els.templateConfigError.textContent = message ? String(message) : "";
  }

  function setTemplatePreviewMessage(message) {
    if (!els.templatePreviewOutput) {
      return;
    }
    els.templatePreviewOutput.classList.add("muted");
    els.templatePreviewOutput.replaceChildren();
    els.templatePreviewOutput.textContent = message || "";
  }

  function cloneJsonValue(value) {
    try {
      return JSON.parse(JSON.stringify(value));
    } catch {
      return null;
    }
  }

  function getDefaultTemplateConfig() {
    const cloned = cloneJsonValue(TEMPLATE_DEFAULT_CONFIG_V1);
    return cloned && typeof cloned === "object" ? cloned : { version: 1, templates: {} };
  }

  function normalizeTemplateAliasToken(value) {
    return String(value || "")
      .trim()
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/\s+/g, " ");
  }

  function parseCellRef(cellRef) {
    const raw = String(cellRef || "").trim().toUpperCase();
    const match = /^([A-Z]+)([1-9][0-9]*)$/.exec(raw);
    if (!match) {
      throw new Error(`Invalid cell ref "${cellRef}". Expected format like A1.`);
    }

    const letters = match[1];
    const row = Number(match[2]) || 0;
    let col = 0;
    for (let i = 0; i < letters.length; i += 1) {
      col = (col * 26) + (letters.charCodeAt(i) - 64);
    }

    if (!row || !col) {
      throw new Error(`Invalid cell ref "${cellRef}".`);
    }

    return { row, col, raw };
  }

  function parseRangeKey(rangeKey) {
    const raw = String(rangeKey || "").trim().toUpperCase();
    if (!raw) {
      throw new Error("Range key is empty.");
    }

    const parts = raw.split(":").map((item) => item.trim()).filter(Boolean);
    if (!parts.length || parts.length > 2) {
      throw new Error(`Invalid range "${rangeKey}". Expected A1 or A1:B2.`);
    }

    const start = parseCellRef(parts[0]);
    const end = parseCellRef(parts.length > 1 ? parts[1] : parts[0]);

    return {
      key: raw,
      r1: Math.min(start.row, end.row),
      c1: Math.min(start.col, end.col),
      r2: Math.max(start.row, end.row),
      c2: Math.max(start.col, end.col)
    };
  }

  function isTemplateOptionConfigKey(rawKey) {
    const key = String(rawKey || "").trim().toLowerCase();
    if (!key) {
      return false;
    }
    return (
      key === "_options"
      || key === "options"
      || key === "ranges"
      || key === "compact"
      || key === "hideemptyrows"
      || key === "hiderowswithoutvalues"
      || key === "expandmultilinerows"
      || key === "removeemptyrows"
      || key === "removeemptyrowsadvanced"
      || key === "removeemptyrowsadv"
      || key === "expandarrayrows"
      || key === "arraytorows"
    );
  }

  function validateTemplateConfig(config) {
    const errors = [];
    if (!config || typeof config !== "object" || Array.isArray(config)) {
      return { valid: false, errors: ["Config must be a JSON object."] };
    }

    const version = Number(config.version);
    if (version !== 1) {
      errors.push("Config.version must be 1.");
    }

    const templates = config.templates;
    if (!templates || typeof templates !== "object" || Array.isArray(templates)) {
      errors.push("Config.templates must be an object.");
      return { valid: false, errors };
    }

    const templateKeys = Object.keys(templates);
    if (!templateKeys.length) {
      errors.push("Config.templates must contain at least one template key.");
      return { valid: false, errors };
    }

    for (const templateKey of templateKeys) {
      const templateDef = templates[templateKey];
      if (!templateDef || typeof templateDef !== "object" || Array.isArray(templateDef)) {
        errors.push(`templates.${templateKey} must be an object of range -> style.`);
        continue;
      }

      const hasRangesObject = Object.prototype.hasOwnProperty.call(templateDef, "ranges");
      const ranges = hasRangesObject ? templateDef.ranges : templateDef;
      if (!ranges || typeof ranges !== "object" || Array.isArray(ranges)) {
        errors.push(`templates.${templateKey}.ranges must be an object of range -> style.`);
        continue;
      }

      const optionCandidates = ["_options", "options"];
      for (const optKey of optionCandidates) {
        if (!Object.prototype.hasOwnProperty.call(templateDef, optKey)) {
          continue;
        }
        const optValue = templateDef[optKey];
        if (!optValue || typeof optValue !== "object" || Array.isArray(optValue)) {
          errors.push(`templates.${templateKey}.${optKey} must be an object.`);
        }
      }

      for (const rangeKey of Object.keys(ranges)) {
        if (isTemplateOptionConfigKey(rangeKey)) {
          continue;
        }
        try {
          parseRangeKey(rangeKey);
        } catch (err) {
          errors.push(`templates.${templateKey}.${rangeKey}: ${err && err.message ? err.message : err}`);
        }

        const cellConfig = ranges[rangeKey];
        if (!cellConfig || typeof cellConfig !== "object" || Array.isArray(cellConfig)) {
          errors.push(`templates.${templateKey}.${rangeKey} must be an object.`);
        }
      }
    }

    return { valid: errors.length === 0, errors };
  }

  function loadTemplateConfig() {
    try {
      const raw = localStorage.getItem(TEMPLATE_CONFIG_STORAGE_KEY_V1);
      if (!raw) {
        return getDefaultTemplateConfig();
      }
      const parsed = JSON.parse(raw);
      const check = validateTemplateConfig(parsed);
      if (!check.valid) {
        return getDefaultTemplateConfig();
      }
      return parsed;
    } catch {
      return getDefaultTemplateConfig();
    }
  }

  function saveTemplateConfig(config) {
    try {
      localStorage.setItem(TEMPLATE_CONFIG_STORAGE_KEY_V1, JSON.stringify(config || {}));
    } catch {
      // ignore
    }
  }

  function normalizeTheme(value) {
    return value === "light" ? "light" : "dark";
  }

  function loadTheme() {
    try {
      return normalizeTheme(localStorage.getItem(THEME_STORAGE_KEY_V1) || "");
    } catch {
      return "dark";
    }
  }

  function applyTheme(nextTheme, { save } = {}) {
    const normalized = normalizeTheme(nextTheme);
    state.theme = normalized;
    document.documentElement.setAttribute("data-theme", normalized);

    if (els.themeToggle) {
      els.themeToggle.checked = normalized === "dark";
    }

    if (save === false) {
      return;
    }

    try {
      localStorage.setItem(THEME_STORAGE_KEY_V1, normalized);
    } catch {
      // ignore
    }
  }

  function clampNumber(value, min, max) {
    return Math.min(max, Math.max(min, value));
  }

  function normalizeLayoutSplit(value) {
    const numeric = Number(value);
    if (!Number.isFinite(numeric)) {
      return LAYOUT_SPLIT_DEFAULT;
    }
    return clampNumber(numeric, LAYOUT_SPLIT_MIN, LAYOUT_SPLIT_MAX);
  }

  function loadLayoutSplit() {
    try {
      return normalizeLayoutSplit(localStorage.getItem(LAYOUT_SPLIT_STORAGE_KEY_V1));
    } catch {
      return LAYOUT_SPLIT_DEFAULT;
    }
  }

  function saveLayoutSplit(value) {
    try {
      localStorage.setItem(LAYOUT_SPLIT_STORAGE_KEY_V1, String(normalizeLayoutSplit(value)));
    } catch {
      // ignore
    }
  }

  function updateSplitterAria(leftPercent) {
    if (!els.panelSplitter) {
      return;
    }

    const left = Math.round(leftPercent);
    const right = Math.round(100 - leftPercent);
    els.panelSplitter.setAttribute("aria-valuemin", String(LAYOUT_SPLIT_MIN));
    els.panelSplitter.setAttribute("aria-valuemax", String(LAYOUT_SPLIT_MAX));
    els.panelSplitter.setAttribute("aria-valuenow", String(left));
    els.panelSplitter.setAttribute("aria-valuetext", `${left}% code, ${right}% output`);
  }

  function applyLayoutSplit(nextPercent, { save } = {}) {
    const normalized = normalizeLayoutSplit(nextPercent);
    state.layoutLeftPane = normalized;
    document.documentElement.style.setProperty("--layout-left-pane", `${normalized}%`);
    updateSplitterAria(normalized);

    if (save === false) {
      return;
    }

    saveLayoutSplit(normalized);
  }

  function isCompactLayout() {
    if (typeof window.matchMedia === "function") {
      return window.matchMedia(MOBILE_LAYOUT_QUERY).matches;
    }
    return window.innerWidth <= 980;
  }

  function setLayoutResizing(active) {
    if (!els.mainLayout) {
      return;
    }
    els.mainLayout.classList.toggle("is-resizing", Boolean(active));
  }

  function initLayoutSplitter() {
    applyLayoutSplit(loadLayoutSplit(), { save: false });

    if (!els.mainLayout || !els.panelSplitter) {
      return;
    }

    let dragging = false;
    let activePointerId = null;

    function applySplitFromClientX(clientX) {
      const layoutRect = els.mainLayout.getBoundingClientRect();
      const splitterRect = els.panelSplitter.getBoundingClientRect();
      const usableWidth = layoutRect.width - splitterRect.width;
      if (usableWidth <= 0) {
        return;
      }

      const leftWidth = clientX - layoutRect.left - (splitterRect.width / 2);
      const leftPercent = (leftWidth / usableWidth) * 100;
      applyLayoutSplit(leftPercent, { save: false });
    }

    function onPointerMove(ev) {
      if (!dragging || isCompactLayout()) {
        return;
      }
      applySplitFromClientX(ev.clientX);
      ev.preventDefault();
    }

    function stopDragging() {
      if (!dragging) {
        return;
      }
      dragging = false;
      setLayoutResizing(false);
      if (activePointerId !== null && typeof els.panelSplitter.releasePointerCapture === "function") {
        try {
          els.panelSplitter.releasePointerCapture(activePointerId);
        } catch {
          // ignore
        }
      }
      activePointerId = null;
      saveLayoutSplit(state.layoutLeftPane);
      window.removeEventListener("pointermove", onPointerMove);
      window.removeEventListener("pointerup", stopDragging);
      window.removeEventListener("pointercancel", stopDragging);
    }

    els.panelSplitter.addEventListener("pointerdown", (ev) => {
      if (ev.button !== 0 || isCompactLayout()) {
        return;
      }

      dragging = true;
      activePointerId = ev.pointerId;
      setLayoutResizing(true);

      if (typeof els.panelSplitter.setPointerCapture === "function") {
        try {
          els.panelSplitter.setPointerCapture(ev.pointerId);
        } catch {
          // ignore
        }
      }

      applySplitFromClientX(ev.clientX);
      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", stopDragging);
      window.addEventListener("pointercancel", stopDragging);
      ev.preventDefault();
    });

    els.panelSplitter.addEventListener("keydown", (ev) => {
      if (isCompactLayout()) {
        return;
      }
      if (ev.key !== "ArrowLeft" && ev.key !== "ArrowRight") {
        return;
      }

      const step = ev.shiftKey ? 5 : 2;
      const delta = ev.key === "ArrowRight" ? step : -step;
      applyLayoutSplit(state.layoutLeftPane + delta);
      ev.preventDefault();
    });

    window.addEventListener("resize", () => {
      if (isCompactLayout()) {
        setLayoutResizing(false);
        return;
      }
      applyLayoutSplit(state.layoutLeftPane, { save: false });
    });
  }

  function validateRuleConfig(config) {
    if (!config || typeof config !== "object" || Array.isArray(config)) {
      return "Config must be a JSON object.";
    }

    if (!config.object || typeof config.object !== "string") {
      return "Missing config.object (string).";
    }

    if (!config.match || typeof config.match !== "object" || Array.isArray(config.match)) {
      return "Missing config.match (object).";
    }

    const match = config.match;
    const hasMatch =
      (typeof match.startKeyword === "string" && match.startKeyword.trim()) ||
      (typeof match.startPhrase === "string" && match.startPhrase.trim()) ||
      (typeof match.type === "string" && match.type.trim());

    if (!hasMatch) {
      return "match must include startKeyword, startPhrase, or type.";
    }

    if (config.block !== undefined && config.block !== null) {
      if (typeof config.block !== "object" || Array.isArray(config.block)) {
        return "block must be an object (or null).";
      }
      if (typeof config.block.endKeyword !== "string" || !config.block.endKeyword.trim()) {
        return "block.endKeyword must be a non-empty string.";
      }
    }

    if (config.extras !== undefined && config.extras !== null) {
      if (typeof config.extras !== "object" || Array.isArray(config.extras)) {
        return "extras must be an object (or null).";
      }
      if (typeof config.extras.type !== "string" || !config.extras.type.trim()) {
        return "extras.type must be a non-empty string.";
      }
    }

    if (config.keywordLabels !== undefined && config.keywordLabels !== null) {
      if (typeof config.keywordLabels !== "object" || Array.isArray(config.keywordLabels)) {
        return "keywordLabels must be an object.";
      }
    }

    if (config.keywordPhrases !== undefined && config.keywordPhrases !== null) {
      if (typeof config.keywordPhrases !== "object" || Array.isArray(config.keywordPhrases)) {
        return "keywordPhrases must be an object.";
      }
    }

    if (config.captureRules !== undefined && config.captureRules !== null && !Array.isArray(config.captureRules)) {
      return "captureRules must be an array.";
    }

    if (Array.isArray(config.captureRules)) {
      for (const rule of config.captureRules) {
        if (!rule || typeof rule !== "object" || Array.isArray(rule)) {
          return "Each captureRules[] item must be an object.";
        }
        if (typeof rule.after !== "string" || !rule.after.trim()) {
          return "Each captureRules[] item must have after (string).";
        }
        if (typeof rule.name !== "string" || !rule.name.trim()) {
          return "Each captureRules[] item must have name (string).";
        }
      }
    }

    return "";
  }

  function generateRuleId() {
    const time = Date.now();
    const rand = Math.random().toString(16).slice(2, 10);
    return `rule-${time}-${rand}`;
  }

  function normalizeCustomRules(list) {
    const output = [];
    const items = Array.isArray(list) ? list : [];

    for (const item of items) {
      if (!item || typeof item !== "object" || Array.isArray(item)) {
        continue;
      }

      if (item.config && typeof item.config === "object" && !Array.isArray(item.config)) {
        const id = item.id ? String(item.id) : generateRuleId();
        output.push({ id, config: item.config });
        continue;
      }

      if (typeof item.object === "string") {
        output.push({ id: generateRuleId(), config: item });
      }
    }

    return output;
  }

  function loadCustomRules() {
    return normalizeCustomRules(loadStorageArray(RULES_STORAGE_KEY_V1));
  }

  function saveCustomRules() {
    try {
      localStorage.setItem(RULES_STORAGE_KEY_V1, JSON.stringify(state.customRules || []));
    } catch {
      // ignore
    }
  }

  function setRulesError(message) {
    if (!els.rulesError) {
      return;
    }
    els.rulesError.textContent = message ? String(message) : "";
  }

  function getCustomConfigs() {
    const output = [];
    for (const rule of state.customRules || []) {
      if (!rule || !rule.config) {
        continue;
      }
      const error = validateRuleConfig(rule.config);
      if (!error) {
        output.push(rule.config);
      }
    }
    return output;
  }

  function describeRuleOption(rule) {
    if (!rule || !rule.config) {
      return "(invalid rule)";
    }

    const objectType = rule.config.object ? String(rule.config.object) : "RULE";
    const match = rule.config.match && typeof rule.config.match === "object" ? rule.config.match : {};
    const summary = match.startPhrase
      ? `startPhrase=${String(match.startPhrase)}`
      : match.startKeyword
        ? `startKeyword=${String(match.startKeyword)}`
        : match.type
          ? `type=${String(match.type)}`
          : "match=?";

    return `${objectType} (${summary})`;
  }

  function renderRulesSelect() {
    if (!els.rulesSelect) {
      return;
    }

    els.rulesSelect.replaceChildren();
    els.rulesSelect.appendChild(el("option", { text: "(New rule)", attrs: { value: "" } }));

    for (const rule of state.customRules || []) {
      const id = rule && rule.id ? String(rule.id) : "";
      if (!id) {
        continue;
      }
      els.rulesSelect.appendChild(
        el("option", {
          text: describeRuleOption(rule),
          attrs: { value: id }
        })
      );
    }

    els.rulesSelect.value = state.activeRuleId || "";
  }

  function selectRule(ruleId) {
    const id = ruleId ? String(ruleId) : "";
    state.activeRuleId = id;
    setRulesError("");

    if (!els.rulesJson) {
      return;
    }

    if (!id) {
      els.rulesJson.value = "";
      return;
    }

    const rule = (state.customRules || []).find((r) => r && String(r.id) === id) || null;
    if (!rule || !rule.config) {
      els.rulesJson.value = "";
      return;
    }

    try {
      els.rulesJson.value = JSON.stringify(rule.config, null, 2);
    } catch {
      els.rulesJson.value = "";
    }
  }

  function createRuleTemplate(kind) {
    const type = String(kind || "startKeyword");

    if (type === "assignment") {
      return {
        object: "ASSIGNMENT",
        match: { type: "assignment" },
        keywordLabels: {
          "=": "assign",
          "+=": "add-assign",
          "-=": "sub-assign",
          "*=": "mul-assign",
          "/=": "div-assign",
          "?=": "cast"
        },
        keywordPhrases: {},
        captureRules: []
      };
    }

    if (type === "startPhrase") {
      return {
        object: "MY_OBJECT",
        match: { startPhrase: "MY PHRASE" },
        keywordLabels: {
          MY: "stmt"
        },
        keywordPhrases: {
          "MY PHRASE": "my-phrase"
        },
        captureRules: [
          { after: "MY PHRASE", name: "name", label: "name" }
        ]
      };
    }

    return {
      object: "MY_OBJECT",
      match: { startKeyword: "MYKEYWORD" },
      keywordLabels: {
        MYKEYWORD: "stmt"
      },
      keywordPhrases: {},
      captureRules: [
        { after: "MYKEYWORD", name: "name", label: "name" }
      ]
    };
  }

  function startNewRule() {
    state.activeRuleId = "";
    if (els.rulesSelect) {
      els.rulesSelect.value = "";
    }

    const kind = els.rulesTemplate ? els.rulesTemplate.value : "startKeyword";
    const template = createRuleTemplate(kind);

    if (els.rulesJson) {
      els.rulesJson.value = JSON.stringify(template, null, 2);
      els.rulesJson.focus();
    }

    setRulesError("");
  }

  function readRuleFromEditor() {
    const text = els.rulesJson ? els.rulesJson.value || "" : "";
    const trimmed = text.trim();
    if (!trimmed) {
      return { config: null, error: "Rule JSON is empty." };
    }

    try {
      const parsed = JSON.parse(trimmed);
      const config = parsed;
      const error = validateRuleConfig(config);
      if (error) {
        return { config: null, error };
      }
      return { config, error: "" };
    } catch (err) {
      return { config: null, error: `JSON parse error: ${err && err.message ? err.message : err}` };
    }
  }

  function saveRuleFromEditor() {
    const { config, error } = readRuleFromEditor();
    if (error) {
      setRulesError(error);
      return;
    }

    setRulesError("");

    if (state.activeRuleId) {
      const target = (state.customRules || []).find((r) => r && String(r.id) === state.activeRuleId) || null;
      if (target) {
        target.config = config;
      } else {
        state.customRules.push({ id: state.activeRuleId, config });
      }
    } else {
      const id = generateRuleId();
      state.customRules.push({ id, config });
      state.activeRuleId = id;
    }

    saveCustomRules();
    renderRulesSelect();
    if (els.rulesSelect) {
      els.rulesSelect.value = state.activeRuleId || "";
    }
  }

  function deleteActiveRule() {
    if (!state.activeRuleId) {
      setRulesError("Select a saved rule to delete.");
      return;
    }

    state.customRules = (state.customRules || []).filter((r) => r && String(r.id) !== state.activeRuleId);
    state.activeRuleId = "";
    saveCustomRules();
    renderRulesSelect();
    if (els.rulesJson) {
      els.rulesJson.value = "";
    }
    setRulesError("");
  }

  function downloadRuleFromEditor() {
    const { config, error } = readRuleFromEditor();
    if (error) {
      setRulesError(error);
      return;
    }

    setRulesError("");

    const fileBase = config && config.object ? String(config.object).trim() : "rule";
    const fileName = `${fileBase}.json`;
    const content = JSON.stringify(config, null, 2);

    try {
      const blob = new Blob([content], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    } catch (err) {
      setRulesError(`Download failed: ${err && err.message ? err.message : err}`);
    }
  }

  function openRulesModal() {
    if (!els.rulesModal) {
      return;
    }

    if (!els.jsonModal.hidden) {
      closeJsonModal();
    }
    if (!els.editModal.hidden) {
      closeEditModal();
    }

    renderRulesSelect();
    if (state.activeRuleId) {
      selectRule(state.activeRuleId);
    } else if (els.rulesJson && !els.rulesJson.value.trim()) {
      startNewRule();
    }

    els.rulesModal.hidden = false;
  }

  function closeRulesModal() {
    if (!els.rulesModal) {
      return;
    }

    els.rulesModal.hidden = true;
    setRulesError("");
  }

  function renderSettingsModalUi() {
    if (!els.settingsModal) {
      return;
    }

    const settings = state.settings || loadSettings();
    state.settings = settings;

    if (els.settingsNormalizeDesc) {
      els.settingsNormalizeDesc.checked = Boolean(settings.normalizeDeclDesc);
    }

    if (els.settingsDeclTypes) {
      els.settingsDeclTypes.replaceChildren();
      for (const type of DECL_TYPE_OPTIONS) {
        const label = document.createElement("label");
        label.className = "toggle";

        const input = document.createElement("input");
        input.type = "checkbox";
        input.value = type;
        input.checked = Array.isArray(settings.declFilterTypes) && settings.declFilterTypes.includes(type);

        label.appendChild(input);
        label.appendChild(document.createTextNode(type));
        els.settingsDeclTypes.appendChild(label);
      }
    }

    if (els.settingsStructTemplate) {
      els.settingsStructTemplate.value = settings.structDescTemplate || DEFAULT_SETTINGS.structDescTemplate;
    }

    if (els.settingsNameTemplates) {
      els.settingsNameTemplates.replaceChildren();

      const table = document.createElement("table");
      const thead = document.createElement("thead");
      const headRow = document.createElement("tr");
      for (const title of ["code", "label", "template"]) {
        const th = document.createElement("th");
        th.textContent = title;
        headRow.appendChild(th);
      }
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement("tbody");
      for (const opt of NAME_CODE_OPTIONS) {
        const tr = document.createElement("tr");

        const codeCell = document.createElement("td");
        codeCell.textContent = opt.code;
        tr.appendChild(codeCell);

        const labelCell = document.createElement("td");
        labelCell.textContent = opt.label;
        tr.appendChild(labelCell);

        const tplCell = document.createElement("td");
        const input = document.createElement("input");
        input.type = "text";
        input.style.width = "100%";
        input.setAttribute("data-code", opt.code);
        input.value = (settings.nameTemplatesByCode && settings.nameTemplatesByCode[opt.code])
          ? String(settings.nameTemplatesByCode[opt.code] || "")
          : String(DEFAULT_SETTINGS.nameTemplatesByCode[opt.code] || "");

        tplCell.appendChild(input);
        tr.appendChild(tplCell);

        tbody.appendChild(tr);
      }
      table.appendChild(tbody);

      els.settingsNameTemplates.appendChild(table);
    }
  }

  function openSettingsModal() {
    if (!els.settingsModal) {
      return;
    }

    if (!els.jsonModal.hidden) {
      closeJsonModal();
    }
    if (!els.editModal.hidden) {
      closeEditModal();
    }
    if (els.rulesModal && !els.rulesModal.hidden) {
      closeRulesModal();
    }

    renderSettingsModalUi();
    els.settingsModal.hidden = false;
  }

  function closeSettingsModal() {
    if (!els.settingsModal) {
      return;
    }
    els.settingsModal.hidden = true;
  }

window.AbapViewerModules.factories = window.AbapViewerModules.factories || {};
window.AbapViewerModules.factories["01-core"] = function registerCore(runtime) {
  const targetRuntime = runtime || (window.AbapViewerRuntime = window.AbapViewerRuntime || {});
  targetRuntime.api = targetRuntime.api || {};
  targetRuntime.els = els;
  targetRuntime.state = state;
  targetRuntime.constants = {
    DESC_STORAGE_KEY_V2,
    DESC_STORAGE_KEY_LEGACY_V1,
    RULES_STORAGE_KEY_V1,
    SETTINGS_STORAGE_KEY_V1,
    TEMPLATE_CONFIG_STORAGE_KEY_V1,
    THEME_STORAGE_KEY_V1,
    LAYOUT_SPLIT_STORAGE_KEY_V1,
    LAYOUT_SPLIT_DEFAULT,
    LAYOUT_SPLIT_MIN,
    LAYOUT_SPLIT_MAX,
    MOBILE_LAYOUT_QUERY,
    RENDER_TREE_OPTIONS,
    DECL_TYPE_OPTIONS,
    NAME_CODE_OPTIONS,
    DEFAULT_SETTINGS,
    TEMPLATE_DEFAULT_CONFIG_V1,
    SAMPLE_ABAP
  };
  window.AbapViewerModules.parts["01-core"] = true;
};
window.AbapViewerModules.factories["01-core"](window.AbapViewerRuntime);
</script>
  <script>
// inlined from: ./app/02-descriptions.js
"use strict";

window.AbapViewerModules = window.AbapViewerModules || {};
window.AbapViewerModules.parts = window.AbapViewerModules.parts || {};

  function collectConditionDeclsFromClauses(clauses, addDecl) {
    const list = Array.isArray(clauses) ? clauses : [];
    for (const clause of list) {
      if (!clause || typeof clause !== "object") {
        continue;
      }
      addDecl(clause.leftOperandDecl);
      addDecl(clause.rightOperandDecl);
    }
  }

  function collectConditionDeclsFromExtras(extras, addDecl) {
    if (!extras || typeof extras !== "object" || typeof addDecl !== "function") {
      return;
    }

    if (extras.ifCondition) {
      collectConditionDeclsFromClauses(extras.ifCondition.conditions, addDecl);
    }

    if (extras.performCall) {
      collectConditionDeclsFromClauses(extras.performCall.ifConditions, addDecl);
    }

    if (extras.select) {
      collectConditionDeclsFromClauses(extras.select.whereConditions, addDecl);
      collectConditionDeclsFromClauses(extras.select.havingConditions, addDecl);
    }

    for (const key of ["readTable", "loopAtItab", "modifyItab", "deleteItab"]) {
      if (extras[key]) {
        collectConditionDeclsFromClauses(extras[key].conditions, addDecl);
      }
    }
  }

  function getDeclsForDescriptionsModal() {
    if (state.data && typeof state.data === "object" && Array.isArray(state.data.decls)) {
      return state.data.decls;
    }

    const decls = [];
    const seen = new Set();

    const addDecl = (decl) => {
      if (!decl || typeof decl !== "object") {
        return;
      }
      const key = getDeclOverrideStorageKey(decl) || stringifyDecl(decl);
      if (!key || seen.has(key)) {
        return;
      }
      seen.add(key);
      decls.push(decl);
    };

    walkObjects(state.data && Array.isArray(state.data.objects) ? state.data.objects : [], (obj) => {
      for (const value of getValueEntries(obj)) {
        addDecl(value && value.decl);
      }

      const extras = obj && obj.extras && typeof obj.extras === "object" ? obj.extras : null;
      if (!extras) {
        return;
      }

      const collectFromAssignmentSections = (container, sections) => {
        for (const sectionName of sections) {
          const list = container && Array.isArray(container[sectionName]) ? container[sectionName] : [];
          for (const entry of list) {
            const origin = entry && Array.isArray(entry.originDecls) ? entry.originDecls : [];
            for (const originDecl of origin) {
              addDecl(originDecl);
            }
            addDecl(entry && entry.valueDecl);
          }
        }
      };

      if (extras.callFunction) {
        collectFromAssignmentSections(extras.callFunction, ["exporting", "importing", "changing", "tables", "exceptions"]);
      }

      if (extras.callMethod) {
        collectFromAssignmentSections(extras.callMethod, ["exporting", "importing", "changing", "receiving", "exceptions"]);
      }

      if (extras.performCall) {
        for (const sectionName of ["using", "changing", "tables"]) {
          const list = Array.isArray(extras.performCall[sectionName]) ? extras.performCall[sectionName] : [];
          for (const entry of list) {
            const origin = entry && Array.isArray(entry.originDecls) ? entry.originDecls : [];
            for (const originDecl of origin) {
              addDecl(originDecl);
            }
            addDecl(entry && entry.valueDecl);
          }
        }
      }

      if (extras.form && Array.isArray(extras.form.params)) {
        for (const param of extras.form.params) {
          const origin = param && Array.isArray(param.originDecls) ? param.originDecls : [];
          for (const originDecl of origin) {
            addDecl(originDecl);
          }
        }
      }

      collectConditionDeclsFromExtras(extras, addDecl);
    });

    return decls;
  }

  function getDeclCodeDesc(decl) {
    const source = getSourceDeclDesc(decl);
    if (source) {
      return source;
    }
    return getBaseDeclDesc(decl);
  }

  function renderDeclDescCellLines({ structText, itemText }) {
    const wrap = document.createElement("div");
    const structLine = document.createElement("div");
    const structLabel = document.createElement("span");
    structLabel.className = "muted";
    structLabel.textContent = "Struct: ";
    structLine.appendChild(structLabel);
    structLine.appendChild(document.createTextNode(structText || ""));
    wrap.appendChild(structLine);

    const itemLine = document.createElement("div");
    const itemLabel = document.createElement("span");
    itemLabel.className = "muted";
    itemLabel.textContent = "Item: ";
    itemLine.appendChild(itemLabel);
    itemLine.appendChild(document.createTextNode(itemText || ""));
    wrap.appendChild(itemLine);

    return wrap;
  }

  function renderDeclDescPanelUi() {
    if (!els.declDescPanel) {
      return;
    }

    const settings = state.settings || loadSettings();
    state.settings = settings;

    if (els.declDescTypes) {
      els.declDescTypes.replaceChildren();
      for (const type of DECL_TYPE_OPTIONS) {
        const label = document.createElement("label");
        label.className = "toggle";

        const input = document.createElement("input");
        input.type = "checkbox";
        input.value = type;
        input.checked = Array.isArray(settings.declFilterTypes) && settings.declFilterTypes.includes(type);
        input.addEventListener("change", () => {
          const selected = [];
          const inputs = els.declDescTypes ? els.declDescTypes.querySelectorAll("input[type=checkbox]") : [];
          for (const checkbox of Array.from(inputs)) {
            if (checkbox.checked) {
              selected.push(String(checkbox.value || "").trim().toUpperCase());
            }
          }
          state.settings = normalizeSettings({ ...settings, declFilterTypes: selected });
          saveSettings(state.settings);
          renderDeclDescPanelUi();
        });

        label.appendChild(input);
        label.appendChild(document.createTextNode(type));
        els.declDescTypes.appendChild(label);
      }
    }

    const decls = getDeclsForDescriptionsModal();
    const types = new Set((state.settings && Array.isArray(state.settings.declFilterTypes))
      ? state.settings.declFilterTypes
      : DEFAULT_SETTINGS.declFilterTypes);

    const query = els.declDescSearch ? String(els.declDescSearch.value || "").trim().toLowerCase() : "";
    const missingOnly = Boolean(els.declDescMissingOnly && els.declDescMissingOnly.checked);

    const rows = [];
    let totalRows = 0;
    let missingRows = 0;

    for (const decl of decls) {
      if (!decl || typeof decl !== "object" || !decl.objectType || !decl.name) {
        continue;
      }

      const objectType = String(decl.objectType || "").trim().toUpperCase();
      if (objectType === "STRUCT_FIELD") {
        const structType = String(decl.structObjectType || "").trim().toUpperCase();
        if (structType && !types.has(structType)) {
          continue;
        }
      } else if (!types.has(objectType)) {
        continue;
      }

      totalRows += 1;

      const techName = getDeclTechName(decl);
      const scopeLabel = String(decl.scopeLabel || "");

      const isStructField = isStructFieldDecl(decl);
      if (!isStructField) {
        const codeDescRaw = String(getDeclCodeDesc(decl) || "");
        const userEntry = getDeclOverrideEntry(decl);
        const userDescRaw = userEntry.text ? String(userEntry.text) : "";

        const codeDesc = settings.normalizeDeclDesc ? normalizeDeclDescText(decl, codeDescRaw) : codeDescRaw;
        const userDesc = (!settings.normalizeDeclDesc || userEntry.noNormalize)
          ? userDescRaw
          : normalizeDeclDescText(decl, userDescRaw);

        const missing = !codeDescRaw.trim() && !userDescRaw.trim();
        if (missing) {
          missingRows += 1;
        }
        if (missingOnly && !missing) {
          continue;
        }

        const haystack = [
          objectType,
          scopeLabel,
          techName,
          codeDescRaw,
          userDescRaw,
          codeDesc,
          userDesc
        ]
          .filter(Boolean)
          .join("\n")
          .toLowerCase();

        if (query && !haystack.includes(query)) {
          continue;
        }

        rows.push({
          decl,
          objectType,
          scopeLabel,
          techName,
          missing,
          codeDesc,
          userDesc
        });
        continue;
      }

      const structDecl = buildStructDeclFromFieldDecl(decl);
      const structCodeRaw = structDecl ? String(getDeclCodeDesc(structDecl) || "") : "";
      const structUserRaw = structDecl ? String(getDeclOverrideDesc(structDecl) || "") : "";
      const itemCodeRaw = String(getDeclCodeDesc(decl) || "");
      const itemEntry = getDeclOverrideEntry(decl);
      const itemUserRaw = itemEntry.text ? String(itemEntry.text) : "";

      const structCode = structDecl && settings.normalizeDeclDesc ? normalizeDeclDescText(structDecl, structCodeRaw) : structCodeRaw;
      const structUser = structDecl && settings.normalizeDeclDesc ? normalizeDeclDescText(structDecl, structUserRaw) : structUserRaw;
      const itemCode = settings.normalizeDeclDesc ? normalizeDeclDescText(decl, itemCodeRaw) : itemCodeRaw;
      const itemUser = (!settings.normalizeDeclDesc || itemEntry.noNormalize)
        ? itemUserRaw
        : normalizeDeclDescText(decl, itemUserRaw);

      const structMissing = !structCodeRaw.trim() && !structUserRaw.trim();
      const itemMissing = !itemCodeRaw.trim() && !itemUserRaw.trim();
      const missing = structMissing || itemMissing;
      if (missing) {
        missingRows += 1;
      }
      if (missingOnly && !missing) {
        continue;
      }

      const haystack = [
        objectType,
        scopeLabel,
        techName,
        structCodeRaw,
        structUserRaw,
        itemCodeRaw,
        itemUserRaw,
        structCode,
        structUser,
        itemCode,
        itemUser
      ]
        .filter(Boolean)
        .join("\n")
        .toLowerCase();

      if (query && !haystack.includes(query)) {
        continue;
      }

      rows.push({
        decl,
        objectType,
        scopeLabel,
        techName,
        missing,
        structMissing,
        itemMissing,
        structCode,
        structUser,
        itemCode,
        itemUser
      });
    }

    rows.sort((a, b) => {
      const scopeCmp = String(a.scopeLabel || "").localeCompare(String(b.scopeLabel || ""));
      if (scopeCmp) {
        return scopeCmp;
      }
      const typeCmp = String(a.objectType || "").localeCompare(String(b.objectType || ""));
      if (typeCmp) {
        return typeCmp;
      }
      return String(a.techName || "").localeCompare(String(b.techName || ""));
    });

    if (els.declDescSummary) {
      const shown = rows.length;
      els.declDescSummary.textContent = `Showing ${shown} of ${totalRows} decls • Missing: ${missingRows}`;
    }

    if (!els.declDescTable) {
      refreshInputGutterTargets();
      return;
    }

    if (!state.data || !Array.isArray(state.data.objects)) {
      els.declDescTable.replaceChildren(el("div", { className: "muted", text: "No data loaded. Click Render first." }));
      refreshInputGutterTargets();
      return;
    }

    const table = document.createElement("table");
    const thead = document.createElement("thead");
    const headRow = document.createElement("tr");
    for (const title of ["type", "scope", "technical id", "code desc", "user desc", ""]) {
      const th = document.createElement("th");
      th.textContent = title;
      headRow.appendChild(th);
    }
    thead.appendChild(headRow);
    table.appendChild(thead);

    const tbody = document.createElement("tbody");
    for (const row of rows) {
      const tr = document.createElement("tr");
      const declKey = getDeclOverrideStorageKey(row.decl);
      if (declKey) {
        tr.setAttribute("data-decl-key", declKey);
        if (declKey === state.selectedDeclKey) {
          tr.classList.add("desc-selected");
        }
      }
      if (row.decl && row.decl.lineStart) {
        tr.setAttribute("data-line-start", String(row.decl.lineStart));
      }

      const typeCell = document.createElement("td");
      typeCell.textContent = row.objectType || "";
      tr.appendChild(typeCell);

      const scopeCell = document.createElement("td");
      scopeCell.textContent = row.scopeLabel || "";
      tr.appendChild(scopeCell);

      const idCell = document.createElement("td");
      const idWrap = document.createElement("div");
      const idLine = document.createElement("div");
      idLine.textContent = row.techName || "";
      const title = buildDeclTitle(row.decl);
      if (title) {
        idLine.title = title;
      }
      if (row.decl && row.decl.lineStart) {
        idLine.style.cursor = "pointer";
        idLine.addEventListener("click", (ev) => {
          ev.stopPropagation();
          selectCodeLines(row.decl.lineStart, row.decl.lineStart);
          if (row.decl.id) {
            setSelectedCard(row.decl.id);
          }
        });
      }
      idWrap.appendChild(idLine);

      if (row.objectType === "STRUCT_FIELD") {
        const pills = document.createElement("div");
        if (row.structMissing) {
          pills.appendChild(el("span", { className: "pill", text: "struct missing" }));
        }
        if (row.itemMissing) {
          pills.appendChild(el("span", { className: "pill", text: "item missing" }));
        }
        if (pills.childNodes.length) {
          idWrap.appendChild(pills);
        }
      } else if (row.missing) {
        idWrap.appendChild(el("span", { className: "pill", text: "missing" }));
      }

      idCell.appendChild(idWrap);
      tr.appendChild(idCell);

      const codeCell = document.createElement("td");
      if (row.objectType === "STRUCT_FIELD") {
        codeCell.appendChild(renderDeclDescCellLines({ structText: row.structCode || "", itemText: row.itemCode || "" }));
      } else {
        codeCell.textContent = row.codeDesc || "";
      }
      tr.appendChild(codeCell);

      const userCell = document.createElement("td");
      if (row.objectType === "STRUCT_FIELD") {
        userCell.appendChild(renderDeclDescCellLines({ structText: row.structUser || "", itemText: row.itemUser || "" }));
      } else {
        userCell.textContent = row.userDesc || "";
      }
      tr.appendChild(userCell);

      const actionCell = document.createElement("td");
      const btn = el("button", {
        className: "icon-btn",
        text: "✎",
        attrs: { type: "button", title: "Edit description", "aria-label": "Edit description" }
      });
      btn.addEventListener("click", (ev) => {
        ev.stopPropagation();
        editDeclDesc(row.decl);
      });
      actionCell.appendChild(btn);
      tr.appendChild(actionCell);

      tbody.appendChild(tr);
    }
    table.appendChild(tbody);

    els.declDescTable.replaceChildren(table);
    refreshInputGutterTargets();
  }

  function setRightTab(nextTab) {
    const tab = nextTab === "descriptions"
      ? "descriptions"
      : (nextTab === "template" ? "template" : "output");
    state.rightTab = tab;

    const showDescriptions = tab === "descriptions";
    const showTemplate = tab === "template";
    const showOutput = tab === "output";
    if (els.output) {
      els.output.hidden = !showOutput;
    }
    if (els.templatePreviewPanel) {
      els.templatePreviewPanel.hidden = !showTemplate;
    }
    if (els.declDescPanel) {
      els.declDescPanel.hidden = !showDescriptions;
    }

    if (els.rightPanelTitle) {
      els.rightPanelTitle.textContent = showDescriptions
        ? "Descriptions"
        : (showTemplate ? "Template Preview" : "Output");
    }

    if (els.rightTabOutputBtn) {
      els.rightTabOutputBtn.classList.toggle("active", showOutput);
      els.rightTabOutputBtn.setAttribute("aria-selected", String(showOutput));
    }
    if (els.rightTabTemplateBtn) {
      els.rightTabTemplateBtn.classList.toggle("active", showTemplate);
      els.rightTabTemplateBtn.setAttribute("aria-selected", String(showTemplate));
    }
    if (els.rightTabDescBtn) {
      els.rightTabDescBtn.classList.toggle("active", showDescriptions);
      els.rightTabDescBtn.setAttribute("aria-selected", String(showDescriptions));
    }
    if (els.declDescJsonBtn) {
      els.declDescJsonBtn.hidden = !showDescriptions;
    }

    if (showDescriptions) {
      renderDeclDescPanelUi();
      setTimeout(() => {
        if (els.declDescSearch) {
          els.declDescSearch.focus();
        }
      }, 0);
    } else if (showTemplate) {
      renderTemplatePreview();
    }

    refreshInputGutterTargets();
  }

  function applySettingsFromModal() {
    if (!els.settingsModal) {
      return;
    }

    const next = {
      normalizeDeclDesc: Boolean(els.settingsNormalizeDesc && els.settingsNormalizeDesc.checked),
      declFilterTypes: [],
      structDescTemplate: (els.settingsStructTemplate && els.settingsStructTemplate.value)
        ? String(els.settingsStructTemplate.value || "")
        : DEFAULT_SETTINGS.structDescTemplate,
      nameTemplatesByCode: {}
    };

    if (els.settingsDeclTypes) {
      const inputs = els.settingsDeclTypes.querySelectorAll("input[type=checkbox]");
      for (const input of Array.from(inputs)) {
        if (input.checked) {
          next.declFilterTypes.push(String(input.value || "").trim().toUpperCase());
        }
      }
    }

    const nameInputs = els.settingsNameTemplates
      ? els.settingsNameTemplates.querySelectorAll("input[data-code]")
      : [];

    for (const input of Array.from(nameInputs)) {
      const code = String(input.getAttribute("data-code") || "").trim().toUpperCase();
      if (!code) {
        continue;
      }
      next.nameTemplatesByCode[code] = String(input.value || "");
    }

    state.settings = normalizeSettings(next);
    saveSettings(state.settings);
    state.haystackById = buildSearchIndex(state.renderObjects);
    renderOutput();
  }

  function resetSettingsToDefault() {
    state.settings = normalizeSettings(DEFAULT_SETTINGS);
    saveSettings(state.settings);
    renderSettingsModalUi();
    state.haystackById = buildSearchIndex(state.renderObjects);
    renderOutput();
  }

  function normalizeKeyToken(value) {
    return String(value || "").trim().toUpperCase();
  }

  function getDeclFallbackKey(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const name = normalizeKeyToken(decl.name);
    if (!name) {
      return "";
    }

    const objectType = normalizeKeyToken(decl.objectType);
    const file = String(decl.file || "").trim();
    const line = decl.lineStart ? String(decl.lineStart) : "";
    return `FALLBACK:${objectType}|${name}|${file}|${line}`;
  }

  function getDeclKey(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const scope = normalizeKeyToken(decl.scopeLabel);
    const name = normalizeKeyToken(decl.name);

    if (!scope || !name) {
      return "";
    }

    return `${scope}:${name}`;
  }

  function getLegacyDeclKey(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const type = normalizeKeyToken(decl.objectType);
    const name = normalizeKeyToken(decl.name);

    if (!type || !name) {
      return "";
    }

    return `${type}:NAME:${name}`;
  }

  function getDeclOverrideLookupKeys(decl) {
    const keys = [];
    const pushKey = (value) => {
      const key = String(value || "").trim();
      if (!key || keys.includes(key)) {
        return;
      }
      keys.push(key);
    };

    pushKey(getDeclKey(decl));
    pushKey(getLegacyDeclKey(decl));
    pushKey(getDeclFallbackKey(decl));
    return keys;
  }

  function getDeclOverrideStorageKey(decl) {
    const keys = getDeclOverrideLookupKeys(decl);
    return keys.length ? keys[0] : "";
  }

  function normalizeDescOverrideEntry(value) {
    if (typeof value === "string") {
      return { text: String(value || ""), noNormalize: false };
    }
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      return { text: "", noNormalize: false };
    }

    const text = typeof value.text === "string"
      ? value.text
      : typeof value.desc === "string"
        ? value.desc
        : typeof value.value === "string"
          ? value.value
          : "";

    const noNormalize = Boolean(value.noNormalize || value.skipNormalize || value.disableNormalize || value.no_normalize);
    return { text: String(text || ""), noNormalize };
  }

  function getDeclOverrideEntry(decl) {
    const keys = getDeclOverrideLookupKeys(decl);
    for (const key of keys) {
      if (key && Object.prototype.hasOwnProperty.call(state.descOverrides || {}, key)) {
        return normalizeDescOverrideEntry(state.descOverrides[key]);
      }
    }

    const legacyKey = getLegacyDeclKey(decl);
    if (legacyKey && Object.prototype.hasOwnProperty.call(state.descOverridesLegacy || {}, legacyKey)) {
      return { text: String(state.descOverridesLegacy[legacyKey] || ""), noNormalize: false };
    }

    return { text: "", noNormalize: false };
  }

  function getDeclOverrideDesc(decl) {
    return getDeclOverrideEntry(decl).text;
  }

  function getDeclOverrideNoNormalize(decl) {
    return Boolean(getDeclOverrideEntry(decl).noNormalize);
  }

  function getBaseDeclDesc(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const objectType = normalizeKeyToken(decl.objectType);
    const scopeType = normalizeKeyToken(decl.scopeType);
    if (objectType === "PATH_DECL" || scopeType === "PATH") {
      return "";
    }

    const registry = window.AbapVarDescriptions && typeof window.AbapVarDescriptions === "object"
      ? window.AbapVarDescriptions
      : null;
    if (!registry) {
      return "";
    }

    const nameUpper = normalizeKeyToken(decl.name);
    if (!nameUpper) {
      return "";
    }

    const scopeLabel = normalizeKeyToken(decl.scopeLabel);

    if (objectType === "SYSTEM" || scopeLabel === "SYSTEM") {
      const systemMap = registry.system && typeof registry.system === "object" ? registry.system : null;
      if (systemMap && Object.prototype.hasOwnProperty.call(systemMap, nameUpper)) {
        return String(systemMap[nameUpper] || "");
      }
    }

    const byScope = registry.customByScope && typeof registry.customByScope === "object" ? registry.customByScope : null;
    if (byScope && scopeLabel && Object.prototype.hasOwnProperty.call(byScope, scopeLabel)) {
      const scopeMap = byScope[scopeLabel];
      if (scopeMap && typeof scopeMap === "object" && Object.prototype.hasOwnProperty.call(scopeMap, nameUpper)) {
        return String(scopeMap[nameUpper] || "");
      }
    }

    const globalMap = registry.customGlobal && typeof registry.customGlobal === "object" ? registry.customGlobal : null;
    if (globalMap && Object.prototype.hasOwnProperty.call(globalMap, nameUpper)) {
      return String(globalMap[nameUpper] || "");
    }

    return "";
  }

  function getSourceDeclDesc(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }
    return decl.comment ? String(decl.comment) : "";
  }

  function normalizeDeclDescText(decl, text) {
    const settings = state.settings || DEFAULT_SETTINGS;
    if (!settings.normalizeDeclDesc) {
      return String(text || "").trim();
    }
    return normalizeDeclDescByTemplate(decl, text);
  }

  function stripDeclTemplateAffixes(text, template) {
    const raw = String(text || "").trim();
    if (!raw) {
      return "";
    }

    const tpl = String(template || "");
    const marker = "{{desc}}";
    const markerIndex = tpl.indexOf(marker);
    if (markerIndex === -1) {
      return raw;
    }

    const prefix = tpl.slice(0, markerIndex).trim();
    const suffix = tpl.slice(markerIndex + marker.length).trim();

    let next = raw;
    if (prefix && next.toLowerCase().startsWith(prefix.toLowerCase())) {
      next = next.slice(prefix.length).trim();
    }
    if (
      suffix &&
      next.length >= suffix.length &&
      next.toLowerCase().endsWith(suffix.toLowerCase())
    ) {
      next = next.slice(0, next.length - suffix.length).trim();
    }

    return next || raw;
  }

  function normalizeDeclDescByTemplate(decl, text) {
    const descTrimmed = String(text || "").trim();
    if (!descTrimmed) {
      return "";
    }

    const techName = getDeclTechName(decl);
    const bare = stripAngleBrackets(techName);
    if (bare.length < 3) {
      return descTrimmed;
    }

    const code = bare.slice(1, 3).toUpperCase();
    const settings = state.settings || DEFAULT_SETTINGS;
    const templates = settings.nameTemplatesByCode || DEFAULT_SETTINGS.nameTemplatesByCode;
    const template = templates && Object.prototype.hasOwnProperty.call(templates, code) ? String(templates[code] || "") : "";
    if (!template.trim()) {
      return descTrimmed;
    }

    const strippedKnownPrefix = stripDeclCategoryPrefix(descTrimmed);
    const normalizedDesc = stripDeclTemplateAffixes(strippedKnownPrefix, template);
    const normalized = template.replace(/\{\{desc\}\}/g, normalizedDesc).trim();
    return normalized || descTrimmed;
  }

  function getEffectiveDeclAtomicDesc(decl) {
    const override = getDeclOverrideDesc(decl);
    if (override) {
      return override;
    }

    const source = getSourceDeclDesc(decl);
    if (source) {
      return source;
    }

    return getBaseDeclDesc(decl);
  }

  function getEffectiveDeclAtomicDescNormalized(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const settings = state.settings || DEFAULT_SETTINGS;
    const normalizeEnabled = Boolean(settings.normalizeDeclDesc);

    const overrideEntry = getDeclOverrideEntry(decl);
    const overrideText = overrideEntry.text ? String(overrideEntry.text) : "";
    if (overrideText) {
      if (!normalizeEnabled || overrideEntry.noNormalize) {
        return overrideText;
      }
      return normalizeDeclDescText(decl, overrideText);
    }

    const source = getSourceDeclDesc(decl);
    if (source) {
      return normalizeEnabled ? normalizeDeclDescText(decl, source) : source;
    }

    const base = getBaseDeclDesc(decl);
    if (base) {
      return normalizeEnabled ? normalizeDeclDescText(decl, base) : base;
    }

    return String(getDeclTechName(decl) || "").trim();
  }

  function getFinalDeclAtomicDescNormalized(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const overrideEntry = getDeclOverrideEntry(decl);
    const overrideText = overrideEntry.text ? String(overrideEntry.text) : "";
    if (overrideText) {
      if (overrideEntry.noNormalize) {
        return overrideText;
      }
      return normalizeDeclDescByTemplate(decl, overrideText);
    }

    const codeDesc = getDeclCodeDesc(decl);
    if (codeDesc) {
      return normalizeDeclDescByTemplate(decl, codeDesc);
    }

    return String(getDeclTechName(decl) || "").trim();
  }

  function buildStructDeclFromFieldDecl(decl) {
    if (!decl || typeof decl !== "object") {
      return null;
    }

    if (!decl.scopeLabel || !decl.structName) {
      return null;
    }

    return {
      id: decl.structId || null,
      objectType: decl.structObjectType || decl.objectType || "STRUCT",
      name: String(decl.structName || ""),
      file: decl.file || "",
      lineStart: decl.structLineStart || null,
      raw: decl.structRaw || "",
      comment: decl.structComment || decl.structTypeComment || "",
      scopeId: decl.scopeId || 0,
      scopeLabel: decl.scopeLabel || "",
      scopeType: decl.scopeType || "",
      scopeName: decl.scopeName || ""
    };
  }

  function formatStructFieldDesc(decl) {
    if (!isStructFieldDecl(decl)) {
      return getEffectiveDeclAtomicDesc(decl);
    }

    const settings = state.settings || DEFAULT_SETTINGS;
    const template = settings.structDescTemplate || DEFAULT_SETTINGS.structDescTemplate;

    const structTech = String(decl.structName || "").trim() || getDeclTechName(decl);
    const itemTech = String(decl.fieldPath || "").trim() || (() => {
      const tech = getDeclTechName(decl);
      const structPrefix = String(decl.structName || "").trim();
      if (structPrefix && tech.toUpperCase().startsWith(`${structPrefix.toUpperCase()}-`)) {
        return tech.slice(structPrefix.length + 1);
      }
      return tech;
    })();

    const structDecl = buildStructDeclFromFieldDecl(decl);
    const structDescRaw = structDecl ? getEffectiveDeclAtomicDescNormalized(structDecl) : "";
    const itemDescRaw = getEffectiveDeclAtomicDescNormalized(decl);

    const structText = String(structDescRaw || "").trim() || structTech;
    const itemText = String(itemDescRaw || "").trim() || itemTech;

    return String(template || DEFAULT_SETTINGS.structDescTemplate)
      .replace(/\{\{struct\}\}/g, structText)
      .replace(/\{\{item\}\}/g, itemText);
  }

  function getEffectiveDeclDesc(decl) {
    if (isStructFieldDecl(decl)) {
      return formatStructFieldDesc(decl);
    }

    return getEffectiveDeclAtomicDescNormalized(decl);
  }

  function formatStructFieldFinalDesc(decl) {
    if (!isStructFieldDecl(decl)) {
      return getFinalDeclAtomicDescNormalized(decl);
    }

    const structDecl = buildStructDeclFromFieldDecl(decl);
    const structText = structDecl ? String(getFinalDeclAtomicDescNormalized(structDecl) || "").trim() : "";
    const itemText = String(getFinalDeclAtomicDescNormalized(decl) || "").trim();

    if (!structText && !itemText) {
      return "";
    }
    if (!structText) {
      return itemText;
    }
    if (!itemText) {
      return structText;
    }

    const settings = state.settings || DEFAULT_SETTINGS;
    const template = settings.structDescTemplate || DEFAULT_SETTINGS.structDescTemplate;
    return String(template || DEFAULT_SETTINGS.structDescTemplate)
      .replace(/\{\{struct\}\}/g, structText)
      .replace(/\{\{item\}\}/g, itemText);
  }

  function getFinalDeclDesc(decl) {
    if (isStructFieldDecl(decl)) {
      return formatStructFieldFinalDesc(decl);
    }
    return getFinalDeclAtomicDescNormalized(decl);
  }

  function openEditModal({ mode, key, structKey, itemKey, label, hint, initialValue, structValue, itemValue, skipNormalize }) {
    const editMode = mode === "structField" ? "structField" : "single";

    if (editMode === "single" && !key) {
      return;
    }

    if (editMode === "structField" && (!structKey || !itemKey)) {
      return;
    }

    if (!els.jsonModal.hidden) {
      closeJsonModal();
    }

    state.activeEdit = editMode === "structField"
      ? { mode: "structField", structKey, itemKey }
      : { mode: "single", key };
    els.editLabel.textContent = label ? String(label) : "";

    const hintText = hint ? String(hint) : "";
    els.editHint.textContent = hintText;
    els.editHint.style.display = hintText ? "block" : "none";

    if (els.editSingleWrap) {
      els.editSingleWrap.hidden = editMode !== "single";
    }
    if (els.editStructWrap) {
      els.editStructWrap.hidden = editMode !== "structField";
    }

    els.editDesc.value = "";
    if (els.editStructDesc) {
      els.editStructDesc.value = "";
    }
    if (els.editItemDesc) {
      els.editItemDesc.value = "";
    }
    if (els.editSkipNormalize) {
      els.editSkipNormalize.checked = Boolean(skipNormalize);
    }

    if (editMode === "single") {
      els.editDesc.value = initialValue ? String(initialValue) : "";
    } else {
      if (els.editStructDesc) {
        els.editStructDesc.value = structValue ? String(structValue) : "";
      }
      if (els.editItemDesc) {
        els.editItemDesc.value = itemValue ? String(itemValue) : "";
      }
    }

    els.editModal.hidden = false;
    setTimeout(() => {
      const target = editMode === "structField" && els.editStructDesc ? els.editStructDesc : els.editDesc;
      target.focus();
    }, 0);
  }

  function closeEditModal() {
    els.editModal.hidden = true;
    els.editDesc.value = "";
    if (els.editStructDesc) {
      els.editStructDesc.value = "";
    }
    if (els.editItemDesc) {
      els.editItemDesc.value = "";
    }
    if (els.editSkipNormalize) {
      els.editSkipNormalize.checked = false;
    }
    state.activeEdit = null;
  }

  function applyEditModal(action) {
    if (!state.activeEdit) {
      return;
    }

    const mode = state.activeEdit.mode === "structField" ? "structField" : "single";
    const skipNormalize = Boolean(els.editSkipNormalize && els.editSkipNormalize.checked);

    if (mode === "single") {
      const key = state.activeEdit.key;
      if (!key) {
        return;
      }

      const value = action === "clear" ? "" : String(els.editDesc.value || "");
      const trimmed = value.trim();
      const stored = skipNormalize ? trimmed : stripDeclCategoryPrefix(trimmed);

      if (!stored) {
        delete state.descOverrides[key];
      } else {
        state.descOverrides[key] = skipNormalize ? { text: stored, noNormalize: true } : stored;
      }
    } else {
      const structKey = state.activeEdit.structKey;
      const itemKey = state.activeEdit.itemKey;
      if (!structKey || !itemKey) {
        return;
      }

      const structValue = action === "clear" ? "" : String((els.editStructDesc && els.editStructDesc.value) || "");
      const itemValue = action === "clear" ? "" : String((els.editItemDesc && els.editItemDesc.value) || "");
      const structTrimmed = structValue.trim();
      const itemTrimmed = itemValue.trim();
      const structStored = stripDeclCategoryPrefix(structTrimmed);
      const itemStored = skipNormalize ? itemTrimmed : stripDeclCategoryPrefix(itemTrimmed);

      if (!structStored) {
        delete state.descOverrides[structKey];
      } else {
        state.descOverrides[structKey] = structStored;
      }

      if (!itemStored) {
        delete state.descOverrides[itemKey];
      } else {
        state.descOverrides[itemKey] = skipNormalize ? { text: itemStored, noNormalize: true } : itemStored;
      }
    }

    saveDescOverrides();
    state.haystackById = buildSearchIndex(state.renderObjects);
    renderOutput();
    if (state.rightTab === "descriptions") {
      renderDeclDescPanelUi();
    }
  }

  function editDeclDesc(decl) {
    if (!decl || !decl.name) {
      return;
    }

    const isStructField = isStructFieldDecl(decl);

    const key = getDeclOverrideStorageKey(decl);
    if (!key) {
      return;
    }

    const settings = state.settings || DEFAULT_SETTINGS;
    const normalizeEnabled = Boolean(settings.normalizeDeclDesc);

    const currentEntry = getDeclOverrideEntry(decl);
    const current = currentEntry.text ? String(currentEntry.text) : "";
    const effective = getEffectiveDeclDesc(decl);
    const currentDisplay = current
      ? (normalizeEnabled && !currentEntry.noNormalize ? normalizeDeclDescText(decl, current) : current)
      : "";
    const hintParts = [];
    hintParts.push(`Key: ${key}`);
    if (decl.scopeLabel) {
      hintParts.push(`Scope: ${decl.scopeLabel}`);
    }
    if (decl.objectType) {
      hintParts.push(`Type: ${decl.objectType}`);
    }
    if (decl.lineStart) {
      hintParts.push(`Line: ${decl.lineStart}`);
    }
    const base = getBaseDeclDesc(decl);
    const source = getSourceDeclDesc(decl);
    if (base) {
      hintParts.push(`Registry: ${base}`);
    }
    if (source) {
      hintParts.push(`Comment: ${source}`);
    }
    if (decl.raw) {
      hintParts.push(decl.raw);
    }

    if (!isStructField) {
      openEditModal({
        mode: "single",
        key,
        label: `${decl.objectType || "DECL"} ${getDeclTechName(decl)}`,
        hint: hintParts.join(" • "),
        initialValue: currentDisplay || effective,
        skipNormalize: Boolean(currentEntry.noNormalize)
      });
      return;
    }

    const structDecl = buildStructDeclFromFieldDecl(decl);
    const structKey = structDecl ? getDeclOverrideStorageKey(structDecl) : "";
    if (!structKey) {
      return;
    }

    const structCurrentEntry = structDecl ? getDeclOverrideEntry(structDecl) : { text: "", noNormalize: false };
    const structCurrent = structCurrentEntry.text ? String(structCurrentEntry.text) : "";
    const structEffective = structDecl ? getEffectiveDeclDesc(structDecl) : "";
    const structCurrentDisplay = structDecl && structCurrent && normalizeEnabled
      ? normalizeDeclDescText(structDecl, structCurrent)
      : structCurrent;

    hintParts.push(`StructKey: ${structKey}`);
    hintParts.push(`ItemKey: ${key}`);

    openEditModal({
      mode: "structField",
      structKey,
      itemKey: key,
      label: `${decl.objectType || "DECL"} ${getDeclTechName(decl)}`,
      hint: hintParts.join(" • "),
      structValue: structCurrentDisplay || structEffective,
      itemValue: currentDisplay || getEffectiveDeclAtomicDescNormalized(decl),
      skipNormalize: Boolean(currentEntry.noNormalize)
    });
  }

  function escapeSelectorValue(value) {
    const text = String(value || "");
    if (window.CSS && typeof window.CSS.escape === "function") {
      return window.CSS.escape(text);
    }
    return text.replace(/"/g, '\\"');
  }

  function safeJson(value, pretty) {
    try {
      return JSON.stringify(value, null, pretty ? 2 : 0);
    } catch {
      return "";
    }
  }

  function sanitizeXmlText(value) {
    const text = String(value ?? "");
    // Keep: TAB (0x9), LF (0xA), CR (0xD)
    return text.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F]/g, "");
  }

  function escapeXmlText(value) {
    return sanitizeXmlText(value)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&apos;");
  }

  function toXmlTagName(key) {
    const raw = String(key || "").trim();
    if (!raw) {
      return "value";
    }

    const normalized = raw.replace(/[^A-Za-z0-9_:-]/g, "_");
    if (!/^[A-Za-z_]/.test(normalized)) {
      return `_${normalized}`;
    }
    return normalized;
  }

  function getArrayItemTagName(keyHint) {
    const key = String(keyHint || "").trim().toLowerCase();
    if (key === "objects" || key === "children") {
      return "object";
    }
    return "item";
  }

  function isPlainObjectRecord(value) {
    return Boolean(value) && typeof value === "object" && !Array.isArray(value);
  }

  function isAbapStatementObject(value) {
    if (!isPlainObjectRecord(value)) {
      return false;
    }
    const hasNodeShape = Object.prototype.hasOwnProperty.call(value, "values")
      || Object.prototype.hasOwnProperty.call(value, "extras")
      || Object.prototype.hasOwnProperty.call(value, "children");
    if (!hasNodeShape) {
      return false;
    }
    return (
      Object.prototype.hasOwnProperty.call(value, "objectType")
      && Object.prototype.hasOwnProperty.call(value, "raw")
      && Object.prototype.hasOwnProperty.call(value, "lineStart")
    );
  }

  function extractIdentifierCandidate(text) {
    const raw = String(text || "").trim();
    if (!raw) {
      return "";
    }
    if (raw.startsWith("'") || raw.startsWith("|")) {
      return "";
    }
    if (/^[+-]?\d/.test(raw)) {
      return "";
    }

    const sysMatch = raw.match(/^SY-[A-Za-z_][A-Za-z0-9_]*/i);
    if (sysMatch) {
      return sysMatch[0].toUpperCase();
    }

    const fieldPathMatch = raw.match(
      /^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(?:(?:->|=>|~|-)[A-Za-z_][A-Za-z0-9_]*)+/
    );
    if (fieldPathMatch) {
      return String(fieldPathMatch[0] || "").trim();
    }

    const inlinePatterns = [
      /@?DATA\s*\(\s*([^)]+)\s*\)/i,
      /@?FINAL\s*\(\s*([^)]+)\s*\)/i,
      /FIELD-SYMBOL\s*\(\s*(<[^>]+>)\s*\)/i
    ];
    for (const regex of inlinePatterns) {
      const match = regex.exec(raw);
      if (!match || !match[1]) {
        continue;
      }
      const candidate = String(match[1] || "").trim();
      if (candidate) {
        return candidate;
      }
    }

    const genericMatch = raw.match(
      /<[^>]+>|[A-Za-z_][A-Za-z0-9_]*(?:(?:->|=>|~|-)[A-Za-z_][A-Za-z0-9_]*)*/
    );
    return genericMatch ? String(genericMatch[0] || "").trim() : "";
  }

  function resolveFallbackFieldId(entry) {
    if (!isPlainObjectRecord(entry)) {
      return "";
    }

    const fromDeclRef = String(entry.declRef || "").trim();
    if (fromDeclRef) {
      return fromDeclRef;
    }

    const valueText = String(entry.value || "").trim();
    const identifier = extractIdentifierCandidate(valueText);
    if (identifier) {
      return identifier;
    }

    if (valueText) {
      return valueText;
    }

    const fromName = String(entry.name || "").trim();
    if (fromName) {
      return fromName;
    }

    return "";
  }

  function buildPathKeyFromParts(parts) {
    const tokens = Array.isArray(parts) ? parts : [];
    const cleaned = [];
    for (const part of tokens) {
      const token = String(part || "").trim();
      if (token) {
        cleaned.push(token);
      }
    }
    return cleaned.join("/");
  }

  function normalizeSyntheticPathKey(pathKey) {
    const text = String(pathKey || "").trim();
    if (!text) {
      return "ROOT";
    }
    const normalized = text
      .replace(/\s+/g, "_")
      .replace(/[^A-Za-z0-9_:\-./[\]#]/g, "_")
      .toUpperCase();
    return normalized || "ROOT";
  }

  function buildSyntheticDeclForPath({ pathKey, fieldId, file, lineStart, raw, role }) {
    const name = String(fieldId || "").trim();
    if (!name) {
      return null;
    }

    const numericLine = lineStart === null || lineStart === undefined || lineStart === ""
      ? null
      : (Number(lineStart) || null);

    const normalizedPath = normalizeSyntheticPathKey(pathKey);
    return {
      id: null,
      objectType: "PATH_DECL",
      name,
      file: String(file || ""),
      lineStart: numericLine,
      raw: String(raw || ""),
      comment: "",
      scopeId: 0,
      scopeLabel: `PATH:${normalizedPath}`,
      scopeType: "PATH",
      scopeName: String(role || "")
    };
  }

  function getDeclSourceContextFromObject(obj) {
    if (!isPlainObjectRecord(obj)) {
      return { file: "", lineStart: null, raw: "" };
    }
    return {
      file: String(obj.file || ""),
      lineStart: obj.lineStart === null || obj.lineStart === undefined
        ? null
        : (Number(obj.lineStart) || null),
      raw: String(obj.raw || "")
    };
  }

  function buildObjectPathBase(obj) {
    const id = normalizeId(obj && obj.id);
    if (id) {
      return `OBJECT:${id}`;
    }
    const type = String(obj && obj.objectType ? obj.objectType : "OBJECT").trim() || "OBJECT";
    const file = String(obj && obj.file ? obj.file : "").trim() || "NO_FILE";
    const line = obj && obj.lineStart ? String(obj.lineStart) : "0";
    return `OBJECT:${type}:${file}:${line}`;
  }

  function hasAnyDecls(list) {
    if (!Array.isArray(list)) {
      return false;
    }
    return list.some((item) => item && typeof item === "object");
  }

  function ensureEntryDeclWithSynthetic(entry, options) {
    if (!isPlainObjectRecord(entry)) {
      return entry;
    }
    if (isDeclLikeObject(entry.decl)) {
      return entry;
    }

    const fieldId = resolveFallbackFieldId(entry);
    const pathKey = buildPathKeyFromParts([options && options.pathKey ? options.pathKey : "", "decl"]);
    const syntheticDecl = buildSyntheticDeclForPath({
      pathKey,
      fieldId,
      file: options && options.file ? options.file : "",
      lineStart: options ? options.lineStart : null,
      raw: options && options.raw ? options.raw : "",
      role: options && options.role ? options.role : "value"
    });
    if (!syntheticDecl) {
      return entry;
    }

    const next = { ...entry, decl: syntheticDecl };
    if (!String(next.declRef || "").trim()) {
      next.declRef = fieldId;
    }
    return next;
  }

  function ensureValueDeclWithSynthetic(entry, options) {
    if (!isPlainObjectRecord(entry)) {
      return entry;
    }
    if (isDeclLikeObject(entry.valueDecl) || hasAnyDecls(entry.originDecls)) {
      return entry;
    }

    const sourceForId = {
      declRef: String(entry.valueRef || entry.declRef || "").trim(),
      value: entry.value,
      name: entry.name || (options && options.nameHint ? options.nameHint : "")
    };
    const fieldId = resolveFallbackFieldId(sourceForId);
    const pathKey = buildPathKeyFromParts([options && options.pathKey ? options.pathKey : "", "valueDecl"]);
    const syntheticDecl = buildSyntheticDeclForPath({
      pathKey,
      fieldId,
      file: options && options.file ? options.file : "",
      lineStart: options ? options.lineStart : null,
      raw: options && options.raw ? options.raw : "",
      role: options && options.role ? options.role : "value"
    });
    if (!syntheticDecl) {
      return entry;
    }

    return {
      ...entry,
      valueDecl: syntheticDecl
    };
  }

  function ensureConditionClauseDeclsWithSynthetic(clause, options) {
    if (!isPlainObjectRecord(clause)) {
      return clause;
    }

    let next = clause;
    const file = options && options.file ? options.file : "";
    const lineStart = options ? options.lineStart : null;
    const raw = options && options.raw ? options.raw : "";
    const basePath = options && options.pathKey ? options.pathKey : "";

    if (!isDeclLikeObject(clause.leftOperandDecl)) {
      const leftFieldId = resolveFallbackFieldId({
        declRef: clause.leftOperandRef,
        value: clause.leftOperand,
        name: "leftOperand"
      });
      const leftDecl = buildSyntheticDeclForPath({
        pathKey: buildPathKeyFromParts([basePath, "leftOperandDecl"]),
        fieldId: leftFieldId,
        file,
        lineStart,
        raw,
        role: "leftOperand"
      });
      if (leftDecl) {
        if (next === clause) {
          next = { ...clause };
        }
        next.leftOperandDecl = leftDecl;
        if (!String(next.leftOperandRef || "").trim()) {
          next.leftOperandRef = leftFieldId;
        }
      }
    }

    if (!isDeclLikeObject(clause.rightOperandDecl)) {
      const rightFieldId = resolveFallbackFieldId({
        declRef: clause.rightOperandRef,
        value: clause.rightOperand,
        name: "rightOperand"
      });
      const rightDecl = buildSyntheticDeclForPath({
        pathKey: buildPathKeyFromParts([basePath, "rightOperandDecl"]),
        fieldId: rightFieldId,
        file,
        lineStart,
        raw,
        role: "rightOperand"
      });
      if (rightDecl) {
        if (next === clause) {
          next = { ...clause };
        }
        next.rightOperandDecl = rightDecl;
        if (!String(next.rightOperandRef || "").trim()) {
          next.rightOperandRef = rightFieldId;
        }
      }
    }

    return next;
  }

  function normalizeXmlObjectId(value) {
    if (value === null || value === undefined) {
      return "";
    }
    return String(value);
  }

  function getFormNameFromNode(node) {
    if (!node || typeof node !== "object") {
      return "";
    }
    const valueName = getFirstValueFromValues(node.values, "name");
    const extrasName = node.extras && node.extras.form && node.extras.form.name
      ? String(node.extras.form.name)
      : "";
    return String(valueName || extrasName || "").trim();
  }

  function getPerformFormNameFromNode(node) {
    if (!node || typeof node !== "object") {
      return "";
    }
    const extrasName = node.extras && node.extras.performCall && node.extras.performCall.form
      ? String(node.extras.performCall.form)
      : "";
    const valueName = getFirstValueFromValues(node.values, "form");
    return String(extrasName || valueName || "").trim();
  }

  function getPerformProgramFromNode(node) {
    if (!node || typeof node !== "object") {
      return "";
    }
    const extrasProgram = node.extras && node.extras.performCall && node.extras.performCall.program
      ? String(node.extras.performCall.program)
      : "";
    const valueProgram = getFirstValueFromValues(node.values, "program");
    return String(extrasProgram || valueProgram || "").trim();
  }

  function buildFormsByNameUpperFromRoots(rawRoots) {
    const map = new Map();
    walkObjects(rawRoots, (obj) => {
      if (!obj || obj.objectType !== "FORM") {
        return;
      }
      const name = getFormNameFromNode(obj);
      if (!name) {
        return;
      }
      const upper = name.toUpperCase();
      if (!map.has(upper)) {
        map.set(upper, obj);
      }
    });
    return map;
  }

  function buildRenderableObjects(rawRoots, options) {
    const roots = Array.isArray(rawRoots) ? rawRoots : [];
    if (!roots.length) {
      return [];
    }

    const opts = {
      expandPerformForms: true,
      hideFormRoots: true,
      maxExpandDepth: Number.POSITIVE_INFINITY,
      ...(options && typeof options === "object" ? options : {})
    };
    const maxExpandDepth = Math.max(0, Number(opts.maxExpandDepth) || 0);
    const formsByNameUpper = opts.expandPerformForms ? buildFormsByNameUpperFromRoots(roots) : new Map();

    const cloneNode = (sourceNode, parentId, expandDepth, pathToken, forceSyntheticId, formCallStack) => {
      if (!sourceNode || typeof sourceNode !== "object") {
        return null;
      }

      if (opts.hideFormRoots && sourceNode.objectType === "FORM" && !forceSyntheticId) {
        return null;
      }

      const out = {};
      for (const key of Object.keys(sourceNode)) {
        if (key === "children") {
          continue;
        }
        out[key] = sourceNode[key];
      }

      if (forceSyntheticId) {
        out.id = `PERFORM_EXPANDED:${pathToken}`;
      }

      if (parentId !== undefined) {
        out.parent = parentId;
      }

      const ownId = out.id !== null && out.id !== undefined && String(out.id).trim() ? out.id : undefined;
      const outChildren = [];

      const sourceChildren = Array.isArray(sourceNode.children) ? sourceNode.children : [];
      for (let index = 0; index < sourceChildren.length; index += 1) {
        const child = sourceChildren[index];
        const childPath = `${pathToken}.C${index}`;
        const clonedChild = cloneNode(child, ownId, expandDepth, childPath, forceSyntheticId, formCallStack);
        if (clonedChild) {
          outChildren.push(clonedChild);
        }
      }

      if (
        opts.expandPerformForms &&
        sourceNode.objectType === "PERFORM" &&
        expandDepth < maxExpandDepth
      ) {
        const formName = getPerformFormNameFromNode(sourceNode);
        const programName = getPerformProgramFromNode(sourceNode);
        const formNameUpper = formName ? formName.toUpperCase() : "";
        const resolvedForm = !programName && formNameUpper ? formsByNameUpper.get(formNameUpper) : null;
        const isRecursiveCall = Boolean(formNameUpper) && Array.isArray(formCallStack) && formCallStack.includes(formNameUpper);

        if (resolvedForm && !isRecursiveCall) {
          const nextFormCallStack = formNameUpper
            ? [...(Array.isArray(formCallStack) ? formCallStack : []), formNameUpper]
            : (Array.isArray(formCallStack) ? formCallStack.slice() : []);
          const formChildren = Array.isArray(resolvedForm.children) ? resolvedForm.children : [];
          for (let index = 0; index < formChildren.length; index += 1) {
            const formChild = formChildren[index];
            const expandedPath = `${pathToken}.FORM:${formNameUpper}.C${index}`;
            const clonedExpandedChild = cloneNode(formChild, ownId, expandDepth + 1, expandedPath, true, nextFormCallStack);
            if (clonedExpandedChild) {
              outChildren.push(clonedExpandedChild);
            }
          }
        }
      }

      if (outChildren.length) {
        out.children = outChildren;
      } else if (Array.isArray(sourceNode.children)) {
        out.children = [];
      }

      return out;
    };

    const output = [];
    for (let index = 0; index < roots.length; index += 1) {
      const root = roots[index];
      const clonedRoot = cloneNode(root, null, 0, `ROOT${index}`, false, []);
      if (clonedRoot) {
        output.push(clonedRoot);
      }
    }

    return output;
  }

  function buildXmlExportRoots(objects) {
    const input = Array.isArray(objects) ? objects : [];
    if (!input.length) {
      return [];
    }

    const nodeById = new Map();
    const idOrder = [];
    const childIdsByParentId = new Map();
    const topLevelNoIdNodes = [];

    const pushChildId = (parentId, childId) => {
      if (!parentId || !childId) {
        return;
      }
      if (!childIdsByParentId.has(parentId)) {
        childIdsByParentId.set(parentId, []);
      }
      const list = childIdsByParentId.get(parentId);
      if (!list.includes(childId)) {
        list.push(childId);
      }
    };

    const stack = input
      .filter((node) => node && typeof node === "object")
      .map((node) => ({ node, isTopLevel: true }));

    while (stack.length) {
      const item = stack.pop();
      const node = item && item.node;
      if (!node || typeof node !== "object") {
        continue;
      }

      const nodeId = normalizeXmlObjectId(node.id);
      if (!nodeId) {
        if (item.isTopLevel) {
          topLevelNoIdNodes.push(node);
        }
      } else if (!nodeById.has(nodeId)) {
        nodeById.set(nodeId, node);
        idOrder.push(nodeId);
      }

      const parentId = normalizeXmlObjectId(node.parent);
      if (nodeId && parentId) {
        pushChildId(parentId, nodeId);
      }

      const children = Array.isArray(node.children) ? node.children : [];
      for (let index = children.length - 1; index >= 0; index -= 1) {
        const child = children[index];
        if (!child || typeof child !== "object") {
          continue;
        }
        const childId = normalizeXmlObjectId(child.id);
        if (nodeId && childId) {
          pushChildId(nodeId, childId);
        }
        stack.push({ node: child, isTopLevel: false });
      }
    }

    if (!nodeById.size) {
      return input.slice();
    }

    const cloneNodeNoId = (node, seenNoId) => {
      if (!node || typeof node !== "object") {
        return node;
      }
      if (seenNoId.has(node)) {
        return null;
      }

      const nextSeenNoId = new Set(seenNoId);
      nextSeenNoId.add(node);

      const out = {};
      for (const key of Object.keys(node)) {
        if (key === "children") {
          continue;
        }
        out[key] = node[key];
      }

      const children = Array.isArray(node.children) ? node.children : [];
      const outChildren = [];
      for (const child of children) {
        if (!child || typeof child !== "object") {
          continue;
        }
        const childId = normalizeXmlObjectId(child.id);
        if (childId) {
          // ID-based children are wired later from parent map.
          continue;
        }
        const cloned = cloneNodeNoId(child, nextSeenNoId);
        if (cloned) {
          outChildren.push(cloned);
        }
      }

      if (outChildren.length) {
        out.children = outChildren;
      } else if (Array.isArray(node.children) && node.children.length === 0) {
        out.children = [];
      }

      return out;
    };

    const cloneNodeById = (nodeId, ancestorIds, emittedIds) => {
      if (!nodeId || !nodeById.has(nodeId)) {
        return null;
      }
      if (ancestorIds.has(nodeId)) {
        return null;
      }
      if (emittedIds && emittedIds.has(nodeId)) {
        return null;
      }

      const node = nodeById.get(nodeId);
      const nextAncestors = new Set(ancestorIds);
      nextAncestors.add(nodeId);
      if (emittedIds) {
        emittedIds.add(nodeId);
      }

      const out = {};
      for (const key of Object.keys(node)) {
        if (key === "children") {
          continue;
        }
        out[key] = node[key];
      }

      const outChildren = [];

      const explicitChildren = Array.isArray(node.children) ? node.children : [];
      for (const child of explicitChildren) {
        if (!child || typeof child !== "object") {
          continue;
        }
        const childId = normalizeXmlObjectId(child.id);
        if (childId) {
          continue;
        }
        const clonedNoId = cloneNodeNoId(child, new Set());
        if (clonedNoId) {
          outChildren.push(clonedNoId);
        }
      }

      const childIds = childIdsByParentId.get(nodeId) || [];
      for (const childId of childIds) {
        const cloned = cloneNodeById(childId, nextAncestors, emittedIds);
        if (cloned) {
          outChildren.push(cloned);
        }
      }

      if (outChildren.length) {
        out.children = outChildren;
      } else if (Array.isArray(node.children) && node.children.length === 0) {
        out.children = [];
      }

      return out;
    };

    const isRootId = (nodeId) => {
      const node = nodeById.get(nodeId);
      if (!node) {
        return false;
      }
      const parentId = normalizeXmlObjectId(node.parent);
      return !parentId || !nodeById.has(parentId);
    };

    const rootIds = [];
    const addedRootIds = new Set();
    const addRootId = (nodeId) => {
      if (!nodeId || addedRootIds.has(nodeId) || !nodeById.has(nodeId)) {
        return;
      }
      addedRootIds.add(nodeId);
      rootIds.push(nodeId);
    };

    for (const topNode of input) {
      const topId = normalizeXmlObjectId(topNode && topNode.id);
      if (topId && isRootId(topId)) {
        addRootId(topId);
      }
    }

    for (const nodeId of idOrder) {
      if (isRootId(nodeId)) {
        addRootId(nodeId);
      }
    }

    const reachableIds = new Set();
    const markReachable = (nodeId) => {
      if (!nodeId || reachableIds.has(nodeId) || !nodeById.has(nodeId)) {
        return;
      }
      reachableIds.add(nodeId);
      const childIds = childIdsByParentId.get(nodeId) || [];
      for (const childId of childIds) {
        markReachable(childId);
      }
    };

    for (const rootId of rootIds) {
      markReachable(rootId);
    }

    for (const nodeId of idOrder) {
      if (!reachableIds.has(nodeId)) {
        addRootId(nodeId);
        markReachable(nodeId);
      }
    }

    const roots = [];
    const emittedIds = new Set();
    for (const node of topLevelNoIdNodes) {
      const cloned = cloneNodeNoId(node, new Set());
      if (cloned) {
        roots.push(cloned);
      }
    }
    for (const rootId of rootIds) {
      const cloned = cloneNodeById(rootId, new Set(), emittedIds);
      if (cloned) {
        roots.push(cloned);
      }
    }

    return roots;
  }

  function isDeclLikeObject(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    return (
      typeof value.objectType === "string" &&
      typeof value.name === "string" &&
      typeof value.scopeLabel === "string"
    );
  }

  function isDeclHintKey(keyHint) {
    const key = String(keyHint || "").trim();
    if (!key) {
      return false;
    }
    return /decl$/i.test(key);
  }

  function isDeclObjectForXml(keyHint, value) {
    if (isDeclLikeObject(value)) {
      return true;
    }
    if (!isDeclHintKey(keyHint) || !value || typeof value !== "object" || Array.isArray(value)) {
      return false;
    }
    return (
      typeof value.name === "string" ||
      typeof value.objectType === "string" ||
      typeof value.scopeLabel === "string" ||
      typeof value.comment === "string"
    );
  }

  function hasValueLevelDescFields(value) {
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      return false;
    }
    return (
      Object.prototype.hasOwnProperty.call(value, "userDesc") ||
      Object.prototype.hasOwnProperty.call(value, "codeDesc")
    );
  }

  function resolveValueLevelTechId(value) {
    if (!value || typeof value !== "object") {
      return "";
    }

    if (isDeclLikeObject(value.decl)) {
      const declTech = String(getDeclTechName(value.decl) || "").trim();
      if (declTech) {
        return declTech;
      }
    }

    const declRef = String(value.declRef || "").trim();
    if (declRef) {
      return declRef;
    }

    const identifier = extractIdentifierCandidate(value.value);
    if (identifier) {
      return identifier;
    }

    const rawValue = String(value.value || "").trim();
    if (rawValue) {
      return rawValue;
    }

    const fallbackName = String(value.name || "").trim();
    return fallbackName;
  }

  function resolveValueLevelFinalDesc(value) {
    if (!value || typeof value !== "object") {
      return "";
    }

    const userDesc = String(value.userDesc || "").trim();
    if (userDesc) {
      return userDesc;
    }

    const codeDesc = String(value.codeDesc || "").trim();
    if (codeDesc) {
      return codeDesc;
    }

    return resolveValueLevelTechId(value);
  }

window.AbapViewerModules.factories = window.AbapViewerModules.factories || {};
window.AbapViewerModules.factories["02-descriptions"] = function registerDescriptions(runtime) {
  const targetRuntime = runtime || (window.AbapViewerRuntime = window.AbapViewerRuntime || {});
  targetRuntime.api = targetRuntime.api || {};
  targetRuntime.api.renderDeclDescPanelUi = renderDeclDescPanelUi;
  targetRuntime.api.getFinalDeclDesc = getFinalDeclDesc;
  targetRuntime.api.getEffectiveDeclDesc = getEffectiveDeclDesc;
  targetRuntime.api.resolveValueLevelFinalDesc = resolveValueLevelFinalDesc;
  window.AbapViewerModules.parts["02-descriptions"] = true;
};
window.AbapViewerModules.factories["02-descriptions"](window.AbapViewerRuntime);
</script>
  <script>
// inlined from: ./app/03-template-preview.js
"use strict";

window.AbapViewerModules = window.AbapViewerModules || {};
window.AbapViewerModules.parts = window.AbapViewerModules.parts || {};

  function toInlineCssText(styleMap) {
    if (!styleMap || typeof styleMap !== "object") {
      return "";
    }
    const entries = [];
    for (const [key, value] of Object.entries(styleMap)) {
      const cssKey = String(key || "").trim();
      const cssValue = String(value || "").trim();
      if (!cssKey || !cssValue) {
        continue;
      }
      entries.push(`${cssKey}:${cssValue}`);
    }
    return entries.join(";");
  }

  function normalizeTemplateColorValue(value) {
    const raw = String(value || "").trim();
    if (!raw) {
      return "";
    }

    const alias = normalizeTemplateAliasToken(raw);
    if (!alias || alias === "default") {
      return "";
    }
    if (alias === "mau xanh nhat") {
      return "#dbeef4";
    }
    if (alias === "den") {
      return "#000000";
    }
    return raw;
  }

  function normalizeTemplateBorderValue(value) {
    const raw = String(value || "").trim();
    if (!raw) {
      return "";
    }

    const alias = normalizeTemplateAliasToken(raw);
    if (!alias || alias === "default") {
      return "";
    }
    if (alias === "outside line mong") {
      return "outside-thin";
    }
    return raw;
  }

  function normalizeTemplateAlignValue(value) {
    const alias = normalizeTemplateAliasToken(value);
    if (!alias || alias === "default") {
      return "";
    }
    if (alias === "left" || alias === "center" || alias === "right") {
      return alias;
    }
    return "";
  }

  function normalizeTemplateVAlignValue(value) {
    const alias = normalizeTemplateAliasToken(value);
    if (!alias || alias === "default") {
      return "";
    }
    if (alias === "top") {
      return "top";
    }
    if (alias === "middle" || alias === "center") {
      return "middle";
    }
    if (alias === "bottom") {
      return "bottom";
    }
    return "";
  }

  function parseTemplatePathSegments(pathExpression) {
    const raw = String(pathExpression || "").trim();
    if (!raw) {
      return [];
    }

    const segments = [];
    let token = "";
    let index = 0;

    const pushToken = () => {
      const trimmed = token.trim();
      if (trimmed) {
        segments.push(trimmed);
      }
      token = "";
    };

    while (index < raw.length) {
      const ch = raw[index];
      if (ch === ".") {
        pushToken();
        index += 1;
        continue;
      }

      if (ch === "[") {
        pushToken();
        const close = raw.indexOf("]", index + 1);
        if (close === -1) {
          return null;
        }
        const inside = raw.slice(index + 1, close).trim();
        if (!/^\d+$/.test(inside)) {
          return null;
        }
        segments.push(Number(inside));
        index = close + 1;
        continue;
      }

      token += ch;
      index += 1;
    }

    pushToken();
    return segments;
  }

  function resolveTemplatePathValue(root, pathExpression) {
    const segments = parseTemplatePathSegments(pathExpression);
    if (!segments) {
      return undefined;
    }

    let current = root;
    for (const segment of segments) {
      if (typeof segment === "number") {
        if (!Array.isArray(current)) {
          return undefined;
        }
        current = current[segment];
        continue;
      }

      const key = String(segment || "").trim();
      if (!key) {
        continue;
      }

      if (Array.isArray(current)) {
        const projected = [];
        for (const item of current) {
          if (!item || typeof item !== "object") {
            continue;
          }

          const keyLower = key.toLowerCase();
          if (keyLower === "desc" && isDeclLikeObject(item)) {
            projected.push(getEffectiveDeclDesc(item));
            continue;
          }

          if (keyLower === "finaldesc") {
            if (isDeclLikeObject(item)) {
              projected.push(getFinalDeclDesc(item));
              continue;
            }
            if (hasValueLevelDescFields(item) || isDeclLikeObject(item.decl)) {
              projected.push(resolveValueLevelFinalDesc(item));
              continue;
            }
          }

          if (Object.prototype.hasOwnProperty.call(item, key)) {
            projected.push(item[key]);
          }
        }
        if (!projected.length) {
          return undefined;
        }
        current = projected;
        continue;
      }

      if (!current || typeof current !== "object") {
        return undefined;
      }

      const keyLower = key.toLowerCase();
      if (keyLower === "desc" && isDeclLikeObject(current)) {
        return getEffectiveDeclDesc(current);
      }

      if (keyLower === "finaldesc") {
        if (isDeclLikeObject(current)) {
          return getFinalDeclDesc(current);
        }
        if (hasValueLevelDescFields(current) || isDeclLikeObject(current.decl)) {
          return resolveValueLevelFinalDesc(current);
        }
      }

      if (!Object.prototype.hasOwnProperty.call(current, key)) {
        return undefined;
      }
      current = current[key];
    }

    return current;
  }

  function buildTemplatePathCandidates(tokenExpression) {
    const raw = String(tokenExpression || "").trim();
    if (!raw) {
      return [];
    }

    const candidates = new Set();
    candidates.add(raw);

    if (/^keyword\./i.test(raw)) {
      candidates.add(`keywords.${raw.slice("keyword.".length)}`);
    }

    return Array.from(candidates);
  }

  function getTemplateArrayItemTagName(keyHint) {
    if (typeof getArrayItemTagName === "function") {
      return getArrayItemTagName(keyHint);
    }
    const key = String(keyHint || "").trim().toLowerCase();
    if (key === "objects" || key === "children") {
      return "object";
    }
    return "item";
  }

  function normalizeTemplateEntryForPath(value, keyHint, pathParts, ownerContext) {
    if (typeof normalizeEntryObjectForXml !== "function") {
      return value;
    }
    try {
      return normalizeEntryObjectForXml(value, keyHint, pathParts, ownerContext);
    } catch {
      return value;
    }
  }

  function buildTemplateContextObject(obj, objectIndexOneBased) {
    const objectIndex = Number(objectIndexOneBased) || 1;
    const basePathParts = ["objects", `object[${objectIndex}]`];

    const cloneRecursive = (value, keyHint, pathParts, ownerContext) => {
      if (value === null || value === undefined) {
        return value;
      }
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return value;
      }

      if (Array.isArray(value)) {
        const itemTag = getTemplateArrayItemTagName(keyHint);
        return value.map((item, index) => cloneRecursive(
          item,
          itemTag,
          pathParts.concat(`${itemTag}[${index + 1}]`),
          ownerContext
        ));
      }

      if (typeof value !== "object") {
        return value;
      }

      const nextOwnerContext = (typeof isAbapStatementObject === "function" && isAbapStatementObject(value))
        ? value
        : ownerContext;
      const normalized = normalizeTemplateEntryForPath(value, keyHint, pathParts, nextOwnerContext);
      if (!normalized || typeof normalized !== "object") {
        return normalized;
      }

      const out = {};
      for (const key of Object.keys(normalized)) {
        out[key] = cloneRecursive(
          normalized[key],
          key,
          pathParts.concat(key),
          nextOwnerContext
        );
      }
      return out;
    };

    return cloneRecursive(obj, "object", basePathParts, obj);
  }

  function stringifyTemplateResolvedValue(value) {
    if (value === undefined || value === null) {
      return "";
    }
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      return String(value);
    }
    if (Array.isArray(value)) {
      return value
        .map((item) => stringifyTemplateResolvedValue(item))
        .filter((text) => text !== "")
        .join("\n");
    }
    if (isDeclLikeObject(value)) {
      return getDeclDisplayName(value) || getDeclTechName(value);
    }
    if (typeof value === "object") {
      if (hasValueLevelDescFields(value) || isDeclLikeObject(value.decl)) {
        const finalDesc = resolveValueLevelFinalDesc(value);
        if (finalDesc) {
          return finalDesc;
        }
      }
      return safeJson(value, false);
    }
    return String(value);
  }

  function collectTemplateDumpPaths(root) {
    const out = new Set();

    const walk = (value, path) => {
      if (path) {
        out.add(path);
      }
      if (value === null || value === undefined) {
        return;
      }

      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i += 1) {
          const nextPath = path ? `${path}[${i}]` : `[${i}]`;
          walk(value[i], nextPath);
        }
        return;
      }

      if (typeof value !== "object") {
        return;
      }

      if (path && isDeclLikeObject(value)) {
        out.add(`${path}.desc`);
        out.add(`${path}.finalDesc`);
      }
      if (path && (hasValueLevelDescFields(value) || isDeclLikeObject(value.decl))) {
        out.add(`${path}.finalDesc`);
      }

      for (const key of Object.keys(value)) {
        const nextPath = path ? `${path}.${key}` : key;
        walk(value[key], nextPath);
      }
    };

    walk(root, "");
    return Array.from(out).sort((a, b) => a.localeCompare(b));
  }

  function formatTemplateDumpValue(value) {
    if (value === undefined || value === null) {
      return "";
    }
    const text = String(value);
    return text
      .replace(/\r\n/g, "\\n")
      .replace(/\r/g, "\\n")
      .replace(/\n/g, "\\n");
  }

  function collectTemplateDumpPathValues(root) {
    const out = new Map();

    const addEntry = (path, value) => {
      const key = String(path || "").trim();
      if (!key || out.has(key)) {
        return;
      }
      out.set(key, formatTemplateDumpValue(value));
    };

    const walk = (value, path) => {
      const currentPath = String(path || "");
      if (value === undefined) {
        return;
      }

      if (value === null) {
        if (currentPath) {
          addEntry(currentPath, "");
        }
        return;
      }

      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        if (currentPath) {
          addEntry(currentPath, value);
        }
        return;
      }

      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i += 1) {
          const nextPath = currentPath ? `${currentPath}[${i}]` : `[${i}]`;
          walk(value[i], nextPath);
        }
        return;
      }

      if (typeof value !== "object") {
        if (currentPath) {
          addEntry(currentPath, String(value));
        }
        return;
      }

      if (currentPath && isDeclLikeObject(value)) {
        addEntry(`${currentPath}.desc`, getEffectiveDeclDesc(value));
        addEntry(`${currentPath}.finalDesc`, getFinalDeclDesc(value));
      }
      if (currentPath && (hasValueLevelDescFields(value) || isDeclLikeObject(value.decl))) {
        addEntry(`${currentPath}.finalDesc`, resolveValueLevelFinalDesc(value));
      }

      const keys = Object.keys(value);
      keys.sort((a, b) => a.localeCompare(b));
      for (const key of keys) {
        const nextPath = currentPath ? `${currentPath}.${key}` : key;
        walk(value[key], nextPath);
      }
    };

    walk(root, "");
    return Array.from(out.entries()).map(([path, value]) => `${path} = ${value}`);
  }

  function openTemplatePathDump(contextObj, index, obj) {
    const lines = collectTemplateDumpPathValues(contextObj);
    const fallback = collectTemplateDumpPaths(contextObj).map((path) => `${path} =`);
    const dumpText = (lines.length ? lines : fallback).join("\n");
    const objectType = obj && obj.objectType ? String(obj.objectType) : "OBJECT";
    const title = `Template Paths #${Number(index) + 1} ${objectType}`;

    if (typeof openTextModal === "function") {
      openTextModal(title, dumpText || "[No paths]");
      return;
    }

    if (typeof setError === "function") {
      setError("Path viewer is unavailable.");
    }
  }

  function resolveTemplatePlaceholderValue(obj, tokenExpression) {
    const token = String(tokenExpression || "").trim();
    if (!token) {
      return "";
    }

    if (token === "__DUMP__") {
      return collectTemplateDumpPaths(obj).join("\n");
    }
    if (token === "__DUMP_VALUES__" || token === "__DUMP_WITH_VALUES__") {
      return collectTemplateDumpPathValues(obj).join("\n");
    }

    const candidates = buildTemplatePathCandidates(token);

    for (const candidate of candidates) {
      const value = resolveTemplatePathValue(obj, candidate);
      if (value !== undefined) {
        return value;
      }
    }

    return "";
  }

  function resolveTemplateText(rawText, obj) {
    const templateText = String(rawText === undefined || rawText === null ? "" : rawText);
    if (!templateText.includes("{")) {
      return {
        text: templateText,
        hasPlaceholder: false,
        hasTokenValue: false
      };
    }

    let hasPlaceholder = false;
    let hasTokenValue = false;
    const text = templateText.replace(/\{([^{}]+)\}/g, (full, token) => {
      hasPlaceholder = true;
      const resolved = resolveTemplatePlaceholderValue(obj, token);
      const resolvedText = stringifyTemplateResolvedValue(resolved);
      if (resolvedText !== "") {
        hasTokenValue = true;
      }
      return resolvedText;
    });

    return {
      text,
      hasPlaceholder,
      hasTokenValue
    };
  }

  function createTemplateCellModel() {
    return {
      text: "",
      style: {},
      hidden: false,
      rowspan: 1,
      colspan: 1,
      hasPlaceholder: false,
      hasTokenValue: false
    };
  }

  function buildTemplateCellStyle(rangeConfig, position) {
    const cfg = rangeConfig && typeof rangeConfig === "object" ? rangeConfig : {};
    const style = {};

    const background = normalizeTemplateColorValue(cfg.background);
    if (background) {
      style["background-color"] = background;
    }

    const fontColor = normalizeTemplateColorValue(cfg["font color"]);
    if (fontColor) {
      style.color = fontColor;
    }

    const fontSize = Number(cfg["font size"]);
    if (Number.isFinite(fontSize) && fontSize > 0) {
      style["font-size"] = `${fontSize}pt`;
    }

    const fontFamilyRaw = String(cfg["font family"] || "").trim();
    if (fontFamilyRaw && normalizeTemplateAliasToken(fontFamilyRaw) !== "default") {
      style["font-family"] = fontFamilyRaw;
    }

    if (cfg.bold === true) {
      style["font-weight"] = "700";
    }
    if (cfg.italic === true) {
      style["font-style"] = "italic";
    }
    if (cfg.underline === true) {
      style["text-decoration"] = "underline";
    }

    const align = normalizeTemplateAlignValue(cfg.align);
    if (align) {
      style["text-align"] = align;
    }

    const valign = normalizeTemplateVAlignValue(cfg.valign);
    if (valign) {
      style["vertical-align"] = valign;
    }

    if (cfg.wrap === true) {
      style["white-space"] = "pre-wrap";
    } else if (cfg.wrap === false) {
      style["white-space"] = "nowrap";
    }

    const border = normalizeTemplateBorderValue(cfg.border);
    if (border === "outside-thin") {
      const borderLine = "1px solid #c8c8c8";
      if (position && position.isMergeAnchor) {
        style.border = borderLine;
      } else {
        style["border-top"] = position && position.isTop ? borderLine : "none";
        style["border-right"] = position && position.isRight ? borderLine : "none";
        style["border-bottom"] = position && position.isBottom ? borderLine : "none";
        style["border-left"] = position && position.isLeft ? borderLine : "none";
      }
    } else if (border) {
      style.border = border;
    }

    return style;
  }

  function parseTemplateOptionBoolean(value, fallback) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "number") {
      if (value === 1) {
        return true;
      }
      if (value === 0) {
        return false;
      }
      return fallback;
    }
    const token = String(value || "").trim().toLowerCase();
    if (!token) {
      return fallback;
    }
    if (token === "1" || token === "true" || token === "yes" || token === "y" || token === "on") {
      return true;
    }
    if (token === "0" || token === "false" || token === "no" || token === "n" || token === "off") {
      return false;
    }
    return fallback;
  }

  function getTemplateOptionByPath(source, path) {
    if (!source || typeof source !== "object" || Array.isArray(source)) {
      return undefined;
    }
    const parts = String(path || "").split(".").map((item) => String(item || "").trim()).filter(Boolean);
    if (!parts.length) {
      return undefined;
    }

    let current = source;
    for (const part of parts) {
      if (!current || typeof current !== "object" || Array.isArray(current)) {
        return undefined;
      }
      if (!Object.prototype.hasOwnProperty.call(current, part)) {
        return undefined;
      }
      current = current[part];
    }
    return current;
  }

  function readTemplateOptionValue(sources, paths) {
    const sourceList = Array.isArray(sources) ? sources : [];
    const pathList = Array.isArray(paths) ? paths : [];
    for (const source of sourceList) {
      for (const path of pathList) {
        const value = getTemplateOptionByPath(source, path);
        if (value !== undefined) {
          return value;
        }
      }
    }
    return undefined;
  }

  function normalizeTemplatePreviewOptions(optionSource, templateDef, rangeSource) {
    const sources = [optionSource, templateDef, rangeSource];
    const hideEmptyRows = parseTemplateOptionBoolean(readTemplateOptionValue(sources, [
      "hideEmptyRows",
      "removeEmptyRows",
      "compact.removeEmptyRows"
    ]), true);
    const hideRowsWithoutValues = parseTemplateOptionBoolean(readTemplateOptionValue(sources, [
      "hideRowsWithoutValues",
      "removeEmptyRowsAdvanced",
      "removeEmptyRowsAdv",
      "compact.removeEmptyRowsAdvanced",
      "compact.removeEmptyRowsAdv"
    ]), true);
    const expandMultilineRows = parseTemplateOptionBoolean(readTemplateOptionValue(sources, [
      "expandMultilineRows",
      "expandArrayRows",
      "arrayToRows"
    ]), false);

    return {
      hideEmptyRows,
      hideRowsWithoutValues,
      expandMultilineRows
    };
  }

  function isTemplateRangeMetaKey(rawKey) {
    const key = String(rawKey || "").trim().toLowerCase();
    if (!key) {
      return false;
    }
    return (
      key === "_options"
      || key === "options"
      || key === "ranges"
      || key === "compact"
      || key === "hideemptyrows"
      || key === "hiderowswithoutvalues"
      || key === "expandmultilinerows"
      || key === "removeemptyrows"
      || key === "removeemptyrowsadvanced"
      || key === "removeemptyrowsadv"
      || key === "expandarrayrows"
      || key === "arraytorows"
    );
  }

  function resolveTemplateDefinitionForPreview(definition) {
    if (!definition || typeof definition !== "object" || Array.isArray(definition)) {
      return {
        map: null,
        options: normalizeTemplatePreviewOptions(null, null, null)
      };
    }

    const hasRanges = definition.ranges && typeof definition.ranges === "object" && !Array.isArray(definition.ranges);
    const rangeSource = hasRanges ? definition.ranges : definition;
    const optionSource = (definition._options && typeof definition._options === "object" && !Array.isArray(definition._options))
      ? definition._options
      : ((definition.options && typeof definition.options === "object" && !Array.isArray(definition.options))
        ? definition.options
        : null);
    const options = normalizeTemplatePreviewOptions(optionSource, definition, rangeSource);

    const map = {};
    for (const [key, value] of Object.entries(rangeSource)) {
      if (isTemplateRangeMetaKey(key)) {
        continue;
      }
      map[key] = value;
    }

    return { map, options };
  }

  function splitTemplateTextLines(text) {
    const normalized = String(text === undefined || text === null ? "" : text)
      .replace(/\r\n/g, "\n")
      .replace(/\r/g, "\n");
    if (normalized === "") {
      return [""];
    }
    return normalized.split("\n");
  }

  function getTemplateTextLine(lines, index) {
    const list = Array.isArray(lines) && lines.length ? lines : [""];
    const idx = Number(index) || 0;
    if (idx < list.length) {
      return String(list[idx] || "");
    }
    return String(list[list.length - 1] || "");
  }

  function cloneTemplateMatrixCell(cell) {
    if (!cell || typeof cell !== "object") {
      return createTemplateCellModel();
    }
    return {
      text: String(cell.text || ""),
      style: { ...(cell.style && typeof cell.style === "object" ? cell.style : {}) },
      hidden: Boolean(cell.hidden),
      rowspan: Number(cell.rowspan) || 1,
      colspan: Number(cell.colspan) || 1,
      hasPlaceholder: Boolean(cell.hasPlaceholder),
      hasTokenValue: Boolean(cell.hasTokenValue)
    };
  }

  function expandTemplateMatrixRows(matrix) {
    const rows = Array.isArray(matrix)
      ? matrix.map((row) => (Array.isArray(row) ? row.map((cell) => cloneTemplateMatrixCell(cell)) : []))
      : [];
    if (!rows.length) {
      return rows;
    }

    for (let rowIndex = rows.length - 1; rowIndex >= 0; rowIndex -= 1) {
      const row = rows[rowIndex];
      if (!Array.isArray(row) || !row.length) {
        continue;
      }

      const hasMergedCells = row.some((cell) => cell && (cell.hidden || cell.rowspan > 1 || cell.colspan > 1));
      if (hasMergedCells) {
        continue;
      }

      const lineByCol = new Map();
      let maxLines = 1;
      for (let colIndex = 0; colIndex < row.length; colIndex += 1) {
        const cell = row[colIndex];
        if (!cell || cell.hidden) {
          continue;
        }
        const lines = splitTemplateTextLines(cell.text);
        lineByCol.set(colIndex, lines);
        maxLines = Math.max(maxLines, lines.length);
      }

      if (maxLines <= 1) {
        continue;
      }

      for (let colIndex = 0; colIndex < row.length; colIndex += 1) {
        const cell = row[colIndex];
        if (!cell || cell.hidden) {
          continue;
        }
        const lines = lineByCol.get(colIndex) || [String(cell.text || "")];
        cell.text = getTemplateTextLine(lines, 0);
      }

      const extraRows = [];
      for (let lineIndex = 1; lineIndex < maxLines; lineIndex += 1) {
        const extraRow = row.map((cell) => cloneTemplateMatrixCell(cell));
        for (let colIndex = 0; colIndex < extraRow.length; colIndex += 1) {
          const cell = extraRow[colIndex];
          if (!cell || cell.hidden) {
            continue;
          }
          const lines = lineByCol.get(colIndex) || [String(cell.text || "")];
          cell.text = getTemplateTextLine(lines, lineIndex);
        }
        extraRows.push(extraRow);
      }

      if (extraRows.length) {
        rows.splice(rowIndex + 1, 0, ...extraRows);
      }
    }

    return rows;
  }

  function isTemplateRowBlank(row) {
    const list = Array.isArray(row) ? row : [];
    for (const cell of list) {
      if (!cell || cell.hidden) {
        continue;
      }
      if (String(cell.text || "").trim() !== "") {
        return false;
      }
    }
    return true;
  }

  function getTemplateRowPlaceholderState(row) {
    const list = Array.isArray(row) ? row : [];
    let hasPlaceholder = false;
    let hasTokenValue = false;
    for (const cell of list) {
      if (!cell || cell.hidden) {
        continue;
      }
      if (cell.hasPlaceholder) {
        hasPlaceholder = true;
      }
      if (cell.hasTokenValue) {
        hasTokenValue = true;
      }
    }
    return { hasPlaceholder, hasTokenValue };
  }

  function compactTemplateMatrixRows(matrix, options) {
    const rows = Array.isArray(matrix) ? matrix : [];
    if (!rows.length) {
      return rows;
    }

    const removeAdvanced = options && options.hideRowsWithoutValues === true;
    const removeEmpty = removeAdvanced || (options && options.hideEmptyRows === true);
    if (!removeAdvanced && !removeEmpty) {
      return rows;
    }

    const out = [];
    for (const row of rows) {
      const rowBlank = isTemplateRowBlank(row);
      if (removeAdvanced) {
        const stateRow = getTemplateRowPlaceholderState(row);
        if (rowBlank || (stateRow.hasPlaceholder && !stateRow.hasTokenValue)) {
          continue;
        }
        out.push(row);
        continue;
      }

      if (removeEmpty && rowBlank) {
        continue;
      }
      out.push(row);
    }

    return out;
  }

  function applyTemplatePreviewOptions(matrix, options) {
    let next = Array.isArray(matrix) ? matrix : [];
    if (!next.length) {
      return next;
    }
    if (options && options.expandMultilineRows === true) {
      next = expandTemplateMatrixRows(next);
    }
    return compactTemplateMatrixRows(next, options);
  }

  function buildTemplateGridModel(obj, templateMap, templateOptions) {
    const map = templateMap && typeof templateMap === "object" ? templateMap : {};
    const options = templateOptions && typeof templateOptions === "object"
      ? templateOptions
      : normalizeTemplatePreviewOptions(null, null, null);
    const entries = [];
    const errors = [];
    let maxRow = 0;
    let maxCol = 0;

    for (const rangeKey of Object.keys(map)) {
      if (isTemplateRangeMetaKey(rangeKey)) {
        continue;
      }
      try {
        const parsedRange = parseRangeKey(rangeKey);
        entries.push({
          rangeKey,
          parsedRange,
          config: map[rangeKey] && typeof map[rangeKey] === "object" ? map[rangeKey] : {}
        });
        maxRow = Math.max(maxRow, parsedRange.r2);
        maxCol = Math.max(maxCol, parsedRange.c2);
      } catch (err) {
        errors.push(`${rangeKey}: ${err && err.message ? err.message : err}`);
      }
    }

    if (!entries.length) {
      return {
        matrix: [],
        maxRow: 0,
        maxCol: 0,
        errors
      };
    }

    const matrix = Array.from({ length: maxRow }, () =>
      Array.from({ length: maxCol }, () => createTemplateCellModel())
    );

    for (const entry of entries) {
      const cfg = entry.config;
      const range = entry.parsedRange;
      const hasText = Object.prototype.hasOwnProperty.call(cfg, "text");
      const textMeta = hasText ? resolveTemplateText(cfg.text, obj) : null;
      const merge = cfg && cfg.merge === true;

      if (merge) {
        for (let row = range.r1; row <= range.r2; row += 1) {
          for (let col = range.c1; col <= range.c2; col += 1) {
            const cell = matrix[row - 1][col - 1];
            if (!cell) {
              continue;
            }
            const isAnchor = row === range.r1 && col === range.c1;
            if (isAnchor) {
              cell.hidden = false;
              cell.rowspan = range.r2 - range.r1 + 1;
              cell.colspan = range.c2 - range.c1 + 1;
              if (hasText) {
                cell.text = String(textMeta && textMeta.text ? textMeta.text : "");
                cell.hasPlaceholder = cell.hasPlaceholder || Boolean(textMeta && textMeta.hasPlaceholder);
                cell.hasTokenValue = cell.hasTokenValue || Boolean(textMeta && textMeta.hasTokenValue);
              }
              const cellStyle = buildTemplateCellStyle(cfg, {
                isTop: true,
                isRight: true,
                isBottom: true,
                isLeft: true,
                isMergeAnchor: true
              });
              cell.style = { ...cell.style, ...cellStyle };
            } else {
              cell.hidden = true;
              cell.rowspan = 1;
              cell.colspan = 1;
            }
          }
        }
        continue;
      }

      for (let row = range.r1; row <= range.r2; row += 1) {
        for (let col = range.c1; col <= range.c2; col += 1) {
          const cell = matrix[row - 1][col - 1];
          if (!cell) {
            continue;
          }
          cell.hidden = false;
          cell.rowspan = 1;
          cell.colspan = 1;
          if (hasText) {
            cell.text = String(textMeta && textMeta.text ? textMeta.text : "");
            cell.hasPlaceholder = cell.hasPlaceholder || Boolean(textMeta && textMeta.hasPlaceholder);
            cell.hasTokenValue = cell.hasTokenValue || Boolean(textMeta && textMeta.hasTokenValue);
          }
          const cellStyle = buildTemplateCellStyle(cfg, {
            isTop: row === range.r1,
            isRight: col === range.c2,
            isBottom: row === range.r2,
            isLeft: col === range.c1,
            isMergeAnchor: false
          });
          cell.style = { ...cell.style, ...cellStyle };
        }
      }
    }

    const compactedMatrix = applyTemplatePreviewOptions(matrix, options);
    return {
      matrix: compactedMatrix,
      maxRow: compactedMatrix.length,
      maxCol,
      errors
    };
  }

  function renderTemplateTable(model) {
    const matrix = model && Array.isArray(model.matrix) ? model.matrix : [];
    if (!matrix.length) {
      return null;
    }

    const table = el("table", {
      className: "template-preview-table",
      attrs: {
        style: "border-collapse:collapse;table-layout:fixed;width:max-content;min-width:100%;"
      }
    });
    const tbody = el("tbody");

    for (let rowIndex = 0; rowIndex < matrix.length; rowIndex += 1) {
      const row = matrix[rowIndex];
      const tr = el("tr");
      for (let colIndex = 0; colIndex < row.length; colIndex += 1) {
        const cell = row[colIndex];
        if (!cell || cell.hidden) {
          continue;
        }

        const td = document.createElement("td");
        if (cell.rowspan > 1) {
          td.rowSpan = cell.rowspan;
        }
        if (cell.colspan > 1) {
          td.colSpan = cell.colspan;
        }

        td.textContent = String(cell.text || "");
        const cssText = toInlineCssText({
          "min-width": "56px",
          "max-width": "360px",
          padding: "4px 6px",
          border: "1px solid #d3d3d3",
          "vertical-align": "top",
          "white-space": "pre-wrap",
          "font-size": "10pt",
          "font-family": "\"MS PGothic\", \"MS UI Gothic\", Meiryo, sans-serif",
          color: "#111111",
          "background-color": "#ffffff",
          ...cell.style
        });
        if (cssText) {
          td.setAttribute("style", cssText);
        }

        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }

    table.appendChild(tbody);
    return table;
  }

  async function copyHtmlWithFallback(html, plainText) {
    const safeHtml = String(html || "");
    const safeText = String(plainText || "");

    if (
      safeHtml
      && navigator.clipboard
      && typeof navigator.clipboard.write === "function"
      && typeof window.ClipboardItem === "function"
    ) {
      const item = new window.ClipboardItem({
        "text/html": new Blob([safeHtml], { type: "text/html" }),
        "text/plain": new Blob([safeText], { type: "text/plain" })
      });
      await navigator.clipboard.write([item]);
      return;
    }

    if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
      await navigator.clipboard.writeText(safeText);
      return;
    }

    const temp = document.createElement("div");
    temp.style.position = "fixed";
    temp.style.left = "-99999px";
    temp.style.top = "0";
    temp.setAttribute("contenteditable", "true");
    temp.innerHTML = safeHtml || safeText.replace(/\n/g, "<br>");
    document.body.appendChild(temp);

    const selection = window.getSelection();
    if (!selection) {
      document.body.removeChild(temp);
      throw new Error("Clipboard selection is unavailable.");
    }

    selection.removeAllRanges();
    const range = document.createRange();
    range.selectNodeContents(temp);
    selection.addRange(range);
    const copied = document.execCommand("copy");
    selection.removeAllRanges();
    document.body.removeChild(temp);

    if (!copied) {
      throw new Error("Copy failed in this browser.");
    }
  }

  function resolveTemplateMapForObject(obj, config) {
    const templates = config && typeof config === "object" && config.templates && typeof config.templates === "object"
      ? config.templates
      : {};
    const objectType = obj && obj.objectType ? String(obj.objectType) : "";
    if (objectType && Object.prototype.hasOwnProperty.call(templates, objectType)) {
      const resolved = resolveTemplateDefinitionForPreview(templates[objectType]);
      return { key: objectType, map: resolved.map, options: resolved.options };
    }
    if (Object.prototype.hasOwnProperty.call(templates, "DEFAULT")) {
      const resolved = resolveTemplateDefinitionForPreview(templates.DEFAULT);
      return { key: "DEFAULT", map: resolved.map, options: resolved.options };
    }
    const resolved = resolveTemplateDefinitionForPreview(null);
    return { key: "", map: null, options: resolved.options };
  }

  function buildTemplatePlainTextFromBlock(block) {
    if (!block) {
      return "";
    }
    return String(block.innerText || block.textContent || "").trim();
  }

  function getRenderableObjectListForTemplate() {
    const out = [];
    const roots = Array.isArray(state.renderObjects) ? state.renderObjects : [];

    const appendNode = (obj, depth) => {
      if (!obj || typeof obj !== "object") {
        return;
      }
      out.push({ obj, depth: Math.max(0, Number(depth) || 0) });

      const children = Array.isArray(obj.children) ? obj.children : [];
      for (const child of children) {
        appendNode(child, (Number(depth) || 0) + 1);
      }
    };

    for (const root of roots) {
      appendNode(root, 0);
    }

    return out;
  }

  function renderTemplatePreview() {
    if (!els.templatePreviewOutput) {
      return;
    }

    if (!state.data || !Array.isArray(state.renderObjects)) {
      setTemplatePreviewMessage("No data loaded.");
      return;
    }

    const config = state.templateConfig && typeof state.templateConfig === "object"
      ? state.templateConfig
      : getDefaultTemplateConfig();

    const check = validateTemplateConfig(config);
    if (!check.valid) {
      setTemplatePreviewMessage("Template config is invalid.");
      setTemplateConfigError(check.errors.join("\n"));
      return;
    }

    const items = getRenderableObjectListForTemplate();
    if (!items.length) {
      setTemplatePreviewMessage("No renderable objects.");
      return;
    }

    const fragment = document.createDocumentFragment();
    for (let index = 0; index < items.length; index += 1) {
      const item = items[index];
      const obj = item.obj;
      const depth = Math.max(0, Number(item.depth) || 0);
      const templateContextObj = buildTemplateContextObject(obj, index + 1);
      const resolved = resolveTemplateMapForObject(obj, config);

      const blockAttrs = { "data-template-index": String(index), "data-depth": String(depth) };
      const lineStart = Number(obj && obj.lineStart) || 0;
      if (lineStart > 0) {
        blockAttrs["data-line-start"] = String(lineStart);
      }
      const block = el("div", { className: "template-block", attrs: blockAttrs });
      const indentPx = Math.min(120, depth * 12);
      if (indentPx > 0) {
        block.style.marginLeft = `${indentPx}px`;
      } else {
        block.style.marginLeft = "";
      }
      const header = el("div", { className: "template-block-header" });

      const left = el("div");
      const label = getObjectLabel(obj);
      const titleText = `${index + 1}. ${String(obj.objectType || "OBJECT")}${label ? ` ${label}` : ""}`;
      left.appendChild(el("h4", { className: "template-block-title", text: titleText }));
      const meta = renderMeta(obj);
      const keyText = resolved.key ? `template=${resolved.key}` : "template=missing";
      left.appendChild(el("div", { className: "template-block-meta", text: [meta, keyText].filter(Boolean).join(" • ") }));
      header.appendChild(left);

      const actions = el("div", { className: "template-block-actions" });
      const codeBtn = el("button", {
        className: "secondary",
        text: "Code",
        attrs: { type: "button", "data-template-action": "code" }
      });
      codeBtn.addEventListener("click", () => {
        const selectedIndex = String(index);
        if (typeof setSelectedTemplateBlock === "function") {
          setSelectedTemplateBlock(selectedIndex);
        } else {
          state.selectedTemplateIndex = selectedIndex;
        }
        if (lineStart > 0 && typeof selectCodeLines === "function") {
          const lineEnd = Number(obj && obj.block && obj.block.lineEnd) || lineStart;
          selectCodeLines(lineStart, lineEnd);
        }
      });
      actions.appendChild(codeBtn);

      const pathsBtn = el("button", {
        className: "secondary",
        text: "Paths",
        attrs: { type: "button", "data-template-action": "paths" }
      });
      pathsBtn.addEventListener("click", (ev) => {
        if (ev && typeof ev.stopPropagation === "function") {
          ev.stopPropagation();
        }
        openTemplatePathDump(templateContextObj, index, obj);
      });
      actions.appendChild(pathsBtn);

      const copyBtn = el("button", {
        className: "secondary",
        text: "Copy",
        attrs: { type: "button", "data-template-action": "copy" }
      });
      copyBtn.addEventListener("click", async () => {
        try {
          const clone = block.cloneNode(true);
          const actionButtons = clone.querySelectorAll("[data-template-action]");
          for (const actionBtn of Array.from(actionButtons)) {
            actionBtn.remove();
          }
          await copyHtmlWithFallback(clone.outerHTML, buildTemplatePlainTextFromBlock(clone));
          setError("");
        } catch (err) {
          setError(`Copy failed: ${err && err.message ? err.message : err}`);
        }
      });
      actions.appendChild(copyBtn);
      header.appendChild(actions);
      block.appendChild(header);
      block.addEventListener("click", () => {
        const selectedIndex = String(index);
        if (typeof setSelectedTemplateBlock === "function") {
          setSelectedTemplateBlock(selectedIndex, { scroll: false });
        } else {
          state.selectedTemplateIndex = selectedIndex;
        }
      });

      if (!resolved.map || typeof resolved.map !== "object") {
        block.appendChild(el("div", { className: "template-empty", text: "[Missing template]" }));
        fragment.appendChild(block);
        continue;
      }

      const model = buildTemplateGridModel(templateContextObj, resolved.map, resolved.options);
      if (model.errors.length) {
        block.appendChild(el("div", { className: "template-error", text: model.errors.join("\n") }));
      }

      const table = renderTemplateTable(model);
      if (table) {
        block.appendChild(table);
      } else {
        block.appendChild(el("div", { className: "template-empty", text: "[Missing template]" }));
      }

      fragment.appendChild(block);
    }

    els.templatePreviewOutput.classList.remove("muted");
    els.templatePreviewOutput.replaceChildren(fragment);
    state.templatePreviewCache = { count: items.length };
    if (state.selectedTemplateIndex !== "" && typeof setSelectedTemplateBlock === "function") {
      setSelectedTemplateBlock(state.selectedTemplateIndex, { scroll: false });
    }
    if (typeof refreshInputGutterTargets === "function") {
      refreshInputGutterTargets();
    }
  }

  function syncTemplateEditorFromState() {
    if (!els.templateConfigJson) {
      return;
    }
    const pretty = safeJson(state.templateConfig || getDefaultTemplateConfig(), true);
    state.templateConfigDraft = pretty;
    els.templateConfigJson.value = pretty;
  }

  function applyTemplateConfigObject(config, options) {
    const opts = options && typeof options === "object" ? options : {};
    const check = validateTemplateConfig(config);
    if (!check.valid) {
      setTemplateConfigError(check.errors.join("\n"));
      return false;
    }

    const next = cloneJsonValue(config);
    if (!next || typeof next !== "object") {
      setTemplateConfigError("Cannot clone template config.");
      return false;
    }

    state.templateConfig = next;
    if (opts.save !== false) {
      saveTemplateConfig(next);
    }
    setTemplateConfigError("");
    syncTemplateEditorFromState();
    renderTemplatePreview();
    return true;
  }

  function applyTemplateConfigFromEditor() {
    const raw = els.templateConfigJson ? String(els.templateConfigJson.value || "").trim() : "";
    if (!raw) {
      setTemplateConfigError("Template config JSON is empty.");
      return;
    }

    let parsed = null;
    try {
      parsed = JSON.parse(raw);
    } catch (err) {
      setTemplateConfigError(`JSON parse error: ${err && err.message ? err.message : err}`);
      return;
    }

    applyTemplateConfigObject(parsed, { save: true });
  }

  function resetTemplateConfig() {
    applyTemplateConfigObject(getDefaultTemplateConfig(), { save: true });
  }

  function exportTemplateConfig() {
    const config = state.templateConfig || getDefaultTemplateConfig();
    const content = safeJson(config, true);
    const fileName = "abap-template-config.json";

    try {
      const blob = new Blob([content], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      setError("");
    } catch (err) {
      setError(`Export failed: ${err && err.message ? err.message : err}`);
    }
  }

  async function importTemplateConfigFromFile(file) {
    if (!file) {
      return;
    }

    let text = "";
    try {
      text = await file.text();
    } catch (err) {
      setTemplateConfigError(`Import failed: ${err && err.message ? err.message : err}`);
      return;
    }

    try {
      const parsed = JSON.parse(text);
      const applied = applyTemplateConfigObject(parsed, { save: true });
      if (applied) {
        setError("");
      }
    } catch (err) {
      setTemplateConfigError(`Import JSON parse error: ${err && err.message ? err.message : err}`);
    }
  }

  async function copyAllTemplateBlocks() {
    if (!els.templatePreviewOutput) {
      return;
    }
    const blocks = Array.from(els.templatePreviewOutput.querySelectorAll(".template-block"));
    if (!blocks.length) {
      setError("Nothing to copy.");
      return;
    }

    const wrapper = document.createElement("div");
    const plainLines = [];
    for (const block of blocks) {
      const clone = block.cloneNode(true);
      const actionButtons = clone.querySelectorAll("[data-template-action]");
      for (const actionBtn of Array.from(actionButtons)) {
        actionBtn.remove();
      }
      wrapper.appendChild(clone);
      plainLines.push(buildTemplatePlainTextFromBlock(clone));
    }

    await copyHtmlWithFallback(wrapper.innerHTML, plainLines.filter(Boolean).join("\n\n"));
  }

window.AbapViewerModules.factories = window.AbapViewerModules.factories || {};
window.AbapViewerModules.factories["03-template-preview"] = function registerTemplatePreview(runtime) {
  const targetRuntime = runtime || (window.AbapViewerRuntime = window.AbapViewerRuntime || {});
  targetRuntime.api = targetRuntime.api || {};
  targetRuntime.api.renderTemplatePreview = renderTemplatePreview;
  targetRuntime.api.applyTemplateConfigFromEditor = applyTemplateConfigFromEditor;
  window.AbapViewerModules.parts["03-template-preview"] = true;
};
window.AbapViewerModules.factories["03-template-preview"](window.AbapViewerRuntime);
</script>
  <script>
// inlined from: ./app/04-output-render.js
"use strict";

window.AbapViewerModules = window.AbapViewerModules || {};
window.AbapViewerModules.parts = window.AbapViewerModules.parts || {};

  function isValueLikeEntryObject(value) {
    if (!isPlainObjectRecord(value)) {
      return false;
    }
    if (isDeclLikeObject(value) || isAbapStatementObject(value)) {
      return false;
    }
    return (
      hasValueLevelDescFields(value)
      || Object.prototype.hasOwnProperty.call(value, "declRef")
      || Object.prototype.hasOwnProperty.call(value, "value")
      || Object.prototype.hasOwnProperty.call(value, "name")
      || Object.prototype.hasOwnProperty.call(value, "label")
    );
  }

  function isAssignmentLikeEntryObject(value) {
    if (!isPlainObjectRecord(value)) {
      return false;
    }
    if (isDeclLikeObject(value) || isAbapStatementObject(value)) {
      return false;
    }
    const hasValueSignals = (
      Object.prototype.hasOwnProperty.call(value, "value")
      || Object.prototype.hasOwnProperty.call(value, "valueRef")
      || Object.prototype.hasOwnProperty.call(value, "valueDecl")
      || Object.prototype.hasOwnProperty.call(value, "originDecls")
    );
    if (!hasValueSignals) {
      return false;
    }
    return (
      Object.prototype.hasOwnProperty.call(value, "name")
      || Object.prototype.hasOwnProperty.call(value, "value")
      || Object.prototype.hasOwnProperty.call(value, "valueRef")
    );
  }

  function isConditionClauseLikeObject(value) {
    if (!isPlainObjectRecord(value)) {
      return false;
    }
    return (
      Object.prototype.hasOwnProperty.call(value, "leftOperand")
      || Object.prototype.hasOwnProperty.call(value, "rightOperand")
      || Object.prototype.hasOwnProperty.call(value, "comparisonOperator")
    );
  }

  function normalizeEntryObjectForXml(value, keyHint, pathParts, ownerContext) {
    if (!isPlainObjectRecord(value)) {
      return value;
    }
    if (isDeclLikeObject(value) || isAbapStatementObject(value)) {
      return value;
    }

    const pathKey = buildPathKeyFromParts(pathParts);
    const pathLower = pathKey.toLowerCase();
    const inValuesPath = pathLower.includes("/values/");
    const inExtrasPath = pathLower.includes("/extras/");
    const keyHintLower = String(keyHint || "").trim().toLowerCase();
    const extrasItemLike = keyHintLower === "item";
    const source = getDeclSourceContextFromObject(ownerContext);

    let next = value;

    if (inValuesPath && isValueLikeEntryObject(next)) {
      next = ensureEntryDeclWithSynthetic(next, {
        pathKey,
        file: source.file,
        lineStart: source.lineStart,
        raw: source.raw,
        role: "xml:value"
      });
    }

    if (inExtrasPath && extrasItemLike) {
      if (isConditionClauseLikeObject(next)) {
        next = ensureConditionClauseDeclsWithSynthetic(next, {
          pathKey,
          file: source.file,
          lineStart: source.lineStart,
          raw: source.raw
        });
      }

      if (isAssignmentLikeEntryObject(next)) {
        next = ensureValueDeclWithSynthetic(next, {
          pathKey,
          file: source.file,
          lineStart: source.lineStart,
          raw: source.raw,
          role: "xml:extras:value",
          nameHint: String(keyHint || "value")
        });
      }

      if (isValueLikeEntryObject(next)) {
        next = ensureEntryDeclWithSynthetic(next, {
          pathKey,
          file: source.file,
          lineStart: source.lineStart,
          raw: source.raw,
          role: "xml:extras"
        });
      }
    }

    return next;
  }

  function appendXmlValue(lines, keyHint, tagName, value, indent, pathParts, ownerContext) {
    const pad = " ".repeat(indent);
    const currentPathParts = Array.isArray(pathParts) ? pathParts : [];
    const currentOwnerContext = ownerContext && typeof ownerContext === "object" ? ownerContext : null;

    if (value === undefined) {
      return;
    }

    if (value === null) {
      lines.push(`${pad}<${tagName}/>`);
      return;
    }

    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      lines.push(`${pad}<${tagName}>${escapeXmlText(String(value))}</${tagName}>`);
      return;
    }

    if (Array.isArray(value)) {
      const itemTag = getArrayItemTagName(keyHint);
      lines.push(`${pad}<${tagName}>`);
      for (let index = 0; index < value.length; index += 1) {
        const item = value[index];
        const itemPathParts = currentPathParts.concat(`${itemTag}[${index + 1}]`);
        appendXmlValue(lines, itemTag, itemTag, item, indent + 2, itemPathParts, currentOwnerContext);
      }
      lines.push(`${pad}</${tagName}>`);
      return;
    }

    if (typeof value === "object") {
      const nextOwnerContext = isAbapStatementObject(value) ? value : currentOwnerContext;
      const normalizedValue = normalizeEntryObjectForXml(value, keyHint, currentPathParts, nextOwnerContext);
      lines.push(`${pad}<${tagName}>`);

      const valueIsDecl = isDeclObjectForXml(keyHint, normalizedValue);
      let hasComputedFinalDesc = false;

      if (valueIsDecl) {
        const declDesc = getEffectiveDeclDesc(normalizedValue);
        if (declDesc) {
          lines.push(`${" ".repeat(indent + 2)}<desc>${escapeXmlText(declDesc)}</desc>`);
        } else {
          lines.push(`${" ".repeat(indent + 2)}<desc/>`);
        }

        const finalDeclDesc = getFinalDeclDesc(normalizedValue);
        hasComputedFinalDesc = true;
        if (finalDeclDesc) {
          lines.push(`${" ".repeat(indent + 2)}<finalDesc>${escapeXmlText(finalDeclDesc)}</finalDesc>`);
        } else {
          lines.push(`${" ".repeat(indent + 2)}<finalDesc/>`);
        }

        const declName = getDeclDisplayName(normalizedValue) || getDeclTechName(normalizedValue);
        lines.push(`${" ".repeat(indent + 2)}<name>${escapeXmlText(declName)}</name>`);
      }

      if (!valueIsDecl) {
        let shouldEmitFinalDesc = false;
        let finalDesc = "";
        if (hasValueLevelDescFields(normalizedValue)) {
          shouldEmitFinalDesc = true;
          finalDesc = resolveValueLevelFinalDesc(normalizedValue);
        } else if (isDeclLikeObject(normalizedValue.decl)) {
          shouldEmitFinalDesc = true;
          finalDesc = getFinalDeclDesc(normalizedValue.decl);
        }

        if (shouldEmitFinalDesc) {
          hasComputedFinalDesc = true;
          if (finalDesc) {
            lines.push(`${" ".repeat(indent + 2)}<finalDesc>${escapeXmlText(finalDesc)}</finalDesc>`);
          } else {
            lines.push(`${" ".repeat(indent + 2)}<finalDesc/>`);
          }
        }
      }

      const preferredOrder = [
        "id",
        "parent",
        "objectType",
        "file",
        "lineStart",
        "comment",
        "raw",
        "keywords",
        "values",
        "extras",
        "block",
        "children"
      ];

      const keys = Object.keys(normalizedValue);
      keys.sort((a, b) => {
        const ai = preferredOrder.indexOf(a);
        const bi = preferredOrder.indexOf(b);
        if (ai !== -1 || bi !== -1) {
          return (ai === -1 ? 999 : ai) - (bi === -1 ? 999 : bi);
        }
        return a.localeCompare(b);
      });

      for (const key of keys) {
        if (key === "desc" && valueIsDecl) {
          // computed above
          continue;
        }
        if (key === "name" && valueIsDecl) {
          // computed above (normalized via settings)
          continue;
        }
        if (key === "finalDesc" && hasComputedFinalDesc) {
          continue;
        }
        const childTag = toXmlTagName(key);
        appendXmlValue(
          lines,
          key,
          childTag,
          normalizedValue[key],
          indent + 2,
          currentPathParts.concat(key),
          nextOwnerContext
        );
      }

      lines.push(`${pad}</${tagName}>`);
      return;
    }

    lines.push(`${pad}<${tagName}>${escapeXmlText(String(value))}</${tagName}>`);
  }

  function buildAbapFlowXml(data) {
    const fileName = data && typeof data === "object" ? String(data.file || "") : "";
    const objects = data && typeof data === "object" && Array.isArray(data.objects) ? data.objects : [];
    const renderObjects = buildRenderableObjects(objects, RENDER_TREE_OPTIONS);
    const exportRoots = buildXmlExportRoots(renderObjects);

    const lines = ['<?xml version="1.0" encoding="UTF-8"?>', "<abapflowObjects>"];
    if (fileName) {
      lines.push(`  <file>${escapeXmlText(fileName)}</file>`);
    }
    lines.push("  <objects>");
    for (let index = 0; index < exportRoots.length; index += 1) {
      const obj = exportRoots[index];
      appendXmlValue(lines, "object", "object", obj, 4, ["objects", `object[${index + 1}]`], obj);
    }
    lines.push("  </objects>");
    lines.push("</abapflowObjects>");

    return lines.join("\n");
  }

  function walkObjects(roots, visit) {
    const stack = Array.isArray(roots) ? roots.slice().reverse() : [];
    while (stack.length) {
      const node = stack.pop();
      if (!node) {
        continue;
      }
      visit(node);
      const children = Array.isArray(node.children) ? node.children : [];
      for (let i = children.length - 1; i >= 0; i -= 1) {
        stack.push(children[i]);
      }
    }
  }

  function collectDeclSearchTextFromExtras(extras) {
    if (!extras || typeof extras !== "object") {
      return "";
    }

    const decls = [];
    const addDecl = (decl) => {
      if (decl && typeof decl === "object") {
        decls.push(decl);
      }
    };
    const addDeclList = (list) => {
      if (!Array.isArray(list)) {
        return;
      }
      for (const decl of list) {
        addDecl(decl);
      }
    };

    const collectFromAssignmentSections = (obj, sections) => {
      for (const sectionName of sections) {
        const list = obj && Array.isArray(obj[sectionName]) ? obj[sectionName] : [];
        for (const entry of list) {
          addDeclList(entry && entry.originDecls);
          addDecl(entry && entry.valueDecl);
        }
      }
    };

    if (extras.callFunction) {
      collectFromAssignmentSections(extras.callFunction, ["exporting", "importing", "changing", "tables", "exceptions"]);
    }

    if (extras.callMethod) {
      collectFromAssignmentSections(extras.callMethod, ["exporting", "importing", "changing", "receiving", "exceptions"]);
    }

    if (extras.performCall) {
      for (const sectionName of ["using", "changing", "tables"]) {
        const list = Array.isArray(extras.performCall[sectionName]) ? extras.performCall[sectionName] : [];
        for (const entry of list) {
          addDeclList(entry && entry.originDecls);
          addDecl(entry && entry.valueDecl);
        }
      }
    }

    if (extras.form && Array.isArray(extras.form.params)) {
      for (const param of extras.form.params) {
        addDeclList(param && param.originDecls);
      }
    }

    collectConditionDeclsFromExtras(extras, addDecl);

    const seen = new Set();
    const parts = [];
    for (const decl of decls) {
      const key = getDeclOverrideStorageKey(decl) || stringifyDecl(decl);
      if (!key || seen.has(key)) {
        continue;
      }
      seen.add(key);
      parts.push(String(decl.name || ""));
      const desc = getEffectiveDeclDesc(decl);
      if (desc) {
        parts.push(desc);
      }
    }

    return parts.filter(Boolean).join("\n");
  }

  function buildSearchIndex(objects) {
    const map = new Map();
    walkObjects(objects, (obj) => {
      const id = normalizeId(obj && obj.id);
      if (!id) {
        return;
      }

      const keywordEntries = getKeywordEntries(obj);
      const keywordsText = keywordEntries.length
        ? keywordEntries.map((k) => `${k.text || ""} ${k.label || ""}`.trim()).join("\n")
        : "";

      const valueEntries = getValueEntries(obj);
      const valuesText = valueEntries.length
        ? valueEntries
            .map((v) => {
              const declText = stringifyDecl(v && v.decl);
              const declDesc = getEffectiveDeclDesc(v && v.decl);
              return [
                v && v.name ? String(v.name) : "",
                v && v.value ? String(v.value) : "",
                v && v.label ? String(v.label) : "",
                v && v.codeDesc ? String(v.codeDesc) : "",
                v && v.declRef ? String(v.declRef) : "",
                declText,
                declDesc
              ]
                .filter(Boolean)
                .join(" ");
            })
            .join("\n")
        : "";

      const extrasText = obj.extras && typeof obj.extras === "object" ? safeJson(obj.extras, false) : "";
      const extrasDeclText = collectDeclSearchTextFromExtras(obj.extras);

      const haystack = [
        obj.objectType || "",
        obj.raw || "",
        obj.comment || "",
        keywordsText,
        valuesText,
        extrasText,
        extrasDeclText
      ]
        .filter(Boolean)
        .join("\n")
        .toLowerCase();

      map.set(id, haystack);
    });
    return map;
  }

  function computeLineOffsets(text) {
    const value = String(text || "");
    const offsets = [0];
    for (let i = 0; i < value.length; i += 1) {
      if (value[i] === "\n") {
        offsets.push(i + 1);
      }
    }
    return offsets;
  }

  function getSelectionRangeForLines(text, lineStart, lineEnd) {
    const value = String(text || "");
    const offsets = state.inputLineOffsets.length ? state.inputLineOffsets : computeLineOffsets(value);
    const start = Math.max(1, Number(lineStart) || 1);
    const end = Math.max(start, Number(lineEnd) || start);
    const startLineIndex = start - 1;
    const endLineIndex = end - 1;
    const startOffset = offsets[startLineIndex] ?? 0;
    const endOffset = offsets[endLineIndex + 1] ?? value.length;
    return { start: startOffset, end: Math.max(startOffset, endOffset) };
  }

  function selectCodeLines(lineStart, lineEnd) {
    const text = els.inputText.value || "";
    state.inputLineOffsets = computeLineOffsets(text);
    const range = getSelectionRangeForLines(text, lineStart, lineEnd);
    els.inputText.focus();
    els.inputText.setSelectionRange(range.start, range.end);
    syncInputGutterScroll();
  }

  function setSelectedCard(id) {
    const normalized = normalizeId(id);
    if (!normalized) {
      return;
    }

    if (state.selectedId) {
      const prev = els.output.querySelector(`[data-id="${escapeSelectorValue(state.selectedId)}"]`);
      if (prev) {
        prev.classList.remove("selected");
      }
    }

    state.selectedId = normalized;
    const next = els.output.querySelector(`[data-id="${escapeSelectorValue(normalized)}"]`);
    if (next) {
      next.classList.add("selected");
      next.scrollIntoView({ block: "nearest" });
    }
  }

  function setSelectedTemplateBlock(index, options) {
    if (!els.templatePreviewOutput) {
      return;
    }

    const opts = options && typeof options === "object" ? options : {};
    const shouldScroll = opts.scroll !== false;
    const normalized = String(index === undefined || index === null ? "" : index).trim();
    if (!normalized) {
      return;
    }

    if (state.selectedTemplateIndex !== "") {
      const prev = els.templatePreviewOutput.querySelector(
        `.template-block[data-template-index="${escapeSelectorValue(state.selectedTemplateIndex)}"]`
      );
      if (prev) {
        prev.classList.remove("selected");
      }
    }

    state.selectedTemplateIndex = normalized;
    const next = els.templatePreviewOutput.querySelector(
      `.template-block[data-template-index="${escapeSelectorValue(normalized)}"]`
    );
    if (next) {
      next.classList.add("selected");
      if (shouldScroll) {
        next.scrollIntoView({ block: "nearest" });
      }
    }
  }

  function setSelectedDeclRow(declKey) {
    const key = String(declKey || "").trim();
    if (!key || !els.declDescTable) {
      return;
    }

    if (state.selectedDeclKey) {
      const prev = els.declDescTable.querySelector(`tr[data-decl-key="${escapeSelectorValue(state.selectedDeclKey)}"]`);
      if (prev) {
        prev.classList.remove("desc-selected");
      }
    }

    state.selectedDeclKey = key;
    const next = els.declDescTable.querySelector(`tr[data-decl-key="${escapeSelectorValue(key)}"]`);
    if (next) {
      next.classList.add("desc-selected");
      next.scrollIntoView({ block: "nearest" });
    }
  }

  function countInputLines(value) {
    const text = String(value || "");
    if (!text) {
      return 1;
    }
    return text.split("\n").length;
  }

  function syncInputGutterScroll() {
    if (!els.inputText || !els.inputGutterContent) {
      return;
    }

    const scrollTop = Number(els.inputText.scrollTop || 0) || 0;
    els.inputGutterContent.style.transform = `translateY(${-scrollTop}px)`;
  }

  function rebuildInputGutter() {
    if (!els.inputText || !els.inputGutterContent) {
      return;
    }

    const trimmed = String(els.inputText.value || "").trim();
    const isJsonLike = (trimmed.startsWith("{") || trimmed.startsWith("[")) && trimmed.length > 1;
    state.inputMode = isJsonLike ? "json" : "abap";

    const lineCount = Math.max(1, countInputLines(els.inputText.value || ""));
    if (lineCount === state.inputLineCount && state.inputGutterButtonsByLine.size) {
      syncInputGutterScroll();
      refreshInputGutterTargets();
      return;
    }

    state.inputLineCount = lineCount;
    state.inputGutterButtonsByLine = new Map();

    const frag = document.createDocumentFragment();
    for (let line = 1; line <= lineCount; line += 1) {
      const row = document.createElement("div");
      row.className = "gutter-line";

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "gutter-jump";
      btn.textContent = "↪";
      btn.hidden = true;
      btn.setAttribute("data-line", String(line));
      row.appendChild(btn);

      const num = document.createElement("span");
      num.className = "gutter-num";
      num.textContent = String(line);
      row.appendChild(num);

      state.inputGutterButtonsByLine.set(line, btn);
      frag.appendChild(row);
    }

    els.inputGutterContent.replaceChildren(frag);
    syncInputGutterScroll();
    refreshInputGutterTargets();
  }

  function computeInputGutterTargetsForOutput() {
    const targets = new Map();
    if (!els.output) {
      return targets;
    }

    const cards = els.output.querySelectorAll(".card[data-id][data-line-start]");
    for (const card of Array.from(cards)) {
      const line = Number(card.getAttribute("data-line-start")) || 0;
      const id = String(card.getAttribute("data-id") || "");
      if (!line || !id || targets.has(line)) {
        continue;
      }
      targets.set(line, { kind: "output", id });
    }

    return targets;
  }

  function computeInputGutterTargetsForDescriptions() {
    const targets = new Map();
    if (!els.declDescTable) {
      return targets;
    }

    const rows = els.declDescTable.querySelectorAll("tr[data-decl-key][data-line-start]");
    for (const row of Array.from(rows)) {
      const line = Number(row.getAttribute("data-line-start")) || 0;
      const declKey = String(row.getAttribute("data-decl-key") || "");
      if (!line || !declKey || targets.has(line)) {
        continue;
      }
      targets.set(line, { kind: "descriptions", declKey });
    }

    return targets;
  }

  function computeInputGutterTargetsForTemplate() {
    const targets = new Map();
    if (!els.templatePreviewOutput) {
      return targets;
    }

    const blocks = els.templatePreviewOutput.querySelectorAll(".template-block[data-template-index][data-line-start]");
    for (const block of Array.from(blocks)) {
      const line = Number(block.getAttribute("data-line-start")) || 0;
      const index = String(block.getAttribute("data-template-index") || "");
      if (!line || !index || targets.has(line)) {
        continue;
      }
      targets.set(line, { kind: "template", index });
    }

    return targets;
  }

  function refreshInputGutterTargets() {
    if (!els.inputGutterContent || !state.inputGutterButtonsByLine.size) {
      return;
    }

    if (state.inputMode !== "abap") {
      state.inputGutterTargetsByLine = new Map();
      for (const btn of state.inputGutterButtonsByLine.values()) {
        btn.hidden = true;
      }
      return;
    }

    let targets = new Map();
    if (state.rightTab === "descriptions") {
      targets = computeInputGutterTargetsForDescriptions();
    } else if (state.rightTab === "output") {
      targets = computeInputGutterTargetsForOutput();
    } else if (state.rightTab === "template") {
      targets = computeInputGutterTargetsForTemplate();
    }

    state.inputGutterTargetsByLine = targets;
    const title = state.rightTab === "descriptions"
      ? "Jump to Descriptions"
      : (state.rightTab === "output"
        ? "Jump to Output"
        : (state.rightTab === "template" ? "Jump to Template" : ""));
    for (const [line, btn] of state.inputGutterButtonsByLine.entries()) {
      const target = targets.get(line);
      btn.hidden = !target;
      if (target) {
        btn.title = title;
        btn.setAttribute("aria-label", title);
      }
    }
  }

  function onInputGutterClick(ev) {
    const target = ev && ev.target && typeof ev.target.closest === "function"
      ? ev.target.closest("button.gutter-jump")
      : null;
    if (!target) {
      return;
    }

    const line = Number(target.getAttribute("data-line")) || 0;
    if (!line) {
      return;
    }

    const jumpTarget = state.inputGutterTargetsByLine.get(line);
    if (!jumpTarget) {
      return;
    }

    if (state.rightTab === "output" && jumpTarget.kind === "output") {
      setSelectedCard(jumpTarget.id);
      return;
    }

    if (state.rightTab === "template" && jumpTarget.kind === "template") {
      setSelectedTemplateBlock(jumpTarget.index);
      return;
    }

    if (state.rightTab === "descriptions" && jumpTarget.kind === "descriptions") {
      setSelectedDeclRow(jumpTarget.declKey);
    }
  }

  function openJsonModal(value) {
    openTextModal("Object JSON", safeJson(value, true));
  }

  function openTextModal(title, text) {
    if (!els.editModal.hidden) {
      closeEditModal();
    }

    if (els.jsonTitle) {
      els.jsonTitle.textContent = title ? String(title) : "";
    }

    els.jsonPre.textContent = text ? String(text) : "";
    els.jsonModal.hidden = false;
  }

  function closeJsonModal() {
    els.jsonModal.hidden = true;
    if (els.jsonTitle) {
      els.jsonTitle.textContent = "Object JSON";
    }
    els.jsonPre.textContent = "";
  }

  async function copyJsonToClipboard() {
    const text = els.jsonPre.textContent || "";
    if (!text) {
      return;
    }

    if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
      await navigator.clipboard.writeText(text);
      return;
    }

    const selection = window.getSelection();
    if (!selection) {
      return;
    }
    selection.removeAllRanges();
    const range = document.createRange();
    range.selectNodeContents(els.jsonPre);
    selection.addRange(range);
    document.execCommand("copy");
    selection.removeAllRanges();
  }

  function stringifyDecl(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const techName = getDeclTechName(decl);
    const displayName = getDeclDisplayName(decl);

    const parts = [];
    if (decl.objectType) {
      parts.push(String(decl.objectType));
    }
    if (decl.scopeLabel) {
      parts.push(`[${String(decl.scopeLabel)}]`);
    }
    if (displayName) {
      parts.push(displayName);
    }
    if (techName && displayName && techName !== displayName) {
      parts.push(`(${techName})`);
    }
    if (decl.file) {
      parts.push(String(decl.file));
    }
    if (decl.lineStart) {
      parts.push(`#${decl.lineStart}`);
    }
    return parts.join(" ");
  }

  function getDeclTechName(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }
    return decl.name ? String(decl.name) : "";
  }

  function stripAngleBrackets(text) {
    const trimmed = String(text || "").trim();
    if (trimmed.startsWith("<") && trimmed.endsWith(">") && trimmed.length > 2) {
      return trimmed.slice(1, -1);
    }
    return trimmed;
  }

  function stripDeclCategoryPrefix(text) {
    const raw = String(text || "").trim();
    if (!raw) {
      return "";
    }

    const match = raw.match(
      /^\s*(HẰNG|HANG|STRUCT|TABLE|RANGETABLE|BIẾN|BIEN|CỜ|CO|FIELDSYMBOL)\b\s*[:\-\[\]]*\s*/i
    );
    if (!match) {
      return raw;
    }

    let rest = raw.slice(match[0].length).trim();
    // If the prefix included an opening "[" (e.g. "BIẾN:[") then strip ONE trailing "]" (e.g. "...]")
    // so "BIẾN:[desc]" -> "desc" instead of "desc]".
    if (match[0].includes("[") && rest.endsWith("]")) {
      rest = rest.slice(0, -1).trim();
    }
    return rest;
  }

  function isStructFieldDecl(decl) {
    if (!decl || typeof decl !== "object") {
      return false;
    }
    if (decl.objectType === "STRUCT_FIELD") {
      return true;
    }
    return Boolean(decl.structName && decl.fieldPath);
  }

  function getDeclDisplayName(decl) {
    const techName = getDeclTechName(decl);
    if (!techName) {
      return "";
    }

    if (isStructFieldDecl(decl)) {
      return techName;
    }

    const desc = getEffectiveDeclDesc(decl);
    const descTrimmed = String(desc || "").trim();
    if (!descTrimmed) {
      return techName;
    }

    const settings = state.settings || DEFAULT_SETTINGS;
    if (settings.normalizeDeclDesc) {
      return descTrimmed;
    }

    const bare = stripAngleBrackets(techName);
    if (bare.length < 3) {
      return techName;
    }

    const code = bare.slice(1, 3).toUpperCase();
    const templates = settings.nameTemplatesByCode || DEFAULT_SETTINGS.nameTemplatesByCode;
    const template = templates && Object.prototype.hasOwnProperty.call(templates, code) ? String(templates[code] || "") : "";
    if (!template.trim()) {
      return techName;
    }

    const strippedKnownPrefix = stripDeclCategoryPrefix(descTrimmed);
    const normalizedDesc = stripDeclTemplateAffixes(strippedKnownPrefix, template);
    const displayName = template.replace(/\{\{desc\}\}/g, normalizedDesc).trim();
    return displayName || techName;
  }

  function buildDeclTitle(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const lines = [];
    lines.push(stringifyDecl(decl));

    const desc = getEffectiveDeclDesc(decl);
    if (desc) {
      lines.push(`Desc: ${desc}`);
    }

    if (decl.raw) {
      lines.push(String(decl.raw));
    }

    return lines.filter(Boolean).join("\n");
  }

  function renderDeclNameCell(decl) {
    const text = decl ? getDeclDisplayName(decl) : "";
    const title = buildDeclTitle(decl);
    const cell = el("td", { text, attrs: title ? { title } : {} });

    if (decl && decl.lineStart) {
      cell.style.cursor = "pointer";
      cell.addEventListener("click", (ev) => {
        ev.stopPropagation();
        selectCodeLines(decl.lineStart, decl.lineStart);
        if (decl.id) {
          setSelectedCard(decl.id);
        }
      });
    }

    return cell;
  }

  function renderDeclDescCell(decl) {
    const text = getEffectiveDeclDesc(decl);
    const title = buildDeclTitle(decl);
    const cell = el("td", { attrs: title ? { title } : {} });

    const wrap = el("div", { className: "decl-desc" });
    wrap.appendChild(el("div", { className: "decl-desc-text", text: text || "" }));

    if (getDeclOverrideStorageKey(decl)) {
      const btn = el("button", {
        className: "icon-btn",
        text: "✎",
        attrs: {
          type: "button",
          title: "Edit decl description",
          "aria-label": "Edit decl description"
        }
      });
      btn.addEventListener("click", (ev) => {
        ev.stopPropagation();
        editDeclDesc(decl);
      });
      wrap.appendChild(btn);
    }

    cell.appendChild(wrap);

    return cell;
  }

  function getDeclRenderKey(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }
    return (
      getDeclKey(decl) ||
      [
        decl.objectType || "",
        decl.scopeLabel || "",
        decl.name || "",
        decl.file || "",
        decl.lineStart || ""
      ].join("|")
    );
  }

  function dedupeDecls(list) {
    const output = [];
    const seen = new Set();
    for (const decl of list || []) {
      if (!decl) {
        continue;
      }
      const key = getDeclRenderKey(decl);
      if (!key || seen.has(key)) {
        continue;
      }
      seen.add(key);
      output.push(decl);
    }
    return output;
  }

  function getDeclListDisplayName(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const displayName = String(getDeclDisplayName(decl) || "").trim();
    const descText = String(getEffectiveDeclDesc(decl) || "").trim();
    if (
      displayName &&
      descText &&
      displayName.localeCompare(descText, undefined, { sensitivity: "accent" }) === 0
    ) {
      const techName = String(getDeclTechName(decl) || "").trim();
      if (techName) {
        return techName;
      }
    }

    return displayName || String(getDeclTechName(decl) || "").trim();
  }

  function renderDeclListCells(decls, fallbackDecl) {
    const list = dedupeDecls(Array.isArray(decls) ? decls.filter(Boolean) : []);
    const effectiveList = list.length ? list : dedupeDecls(fallbackDecl ? [fallbackDecl] : []);

    const nameCell = el("td");
    const descCell = el("td");

    if (!effectiveList.length) {
      return { nameCell, descCell };
    }

    const nameWrap = el("div");
    const descWrap = el("div");

    for (const decl of effectiveList) {
      const nameLine = el("div", { text: getDeclListDisplayName(decl) });
      const title = buildDeclTitle(decl);
      if (title) {
        nameLine.title = title;
      }

      if (decl && decl.lineStart) {
        nameLine.style.cursor = "pointer";
        nameLine.addEventListener("click", (ev) => {
          ev.stopPropagation();
          selectCodeLines(decl.lineStart, decl.lineStart);
          if (decl.id) {
            setSelectedCard(decl.id);
          }
        });
      }

      nameWrap.appendChild(nameLine);

      const descLineWrap = el("div", { className: "decl-desc-line" });
      const descLineText = el("div", { className: "decl-desc-text", text: getEffectiveDeclDesc(decl) || "" });
      if (title) {
        descLineText.title = title;
      }
      descLineWrap.appendChild(descLineText);

      if (getDeclOverrideStorageKey(decl)) {
        const btn = el("button", {
          className: "icon-btn",
          text: "✎",
          attrs: {
            type: "button",
            title: "Edit decl description",
            "aria-label": "Edit decl description"
          }
        });
        btn.addEventListener("click", (ev) => {
          ev.stopPropagation();
          editDeclDesc(decl);
        });
        descLineWrap.appendChild(btn);
      }

      descWrap.appendChild(descLineWrap);
    }

    nameCell.appendChild(nameWrap);
    descCell.appendChild(descWrap);
    return { nameCell, descCell };
  }

  function matchesFilters(obj) {
    const typeOk = !state.type || obj.objectType === state.type;
    if (!typeOk) {
      return false;
    }

    if (!state.query) {
      return true;
    }

    const id = normalizeId(obj && obj.id);
    const haystack = id ? state.haystackById.get(id) : "";
    return haystack ? haystack.includes(state.query) : false;
  }

  function filterTree(obj) {
    const children = Array.isArray(obj.children) ? obj.children : [];
    const filteredChildren = [];
    for (const child of children) {
      const filtered = filterTree(child);
      if (filtered) {
        filteredChildren.push(filtered);
      }
    }

    const selfMatches = matchesFilters(obj);
    if (!selfMatches && !filteredChildren.length) {
      return null;
    }

    return { obj, children: filteredChildren, selfMatches };
  }

  function el(tag, options) {
    const node = document.createElement(tag);
    if (options && options.className) {
      node.className = options.className;
    }
    if (options && options.text !== undefined) {
      node.textContent = options.text;
    }
    if (options && options.attrs) {
      for (const [key, value] of Object.entries(options.attrs)) {
        node.setAttribute(key, String(value));
      }
    }
    return node;
  }

  function renderKeywords(obj) {
    const keywords = getKeywordEntries(obj);
    if (!keywords.length) {
      return null;
    }

    const wrap = el("div");
    for (const keyword of keywords) {
      wrap.appendChild(
        el("span", {
          className: "pill",
          text: keyword && keyword.text ? String(keyword.text) : "",
          attrs: keyword && keyword.label ? { title: String(keyword.label) } : {}
        })
      );
    }
    return wrap;
  }

  function collectDeclsForValueEntry(obj, entry) {
    const decls = [];
    const addDecl = (decl) => {
      if (decl && typeof decl === "object") {
        decls.push(decl);
      }
    };

    const normalizedEntry = ensureEntryDeclForOutput(obj, cloneValueEntryForOutput(entry));

    addDecl(normalizedEntry && normalizedEntry.decl);
    addDecl(normalizedEntry && normalizedEntry.valueDecl);
    if (normalizedEntry && Array.isArray(normalizedEntry.originDecls)) {
      for (const originDecl of normalizedEntry.originDecls) {
        addDecl(originDecl);
      }
    }

    const extras = obj && obj.extras && typeof obj.extras === "object" ? obj.extras : null;
    if (!extras) {
      return dedupeDecls(decls);
    }

    const entryName = String(normalizedEntry && normalizedEntry.name ? normalizedEntry.name : "").trim().toLowerCase();
    if (!entryName) {
      return dedupeDecls(decls);
    }

    if (entryName === "condition" && extras.ifCondition) {
      collectConditionDeclsFromClauses(extras.ifCondition.conditions, addDecl);
    } else if (entryName === "ifcondition" && extras.performCall) {
      collectConditionDeclsFromClauses(extras.performCall.ifConditions, addDecl);
    } else if (entryName === "where") {
      if (extras.select) {
        collectConditionDeclsFromClauses(extras.select.whereConditions, addDecl);
      }
      if (extras.loopAtItab) {
        collectConditionDeclsFromClauses(extras.loopAtItab.conditions, addDecl);
      }
      if (extras.modifyItab) {
        collectConditionDeclsFromClauses(extras.modifyItab.conditions, addDecl);
      }
      if (extras.deleteItab) {
        collectConditionDeclsFromClauses(extras.deleteItab.conditions, addDecl);
      }
    } else if (entryName === "having" && extras.select) {
      collectConditionDeclsFromClauses(extras.select.havingConditions, addDecl);
    } else if ((entryName === "withkey" || entryName === "withtablekey") && extras.readTable) {
      collectConditionDeclsFromClauses(extras.readTable.conditions, addDecl);
    }

    return dedupeDecls(decls);
  }

  function isRawValueEntry(entry) {
    const name = entry && entry.name ? String(entry.name).trim() : "";
    return Boolean(name) && /raw$/i.test(name);
  }

  function makeSectionIndexName(sectionName, indexOneBased) {
    return `${sectionName}[${indexOneBased}]`;
  }

  function makeParsedValueRow({
    sectionName,
    indexOneBased,
    valueText,
    baseEntry,
    decl,
    valueDecl,
    originDecls,
    valueRef
  }) {
    const row = {
      name: makeSectionIndexName(sectionName, indexOneBased),
      value: valueText ? String(valueText) : "",
      label: baseEntry && baseEntry.label ? String(baseEntry.label) : sectionName,
      userDesc: baseEntry && baseEntry.userDesc ? String(baseEntry.userDesc) : "",
      codeDesc: baseEntry && baseEntry.codeDesc ? String(baseEntry.codeDesc) : ""
    };

    if (decl && typeof decl === "object") {
      row.decl = decl;
    }
    if (valueDecl && typeof valueDecl === "object") {
      row.valueDecl = valueDecl;
    }
    if (Array.isArray(originDecls) && originDecls.length) {
      row.originDecls = originDecls.filter((item) => item && typeof item === "object");
    }
    if (valueRef) {
      row.declRef = String(valueRef);
    }

    return row;
  }

  function buildParsedRowsFromPerformList(sectionName, list, baseEntry) {
    const items = Array.isArray(list) ? list : [];
    return items.map((item, index) => makeParsedValueRow({
      sectionName,
      indexOneBased: index + 1,
      valueText: item && item.value ? String(item.value) : "",
      baseEntry,
      decl: item && item.valueDecl ? item.valueDecl : (baseEntry && baseEntry.decl ? baseEntry.decl : null),
      valueDecl: item && item.valueDecl ? item.valueDecl : null,
      originDecls: item && Array.isArray(item.originDecls) ? item.originDecls : [],
      valueRef: item && item.valueRef ? String(item.valueRef) : ""
    }));
  }

  function buildParsedRowsFromAssignments(sectionName, list, baseEntry) {
    const items = Array.isArray(list) ? list : [];
    return items.map((item, index) => {
      const leftName = item && item.name ? String(item.name) : "";
      const rightValue = item && item.value ? String(item.value) : "";
      const valueText = leftName && rightValue
        ? `${leftName} = ${rightValue}`
        : (leftName || rightValue);
      return makeParsedValueRow({
        sectionName,
        indexOneBased: index + 1,
        valueText,
        baseEntry,
        decl: item && item.valueDecl ? item.valueDecl : (baseEntry && baseEntry.decl ? baseEntry.decl : null),
        valueDecl: item && item.valueDecl ? item.valueDecl : null,
        originDecls: item && Array.isArray(item.originDecls) ? item.originDecls : [],
        valueRef: item && item.valueRef ? String(item.valueRef) : ""
      });
    });
  }

  function buildParsedRowsFromParams(sectionName, list, baseEntry) {
    const items = Array.isArray(list) ? list : [];
    return items.map((param, index) => {
      const paramName = param && param.name ? String(param.name) : "";
      const typingText = formatTyping(param && param.typing);
      const valueText = [paramName, typingText].filter(Boolean).join(" ").trim();
      const origins = param && Array.isArray(param.originDecls) ? param.originDecls : [];
      return makeParsedValueRow({
        sectionName,
        indexOneBased: index + 1,
        valueText,
        baseEntry,
        decl: origins.length ? origins[0] : (baseEntry && baseEntry.decl ? baseEntry.decl : null),
        valueDecl: null,
        originDecls: origins,
        valueRef: ""
      });
    });
  }

  function buildParsedRowsFromExceptions(sectionName, list, baseEntry) {
    const items = Array.isArray(list) ? list : [];
    return items.map((item, index) => {
      const name = item && item.name ? String(item.name) : "";
      return makeParsedValueRow({
        sectionName,
        indexOneBased: index + 1,
        valueText: name,
        baseEntry,
        decl: baseEntry && baseEntry.decl ? baseEntry.decl : null,
        valueDecl: null,
        originDecls: item && Array.isArray(item.originDecls) ? item.originDecls : [],
        valueRef: ""
      });
    });
  }

  function buildParsedRowsForRawEntry(obj, baseEntry) {
    if (!obj || !baseEntry) {
      return [];
    }

    const extras = obj.extras && typeof obj.extras === "object" ? obj.extras : null;
    if (!extras) {
      return [];
    }

    const rawName = baseEntry.name ? String(baseEntry.name).trim().toLowerCase() : "";
    if (!rawName) {
      return [];
    }

    if (extras.performCall) {
      const sectionMap = {
        usingraw: "using",
        changingraw: "changing",
        tablesraw: "tables"
      };
      const sectionName = sectionMap[rawName];
      if (sectionName) {
        return buildParsedRowsFromPerformList(sectionName, extras.performCall[sectionName], baseEntry);
      }
    }

    if (extras.callFunction) {
      const sectionMap = {
        exportingraw: "exporting",
        importingraw: "importing",
        changingraw: "changing",
        tablesraw: "tables",
        exceptionsraw: "exceptions"
      };
      const sectionName = sectionMap[rawName];
      if (sectionName) {
        return buildParsedRowsFromAssignments(sectionName, extras.callFunction[sectionName], baseEntry);
      }
    }

    if (extras.callMethod) {
      const sectionMap = {
        exportingraw: "exporting",
        importingraw: "importing",
        changingraw: "changing",
        receivingraw: "receiving",
        exceptionsraw: "exceptions"
      };
      const sectionName = sectionMap[rawName];
      if (sectionName) {
        return buildParsedRowsFromAssignments(sectionName, extras.callMethod[sectionName], baseEntry);
      }
    }

    if (extras.form) {
      const paramsByRawName = {
        usingraw: "USING",
        changingraw: "CHANGING",
        tablesraw: "TABLES"
      };
      if (Object.prototype.hasOwnProperty.call(paramsByRawName, rawName)) {
        const sectionUpper = paramsByRawName[rawName];
        const params = Array.isArray(extras.form.params)
          ? extras.form.params.filter((param) => String(param && param.section ? param.section : "").toUpperCase() === sectionUpper)
          : [];
        return buildParsedRowsFromParams(sectionUpper.toLowerCase(), params, baseEntry);
      }
      if (rawName === "raisingraw") {
        return buildParsedRowsFromExceptions("raising", extras.form.exceptions, baseEntry);
      }
    }

    if (extras.methodSignature) {
      const paramsByRawName = {
        importingraw: "IMPORTING",
        exportingraw: "EXPORTING",
        changingraw: "CHANGING",
        returningraw: "RETURNING"
      };
      if (Object.prototype.hasOwnProperty.call(paramsByRawName, rawName)) {
        const sectionUpper = paramsByRawName[rawName];
        const params = Array.isArray(extras.methodSignature.params)
          ? extras.methodSignature.params.filter((param) => String(param && param.section ? param.section : "").toUpperCase() === sectionUpper)
          : [];
        return buildParsedRowsFromParams(sectionUpper.toLowerCase(), params, baseEntry);
      }
      if (rawName === "raisingraw") {
        return buildParsedRowsFromExceptions("raising", extras.methodSignature.exceptions, baseEntry);
      }
    }

    return [];
  }

  function cloneValueEntryForOutput(entry) {
    if (!entry || typeof entry !== "object") {
      return entry;
    }
    const out = { ...entry };
    if (Array.isArray(entry.originDecls)) {
      out.originDecls = entry.originDecls.slice();
    }
    return out;
  }

  function ensureEntryDeclForOutput(obj, entry) {
    if (!entry || typeof entry !== "object") {
      return entry;
    }
    const source = getDeclSourceContextFromObject(obj);
    const entryName = String(entry.name || "value").trim() || "value";
    return ensureEntryDeclWithSynthetic(entry, {
      pathKey: buildPathKeyFromParts([buildObjectPathBase(obj), "values", entryName]),
      file: source.file,
      lineStart: source.lineStart,
      raw: source.raw,
      role: "value"
    });
  }

  function buildRenderableValueEntries(obj) {
    const values = getValueEntries(obj);
    if (!values.length) {
      return [];
    }

    const rows = [];
    for (const entry of values) {
      const rawRow = cloneValueEntryForOutput(entry);
      if (!isRawValueEntry(entry)) {
        rows.push(ensureEntryDeclForOutput(obj, rawRow));
        continue;
      }

      const parsedRows = buildParsedRowsForRawEntry(obj, entry);
      if (parsedRows.length) {
        for (const parsedRow of parsedRows) {
          rows.push(ensureEntryDeclForOutput(obj, cloneValueEntryForOutput(parsedRow)));
        }
      } else {
        rows.push(ensureEntryDeclForOutput(obj, rawRow));
      }
    }

    return rows;
  }

  function renderValues(obj) {
    const values = buildRenderableValueEntries(obj);
    if (!values.length) {
      return null;
    }

    const table = el("table");
    const thead = el("thead");
    const headRow = el("tr");
    for (const name of ["name", "value", "label", "codeDesc", "declName", "declDesc"]) {
      headRow.appendChild(el("th", { text: name }));
    }
    thead.appendChild(headRow);
    table.appendChild(thead);

    const tbody = el("tbody");
    for (const entry of values) {
      const row = el("tr");
      const relatedDecls = collectDeclsForValueEntry(obj, entry);
      const declListCells = renderDeclListCells(
        relatedDecls.length ? relatedDecls : null,
        relatedDecls.length ? null : entry && entry.decl
      );
      row.appendChild(el("td", { text: entry && entry.name ? String(entry.name) : "" }));
      row.appendChild(el("td", { text: entry && entry.value ? String(entry.value) : "" }));
      row.appendChild(el("td", { text: entry && entry.label ? String(entry.label) : "" }));
      row.appendChild(el("td", { text: entry && entry.codeDesc ? String(entry.codeDesc) : "" }));
      row.appendChild(declListCells.nameCell);
      row.appendChild(declListCells.descCell);
      tbody.appendChild(row);
    }
    table.appendChild(tbody);
    return table;
  }

  function buildExtrasEntryPathKey(obj, extrasScope, sectionName, indexOneBased, itemKind) {
    return buildPathKeyFromParts([
      buildObjectPathBase(obj),
      "extras",
      extrasScope || "extras",
      sectionName || "section",
      `${itemKind || "item"}[${indexOneBased}]`
    ]);
  }

  function normalizeExtrasEntryForOutput(obj, extrasScope, sectionName, indexOneBased, entry) {
    if (!entry || typeof entry !== "object") {
      return entry;
    }

    const source = getDeclSourceContextFromObject(obj);
    const basePath = buildExtrasEntryPathKey(obj, extrasScope, sectionName, indexOneBased, "item");
    let next = cloneValueEntryForOutput(entry);
    next = ensureEntryDeclWithSynthetic(next, {
      pathKey: basePath,
      file: source.file,
      lineStart: source.lineStart,
      raw: source.raw,
      role: `${extrasScope || "extras"}:${sectionName || "entry"}`
    });
    next = ensureValueDeclWithSynthetic(next, {
      pathKey: basePath,
      file: source.file,
      lineStart: source.lineStart,
      raw: source.raw,
      role: `${extrasScope || "extras"}:${sectionName || "entry"}:value`,
      nameHint: sectionName || "value"
    });
    return next;
  }

  function renderAssignmentTable(title, list, context) {
    const items = Array.isArray(list) ? list : [];
    if (!items.length) {
      return null;
    }

    const obj = context && context.obj ? context.obj : null;
    const extrasScope = context && context.extrasScope ? String(context.extrasScope) : "extras";

    const section = el("div");
    section.appendChild(el("div", { className: "muted", text: title }));

    const table = el("table");
    const thead = el("thead");
    const headRow = el("tr");
    for (const key of ["name", "value", "ref", "declName", "declDesc"]) {
      headRow.appendChild(el("th", { text: key }));
    }
    thead.appendChild(headRow);
    table.appendChild(thead);

    const tbody = el("tbody");
    for (let index = 0; index < items.length; index += 1) {
      const entry = items[index];
      const normalizedEntry = normalizeExtrasEntryForOutput(obj, extrasScope, title, index + 1, entry);
      const row = el("tr");
      row.appendChild(el("td", { text: normalizedEntry && normalizedEntry.name ? String(normalizedEntry.name) : "" }));
      row.appendChild(el("td", { text: normalizedEntry && normalizedEntry.value ? String(normalizedEntry.value) : "" }));
      row.appendChild(el("td", { text: normalizedEntry && normalizedEntry.valueRef ? String(normalizedEntry.valueRef) : "" }));
      const { nameCell, descCell } = renderDeclListCells(
        normalizedEntry && normalizedEntry.originDecls,
        normalizedEntry && normalizedEntry.valueDecl
      );
      row.appendChild(nameCell);
      row.appendChild(descCell);
      tbody.appendChild(row);
    }
    table.appendChild(tbody);
    section.appendChild(table);
    return section;
  }

  function renderValueListTable(title, list, context) {
    const items = Array.isArray(list) ? list : [];
    if (!items.length) {
      return null;
    }

    const obj = context && context.obj ? context.obj : null;
    const extrasScope = context && context.extrasScope ? String(context.extrasScope) : "extras";

    const section = el("div");
    section.appendChild(el("div", { className: "muted", text: title }));

    const table = el("table");
    const thead = el("thead");
    const headRow = el("tr");
    for (const key of ["value", "ref", "declName", "declDesc"]) {
      headRow.appendChild(el("th", { text: key }));
    }
    thead.appendChild(headRow);
    table.appendChild(thead);

    const tbody = el("tbody");
    for (let index = 0; index < items.length; index += 1) {
      const entry = items[index];
      const normalizedEntry = normalizeExtrasEntryForOutput(obj, extrasScope, title, index + 1, entry);
      const row = el("tr");
      row.appendChild(el("td", { text: normalizedEntry && normalizedEntry.value ? String(normalizedEntry.value) : "" }));
      row.appendChild(el("td", { text: normalizedEntry && normalizedEntry.valueRef ? String(normalizedEntry.valueRef) : "" }));
      const { nameCell, descCell } = renderDeclListCells(
        normalizedEntry && normalizedEntry.originDecls,
        normalizedEntry && normalizedEntry.valueDecl
      );
      row.appendChild(nameCell);
      row.appendChild(descCell);
      tbody.appendChild(row);
    }
    table.appendChild(tbody);
    section.appendChild(table);
    return section;
  }

  function resolveConditionDeclForViewer(decl, refCandidate) {
    if (decl && typeof decl === "object") {
      return decl;
    }

    const ref = String(refCandidate || "").trim();
    if (!ref) {
      return null;
    }

    const decls = state.data && typeof state.data === "object" && Array.isArray(state.data.decls)
      ? state.data.decls
      : [];
    if (!decls.length) {
      return null;
    }

    const upperRef = ref.toUpperCase();
    let matched = null;
    for (const candidate of decls) {
      if (!candidate || typeof candidate !== "object") {
        continue;
      }
      const nameUpper = String(candidate.name || "").trim().toUpperCase();
      if (!nameUpper || nameUpper !== upperRef) {
        continue;
      }

      if (!matched) {
        matched = candidate;
      }

      const scopeUpper = String(candidate.scopeLabel || "").trim().toUpperCase();
      if (scopeUpper === "GLOBAL") {
        return candidate;
      }
    }

    return matched;
  }

  function renderConditionTable(title, clauses, context) {
    const items = Array.isArray(clauses) ? clauses : [];
    if (!items.length) {
      return null;
    }

    const obj = context && context.obj ? context.obj : null;
    const extrasScope = context && context.extrasScope ? String(context.extrasScope) : "extras";
    const source = getDeclSourceContextFromObject(obj);

    const section = el("div");
    if (title) {
      section.appendChild(el("div", { className: "muted", text: title }));
    }

    const table = el("table");
    const thead = el("thead");
    const headRow = el("tr");
    for (const key of [
      "leftOperand",
      "operator",
      "rightOperand",
      "connector",
      "leftRef",
      "leftDeclName",
      "leftDeclDesc",
      "rightRef",
      "rightDeclName",
      "rightDeclDesc"
    ]) {
      headRow.appendChild(el("th", { text: key }));
    }
    thead.appendChild(headRow);
    table.appendChild(thead);

    const tbody = el("tbody");
    for (let index = 0; index < items.length; index += 1) {
      const clause = items[index];
      const clausePath = buildExtrasEntryPathKey(obj, extrasScope, title || "conditions", index + 1, "clause");
      let normalizedClause = clause;
      let leftRef = clause && clause.leftOperandRef ? String(clause.leftOperandRef) : "";
      let rightRef = clause && clause.rightOperandRef ? String(clause.rightOperandRef) : "";
      const row = el("tr");
      const leftDecl = resolveConditionDeclForViewer(
        clause && clause.leftOperandDecl ? clause.leftOperandDecl : null,
        leftRef || (clause && clause.leftOperand ? clause.leftOperand : "")
      );
      const rightDecl = resolveConditionDeclForViewer(
        clause && clause.rightOperandDecl ? clause.rightOperandDecl : null,
        rightRef || (clause && clause.rightOperand ? clause.rightOperand : "")
      );
      let effectiveLeftDecl = leftDecl;
      let effectiveRightDecl = rightDecl;

      if (!effectiveLeftDecl || !effectiveRightDecl) {
        normalizedClause = ensureConditionClauseDeclsWithSynthetic(clause, {
          pathKey: clausePath,
          file: source.file,
          lineStart: source.lineStart,
          raw: source.raw
        });
        leftRef = normalizedClause && normalizedClause.leftOperandRef ? String(normalizedClause.leftOperandRef) : leftRef;
        rightRef = normalizedClause && normalizedClause.rightOperandRef ? String(normalizedClause.rightOperandRef) : rightRef;
        if (!effectiveLeftDecl) {
          effectiveLeftDecl = normalizedClause && normalizedClause.leftOperandDecl
            ? normalizedClause.leftOperandDecl
            : null;
        }
        if (!effectiveRightDecl) {
          effectiveRightDecl = normalizedClause && normalizedClause.rightOperandDecl
            ? normalizedClause.rightOperandDecl
            : null;
        }
      }

      row.appendChild(el("td", { text: normalizedClause && normalizedClause.leftOperand ? String(normalizedClause.leftOperand) : "" }));
      row.appendChild(el("td", { text: normalizedClause && normalizedClause.comparisonOperator ? String(normalizedClause.comparisonOperator) : "" }));
      row.appendChild(el("td", { text: normalizedClause && normalizedClause.rightOperand ? String(normalizedClause.rightOperand) : "" }));
      row.appendChild(el("td", { text: normalizedClause && normalizedClause.logicalConnector ? String(normalizedClause.logicalConnector) : "" }));
      row.appendChild(el("td", { text: leftRef }));

      const leftDeclCells = renderDeclListCells(null, effectiveLeftDecl);
      row.appendChild(leftDeclCells.nameCell);
      row.appendChild(leftDeclCells.descCell);

      row.appendChild(el("td", { text: rightRef }));
      const rightDeclCells = renderDeclListCells(null, effectiveRightDecl);
      row.appendChild(rightDeclCells.nameCell);
      row.appendChild(rightDeclCells.descCell);

      tbody.appendChild(row);
    }

    table.appendChild(tbody);
    section.appendChild(table);
    return section;
  }

  function appendConditionSection(wrap, title, rawText, clauses, context) {
    if (!wrap) {
      return;
    }

    const raw = String(rawText || "").trim();
    if (raw) {
      wrap.appendChild(el("div", { className: "muted", text: raw }));
    }

    const table = renderConditionTable(title, clauses, context);
    if (table) {
      wrap.appendChild(table);
    }
  }

  function renderParamsTable(title, params) {
    const items = Array.isArray(params) ? params : [];
    if (!items.length) {
      return null;
    }

    const section = el("div");
    section.appendChild(el("div", { className: "muted", text: title }));

    const table = el("table");
    const thead = el("thead");
    const headRow = el("tr");
    for (const key of ["section", "name", "typing", "doc", "declName", "declDesc"]) {
      headRow.appendChild(el("th", { text: key }));
    }
    thead.appendChild(headRow);
    table.appendChild(thead);

    const tbody = el("tbody");
    for (const param of items) {
      const row = el("tr");
      row.appendChild(el("td", { text: param && param.section ? String(param.section) : "" }));
      row.appendChild(el("td", { text: param && param.name ? String(param.name) : "" }));
      const typingText = formatTyping(param && param.typing);
      row.appendChild(el("td", { text: typingText }));
      const docText = param && param.doc
        ? [param.doc.direction || "", param.doc.text || ""].filter(Boolean).join(" ")
        : "";
      row.appendChild(el("td", { text: docText }));
      const { nameCell, descCell } = renderDeclListCells(param && param.originDecls);
      row.appendChild(nameCell);
      row.appendChild(descCell);
      tbody.appendChild(row);
    }
    table.appendChild(tbody);
    section.appendChild(table);
    return section;
  }

  function formatTyping(typing) {
    if (!typing) {
      return "";
    }
    if (typeof typing === "string") {
      return typing;
    }
    if (Array.isArray(typing)) {
      return typing.map((item) => formatTyping(item)).filter(Boolean).join(" ");
    }
    if (typeof typing === "object") {
      const kind = typing.kind ? String(typing.kind) : "";
      let value = "";

      if (typeof typing.value === "string") {
        value = typing.value;
      } else if (typing.value && typeof typing.value === "object") {
        if (typeof typing.value.value === "string") {
          value = typing.value.value;
        } else if (typeof typing.value.raw === "string") {
          value = typing.value.raw;
        } else if (typeof typing.value.name === "string") {
          value = typing.value.name;
        } else {
          value = safeJson(typing.value, false);
        }
      } else if (typing.value !== undefined && typing.value !== null) {
        value = String(typing.value);
      }

      return [kind, value].filter(Boolean).join(" ").trim();
    }
    return String(typing);
  }

  function renderNameList(title, items) {
    const list = Array.isArray(items) ? items : [];
    if (!list.length) {
      return null;
    }

    const section = el("div");
    section.appendChild(el("div", { className: "muted", text: title }));

    const wrap = el("div");
    for (const entry of list) {
      wrap.appendChild(el("span", { className: "pill", text: entry && entry.name ? String(entry.name) : "" }));
    }
    section.appendChild(wrap);
    return section;
  }

  function renderExtras(obj) {
    const extras = obj.extras;
    if (!extras || typeof extras !== "object") {
      return null;
    }

    const wrap = el("div", { className: "extras" });
    wrap.appendChild(el("div", { className: "muted", text: "Extras" }));

    if (extras.form) {
      const form = extras.form;
      const titleParts = [form.name ? `FORM ${form.name}` : ""].filter(Boolean);
      if (form.nameFromComment && form.nameFromComment !== form.name) {
        titleParts.push(`(comment: ${form.nameFromComment})`);
      }
      if (titleParts.length) {
        wrap.appendChild(el("div", { className: "muted", text: titleParts.join(" ") }));
      }

      const paramsTable = renderParamsTable("params", form.params);
      if (paramsTable) {
        wrap.appendChild(paramsTable);
      }

      const exceptions = renderNameList("exceptions", form.exceptions);
      if (exceptions) {
        wrap.appendChild(exceptions);
      }

      return wrap;
    }

    if (extras.methodSignature) {
      const signature = extras.methodSignature;
      if (signature.name) {
        wrap.appendChild(el("div", { className: "muted", text: `METHOD ${signature.name}` }));
      }

      const paramsTable = renderParamsTable("params", signature.params);
      if (paramsTable) {
        wrap.appendChild(paramsTable);
      }

      const exceptions = renderNameList("exceptions", signature.exceptions);
      if (exceptions) {
        wrap.appendChild(exceptions);
      }

      return wrap;
    }

    if (extras.callFunction) {
      const call = extras.callFunction;
      wrap.appendChild(el("div", { className: "muted", text: call.name ? `CALL FUNCTION ${call.name}` : "CALL FUNCTION" }));
      if (call.destination) {
        wrap.appendChild(el("div", { className: "muted", text: `DESTINATION ${call.destination}` }));
      }

      for (const sectionName of ["exporting", "importing", "changing", "tables", "exceptions"]) {
        const table = renderAssignmentTable(sectionName, call[sectionName], { obj, extrasScope: "callFunction" });
        if (table) {
          wrap.appendChild(table);
        }
      }

      return wrap;
    }

    if (extras.callMethod) {
      const call = extras.callMethod;
      wrap.appendChild(el("div", { className: "muted", text: call.target ? `CALL METHOD ${call.target}` : "CALL METHOD" }));

      for (const sectionName of ["exporting", "importing", "changing", "receiving", "exceptions"]) {
        const table = renderAssignmentTable(sectionName, call[sectionName], { obj, extrasScope: "callMethod" });
        if (table) {
          wrap.appendChild(table);
        }
      }

      return wrap;
    }

    if (extras.performCall) {
      const call = extras.performCall;
      wrap.appendChild(el("div", { className: "muted", text: call.form ? `PERFORM ${call.form}` : "PERFORM" }));
      if (call.program) {
        wrap.appendChild(el("div", { className: "muted", text: `IN PROGRAM ${call.program}` }));
      }
      appendConditionSection(
        wrap,
        "ifConditions",
        call.ifCondition ? `IF ${call.ifCondition}` : "",
        call.ifConditions,
        { obj, extrasScope: "performCall" }
      );

      for (const sectionName of ["using", "changing", "tables"]) {
        const table = renderValueListTable(sectionName, call[sectionName], { obj, extrasScope: "performCall" });
        if (table) {
          wrap.appendChild(table);
        }
      }

      return wrap;
    }

    if (extras.ifCondition) {
      const info = extras.ifCondition;
      appendConditionSection(
        wrap,
        "conditions",
        info.conditionRaw ? `IF ${info.conditionRaw}` : "",
        info.conditions,
        { obj, extrasScope: "ifCondition" }
      );
      return wrap;
    }

    if (extras.select) {
      const info = extras.select;
      appendConditionSection(
        wrap,
        "whereConditions",
        info.whereRaw ? `WHERE ${info.whereRaw}` : "",
        info.whereConditions,
        { obj, extrasScope: "select.where" }
      );
      appendConditionSection(
        wrap,
        "havingConditions",
        info.havingRaw ? `HAVING ${info.havingRaw}` : "",
        info.havingConditions,
        { obj, extrasScope: "select.having" }
      );
      return wrap;
    }

    if (extras.readTable) {
      const info = extras.readTable;
      const raw = info.withTableKeyRaw
        ? `WITH TABLE KEY ${info.withTableKeyRaw}`
        : (info.withKeyRaw ? `WITH KEY ${info.withKeyRaw}` : "");
      appendConditionSection(wrap, "conditions", raw, info.conditions, { obj, extrasScope: "readTable" });
      return wrap;
    }

    if (extras.loopAtItab) {
      const info = extras.loopAtItab;
      appendConditionSection(
        wrap,
        "conditions",
        info.whereRaw ? `WHERE ${info.whereRaw}` : "",
        info.conditions,
        { obj, extrasScope: "loopAtItab" }
      );
      return wrap;
    }

    if (extras.modifyItab) {
      const info = extras.modifyItab;
      appendConditionSection(
        wrap,
        "conditions",
        info.whereRaw ? `WHERE ${info.whereRaw}` : "",
        info.conditions,
        { obj, extrasScope: "modifyItab" }
      );
      return wrap;
    }

    if (extras.deleteItab) {
      const info = extras.deleteItab;
      appendConditionSection(
        wrap,
        "conditions",
        info.whereRaw ? `WHERE ${info.whereRaw}` : "",
        info.conditions,
        { obj, extrasScope: "deleteItab" }
      );
      return wrap;
    }

    wrap.appendChild(el("pre", { text: safeJson(extras, true) }));
    return wrap;
  }

  function renderMeta(obj) {
    const parts = [];
    if (obj.file) {
      parts.push(String(obj.file));
    }
    if (obj.lineStart) {
      parts.push(`line ${obj.lineStart}`);
    }
    if (obj.block && obj.block.lineEnd) {
      parts.push(`end ${obj.block.lineEnd}`);
    }
    if (obj.id !== undefined && obj.id !== null) {
      parts.push(`#${obj.id}`);
    }
    return parts.join(" • ");
  }

  function getObjectLabel(obj) {
    for (const key of ["name", "target", "form"]) {
      const value = getFirstValueFromValues(obj.values, key);
      if (value) {
        return value;
      }
    }

    if (obj.extras && obj.extras.callFunction && obj.extras.callFunction.name) {
      return String(obj.extras.callFunction.name);
    }
    if (obj.extras && obj.extras.callMethod && obj.extras.callMethod.target) {
      return String(obj.extras.callMethod.target);
    }
    if (obj.extras && obj.extras.performCall && obj.extras.performCall.form) {
      return String(obj.extras.performCall.form);
    }
    if (obj.extras && obj.extras.form && obj.extras.form.name) {
      return String(obj.extras.form.name);
    }
    if (obj.extras && obj.extras.methodSignature && obj.extras.methodSignature.name) {
      return String(obj.extras.methodSignature.name);
    }

    return "";
  }

  function renderNode(nodeInfo) {
    const obj = nodeInfo.obj;
    const id = normalizeId(obj.id);
    const children = nodeInfo.children || [];

    const cardAttrs = {};
    if (id) {
      cardAttrs["data-id"] = id;
    }
    if (obj && obj.lineStart) {
      cardAttrs["data-line-start"] = String(obj.lineStart);
    }

    const card = el("div", {
      className: `card${obj.block ? " block" : ""}${id && id === state.selectedId ? " selected" : ""}`,
      attrs: Object.keys(cardAttrs).length ? cardAttrs : {}
    });

    const header = el("div", { className: "card-header" });
    const label = getObjectLabel(obj);
    const titleText = `${String(obj.objectType || "(unknown)")}${label ? ` ${label}` : ""}`;
    const title = el("h3", { className: "card-title", text: titleText });

    const meta = renderMeta(obj);
    if (meta) {
      title.appendChild(el("span", { className: "muted", text: `  (${meta})` }));
    }

    header.appendChild(title);

    const actions = el("div", { className: "card-actions" });

    const btnCode = el("button", { className: "btn-ghost", text: "Code" });
    btnCode.type = "button";
    btnCode.addEventListener("click", (ev) => {
      ev.stopPropagation();
      setSelectedCard(id);
      const lineEnd = obj.block && obj.block.lineEnd ? obj.block.lineEnd : obj.lineStart;
      selectCodeLines(obj.lineStart, lineEnd);
    });
    actions.appendChild(btnCode);

    const btnJson = el("button", { className: "btn-ghost", text: "JSON" });
    btnJson.type = "button";
    btnJson.addEventListener("click", (ev) => {
      ev.stopPropagation();
      setSelectedCard(id);
      openJsonModal(obj);
    });
    actions.appendChild(btnJson);

    if (children.length) {
      const isCollapsed = state.collapsedIds.has(id);
      const btnCollapse = el("button", { className: "btn-ghost", text: isCollapsed ? "Expand" : "Collapse" });
      btnCollapse.type = "button";
      btnCollapse.addEventListener("click", (ev) => {
        ev.stopPropagation();
        if (state.collapsedIds.has(id)) {
          state.collapsedIds.delete(id);
        } else {
          state.collapsedIds.add(id);
        }
        renderOutput();
        setSelectedCard(id);
      });
      actions.appendChild(btnCollapse);
    }

    header.appendChild(actions);
    card.appendChild(header);

    if (obj.comment) {
      card.appendChild(el("div", { className: "muted", text: String(obj.comment) }));
    }

    if (state.showKeywords) {
      const kw = renderKeywords(obj);
      if (kw) {
        card.appendChild(kw);
      }
    }

    if (state.showValues) {
      const valuesTable = renderValues(obj);
      if (valuesTable) {
        card.appendChild(valuesTable);
      }
    }

    if (state.showRaw && obj.raw) {
      card.appendChild(el("div", { className: "raw", text: String(obj.raw) }));
    }

    if (state.showExtras) {
      const extras = renderExtras(obj);
      if (extras) {
        card.appendChild(extras);
      }
    }

    if (children.length && !state.collapsedIds.has(id)) {
      const childWrap = el("div", { className: "children" });
      for (const child of children) {
        childWrap.appendChild(renderNode(child));
      }
      card.appendChild(childWrap);
    }

    card.addEventListener("click", () => setSelectedCard(id));
    return card;
  }

  function populateTypeFilter(objects) {
    const types = new Set();
    walkObjects(objects, (obj) => {
      if (obj && obj.objectType) {
        types.add(String(obj.objectType));
      }
    });

    const sorted = Array.from(types).sort((a, b) => a.localeCompare(b));
    const current = els.typeFilter.value || "";

    while (els.typeFilter.options.length > 1) {
      els.typeFilter.remove(1);
    }

    for (const type of sorted) {
      const opt = document.createElement("option");
      opt.value = type;
      opt.textContent = type;
      els.typeFilter.appendChild(opt);
    }

    els.typeFilter.value = sorted.includes(current) ? current : "";
  }

  function renderOutput() {
    const scrollTop = els.output.scrollTop;
    setError("");

    if (!state.data || !Array.isArray(state.renderObjects)) {
      setOutputMessage("No data loaded.");
      refreshInputGutterTargets();
      return;
    }

    state.query = (els.searchInput.value || "").trim().toLowerCase();
    state.type = els.typeFilter.value || "";
    state.showRaw = Boolean(els.showRaw && els.showRaw.checked);
    state.showKeywords = Boolean(els.showKeywords && els.showKeywords.checked);
    state.showValues = Boolean(els.showValues && els.showValues.checked);
    state.showExtras = Boolean(els.showExtras && els.showExtras.checked);

    const filteredRoots = (state.renderObjects || [])
      .map((obj) => filterTree(obj))
      .filter(Boolean);

    if (!filteredRoots.length) {
      setOutputMessage("No matches.");
      refreshInputGutterTargets();
      return;
    }

    const frag = document.createDocumentFragment();
    for (const root of filteredRoots) {
      frag.appendChild(renderNode(root));
    }

    els.output.classList.remove("muted");
    els.output.replaceChildren(frag);
    els.output.scrollTop = scrollTop;

    if (state.selectedId) {
      setSelectedCard(state.selectedId);
    }

    refreshInputGutterTargets();
  }

  function normalizeParsedJson(json) {
    if (Array.isArray(json)) {
      return { file: "", objects: json, decls: [] };
    }
    if (json && typeof json === "object" && Array.isArray(json.objects)) {
      return {
        file: String(json.file || ""),
        objects: json.objects,
        decls: Array.isArray(json.decls) ? json.decls : []
      };
    }
    return null;
  }

window.AbapViewerModules.factories = window.AbapViewerModules.factories || {};
window.AbapViewerModules.factories["04-output-render"] = function registerOutputRender(runtime) {
  const targetRuntime = runtime || (window.AbapViewerRuntime = window.AbapViewerRuntime || {});
  targetRuntime.api = targetRuntime.api || {};
  targetRuntime.api.renderOutput = renderOutput;
  targetRuntime.api.buildAbapFlowXml = buildAbapFlowXml;
  targetRuntime.api.setRightTab = setRightTab;
  window.AbapViewerModules.parts["04-output-render"] = true;
};
window.AbapViewerModules.factories["04-output-render"](window.AbapViewerRuntime);
</script>
  <script>
// inlined from: ./app/05-main.js
"use strict";

window.AbapViewerModules = window.AbapViewerModules || {};
window.AbapViewerModules.parts = window.AbapViewerModules.parts || {};

  function parseFromTextarea(fileName) {
    const content = els.inputText.value || "";
    const trimmed = content.trim();
    const isJsonInput = (trimmed.startsWith("{") || trimmed.startsWith("[")) && trimmed.length > 1;
    state.inputMode = isJsonInput ? "json" : "abap";
    rebuildInputGutter();
    if (!trimmed) {
      setError("Input is empty.");
      setOutputMessage("No data loaded.");
      return;
    }

    state.inputLineOffsets = computeLineOffsets(content);

    if (isJsonInput) {
      try {
        const json = JSON.parse(trimmed);
        const parsed = normalizeParsedJson(json);
        if (!parsed) {
          throw new Error("JSON parsed, but shape is not { file, objects[] } or objects[].");
        }
        state.data = parsed;
      } catch (err) {
        setError(`JSON parse error: ${err && err.message ? err.message : err}`);
        setOutputMessage("No data loaded.");
        return;
      }
    } else {
      if (!window.AbapParser || typeof window.AbapParser.parseAbapText !== "function") {
        setError("AbapParser not loaded.");
        setOutputMessage("No data loaded.");
        return;
      }

      try {
        const builtInConfigs = typeof window.AbapParser.getConfigs === "function" ? window.AbapParser.getConfigs() : [];
        const customConfigs = getCustomConfigs();
        const configs = [...customConfigs, ...builtInConfigs];
        state.data = window.AbapParser.parseAbapText(content, configs, fileName || "");
      } catch (err) {
        setError(`Parse error: ${err && err.message ? err.message : err}`);
        setOutputMessage("No data loaded.");
        return;
      }
    }

    state.collapsedIds.clear();
    state.selectedId = "";
    state.selectedTemplateIndex = "";
    state.renderObjects = buildRenderableObjects(state.data && state.data.objects, RENDER_TREE_OPTIONS);
    state.haystackById = buildSearchIndex(state.renderObjects);
    populateTypeFilter(state.renderObjects);
    renderOutput();
    if (state.rightTab === "descriptions") {
      renderDeclDescPanelUi();
    } else if (state.rightTab === "template") {
      renderTemplatePreview();
    }
  }

  function resetUi() {
    els.searchInput.value = "";
    els.typeFilter.value = "";
    els.showRaw.checked = true;
    els.showKeywords.checked = true;
    els.showValues.checked = true;
    els.showExtras.checked = false;
    state.collapsedIds.clear();
    state.selectedId = "";
  }

  function collapseAll() {
    state.collapsedIds.clear();
    walkObjects(state.renderObjects, (obj) => {
      const id = normalizeId(obj && obj.id);
      const children = Array.isArray(obj && obj.children) ? obj.children : [];
      if (id && children.length) {
        state.collapsedIds.add(id);
      }
    });
  }

  function init() {
    renderBuildInfo();
    state.descOverrides = loadDescOverrides();
    state.descOverridesLegacy = loadLegacyDescOverrides();
    state.customRules = loadCustomRules();
    state.settings = loadSettings();
    state.templateConfig = loadTemplateConfig();
    state.templatePreviewCache = null;
    applyTheme(loadTheme(), { save: false });
    initLayoutSplitter();

    if (els.templateKeyMode) {
      els.templateKeyMode.textContent = "AUTO: objectType -> DEFAULT";
    }
    syncTemplateEditorFromState();
    setTemplateConfigError("");

    if (els.inputText && !els.inputText.value.trim()) {
      els.inputText.value = SAMPLE_ABAP;
    }

    rebuildInputGutter();

    if (els.inputText) {
      els.inputText.addEventListener("input", rebuildInputGutter);
      els.inputText.addEventListener("scroll", syncInputGutterScroll);
    }

    if (els.inputGutter) {
      els.inputGutter.addEventListener("click", onInputGutterClick);
      els.inputGutter.addEventListener("wheel", (ev) => {
        if (!els.inputText) {
          return;
        }
        els.inputText.scrollTop += ev.deltaY;
        syncInputGutterScroll();
        ev.preventDefault();
      }, { passive: false });
    }

    if (els.themeToggle) {
      els.themeToggle.addEventListener("change", () => {
        applyTheme(els.themeToggle.checked ? "dark" : "light");
      });
    }

    els.parseBtn.addEventListener("click", () => parseFromTextarea("input.abap"));
    els.searchInput.addEventListener("input", renderOutput);
    els.typeFilter.addEventListener("change", renderOutput);
    els.showRaw.addEventListener("change", renderOutput);
    els.showKeywords.addEventListener("change", renderOutput);
    els.showValues.addEventListener("change", renderOutput);
    els.showExtras.addEventListener("change", renderOutput);

    els.expandAllBtn.addEventListener("click", () => {
      state.collapsedIds.clear();
      renderOutput();
    });

    els.collapseAllBtn.addEventListener("click", () => {
      if (!state.data) {
        return;
      }
      collapseAll();
      renderOutput();
    });

    els.clearFiltersBtn.addEventListener("click", () => {
      resetUi();
      renderOutput();
    });

    els.descBtn.addEventListener("click", () => {
      setRightTab("descriptions");
    });

    if (els.rightTabOutputBtn) {
      els.rightTabOutputBtn.addEventListener("click", () => setRightTab("output"));
    }

    if (els.rightTabTemplateBtn) {
      els.rightTabTemplateBtn.addEventListener("click", () => setRightTab("template"));
    }

    if (els.rightTabDescBtn) {
      els.rightTabDescBtn.addEventListener("click", () => setRightTab("descriptions"));
    }

    if (els.templateCopyAllBtn) {
      els.templateCopyAllBtn.addEventListener("click", () => {
        copyAllTemplateBlocks()
          .then(() => setError(""))
          .catch((err) => setError(`Copy failed: ${err && err.message ? err.message : err}`));
      });
    }

    if (els.templateResetBtn) {
      els.templateResetBtn.addEventListener("click", resetTemplateConfig);
    }

    if (els.templateExportBtn) {
      els.templateExportBtn.addEventListener("click", exportTemplateConfig);
    }

    if (els.templateImportBtn && els.templateImportInput) {
      els.templateImportBtn.addEventListener("click", () => {
        els.templateImportInput.click();
      });
    }

    if (els.templateImportInput) {
      els.templateImportInput.addEventListener("change", async (ev) => {
        const file = ev && ev.target && ev.target.files ? ev.target.files[0] : null;
        if (!file) {
          return;
        }
        await importTemplateConfigFromFile(file);
        els.templateImportInput.value = "";
      });
    }

    if (els.templateApplyBtn) {
      els.templateApplyBtn.addEventListener("click", applyTemplateConfigFromEditor);
    }

    if (els.templateConfigJson) {
      els.templateConfigJson.addEventListener("keydown", (ev) => {
        if ((ev.ctrlKey || ev.metaKey) && ev.key === "Enter") {
          ev.preventDefault();
          applyTemplateConfigFromEditor();
        }
      });
    }

    if (els.declDescJsonBtn) {
      els.declDescJsonBtn.addEventListener("click", () => {
        openJsonModal({
          storageKey: DESC_STORAGE_KEY_V2,
          overrides: state.descOverrides,
          legacyStorageKey: DESC_STORAGE_KEY_LEGACY_V1,
          legacyOverrides: state.descOverridesLegacy,
          registry: window.AbapVarDescriptions || {}
        });
      });
    }

    if (els.declDescSearch) {
      els.declDescSearch.addEventListener("input", renderDeclDescPanelUi);
    }

    if (els.declDescMissingOnly) {
      els.declDescMissingOnly.addEventListener("change", renderDeclDescPanelUi);
    }

    if (els.rulesBtn) {
      els.rulesBtn.addEventListener("click", openRulesModal);
    }

    if (els.settingsBtn) {
      els.settingsBtn.addEventListener("click", openSettingsModal);
    }

    if (els.exportXmlBtn) {
      els.exportXmlBtn.addEventListener("click", () => {
        if (!state.data || !Array.isArray(state.data.objects)) {
          setError("No parsed data to export. Click Render first.");
          return;
        }
        setError("");
        openTextModal("Export XML", buildAbapFlowXml(state.data));
      });
    }

    els.fileInput.addEventListener("change", async (ev) => {
      const file = ev.target && ev.target.files ? ev.target.files[0] : null;
      if (!file) {
        return;
      }
      const text = await file.text();
      els.inputText.value = text;
      parseFromTextarea(file.name || "");
    });

    if (els.rulesCloseBtn) {
      els.rulesCloseBtn.addEventListener("click", closeRulesModal);
    }
    if (els.rulesModal) {
      els.rulesModal.addEventListener("click", (ev) => {
        if (ev.target === els.rulesModal) {
          closeRulesModal();
        }
      });
    }

    if (els.settingsCloseBtn) {
      els.settingsCloseBtn.addEventListener("click", closeSettingsModal);
    }
    if (els.settingsSaveBtn) {
      els.settingsSaveBtn.addEventListener("click", () => {
        applySettingsFromModal();
        closeSettingsModal();
      });
    }
    if (els.settingsResetBtn) {
      els.settingsResetBtn.addEventListener("click", resetSettingsToDefault);
    }
    if (els.settingsModal) {
      els.settingsModal.addEventListener("click", (ev) => {
        if (ev.target === els.settingsModal) {
          closeSettingsModal();
        }
      });
    }
    if (els.rulesNewBtn) {
      els.rulesNewBtn.addEventListener("click", startNewRule);
    }
    if (els.rulesSaveBtn) {
      els.rulesSaveBtn.addEventListener("click", saveRuleFromEditor);
    }
    if (els.rulesDeleteBtn) {
      els.rulesDeleteBtn.addEventListener("click", deleteActiveRule);
    }
    if (els.rulesDownloadBtn) {
      els.rulesDownloadBtn.addEventListener("click", downloadRuleFromEditor);
    }
    if (els.rulesSelect) {
      els.rulesSelect.addEventListener("change", () => {
        const id = els.rulesSelect.value || "";
        if (!id) {
          startNewRule();
          return;
        }
        selectRule(id);
      });
    }
    if (els.rulesTemplate) {
      els.rulesTemplate.addEventListener("change", () => {
        if (!state.activeRuleId) {
          startNewRule();
        }
      });
    }
    if (els.rulesJson) {
      els.rulesJson.addEventListener("keydown", (ev) => {
        if ((ev.ctrlKey || ev.metaKey) && ev.key === "Enter") {
          ev.preventDefault();
          saveRuleFromEditor();
        }
      });
    }

    els.jsonCloseBtn.addEventListener("click", closeJsonModal);
    els.jsonModal.addEventListener("click", (ev) => {
      if (ev.target === els.jsonModal) {
        closeJsonModal();
      }
    });
    els.jsonCopyBtn.addEventListener("click", () => {
      copyJsonToClipboard().catch((err) => setError(err && err.message ? err.message : err));
    });

    els.editCancelBtn.addEventListener("click", closeEditModal);
    els.editModal.addEventListener("click", (ev) => {
      if (ev.target === els.editModal) {
        closeEditModal();
      }
    });
    els.editSaveBtn.addEventListener("click", () => {
      applyEditModal("save");
      closeEditModal();
    });
    els.editClearBtn.addEventListener("click", () => {
      applyEditModal("clear");
      closeEditModal();
    });

    const onEditKeydown = (ev) => {
      if ((ev.ctrlKey || ev.metaKey) && ev.key === "Enter") {
        ev.preventDefault();
        applyEditModal("save");
        closeEditModal();
      }
    };

    els.editDesc.addEventListener("keydown", onEditKeydown);
    if (els.editStructDesc) {
      els.editStructDesc.addEventListener("keydown", onEditKeydown);
    }
    if (els.editItemDesc) {
      els.editItemDesc.addEventListener("keydown", onEditKeydown);
    }

    window.addEventListener("keydown", (ev) => {
      if (ev.key !== "Escape") {
        return;
      }

      if (!els.editModal.hidden) {
        closeEditModal();
        return;
      }

      if (els.rulesModal && !els.rulesModal.hidden) {
        closeRulesModal();
        return;
      }

      if (!els.jsonModal.hidden) {
        closeJsonModal();
        return;
      }

      if (state.rightTab === "descriptions" || state.rightTab === "template") {
        setRightTab("output");
        return;
      }
    });

    setRightTab(state.rightTab);
    parseFromTextarea("sample.abap");
  }

window.AbapViewerModules.factories = window.AbapViewerModules.factories || {};
window.AbapViewerModules.factories["05-main"] = function registerMain(runtime) {
  const targetRuntime = runtime || (window.AbapViewerRuntime = window.AbapViewerRuntime || {});
  targetRuntime.api = targetRuntime.api || {};
  targetRuntime.api.parseFromTextarea = parseFromTextarea;
  targetRuntime.api.init = init;

  window.AbapViewerModules.start = function startAbapViewer() {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", init, { once: true });
    } else {
      init();
    }
  };
  window.AbapViewerModules.parts["05-main"] = true;
};
window.AbapViewerModules.factories["05-main"](window.AbapViewerRuntime);
</script>
  <script>
// inlined from: ./app.js
"use strict";

(function () {
  window.AbapViewerModules = window.AbapViewerModules || {};
  window.AbapViewerModules.parts = window.AbapViewerModules.parts || {};
  window.AbapViewerRuntime = window.AbapViewerRuntime || {};
  window.AbapViewerRuntime.api = window.AbapViewerRuntime.api || {};

  const requiredParts = [
    "01-core",
    "02-descriptions",
    "03-template-preview",
    "04-output-render",
    "05-main"
  ];

  const missing = requiredParts.filter((name) => !window.AbapViewerModules.parts[name]);
  if (missing.length) {
    const message = `Viewer modules missing: ${missing.join(", ")}. Check script order in viewer/index.html.`;
    const errorEl = document.getElementById("error");
    if (errorEl) {
      errorEl.textContent = message;
    }
    try {
      console.error(message);
    } catch {
      // ignore
    }
    return;
  }

  const runtime = window.AbapViewerRuntime;
  runtime.els = runtime.els || null;
  runtime.state = runtime.state || null;
  runtime.constants = runtime.constants || {};
  runtime.api = runtime.api || {};

  if (typeof window.AbapViewerModules.start !== "function") {
    const message = "Viewer start function not found (window.AbapViewerModules.start).";
    const errorEl = document.getElementById("error");
    if (errorEl) {
      errorEl.textContent = message;
    }
    try {
      console.error(message);
    } catch {
      // ignore
    }
    return;
  }

  window.AbapViewerModules.start(runtime);
})();
</script>
</body>
</html>

