<!--
  AUTO-GENERATED FILE
  Source: E:/Documents/MyGitProject/Abap/viewer/index.html
  Generator: scripts/build-inline-viewer.py
  Do not edit this file directly. Regenerate instead.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ABAP Parser Viewer</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b1220;
      --panel: #0f172a;
      --border: #22324a;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --hover: #1e293b;
      --gutter-bg: #0b1526;
      --code-bg: #0b1526;
      --pill-bg: #1e293b;
      --pill-text: #bfdbfe;
      --selected-row-bg: #1e293b;
      --tab-active-bg: #1e293b;
      --tab-active-border: #334155;
      --tab-active-text: #bfdbfe;
      --danger: #fca5a5;
      --overlay: rgba(0, 0, 0, 0.55);
    }

    :root[data-theme="light"] {
      color-scheme: light;
      --bg: #f6f7f9;
      --panel: #ffffff;
      --border: #d8dde6;
      --text: #222b3a;
      --muted: #6b7280;
      --accent: #1f7ae0;
      --hover: #f3f4f6;
      --gutter-bg: #f8fafc;
      --code-bg: #f8fafc;
      --pill-bg: #eef2ff;
      --pill-text: #3730a3;
      --selected-row-bg: #eef2ff;
      --tab-active-bg: #eef2ff;
      --tab-active-border: #c7d2fe;
      --tab-active-text: #3730a3;
      --danger: #b42318;
      --overlay: rgba(15, 23, 42, 0.5);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, sans-serif;
      color: var(--text);
      background: var(--bg);
      height: 100vh;
      overflow: hidden;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px;
      height: 100vh;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    header {
      margin-bottom: 20px;
    }

    header h1 {
      margin: 0 0 6px 0;
      font-size: 22px;
    }

    header p {
      margin: 0;
      color: var(--muted);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }

    .controls input[type="file"] {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 6px;
      border-radius: 6px;
    }

    .controls button {
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
    }

    .controls input[type="search"],
    .controls select {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 13px;
      min-width: 220px;
    }

    .controls .toggle {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      color: var(--muted);
      font-size: 13px;
      user-select: none;
    }

    .controls .secondary {
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .controls .secondary:hover {
      background: var(--hover);
    }

    .secondary {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
    }

    .secondary:hover {
      background: var(--hover);
    }

    .controls .hint {
      flex-basis: 100%;
    }

    .layout {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      flex: 1;
      min-height: 0;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      min-height: 300px;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .panel-header h2 {
      margin: 0;
      font-size: 18px;
    }

    .panel-tabs {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .tab-btn.active {
      background: var(--tab-active-bg);
      border-color: var(--tab-active-border);
      color: var(--tab-active-text);
    }

    .panel > h2 {
      margin: 0 0 10px 0;
      font-size: 18px;
    }

    #inputText {
      width: 100%;
      min-height: 360px;
      padding: 10px;
      font-family: Consolas, monospace;
      font-size: 13px;
      line-height: 18px;
      resize: none;
      flex: 1;
      min-height: 0;
      border: none;
      outline: none;
      white-space: pre;
      overflow-wrap: normal;
      background: transparent;
      color: var(--text);
    }

    .input-editor {
      width: 100%;
      display: flex;
      flex: 1;
      min-height: 0;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      background: var(--panel);
    }

    #inputGutter {
      width: 68px;
      flex: none;
      border-right: 1px solid var(--border);
      background: var(--gutter-bg);
      color: var(--muted);
      font-family: Consolas, monospace;
      font-size: 12px;
      line-height: 18px;
      position: relative;
      overflow: hidden;
      user-select: none;
    }

    #inputGutterContent {
      padding: 10px 6px;
      will-change: transform;
    }

    .gutter-line {
      height: 18px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .gutter-num {
      flex: 1;
      text-align: right;
    }

    .gutter-jump {
      border: 1px solid transparent;
      background: transparent;
      color: var(--muted);
      padding: 0 4px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      line-height: 1.2;
    }

    .gutter-jump:hover {
      background: var(--hover);
      border-color: var(--border);
      color: var(--text);
    }

    .gutter-jump:focus {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }

    .modal textarea {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      font-family: Consolas, monospace;
      font-size: 13px;
      resize: vertical;
      min-height: 140px;
      max-height: 40vh;
      background: var(--panel);
      color: var(--text);
    }

    .error {
      color: var(--danger);
      font-size: 13px;
      margin-top: 8px;
      white-space: pre-wrap;
    }

    #output {
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding-right: 6px;
    }

    #declDescPanel {
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding-right: 6px;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .card.block {
      border-left: 4px solid var(--accent);
    }

    .card.selected {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }

    .card-title {
      margin: 0;
      font-size: 16px;
      line-height: 1.2;
    }

    .card-actions {
      display: inline-flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .btn-ghost {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 4px 8px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .btn-ghost:hover {
      background: var(--hover);
    }

    .muted {
      color: var(--muted);
      font-size: 13px;
    }

    .raw {
      margin-top: 8px;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--code-bg);
      font-family: Consolas, monospace;
      font-size: 13px;
      white-space: pre-wrap;
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--pill-bg);
      color: var(--pill-text);
      font-size: 12px;
      margin: 2px 4px 2px 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 13px;
    }

    th, td {
      text-align: left;
      border-bottom: 1px solid var(--border);
      padding: 6px 4px;
      vertical-align: top;
    }

    tr.desc-selected td {
      background: var(--selected-row-bg);
    }

    .decl-desc,
    .decl-desc-line {
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .decl-desc-text {
      flex: 1;
      min-width: 0;
      white-space: pre-wrap;
    }

    .icon-btn {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
      padding: 2px 6px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      line-height: 1.1;
    }

    .icon-btn:hover {
      background: var(--hover);
      color: var(--text);
    }

    .icon-btn:focus {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }

    th {
      color: var(--muted);
      font-weight: 600;
    }

    .children {
      margin-top: 12px;
      padding-left: 12px;
      border-left: 2px solid var(--border);
    }

    .extras {
      margin-top: 10px;
      padding-top: 8px;
      border-top: 1px dashed var(--border);
    }

    pre {
      white-space: pre-wrap;
      margin: 6px 0 0 0;
    }

    .modal[hidden] {
      display: none;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: var(--overlay);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 1000;
    }

    .modal-content {
      width: min(1000px, 100%);
      max-height: 85vh;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      gap: 10px;
    }

    .modal-header .modal-actions {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .modal-body {
      padding: 12px;
      overflow: auto;
      min-height: 0;
    }

    .modal-body pre {
      white-space: pre;
      font-family: Consolas, monospace;
      font-size: 12px;
    }

    #editModal,
    #jsonModal {
      z-index: 1100;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ABAP Parser Viewer</h1>
      <p>Paste ABAP code (or JSON output) and click Render.</p>
    </header>

    <div class="controls">
      <input type="file" id="fileInput" accept=".abap,.txt,.json,application/json,text/plain">
      <button type="button" id="parseBtn">Render</button>
      <input type="search" id="searchInput" placeholder="Search (raw/comment/value/decl)…">
      <select id="typeFilter">
        <option value="">All types</option>
      </select>
      <label class="toggle"><input type="checkbox" id="showRaw" checked>raw</label>
      <label class="toggle"><input type="checkbox" id="showKeywords" checked>keywords</label>
      <label class="toggle"><input type="checkbox" id="showValues" checked>values</label>
      <label class="toggle"><input type="checkbox" id="showExtras" checked>extras</label>
      <label class="toggle"><input type="checkbox" id="themeToggle" checked>dark</label>
      <button type="button" id="expandAllBtn" class="secondary">Expand all</button>
      <button type="button" id="collapseAllBtn" class="secondary">Collapse all</button>
      <button type="button" id="clearFiltersBtn" class="secondary">Clear</button>
      <button type="button" id="descBtn" class="secondary">Descriptions</button>
      <button type="button" id="rulesBtn" class="secondary">Rules</button>
      <button type="button" id="settingsBtn" class="secondary">Settings</button>
      <button type="button" id="exportXmlBtn" class="secondary">Export XML</button>
      <span class="muted hint">Tip: click “Code” on a card to select the corresponding lines in the input; click “JSON” to inspect the raw object.</span>
    </div>

    <div class="layout">
      <div class="panel">
        <h2>Input (ABAP / JSON)</h2>
        <div class="input-editor" id="inputEditor">
          <div id="inputGutter"><div id="inputGutterContent"></div></div>
          <textarea id="inputText" placeholder="Paste ABAP code here" wrap="off"></textarea>
        </div>
        <div class="error" id="error"></div>
      </div>

      <div class="panel">
        <div class="panel-header">
          <h2 id="rightPanelTitle">Output</h2>
          <div class="panel-tabs">
            <button type="button" id="rightTabOutputBtn" class="secondary tab-btn active">Output</button>
            <button type="button" id="rightTabDescBtn" class="secondary tab-btn">Descriptions</button>
            <button type="button" id="declDescJsonBtn" class="secondary" hidden>Storage JSON</button>
          </div>
        </div>
        <div id="output" class="muted">No data loaded.</div>
        <div id="declDescPanel" hidden>
          <div class="controls" style="margin-bottom:8px">
            <input type="search" id="declDescSearch" placeholder="Search (type/scope/id/desc)…">
            <label class="toggle"><input type="checkbox" id="declDescMissingOnly" checked>missing only</label>
          </div>
          <div class="muted" style="margin-bottom:6px">Declaration types</div>
          <div id="declDescTypes" class="controls" style="margin-bottom:8px"></div>
          <div class="muted" id="declDescSummary" style="margin-bottom:8px"></div>
          <div id="declDescTable"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="modal" id="jsonModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <strong id="jsonTitle">Object JSON</strong>
        <div class="modal-actions">
          <button type="button" id="jsonCopyBtn" class="secondary">Copy</button>
          <button type="button" id="jsonCloseBtn" class="secondary">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <pre id="jsonPre"></pre>
      </div>
    </div>
  </div>

  <div class="modal" id="editModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <strong>Edit description</strong>
        <div class="modal-actions">
          <button type="button" id="editSaveBtn" class="secondary">Save</button>
          <button type="button" id="editClearBtn" class="secondary">Clear</button>
          <button type="button" id="editCancelBtn" class="secondary">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <div class="muted" id="editLabel" style="margin-bottom:8px"></div>
        <div class="muted" id="editHint" style="margin-bottom:8px"></div>
        <div id="editSingleWrap">
          <textarea id="editDesc" placeholder="Enter description…"></textarea>
        </div>
        <div id="editStructWrap" hidden>
          <div class="muted" style="margin-bottom:6px">Struct description</div>
          <textarea id="editStructDesc" placeholder="Enter struct description…"></textarea>
          <div class="muted" style="margin:8px 0 6px">Item description</div>
          <textarea id="editItemDesc" placeholder="Enter item description…"></textarea>
        </div>
        <div style="margin-top:8px">
          <label class="toggle"><input type="checkbox" id="editSkipNormalize">Skip normalization for this user description</label>
        </div>
        <div class="muted" style="margin-top:8px">Tip: Ctrl+Enter to save, Esc to close.</div>
      </div>
    </div>
  </div>

  <div class="modal" id="rulesModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <strong>Rules</strong>
        <div class="modal-actions">
          <button type="button" id="rulesNewBtn" class="secondary">New</button>
          <button type="button" id="rulesSaveBtn" class="secondary">Save</button>
          <button type="button" id="rulesDeleteBtn" class="secondary">Delete</button>
          <button type="button" id="rulesDownloadBtn" class="secondary">Download</button>
          <button type="button" id="rulesCloseBtn" class="secondary">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <div class="controls" style="margin-bottom:8px">
          <select id="rulesSelect" style="min-width:320px">
            <option value="">(New rule)</option>
          </select>
          <select id="rulesTemplate" style="min-width:220px">
            <option value="startKeyword">Template: startKeyword</option>
            <option value="startPhrase">Template: startPhrase</option>
            <option value="assignment">Template: assignment</option>
          </select>
          <span class="muted">Saved in browser (localStorage). Custom rules take priority when parsing.</span>
        </div>
        <div class="error" id="rulesError"></div>
        <textarea id="rulesJson" placeholder="Paste or edit config JSON here…"></textarea>
        <div class="muted" style="margin-top:8px">Tip: click Save, then Render to test; Download creates a .json you can add into /configs.</div>
      </div>
    </div>
  </div>

  <div class="modal" id="settingsModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <strong>Settings</strong>
        <div class="modal-actions">
          <button type="button" id="settingsSaveBtn" class="secondary">Save</button>
          <button type="button" id="settingsResetBtn" class="secondary">Reset</button>
          <button type="button" id="settingsCloseBtn" class="secondary">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <div class="muted" style="margin-bottom:8px">
          Placeholders:
          <code>{{struct}}</code>, <code>{{item}}</code>, <code>{{desc}}</code>
        </div>

        <div style="margin-bottom:16px">
          <label class="toggle"><input type="checkbox" id="settingsNormalizeDesc">Normalize decl <code>desc</code> (apply templates)</label>
        </div>

        <div style="margin-bottom:16px">
          <div class="muted" style="margin-bottom:6px">Declaration types shown in Descriptions modal</div>
          <div id="settingsDeclTypes" class="controls" style="margin-bottom:0"></div>
        </div>

        <div style="margin-bottom:16px">
          <div class="muted" style="margin-bottom:6px">Struct desc template (used for struct fields)</div>
          <input type="text" id="settingsStructTemplate" placeholder="{{struct}}-{{item}}" style="width:100%">
        </div>

        <div style="margin-bottom:8px">
          <div class="muted" style="margin-bottom:6px">Name normalization templates (use {{desc}})</div>
          <div id="settingsNameTemplates"></div>
        </div>

        <div class="muted" style="margin-top:8px">
          Prefix match: 1 char + CODE (e.g. <code>GCN_TOTAL</code>). If no description, keep technical ID.
        </div>
      </div>
    </div>
  </div>

  <script>
// inlined from: ../shared/abap-parser.js
(function (root, factory) {
  if (typeof module === "object" && module.exports) {
    module.exports = factory();
    return;
  }

  root.AbapParser = factory();
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this), function () {
  "use strict";

  class AbapObject {
    constructor({
      id = null,
      parent = null,
      objectType,
      file,
      lineStart,
      raw,
      block = null,
      extras = null,
      comment,
      keywords,
      values,
      children = []
    }) {
      this.id = id;
      this.parent = parent;
      this.objectType = objectType;
      this.file = file;
      this.lineStart = lineStart;
      this.raw = raw;
      this.block = block;
      this.extras = extras;
      this.comment = comment;
      this.keywords = keywords;
      this.values = values;
      this.children = children;
    }
  }

  const registeredConfigs = [];

  function registerConfig(config) {
    registeredConfigs.push(normalizeConfig(config));
  }

  function getConfigs() {
    return registeredConfigs.slice();
  }

  function normalizeConfig(config) {
    const normalized = {
      ...config,
      match: config.match || {},
      block: config.block || null,
      keywordLabels: normalizeMapKeys(config.keywordLabels),
      keywordPhrases: normalizeMapKeys(config.keywordPhrases),
      captureRules: normalizeCaptureRules(config.captureRules),
      valueDescriptions: normalizeValueDescriptions(config.valueDescriptions)
    };

    if (normalized.match.startKeyword) {
      normalized.match.startKeyword = String(normalized.match.startKeyword).toUpperCase();
    }

    if (normalized.match.startPhrase) {
      normalized.match.startTokens = String(normalized.match.startPhrase)
        .trim()
        .toUpperCase()
        .split(/\s+/)
        .filter(Boolean);
    } else {
      normalized.match.startTokens = [];
    }

    if (normalized.block && normalized.block.endKeyword) {
      normalized.block = {
        ...normalized.block,
        endKeyword: String(normalized.block.endKeyword).toUpperCase()
      };
    }

    return normalized;
  }

  function normalizeMapKeys(map) {
    if (!map) {
      return {};
    }

    const output = {};
    for (const key of Object.keys(map)) {
      output[String(key).toUpperCase()] = map[key];
    }
    return output;
  }

  function normalizeCaptureRules(rules) {
    if (!Array.isArray(rules)) {
      return [];
    }

    return rules.map((rule) => {
      const after = rule.after || "";
      const afterTokens = String(after)
        .trim()
        .toUpperCase()
        .split(/\s+/)
        .filter(Boolean);

      const stopTokensUpper = Array.isArray(rule.stopTokens)
        ? rule.stopTokens
            .map((token) => String(token).trim().toUpperCase())
            .filter(Boolean)
        : [];

      return {
        ...rule,
        afterTokens,
        capture: rule.capture || "next",
        stopTokensUpper
      };
    });
  }

  function normalizeValueDescriptions(desc) {
    if (!desc) {
      return {};
    }

    const output = {};
    for (const key of Object.keys(desc)) {
      output[key] = normalizeMapKeys(desc[key]);
    }
    return output;
  }

  function parseAbapText(content, configs, fileName) {
    const lines = String(content || "").split(/\r?\n/);
    const statements = collectStatements(lines);
    const list = Array.isArray(configs) ? configs : registeredConfigs;
    const objects = parseStatements(statements, list, fileName || "");

    const decls = attachDeclarationRefs({ statements, objects, fileName: fileName || "" });

    return {
      file: fileName || "",
      objects,
      decls
    };
  }

  function collectStatements(lines) {
    const statements = [];
    let current = null;
    let pendingComments = [];

    for (let index = 0; index < lines.length; index += 1) {
      const lineNumber = index + 1;
      const rawLine = lines[index];
      const trimmed = rawLine.trim();

      if (!trimmed) {
        continue;
      }

      if (isCommentLine(trimmed)) {
        const commentText = normalizeComment(trimmed);
        if (current) {
          current.comments.push(commentText);
        } else {
          pendingComments.push(commentText);
        }
        continue;
      }

      const { code, comment } = splitCodeAndInlineComment(rawLine);
      const codeTrim = code.trim();

      if (!codeTrim) {
        if (comment) {
          pendingComments.push(comment);
        }
        continue;
      }

      if (!current) {
        current = {
          lineStart: lineNumber,
          rawParts: [],
          comments: pendingComments,
          leadingComments: pendingComments.slice(),
          lineEntries: []
        };
        pendingComments = [];
      }

      current.rawParts.push(codeTrim);
      if (comment) {
        current.comments.push(comment);
      }
      current.lineEntries.push({ line: lineNumber, code: codeTrim, comment: comment || "" });

      if (codeTrim.endsWith(".")) {
        const raw = current.rawParts.join(" ").replace(/\s+/g, " ").trim();
        const commentText = current.comments.filter(Boolean).join(" ").trim();

        statements.push({
          lineStart: current.lineStart,
          raw,
          comment: commentText,
          commentLines: current.comments.filter(Boolean),
          leadingComments: current.leadingComments ? current.leadingComments.slice() : [],
          lineEntries: current.lineEntries.slice()
        });

        current = null;
      }
    }

    return statements;
  }

  function isCommentLine(trimmedLine) {
    return trimmedLine.startsWith("*") || trimmedLine.startsWith('"');
  }

  function normalizeComment(trimmedLine) {
    if (trimmedLine.startsWith("*") || trimmedLine.startsWith('"')) {
      return trimmedLine.slice(1).trim();
    }
    return trimmedLine.trim();
  }

  function splitCodeAndInlineComment(line) {
    const index = line.indexOf('"');
    if (index === -1) {
      return { code: line, comment: "" };
    }

    const code = line.slice(0, index);
    const comment = line.slice(index + 1).trim();
    return { code, comment };
  }

  function parseStatements(statements, configs, fileName) {
    const roots = [];
    const stack = [];
    let nextId = 1;

    for (const statement of statements) {
      const statementStart = getStatementStartKeyword(statement.raw);
      const currentFrame = stack.length ? stack[stack.length - 1] : null;

      if (currentFrame && statementStart === currentFrame.endKeyword) {
        currentFrame.node.block.endRaw = statement.raw;
        currentFrame.node.block.lineEnd = statement.lineStart;
        stack.pop();
        continue;
      }

      const parentId = currentFrame ? currentFrame.node.id : null;
      const parsedList = parseStatement(statement, configs, fileName, parentId, () => nextId++);
      if (!parsedList || !parsedList.length) {
        continue;
      }

      const targetList = currentFrame ? currentFrame.node.children : roots;
      for (const node of parsedList) {
        targetList.push(node);
        if (node.block && node.block.endKeyword) {
          stack.push({ node, endKeyword: node.block.endKeyword });
        }
      }
    }

    return roots;
  }

  function getStatementStartKeyword(raw) {
    const tokens = tokenize(raw);
    if (!tokens.length) {
      return "";
    }
    return tokens[0].upper;
  }

  function parseStatement(statement, configs, fileName, parentId, nextId) {
    const tokens = tokenize(statement.raw);
    if (tokens.length === 0) {
      return null;
    }

    for (const config of configs) {
      if (!matchesConfig(tokens, config)) {
        continue;
      }

      const startKeyword = config.match && config.match.startKeyword;
      if (startKeyword && isChainedStatementStart(statement.raw, startKeyword)) {
        const chainedStatements = splitChainedStatement(statement.raw, startKeyword);
        const chainedObjects = [];
        const structStack = [];

        for (const raw of chainedStatements) {
          const obj = buildObjectFromRaw(raw, config, statement, fileName, nextId(), parentId);
          if (!obj) {
            continue;
          }

          const segTokens = tokenize(raw);
          const marker = detectStructMarkerFromTokens(segTokens, startKeyword);
          if (marker) {
            const normalizedName = normalizeIdentifierCandidate(marker.name);
            const nameUpper = normalizedName ? normalizedName.toUpperCase() : "";
            const rootUpper = structStack.length ? structStack[0].nameUpper : nameUpper;
            const isRootBegin = marker.kind === "BEGIN" && structStack.length === 0;

            if (marker.kind === "BEGIN") {
              structStack.push({ nameUpper, name: normalizedName || marker.name });
            } else if (marker.kind === "END") {
              // Pop 1 level when names match; otherwise just pop once (best-effort).
              if (structStack.length) {
                const top = structStack[structStack.length - 1];
                if (top && top.nameUpper && top.nameUpper === nameUpper) {
                  structStack.pop();
                } else {
                  structStack.pop();
                }
              }
            }

            attachStructMeta(obj, {
              kind: marker.kind,
              rootNameUpper: rootUpper || nameUpper,
              depth: marker.kind === "BEGIN" ? structStack.length : structStack.length + 1,
              isDecl: isRootBegin
            });
          } else if (structStack.length) {
            attachStructMeta(obj, {
              kind: "FIELD",
              rootNameUpper: structStack[0].nameUpper,
              depth: structStack.length,
              isDecl: false
            });
          } else {
            attachStructMeta(obj, null);
          }

          chainedObjects.push(obj);
        }

        return chainedObjects.length ? chainedObjects : null;
      }

      const object = buildObjectFromRaw(statement.raw, config, statement, fileName, nextId(), parentId);
      if (object && startKeyword) {
        const marker = detectStructMarkerFromTokens(tokenize(statement.raw), startKeyword);
        if (marker) {
          const normalizedName = normalizeIdentifierCandidate(marker.name);
          const nameUpper = normalizedName ? normalizedName.toUpperCase() : "";
          attachStructMeta(object, {
            kind: marker.kind,
            rootNameUpper: nameUpper,
            depth: 1,
            isDecl: marker.kind === "BEGIN"
          });
        } else {
          attachStructMeta(object, null);
        }
      }
      return object ? [object] : null;
    }

    return null;
  }

  function detectStructMarkerFromTokens(tokens, startKeyword) {
    if (!startKeyword || !Array.isArray(tokens) || tokens.length < 4) {
      return null;
    }

    if (!tokens[0] || tokens[0].upper !== String(startKeyword).toUpperCase()) {
      return null;
    }

    const t1 = tokens[1] ? tokens[1].upper : "";
    const t2 = tokens[2] ? tokens[2].upper : "";
    const t3 = tokens[3] ? tokens[3].raw : "";

    if (t1 === "BEGIN" && t2 === "OF" && t3) {
      return { kind: "BEGIN", name: t3 };
    }

    if (t1 === "END" && t2 === "OF" && t3) {
      return { kind: "END", name: t3 };
    }

    return null;
  }

  function attachStructMeta(obj, meta) {
    if (!obj) {
      return;
    }

    if (!meta) {
      return;
    }

    const existingExtras = obj.extras && typeof obj.extras === "object" ? obj.extras : null;
    obj.extras = {
      ...(existingExtras || {}),
      structDef: {
        kind: meta.kind || "",
        rootNameUpper: meta.rootNameUpper || "",
        depth: Number(meta.depth || 0) || 0,
        isDecl: Boolean(meta.isDecl)
      }
    };
  }

  function matchesConfig(tokens, config) {
    const match = config.match || {};
    const matchType = match.type ? String(match.type).trim().toLowerCase() : "";
    if (matchType === "assignment") {
      return isAssignmentStatement(tokens);
    }
    if (match.startTokens && match.startTokens.length) {
      return matchesTokens(tokens, 0, match.startTokens);
    }

    const startKeyword = match.startKeyword;
    if (startKeyword) {
      return tokens[0].upper === startKeyword;
    }

    return false;
  }

  function buildObjectFromRaw(raw, config, statement, fileName, id, parentId) {
    const tokens = tokenize(raw);
    if (tokens.length === 0) {
      return null;
    }

    const keywords = detectKeywords(tokens, config);
    const match = config.match || {};
    const matchType = match.type ? String(match.type).trim().toLowerCase() : "";
    const values = matchType === "assignment"
      ? captureAssignmentValues(tokens, statement.comment)
      : captureValues(tokens, config, statement.comment);
    const extras = buildExtras(config, {
      raw,
      values,
      commentLines: statement.commentLines || []
    });
    const block = config.block && config.block.endKeyword
      ? {
          endKeyword: config.block.endKeyword,
          endRaw: "",
          lineEnd: null
        }
      : null;

    return new AbapObject({
      id,
      parent: parentId,
      objectType: config.object,
      file: fileName,
      lineStart: statement.lineStart,
      raw,
      block,
      extras,
      comment: statement.comment,
      keywords,
      values,
      children: []
    });
  }

  function isAssignmentStatement(tokens) {
    if (!Array.isArray(tokens) || tokens.length < 3) {
      return false;
    }

    const op = tokens[1] && tokens[1].upper ? tokens[1].upper : "";
    const assignmentOps = new Set(["=", "+=", "-=", "*=", "/=", "?="]);
    return assignmentOps.has(op);
  }

  function buildExtras(config, context) {
    const extrasConfig = config.extras || null;
    if (!extrasConfig || !extrasConfig.type) {
      return null;
    }

    if (extrasConfig.type === "form") {
      return buildFormExtras(context);
    }

    if (extrasConfig.type === "callFunction") {
      return buildCallFunctionExtras(context);
    }

    if (extrasConfig.type === "callMethod") {
      return buildCallMethodExtras(context);
    }

    if (extrasConfig.type === "methodSignature") {
      return buildMethodSignatureExtras(context);
    }

    if (extrasConfig.type === "performCall") {
      return buildPerformCallExtras(context);
    }

    return null;
  }

  function buildFormExtras({ raw, values, commentLines }) {
    const map = valuesToFirstValueMap(values);
    const formName = map.name || "";

    const commentInfo = parseFormDocComment(commentLines || []);
    const signature = parseFormSignature(map);

    const docsByNameUpper = new Map(
      commentInfo.params.map((param) => [param.name.toUpperCase(), param])
    );

    const params = signature.params.map((param) => {
      const doc = docsByNameUpper.get(param.name.toUpperCase());
      return {
        ...param,
        doc: doc ? { direction: doc.direction, text: doc.text } : null
      };
    });

    const docOnly = commentInfo.params
      .filter((param) => !signature.namesUpper.has(param.name.toUpperCase()))
      .map((param) => ({
        name: param.name,
        section: "DOC_ONLY",
        typing: null,
        doc: { direction: param.direction, text: param.text }
      }));

    return {
      form: {
        name: formName,
        nameFromComment: commentInfo.formName || "",
        params: [...params, ...docOnly],
        exceptions: signature.exceptions
      }
    };
  }

  function buildCallFunctionExtras({ values }) {
    const map = valuesToFirstValueMap(values);

    return {
      callFunction: {
        name: map.name || "",
        destination: map.destination || "",
        exporting: parseAssignments(map.exportingRaw || ""),
        importing: parseAssignments(map.importingRaw || ""),
        changing: parseAssignments(map.changingRaw || ""),
        tables: parseAssignments(map.tablesRaw || ""),
        exceptions: parseAssignments(map.exceptionsRaw || "")
      }
    };
  }

  function buildCallMethodExtras({ values }) {
    const map = valuesToFirstValueMap(values);

    return {
      callMethod: {
        target: map.target || "",
        exporting: parseAssignments(map.exportingRaw || ""),
        importing: parseAssignments(map.importingRaw || ""),
        changing: parseAssignments(map.changingRaw || ""),
        receiving: parseAssignments(map.receivingRaw || ""),
        exceptions: parseAssignments(map.exceptionsRaw || "")
      }
    };
  }

  function buildMethodSignatureExtras({ values }) {
    const map = valuesToFirstValueMap(values);
    const signature = parseMethodSignature(map);

    return {
      methodSignature: signature
    };
  }

  function parseMethodSignature(valueMap) {
    const importingParams = parseFormParamDefs("IMPORTING", valueMap.importingRaw || "");
    const exportingParams = parseFormParamDefs("EXPORTING", valueMap.exportingRaw || "");
    const changingParams = parseFormParamDefs("CHANGING", valueMap.changingRaw || "");
    const returningParams = parseFormParamDefs("RETURNING", valueMap.returningRaw || "");
    const exceptions = parseFormExceptions(valueMap.raisingRaw || "");

    return {
      name: valueMap.name || "",
      params: [...importingParams, ...exportingParams, ...changingParams, ...returningParams],
      exceptions
    };
  }

  function buildPerformCallExtras({ values }) {
    const map = valuesToFirstValueMap(values);

    return {
      performCall: {
        form: map.form || "",
        program: map.program || "",
        ifCondition: map.ifCondition || "",
        using: parseArgumentTokens(map.usingRaw || "").map((value) => ({ value })),
        changing: parseArgumentTokens(map.changingRaw || "").map((value) => ({ value })),
        tables: parseArgumentTokens(map.tablesRaw || "").map((value) => ({ value }))
      }
    };
  }

  function attachDeclarationRefs({ statements, objects, fileName }) {
    const allObjects = collectAllObjects(objects);
    const idToObject = new Map(allObjects.filter((obj) => obj && obj.id).map((obj) => [obj.id, obj]));
    const procedureBlocks = allObjects
      .filter((obj) => obj && ["FORM", "METHOD"].includes(obj.objectType))
      .filter((obj) => obj.block && obj.block.lineEnd);
    const classBlocks = allObjects
      .filter((obj) => obj && obj.objectType === "CLASS")
      .filter((obj) => obj.block && obj.block.lineEnd);

    const classInfo = buildClassInfo(allObjects);
    const scopeInfoById = buildScopeInfoById({ idToObject });

    const declByScope = new Map();
    ensureScopeMap(declByScope, 0);

    for (const obj of allObjects) {
      const scopeId = getDeclarationScopeId(obj, idToObject, procedureBlocks, classBlocks);
      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);
      const declaredNames = getDeclaredNamesFromObject(obj);
      for (const name of declaredNames) {
        addDecl(declByScope, scopeId, name, buildDeclInfoFromObject(obj, name, scopeInfo));
      }

      if (obj.objectType === "FORM" && obj.extras && obj.extras.form && Array.isArray(obj.extras.form.params)) {
        const formScopeInfo = scopeInfoById.get(obj.id) || buildFallbackScopeInfo(obj.id);
        for (const param of obj.extras.form.params) {
          if (!param || !param.name) {
            continue;
          }
          addDecl(declByScope, obj.id, param.name, {
            id: obj.id,
            objectType: "FORM_PARAM",
            name: param.name,
            file: obj.file || fileName || "",
            lineStart: obj.lineStart || null,
            raw: obj.raw || "",
            comment: param.doc ? param.doc.text || "" : "",
            scopeId: obj.id,
            scopeLabel: formScopeInfo.scopeLabel,
            scopeType: formScopeInfo.scopeType,
            scopeName: formScopeInfo.scopeName
          });
        }
      }
    }

    for (const statement of statements || []) {
      const inlineNames = extractInlineDeclarations(statement.raw || "");
      if (!inlineNames.length) {
        continue;
      }

      const scopeId = getStatementScopeId(statement.lineStart, procedureBlocks, classBlocks);
      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);
      for (const name of inlineNames) {
        addDecl(declByScope, scopeId, name, {
          id: null,
          objectType: "INLINE",
          name,
          file: fileName || "",
          lineStart: statement.lineStart || null,
          raw: statement.raw || "",
          comment: statement.comment || "",
          scopeId,
          scopeLabel: scopeInfo.scopeLabel,
          scopeType: scopeInfo.scopeType,
          scopeName: scopeInfo.scopeName
        });
      }
    }

    const structDefs = buildStructDefsFromStatements({
      statements,
      procedureBlocks,
      classBlocks,
      scopeInfoById,
      fileName: fileName || ""
    });

    attachStructFieldDecls({
      allObjects,
      idToObject,
      declByScope,
      scopeInfoById,
      procedureBlocks,
      classBlocks,
      classInfo,
      fileName: fileName || "",
      structDefs
    });

    for (const obj of allObjects) {
      const resolveContext = buildResolveContext(obj, idToObject, declByScope, classInfo);
      annotateValuesWithDecls(obj.values, resolveContext);
      annotateExtrasWithDecls(obj.extras, resolveContext);
    }

    attachPerformOriginDecls({ allObjects, formsByNameUpper: buildFormsByNameUpper(allObjects), scopeInfoById });

    const decls = [];
    for (const scopeMap of declByScope.values()) {
      for (const decl of scopeMap.values()) {
        decls.push(decl);
      }
    }
    return decls;
  }

  function ensureStructDefScopeMap(mapByScope, scopeId) {
    if (!mapByScope.has(scopeId)) {
      mapByScope.set(scopeId, new Map());
    }
  }

  function buildStructDefsFromStatements({ statements, procedureBlocks, classBlocks, scopeInfoById, fileName }) {
    const dataByScope = new Map();
    const typeByScope = new Map();

    for (const statement of statements || []) {
      const startKeyword = getStatementStartKeyword(statement.raw || "");
      if (startKeyword !== "DATA" && startKeyword !== "TYPES") {
        continue;
      }

      const lineEntries = Array.isArray(statement.lineEntries) ? statement.lineEntries : [];
      if (!lineEntries.length) {
        continue;
      }

      const scopeId = getStatementScopeId(statement.lineStart, procedureBlocks, classBlocks);
      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);

      const defs = parseStructDefsFromLineEntries({
        kind: startKeyword,
        lineEntries,
        leadingComments: Array.isArray(statement.leadingComments) ? statement.leadingComments : [],
        fileName: fileName || "",
        scopeId,
        scopeInfo
      });

      const target = startKeyword === "DATA" ? dataByScope : typeByScope;
      ensureStructDefScopeMap(target, scopeId);
      const scopeMap = target.get(scopeId);

      for (const def of defs) {
        if (!def || !def.nameUpper) {
          continue;
        }
        if (!scopeMap.has(def.nameUpper)) {
          scopeMap.set(def.nameUpper, def);
        }
      }
    }

    return { dataByScope, typeByScope };
  }

  function parseStructDefsFromLineEntries({ kind, lineEntries, leadingComments, fileName, scopeId, scopeInfo }) {
    const defs = [];
    let current = null;
    const stack = [];
    const leadingText = Array.isArray(leadingComments) ? leadingComments.filter(Boolean).join(" ").trim() : "";

    function currentNestedPrefix() {
      if (stack.length <= 1) {
        return "";
      }
      return stack
        .slice(1)
        .map((ctx) => ctx.name)
        .filter(Boolean)
        .join("-");
    }

    function addField(path, info) {
      if (!current || !path) {
        return;
      }

      const normalized = normalizeIdentifierCandidate(path);
      if (!normalized) {
        return;
      }

      const pathUpper = normalized.toUpperCase();
      if (!current.fields.has(pathUpper)) {
        current.fields.set(pathUpper, {
          path: normalized,
          pathUpper,
          file: fileName || "",
          lineStart: info && info.lineStart ? info.lineStart : null,
          raw: info && info.raw ? info.raw : "",
          comment: info && info.comment ? info.comment : ""
        });
      }
    }

    for (const entry of lineEntries) {
      const code = String(entry && entry.code ? entry.code : "").trim();
      if (!code) {
        continue;
      }

      const comment = entry && entry.comment ? String(entry.comment || "") : "";
      const lineStart = entry && entry.line ? Number(entry.line || 0) || null : null;

      const withoutDot = code.replace(/\.$/, "").trim();
      const segments = splitByCommaOutsideQuotes(withoutDot)
        .map((segment) => segment.trim())
        .filter(Boolean);

      for (const segment of segments) {
        const marker = parseStructMarker(segment);
        if (marker && marker.kind === "BEGIN") {
          const name = normalizeIdentifierCandidate(marker.name);
          if (!name) {
            continue;
          }
          const nameUpper = name.toUpperCase();

          if (!stack.length) {
            current = {
              kind,
              name,
              nameUpper,
              file: fileName || "",
              scopeId,
              scopeLabel: scopeInfo ? scopeInfo.scopeLabel : "",
              lineStart,
              rawStart: segment,
              comment: String(comment || "").trim() || leadingText,
              fields: new Map()
            };
            stack.push({ name, nameUpper });
            continue;
          }

          const prefix = currentNestedPrefix();
          const path = prefix ? `${prefix}-${name}` : name;
          addField(path, { lineStart, raw: segment, comment: String(comment || "").trim() });
          stack.push({ name, nameUpper });
          continue;
        }

        if (marker && marker.kind === "END") {
          const name = normalizeIdentifierCandidate(marker.name);
          const nameUpper = name ? name.toUpperCase() : "";

          if (stack.length) {
            const top = stack[stack.length - 1];
            if (top && top.nameUpper && nameUpper && top.nameUpper === nameUpper) {
              stack.pop();
            } else {
              stack.pop();
            }
          }

          if (!stack.length && current) {
            defs.push(current);
            current = null;
          }
          continue;
        }

        if (!stack.length || !current) {
          continue;
        }

        const fieldName = extractStructFieldName(segment);
        if (!fieldName) {
          continue;
        }

        const prefix = currentNestedPrefix();
        const path = prefix ? `${prefix}-${fieldName}` : fieldName;
        addField(path, { lineStart, raw: segment, comment: String(comment || "").trim() });
      }
    }

    return defs;
  }

  function parseStructMarker(segment) {
    const text = String(segment || "");
    const beginMatch = text.match(/\bBEGIN\s+OF\s+([A-Za-z_][A-Za-z0-9_]*)/i);
    if (beginMatch) {
      return { kind: "BEGIN", name: beginMatch[1] };
    }

    const endMatch = text.match(/\bEND\s+OF\s+([A-Za-z_][A-Za-z0-9_]*)/i);
    if (endMatch) {
      return { kind: "END", name: endMatch[1] };
    }

    return null;
  }

  function extractStructFieldName(segment) {
    const text = String(segment || "").trim();
    if (!text) {
      return "";
    }

    const match = text.match(/^([A-Za-z_][A-Za-z0-9_]*)/);
    if (!match) {
      return "";
    }

    const candidate = match[1] || "";
    const upper = candidate.toUpperCase();
    if (["BEGIN", "END", "INCLUDE"].includes(upper)) {
      return "";
    }

    return normalizeIdentifierCandidate(candidate) || "";
  }

  function resolveStructDefByContext(typeUpper, context, typeStructDefsByScope) {
    if (!typeUpper || !typeStructDefsByScope) {
      return null;
    }

    const procMap = context && context.procId ? typeStructDefsByScope.get(context.procId) : null;
    if (procMap && procMap.has(typeUpper)) {
      return procMap.get(typeUpper);
    }

    const classMap = context && context.classDefId ? typeStructDefsByScope.get(context.classDefId) : null;
    if (classMap && classMap.has(typeUpper)) {
      return classMap.get(typeUpper);
    }

    const globalMap = typeStructDefsByScope.get(0);
    if (globalMap && globalMap.has(typeUpper)) {
      return globalMap.get(typeUpper);
    }

    return null;
  }

  function getStructTypeCandidateFromDeclObject(obj) {
    if (!obj) {
      return "";
    }

    const type = getFirstValue(obj.values, "type");
    const like = getFirstValue(obj.values, "like");
    const structure = getFirstValue(obj.values, "structure");

    const candidate = type || like || structure;
    const normalized = normalizeIdentifierCandidate(candidate);
    return normalized || "";
  }

  function patchDeclComment(declByScope, scopeId, nameUpper, comment) {
    const trimmed = String(comment || "").trim();
    if (!declByScope || !declByScope.has(scopeId)) {
      return;
    }

    const scopeMap = declByScope.get(scopeId);
    if (!scopeMap || !scopeMap.has(nameUpper)) {
      return;
    }

    const decl = scopeMap.get(nameUpper);
    if (decl && String(decl.comment || "").trim() !== trimmed) {
      decl.comment = trimmed;
    }
  }

  function attachStructFieldDecls({
    allObjects,
    idToObject,
    declByScope,
    scopeInfoById,
    procedureBlocks,
    classBlocks,
    classInfo,
    fileName,
    structDefs
  }) {
    const dataByScope = structDefs && structDefs.dataByScope ? structDefs.dataByScope : new Map();
    const typeByScope = structDefs && structDefs.typeByScope ? structDefs.typeByScope : new Map();

    // 1) DATA inline structs: create `${var}-${field}` decls with per-field comments.
    for (const [scopeId, defsByName] of dataByScope.entries()) {
      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);

      for (const def of defsByName.values()) {
        if (!def || !def.name || !def.nameUpper) {
          continue;
        }

        patchDeclComment(declByScope, scopeId, def.nameUpper, def.comment || "");

        for (const field of def.fields.values()) {
          const fullName = `${def.name}-${field.path}`;
          addDecl(declByScope, scopeId, fullName, {
            id: null,
            objectType: "STRUCT_FIELD",
            name: fullName,
            file: fileName || "",
            lineStart: field.lineStart || null,
            raw: field.raw || "",
            comment: field.comment || "",
            scopeId,
            scopeLabel: scopeInfo.scopeLabel,
            scopeType: scopeInfo.scopeType,
            scopeName: scopeInfo.scopeName,
            structName: def.name,
            fieldPath: field.path,
            structObjectType: def.kind || "DATA",
            structLineStart: def.lineStart || null,
            structRaw: def.rawStart || "",
            structComment: def.comment || ""
          });
        }
      }
    }

    // 2) Typed declarations: `DATA ls_s TYPE ty_s.` -> create `ls_s-field` from `TYPES ... BEGIN OF ty_s`.
    for (const obj of allObjects || []) {
      if (!obj || !obj.objectType || !obj.values) {
        continue;
      }

      const structMeta = obj.extras && typeof obj.extras === "object" ? obj.extras.structDef : null;
      if (structMeta && structMeta.isDecl === false) {
        continue;
      }

      const declName = getFirstValue(obj.values, "name");
      const normalizedDeclName = normalizeIdentifierCandidate(declName);
      if (!normalizedDeclName) {
        continue;
      }

      const scopeId = getDeclarationScopeId(obj, idToObject, procedureBlocks, classBlocks);
      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);

      // Skip if already an inline DATA struct in the same scope (DATA wins; addDecl also protects).
      const dataScopeMap = dataByScope.get(scopeId);
      if (dataScopeMap && dataScopeMap.has(normalizedDeclName.toUpperCase())) {
        continue;
      }

      const typeName = getStructTypeCandidateFromDeclObject(obj);
      if (!typeName) {
        continue;
      }

      const typeUpper = typeName.toUpperCase();
      const context = buildResolveContext(obj, idToObject, declByScope, classInfo);
      const typeDef = resolveStructDefByContext(typeUpper, context, typeByScope);
      if (!typeDef) {
        continue;
      }

      patchDeclComment(declByScope, typeDef.scopeId || scopeId, typeUpper, typeDef.comment || "");

      for (const field of typeDef.fields.values()) {
        const fullName = `${normalizedDeclName}-${field.path}`;
        addDecl(declByScope, scopeId, fullName, {
          id: null,
          objectType: "STRUCT_FIELD",
          name: fullName,
          file: fileName || "",
          lineStart: field.lineStart || null,
          raw: field.raw || "",
          comment: field.comment || "",
          scopeId,
          scopeLabel: scopeInfo.scopeLabel,
          scopeType: scopeInfo.scopeType,
          scopeName: scopeInfo.scopeName,
          structName: normalizedDeclName,
          fieldPath: field.path,
          structObjectType: obj.objectType || "DATA",
          structId: obj.id || null,
          structLineStart: obj.lineStart || null,
          structRaw: obj.raw || "",
          structComment: obj.comment || "",
          structTypeName: typeDef.name || typeName,
          structTypeLineStart: typeDef.lineStart || null,
          structTypeRaw: typeDef.rawStart || "",
          structTypeComment: typeDef.comment || ""
        });
      }
    }
  }

  function collectAllObjects(roots) {
    const list = [];
    for (const root of roots || []) {
      walkObject(root, list);
    }
    return list;
  }

  function walkObject(node, list) {
    if (!node) {
      return;
    }

    list.push(node);
    if (Array.isArray(node.children)) {
      for (const child of node.children) {
        walkObject(child, list);
      }
    }
  }

  function buildClassInfo(allObjects) {
    const byName = new Map();
    for (const obj of allObjects) {
      if (!obj || obj.objectType !== "CLASS") {
        continue;
      }
      const className = getFirstValue(obj.values, "name");
      if (!className) {
        continue;
      }
      const classNameUpper = className.toUpperCase();
      const kind = classifyClassBlock(obj.raw || "");
      if (!byName.has(classNameUpper)) {
        byName.set(classNameUpper, { definition: null, implementation: null });
      }
      const entry = byName.get(classNameUpper);
      if (kind === "DEFINITION") {
        entry.definition = obj;
      } else if (kind === "IMPLEMENTATION") {
        entry.implementation = obj;
      }
    }

    const methodParamsByClassAndName = new Map();
    for (const [classNameUpper, entry] of byName.entries()) {
      const classDef = entry.definition;
      if (!classDef || !Array.isArray(classDef.children)) {
        continue;
      }

      for (const child of classDef.children) {
        if (!child || !["METHODS", "CLASS-METHODS"].includes(child.objectType)) {
          continue;
        }

        const methodName = getFirstValue(child.values, "name");
        if (!methodName) {
          continue;
        }

        const signature = child.extras && child.extras.methodSignature ? child.extras.methodSignature : null;
        const params = signature && Array.isArray(signature.params) ? signature.params : [];
        const paramsByNameUpper = new Map();

        for (const param of params) {
          if (!param || !param.name) {
            continue;
          }
          paramsByNameUpper.set(param.name.toUpperCase(), {
            id: child.id,
            objectType: "METHOD_PARAM",
            name: param.name,
            file: child.file || "",
            lineStart: child.lineStart || null,
            raw: child.raw || "",
            comment: "",
            scopeId: child.id,
            scopeLabel: `METHODSIG:${classNameUpper}=>${methodName.toUpperCase()}`,
            scopeType: "METHODSIG",
            scopeName: methodName
          });
        }

        methodParamsByClassAndName.set(`${classNameUpper}:${methodName.toUpperCase()}`, {
          classNameUpper,
          methodNameUpper: methodName.toUpperCase(),
          paramsByNameUpper,
          signatureId: child.id
        });
      }
    }

    return {
      byName,
      methodParamsByClassAndName
    };
  }

  function classifyClassBlock(raw) {
    const upper = String(raw || "").toUpperCase();
    if (upper.includes(" DEFINITION")) {
      return "DEFINITION";
    }
    if (upper.includes(" IMPLEMENTATION")) {
      return "IMPLEMENTATION";
    }
    return "";
  }

  function getFirstValue(values, name) {
    for (const entry of values || []) {
      if (entry && entry.name === name) {
        return entry.value || "";
      }
    }
    return "";
  }

  function ensureScopeMap(declByScope, scopeId) {
    if (!declByScope.has(scopeId)) {
      declByScope.set(scopeId, new Map());
    }
  }

  function addDecl(declByScope, scopeId, name, declInfo) {
    const normalized = normalizeIdentifierCandidate(name);
    if (!normalized) {
      return;
    }
    const upper = normalized.toUpperCase();
    ensureScopeMap(declByScope, scopeId);
    const map = declByScope.get(scopeId);
    if (!map.has(upper)) {
      map.set(upper, declInfo);
    }
  }

  function getDeclarationScopeId(obj, idToObject, procedureBlocks, classBlocks) {
    if (!obj) {
      return 0;
    }
    const procId = getProcedureScopeId(obj, idToObject);
    if (procId) {
      return procId;
    }
    const line = obj.lineStart || 0;
    return getStatementScopeId(line, [], classBlocks);
  }

  function getProcedureScopeId(obj, idToObject) {
    let current = obj;
    while (current) {
      if (current.objectType === "FORM" || current.objectType === "METHOD") {
        return current.id || 0;
      }
      current = current.parent ? idToObject.get(current.parent) : null;
    }
    return 0;
  }

  function getStatementScopeId(lineStart, procedureBlocks, classBlocks) {
    const proc = findInnermostBlock(lineStart, procedureBlocks);
    if (proc) {
      return proc.id || 0;
    }
    const cls = findInnermostBlock(lineStart, classBlocks);
    if (cls) {
      return cls.id || 0;
    }
    return 0;
  }

  function findInnermostBlock(line, blocks) {
    let best = null;
    let bestSize = Infinity;
    const currentLine = Number(line || 0);

    for (const block of blocks || []) {
      const start = Number(block.lineStart || 0);
      const end = Number(block.block && block.block.lineEnd ? block.block.lineEnd : 0);
      if (!start || !end) {
        continue;
      }
      if (currentLine < start || currentLine > end) {
        continue;
      }
      const size = end - start;
      if (size < bestSize) {
        best = block;
        bestSize = size;
      }
    }

    return best;
  }

  function getDeclaredNamesFromObject(obj) {
    if (!obj || !obj.objectType) {
      return [];
    }

    const structMeta = obj.extras && typeof obj.extras === "object" ? obj.extras.structDef : null;
    if (structMeta && structMeta.isDecl === false) {
      return [];
    }

    const type = obj.objectType;
    if (["DATA", "CONSTANTS", "PARAMETERS", "SELECT-OPTIONS", "TYPES", "RANGES", "STATICS", "CLASS-DATA", "FIELD-SYMBOLS"].includes(type)) {
      const name = getFirstValue(obj.values, "name");
      return name ? [name] : [];
    }

    return [];
  }

  function buildDeclInfoFromObject(obj, name, scopeInfo) {
    const scope = scopeInfo || buildFallbackScopeInfo(0);
    return {
      id: obj.id || null,
      objectType: obj.objectType || "",
      name: normalizeIdentifierCandidate(name) || name || "",
      file: obj.file || "",
      lineStart: obj.lineStart || null,
      raw: obj.raw || "",
      comment: obj.comment || "",
      scopeId: scope.scopeId,
      scopeLabel: scope.scopeLabel,
      scopeType: scope.scopeType,
      scopeName: scope.scopeName
    };
  }

  function buildFallbackScopeInfo(scopeId) {
    const id = Number(scopeId || 0) || 0;
    if (!id) {
      return { scopeId: 0, scopeType: "GLOBAL", scopeLabel: "GLOBAL", scopeName: "" };
    }
    return { scopeId: id, scopeType: "SCOPE", scopeLabel: `SCOPE:${id}`, scopeName: "" };
  }

  function buildScopeInfoById({ idToObject }) {
    const map = new Map();
    map.set(0, buildFallbackScopeInfo(0));

    for (const [id, obj] of idToObject.entries()) {
      if (!obj || !obj.objectType) {
        continue;
      }

      const type = obj.objectType;
      if (!["FORM", "METHOD", "CLASS", "METHODS", "CLASS-METHODS"].includes(type)) {
        continue;
      }

      if (type === "FORM") {
        const formName = getFirstValue(obj.values, "name") || "";
        const upper = formName ? formName.toUpperCase() : "";
        map.set(id, {
          scopeId: id,
          scopeType: "FORM",
          scopeLabel: upper ? `FORM:${upper}` : `FORM:${id}`,
          scopeName: formName
        });
        continue;
      }

      if (type === "METHOD") {
        const methodName = getFirstValue(obj.values, "name") || "";
        const methodUpper = methodName ? methodName.toUpperCase() : "";
        const classUpper = findAncestorNameUpper(obj, idToObject, "CLASS");
        const label = classUpper && methodUpper
          ? `METHOD:${classUpper}=>${methodUpper}`
          : methodUpper
              ? `METHOD:${methodUpper}`
              : `METHOD:${id}`;

        map.set(id, {
          scopeId: id,
          scopeType: "METHOD",
          scopeLabel: label,
          scopeName: methodName
        });
        continue;
      }

      if (type === "CLASS") {
        const className = getFirstValue(obj.values, "name") || "";
        const classUpper = className ? className.toUpperCase() : "";
        map.set(id, {
          scopeId: id,
          scopeType: "CLASS",
          scopeLabel: classUpper ? `CLASS:${classUpper}` : `CLASS:${id}`,
          scopeName: className
        });
        continue;
      }

      if (type === "METHODS" || type === "CLASS-METHODS") {
        const methodName = getFirstValue(obj.values, "name") || "";
        const methodUpper = methodName ? methodName.toUpperCase() : "";
        const classUpper = findAncestorNameUpper(obj, idToObject, "CLASS");
        const label = classUpper && methodUpper
          ? `METHODSIG:${classUpper}=>${methodUpper}`
          : methodUpper
              ? `METHODSIG:${methodUpper}`
              : `METHODSIG:${id}`;

        map.set(id, {
          scopeId: id,
          scopeType: "METHODSIG",
          scopeLabel: label,
          scopeName: methodName
        });
      }
    }

    return map;
  }

  function findAncestorNameUpper(obj, idToObject, objectType) {
    let current = obj;
    while (current) {
      if (current.objectType === objectType) {
        const name = getFirstValue(current.values, "name") || "";
        return name ? name.toUpperCase() : "";
      }
      current = current.parent ? idToObject.get(current.parent) : null;
    }
    return "";
  }

  function buildFormsByNameUpper(allObjects) {
    const map = new Map();
    for (const obj of allObjects || []) {
      if (!obj || obj.objectType !== "FORM") {
        continue;
      }

      const name = getFirstValue(obj.values, "name") || (obj.extras && obj.extras.form ? obj.extras.form.name : "");
      if (!name) {
        continue;
      }

      const upper = String(name).toUpperCase();
      if (!map.has(upper)) {
        map.set(upper, obj);
      }
    }
    return map;
  }

  function declIdentityKey(decl) {
    if (!decl) {
      return "";
    }
    const objectType = decl.objectType || "";
    const scopeLabel = decl.scopeLabel || "";
    const name = decl.name || "";
    const file = decl.file || "";
    const line = decl.lineStart || "";
    return `${objectType}|${scopeLabel}|${name}|${file}|${line}`;
  }

  function attachPerformOriginDecls({ allObjects, formsByNameUpper }) {
    const formParamSections = new Set(["USING", "CHANGING", "TABLES"]);

    const forms = Array.from(formsByNameUpper.values())
      .filter((obj) => obj && obj.id && obj.extras && obj.extras.form && Array.isArray(obj.extras.form.params));

    const formParamsByFormId = new Map();
    const originsByFormIdAndParamUpper = new Map();

    for (const form of forms) {
      const params = form.extras.form.params.filter((param) => param && formParamSections.has(param.section));
      const byNameUpper = new Map(params.map((param) => [param.name.toUpperCase(), param]));
      const bySection = { USING: [], CHANGING: [], TABLES: [] };
      for (const param of params) {
        bySection[param.section].push(param);
      }

      formParamsByFormId.set(form.id, { form, byNameUpper, bySection });

      const originByParam = new Map();
      for (const param of params) {
        originByParam.set(param.name.toUpperCase(), new Map());
      }
      originsByFormIdAndParamUpper.set(form.id, originByParam);
    }

    const performCalls = (allObjects || []).filter(
      (obj) => obj && obj.objectType === "PERFORM" && obj.extras && obj.extras.performCall
    );

    function getOriginsForFormParamDecl(decl) {
      if (!decl || decl.objectType !== "FORM_PARAM" || !decl.id || !decl.name) {
        return new Map();
      }
      const byParam = originsByFormIdAndParamUpper.get(decl.id);
      if (!byParam) {
        return new Map();
      }
      return byParam.get(decl.name.toUpperCase()) || new Map();
    }

    function originsFromValueDecl(valueDecl) {
      if (!valueDecl) {
        return new Map();
      }
      if (valueDecl.objectType === "FORM_PARAM") {
        return new Map(getOriginsForFormParamDecl(valueDecl));
      }
      const key = declIdentityKey(valueDecl);
      return key ? new Map([[key, valueDecl]]) : new Map();
    }

    function unionInto(target, source) {
      if (!target || !source) {
        return false;
      }
      let changed = false;
      for (const [key, decl] of source.entries()) {
        if (!target.has(key)) {
          target.set(key, decl);
          changed = true;
        }
      }
      return changed;
    }

    const maxIterations = 50;
    for (let iter = 0; iter < maxIterations; iter += 1) {
      let changed = false;

      for (const callObj of performCalls) {
        const call = callObj.extras.performCall;
        const formNameUpper = String(call.form || "").toUpperCase();
        if (!formNameUpper) {
          continue;
        }

        const calleeForm = formsByNameUpper.get(formNameUpper);
        if (!calleeForm || !calleeForm.id) {
          continue;
        }

        const calleeInfo = formParamsByFormId.get(calleeForm.id);
        if (!calleeInfo) {
          continue;
        }

        const calleeOrigins = originsByFormIdAndParamUpper.get(calleeForm.id);
        if (!calleeOrigins) {
          continue;
        }

        for (const section of ["USING", "CHANGING", "TABLES"]) {
          const formalParams = calleeInfo.bySection[section] || [];
          const actualArgs = Array.isArray(call[section.toLowerCase()]) ? call[section.toLowerCase()] : [];
          const max = Math.min(formalParams.length, actualArgs.length);

          for (let index = 0; index < max; index += 1) {
            const formal = formalParams[index];
            const actual = actualArgs[index];
            if (!formal || !formal.name || !actual) {
              continue;
            }

            const target = calleeOrigins.get(formal.name.toUpperCase());
            if (!target) {
              continue;
            }

            const sourceOrigins = originsFromValueDecl(actual.valueDecl);
            if (unionInto(target, sourceOrigins)) {
              changed = true;
            }
          }
        }
      }

      if (!changed) {
        break;
      }
    }

    for (const form of forms) {
      const originByParam = originsByFormIdAndParamUpper.get(form.id);
      if (!originByParam) {
        continue;
      }

      for (const param of form.extras.form.params) {
        if (!param || !param.name || !formParamSections.has(param.section)) {
          continue;
        }
        const originMap = originByParam.get(param.name.toUpperCase());
        param.originDecls = originMap ? Array.from(originMap.values()) : [];
      }
    }

    for (const callObj of performCalls) {
      const call = callObj.extras.performCall;
      for (const sectionName of ["using", "changing", "tables"]) {
        const list = Array.isArray(call[sectionName]) ? call[sectionName] : [];
        for (const entry of list) {
          entry.originDecls = Array.from(originsFromValueDecl(entry.valueDecl).values());
        }
      }
    }

    for (const obj of allObjects || []) {
      if (!obj || !obj.extras) {
        continue;
      }

      if (obj.extras.callFunction) {
        for (const sectionName of ["exporting", "importing", "changing", "tables", "exceptions"]) {
          const list = Array.isArray(obj.extras.callFunction[sectionName]) ? obj.extras.callFunction[sectionName] : [];
          for (const entry of list) {
            entry.originDecls = Array.from(originsFromValueDecl(entry.valueDecl).values());
          }
        }
      }

      if (obj.extras.callMethod) {
        for (const sectionName of ["exporting", "importing", "changing", "receiving", "exceptions"]) {
          const list = Array.isArray(obj.extras.callMethod[sectionName]) ? obj.extras.callMethod[sectionName] : [];
          for (const entry of list) {
            entry.originDecls = Array.from(originsFromValueDecl(entry.valueDecl).values());
          }
        }
      }
    }
  }

  function extractInlineDeclarations(raw) {
    const text = String(raw || "");
    const results = [];

    [
      /@?DATA\s*\(\s*([^)]+)\s*\)/gi,
      /@?FINAL\s*\(\s*([^)]+)\s*\)/gi,
      /FIELD-SYMBOL\s*\(\s*(<[^>]+>)\s*\)/gi
    ].forEach((regex) => {
      let match = null;
      while ((match = regex.exec(text))) {
        const candidate = normalizeIdentifierCandidate(match[1]);
        if (candidate) {
          results.push(candidate);
        }
      }
    });

    return Array.from(new Set(results));
  }

  function normalizeIdentifierCandidate(raw) {
    const trimmed = String(raw || "").trim();
    if (!trimmed) {
      return "";
    }
    if (/^<[^>]+>$/.test(trimmed)) {
      return trimmed;
    }
    if (/^SY-[A-Za-z_][A-Za-z0-9_]*$/i.test(trimmed)) {
      return trimmed.toUpperCase();
    }
    if (/^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(-[A-Za-z_][A-Za-z0-9_]*)+$/i.test(trimmed)) {
      return trimmed;
    }
    if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(trimmed)) {
      return trimmed;
    }
    return "";
  }

  function buildResolveContext(obj, idToObject, declByScope, classInfo) {
    const procId = getProcedureScopeId(obj, idToObject);
    const methodBlock = findAncestor(obj, idToObject, "METHOD");
    const classBlock = findAncestor(obj, idToObject, "CLASS");

    const classNameUpper = classBlock ? getFirstValue(classBlock.values, "name").toUpperCase() : "";
    const methodNameUpper = methodBlock ? getFirstValue(methodBlock.values, "name").toUpperCase() : "";
    const classDef = classNameUpper && classInfo.byName.get(classNameUpper)
      ? classInfo.byName.get(classNameUpper).definition
      : null;

    const methodParamsEntry = classNameUpper && methodNameUpper
      ? classInfo.methodParamsByClassAndName.get(`${classNameUpper}:${methodNameUpper}`)
      : null;

    return {
      obj,
      procId,
      classNameUpper,
      methodNameUpper,
      classDefId: classDef ? classDef.id : 0,
      declByScope,
      methodParamsByNameUpper: methodParamsEntry ? methodParamsEntry.paramsByNameUpper : null
    };
  }

  function findAncestor(obj, idToObject, objectType) {
    let current = obj;
    while (current) {
      if (current.objectType === objectType) {
        return current;
      }
      current = current.parent ? idToObject.get(current.parent) : null;
    }
    return null;
  }

  function annotateValuesWithDecls(values, context) {
    if (!Array.isArray(values)) {
      return;
    }

    for (const entry of values) {
      if (!entry || !entry.value) {
        continue;
      }
      const ref = extractFirstIdentifierFromExpression(entry.value);
      if (!ref) {
        continue;
      }
      const decl = resolveDecl(ref, context);
      if (!decl) {
        continue;
      }
      entry.declRef = ref;
      entry.decl = decl;
    }
  }

  function annotateExtrasWithDecls(extras, context) {
    if (!extras || typeof extras !== "object") {
      return;
    }

    if (extras.callFunction) {
      annotateCallFunctionExtras(extras.callFunction, context);
    }

    if (extras.callMethod) {
      annotateCallMethodExtras(extras.callMethod, context);
    }

    if (extras.performCall) {
      annotatePerformCallExtras(extras.performCall, context);
    }
  }

  function annotateCallFunctionExtras(callFunction, context) {
    for (const sectionName of ["exporting", "importing", "changing", "tables", "exceptions"]) {
      const list = callFunction && Array.isArray(callFunction[sectionName]) ? callFunction[sectionName] : [];
      for (const entry of list) {
        if (!entry || !entry.value) {
          continue;
        }
        const ref = extractFirstIdentifierFromExpression(entry.value);
        if (!ref) {
          continue;
        }
        entry.valueRef = ref;
        entry.valueDecl = resolveDecl(ref, context);
      }
    }
  }

  function annotateCallMethodExtras(callMethod, context) {
    for (const sectionName of ["exporting", "importing", "changing", "receiving", "exceptions"]) {
      const list = callMethod && Array.isArray(callMethod[sectionName]) ? callMethod[sectionName] : [];
      for (const entry of list) {
        if (!entry || !entry.value) {
          continue;
        }
        const ref = extractFirstIdentifierFromExpression(entry.value);
        if (!ref) {
          continue;
        }
        entry.valueRef = ref;
        entry.valueDecl = resolveDecl(ref, context);
      }
    }
  }

  function annotatePerformCallExtras(performCall, context) {
    for (const sectionName of ["using", "changing", "tables"]) {
      const list = performCall && Array.isArray(performCall[sectionName]) ? performCall[sectionName] : [];
      for (const entry of list) {
        if (!entry || !entry.value) {
          continue;
        }
        const ref = extractFirstIdentifierFromExpression(entry.value);
        if (!ref) {
          continue;
        }
        entry.valueRef = ref;
        entry.valueDecl = resolveDecl(ref, context);
      }
    }
  }

  function resolveDecl(identifier, context) {
    const normalized = normalizeIdentifierCandidate(identifier);
    if (!normalized) {
      return null;
    }
    const upper = normalized.toUpperCase();

    const procMap = context.procId ? context.declByScope.get(context.procId) : null;
    if (procMap && procMap.has(upper)) {
      return procMap.get(upper);
    }

    const methodParams = context.methodParamsByNameUpper;
    if (methodParams && methodParams.has(upper)) {
      return methodParams.get(upper);
    }

    const classMap = context.classDefId ? context.declByScope.get(context.classDefId) : null;
    if (classMap && classMap.has(upper)) {
      return classMap.get(upper);
    }

    const globalMap = context.declByScope.get(0);
    if (globalMap && globalMap.has(upper)) {
      return globalMap.get(upper);
    }

    const systemDecl = buildSystemDeclInfo(normalized);
    if (systemDecl) {
      return systemDecl;
    }

    return null;
  }

  function buildSystemDeclInfo(identifier) {
    const upper = String(identifier || "").trim().toUpperCase();
    if (!upper) {
      return null;
    }

    const known = new Set([
      "ABAP_TRUE",
      "ABAP_FALSE",
      "ABAP_UNDEFINED",
      "SPACE",
      "SY-SUBRC",
      "SY-TABIX",
      "SY-UNAME",
      "SY-REPID"
    ]);

    if (!upper.startsWith("SY-") && !known.has(upper)) {
      return null;
    }

    return {
      id: null,
      objectType: "SYSTEM",
      name: upper,
      file: "",
      lineStart: null,
      raw: "",
      comment: "",
      scopeId: 0,
      scopeLabel: "SYSTEM",
      scopeType: "SYSTEM",
      scopeName: ""
    };
  }

  function extractFirstIdentifierFromExpression(expression) {
    const text = String(expression || "").trim();
    if (!text) {
      return "";
    }
    if (text.startsWith("'") || text.startsWith("|")) {
      return "";
    }
    if (/^[+-]?\\d/.test(text)) {
      return "";
    }

    const sysMatch = text.match(/^SY-[A-Za-z_][A-Za-z0-9_]*/i);
    if (sysMatch) {
      return sysMatch[0].toUpperCase();
    }

    const fieldPath = extractFirstFieldPathFromExpression(text);
    if (fieldPath) {
      return fieldPath;
    }

    const inline = extractFirstInlineDeclaration(text);
    if (inline) {
      return inline;
    }

    const matches = text.matchAll(/<[^>]+>|[A-Za-z_][A-Za-z0-9_]*/g);
    for (const match of matches) {
      const candidate = normalizeIdentifierCandidate(match[0]);
      if (candidate) {
        return candidate;
      }
    }

    return "";
  }

  function extractFirstFieldPathFromExpression(text) {
    const match = String(text || "").match(/^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(?:-[A-Za-z_][A-Za-z0-9_]*)+/);
    if (!match) {
      return "";
    }
    const candidate = normalizeIdentifierCandidate(match[0]);
    return candidate || "";
  }

  function extractFirstInlineDeclaration(text) {
    const patterns = [
      { regex: /@?DATA\\s*\\(\\s*([^)]+)\\s*\\)/i, group: 1 },
      { regex: /@?FINAL\\s*\\(\\s*([^)]+)\\s*\\)/i, group: 1 },
      { regex: /FIELD-SYMBOL\\s*\\(\\s*(<[^>]+>)\\s*\\)/i, group: 1 }
    ];

    let best = null;
    for (const pattern of patterns) {
      const match = pattern.regex.exec(text);
      if (!match) {
        continue;
      }
      const candidate = normalizeIdentifierCandidate(match[pattern.group]);
      if (!candidate) {
        continue;
      }
      if (!best || match.index < best.index) {
        best = { index: match.index, name: candidate };
      }
    }

    return best ? best.name : "";
  }

  function parseArgumentTokens(segmentRaw) {
    const trimmed = String(segmentRaw || "").trim();
    if (!trimmed) {
      return [];
    }

    const tokens = tokenize(`${trimmed}.`);
    return tokens.map((token) => token.raw).filter(Boolean);
  }

  function parseAssignments(segmentRaw) {
    const trimmed = String(segmentRaw || "").trim();
    if (!trimmed) {
      return [];
    }

    const tokens = tokenize(`${trimmed}.`).map((token) => token.raw).filter(Boolean);
    const assignments = [];

    for (let index = 0; index < tokens.length; index += 1) {
      const token = tokens[index];

      if (token === "=") {
        continue;
      }

      const equalIndex = token.indexOf("=");
      if (equalIndex > 0) {
        const left = token.slice(0, equalIndex).trim();
        const rightInline = token.slice(equalIndex + 1).trim();

        const name = normalizeFormParamName(left);
        if (!name) {
          continue;
        }

        const value = rightInline || (tokens[index + 1] || "");
        if (!rightInline) {
          index += 1;
        }

        assignments.push({ name, value });
        continue;
      }

      if (tokens[index + 1] === "=" && tokens[index + 2]) {
        const name = normalizeFormParamName(token);
        if (!name) {
          continue;
        }

        const value = tokens[index + 2];
        assignments.push({ name, value });
        index += 2;
      }
    }

    return assignments;
  }

  function valuesToFirstValueMap(values) {
    const map = {};
    for (const entry of values || []) {
      if (!entry || !entry.name) {
        continue;
      }
      if (map[entry.name] === undefined) {
        map[entry.name] = entry.value || "";
      }
    }
    return map;
  }

  function parseFormSignature(valueMap) {
    const usingParams = parseFormParamDefs("USING", valueMap.usingRaw || "");
    const changingParams = parseFormParamDefs("CHANGING", valueMap.changingRaw || "");
    const tablesParams = parseFormParamDefs("TABLES", valueMap.tablesRaw || "");
    const exceptions = parseFormExceptions(valueMap.raisingRaw || "");

    const params = [...usingParams, ...changingParams, ...tablesParams];
    const namesUpper = new Set(params.map((param) => param.name.toUpperCase()));

    return {
      params,
      exceptions,
      namesUpper
    };
  }

  function parseFormParamDefs(section, segmentRaw) {
    const trimmed = String(segmentRaw || "").trim();
    if (!trimmed) {
      return [];
    }

    const tokens = tokenize(`${trimmed}.`);
    const params = [];
    const seen = new Set();

    for (let index = 0; index < tokens.length; index += 1) {
      const tokenUpper = tokens[index].upper;
      if (!["TYPE", "LIKE", "STRUCTURE"].includes(tokenUpper)) {
        continue;
      }

      const nameToken = tokens[index - 1];
      if (!nameToken) {
        continue;
      }

      const name = normalizeFormParamName(nameToken.raw);
      if (!name) {
        continue;
      }

      const key = `${section}:${name.toUpperCase()}`;
      if (seen.has(key)) {
        continue;
      }

      const typing = readTyping(tokens, index);
      params.push({
        section,
        name,
        typing
      });

      seen.add(key);
    }

    if (params.length) {
      return params;
    }

    for (const token of tokens) {
      const name = normalizeFormParamName(token.raw);
      if (!name) {
        continue;
      }
      const key = `${section}:${name.toUpperCase()}`;
      if (seen.has(key)) {
        continue;
      }
      params.push({
        section,
        name,
        typing: null
      });
      seen.add(key);
    }

    return params;
  }

  function readTyping(tokens, keywordIndex) {
    const kind = tokens[keywordIndex].upper;
    const next = tokens[keywordIndex + 1];
    const next2 = tokens[keywordIndex + 2];
    const next3 = tokens[keywordIndex + 3];

    if ((kind === "TYPE" || kind === "LIKE") && next && next.upper === "REF" && next2 && next2.upper === "TO" && next3) {
      return { kind: `${kind} REF TO`, value: next3.raw };
    }

    if (next) {
      return { kind, value: next.raw };
    }

    return { kind, value: "" };
  }

  function parseFormExceptions(segmentRaw) {
    const trimmed = String(segmentRaw || "").trim();
    if (!trimmed) {
      return [];
    }

    const tokens = tokenize(`${trimmed}.`);
    return tokens
      .map((token) => token.raw)
      .filter(Boolean)
      .map((name) => ({ name }));
  }

  function normalizeFormParamName(raw) {
    const trimmed = String(raw || "").trim();
    if (!trimmed) {
      return "";
    }

    const valueMatch = trimmed.match(/^VALUE\(([^)]+)\)$/i);
    const candidate = valueMatch ? valueMatch[1] : trimmed;
    const cleaned = candidate.replace(/^[([{]+/, "").replace(/[)\]}]+$/, "").trim();

    if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(cleaned)) {
      return "";
    }

    return cleaned;
  }

  function parseFormDocComment(commentLines) {
    const params = [];
    let formName = "";

    for (const line of commentLines || []) {
      const text = String(line || "").trim();
      if (!text) {
        continue;
      }

      if (!formName) {
        const match = text.match(/\bForm\s+([A-Za-z_][A-Za-z0-9_]*)\b/i);
        if (match) {
          formName = match[1];
        }
      }

      const paramMatch = text.match(/^(-->|<--|<->)\s+([A-Za-z_][A-Za-z0-9_]*)\s*(.*)$/);
      if (!paramMatch) {
        continue;
      }

      const direction = decodeArrowDirection(paramMatch[1]);
      const name = paramMatch[2];
      const desc = String(paramMatch[3] || "").trim();

      params.push({
        direction,
        name,
        text: desc
      });
    }

    return {
      formName,
      params
    };
  }

  function decodeArrowDirection(symbol) {
    if (symbol === "-->") {
      return "in";
    }
    if (symbol === "<--") {
      return "out";
    }
    return "inout";
  }

  function isChainedStatementStart(raw, startKeyword) {
    if (!startKeyword) {
      return false;
    }

    const pattern = new RegExp(`^\\s*${escapeRegExp(startKeyword)}\\s*:`, "i");
    return pattern.test(raw);
  }

  function splitChainedStatement(raw, startKeyword) {
    const pattern = new RegExp(`^\\s*${escapeRegExp(startKeyword)}\\s*:\\s*`, "i");
    const match = raw.match(pattern);
    if (!match) {
      return [raw];
    }

    let body = raw.slice(match[0].length).trim();
    body = body.replace(/\.$/, "").trim();
    if (!body) {
      return [];
    }

    const parts = splitByCommaOutsideQuotes(body)
      .map((part) => part.trim())
      .filter(Boolean);

    return parts.map((part) => `${startKeyword} ${part}.`);
  }

  function splitByCommaOutsideQuotes(text) {
    const parts = [];
    let current = "";
    let inSingleQuote = false;
    let inPipe = false;

    for (let index = 0; index < text.length; index += 1) {
      const char = text[index];
      const next = index + 1 < text.length ? text[index + 1] : "";

      if (char === "'" && !inPipe) {
        if (inSingleQuote && next === "'") {
          current += "''";
          index += 1;
          continue;
        }
        inSingleQuote = !inSingleQuote;
        current += char;
        continue;
      }

      if (char === "|" && !inSingleQuote) {
        if (inPipe && next === "|") {
          current += "||";
          index += 1;
          continue;
        }
        inPipe = !inPipe;
        current += char;
        continue;
      }

      if (char === "," && !inSingleQuote && !inPipe) {
        parts.push(current.trim());
        current = "";
        continue;
      }

      current += char;
    }

    if (current.trim()) {
      parts.push(current.trim());
    }

    return parts;
  }

  function escapeRegExp(text) {
    return String(text).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function tokenize(statementRaw) {
    const trimmed = statementRaw.trim();
    if (!trimmed) {
      return [];
    }

    const withoutDot = trimmed.replace(/\.$/, "").trim();
    const tokens = [];
    let index = 0;

    while (index < withoutDot.length) {
      const char = withoutDot[index];

      if (/\s/.test(char)) {
        index += 1;
        continue;
      }

      if (char === "'" || char === "|") {
        const quoteChar = char;
        let end = index + 1;
        while (end < withoutDot.length && withoutDot[end] !== quoteChar) {
          end += 1;
        }
        if (end < withoutDot.length) {
          end += 1;
        }
        const token = withoutDot.slice(index, end);
        tokens.push(token);
        index = end;
        continue;
      }

      let end = index + 1;
      while (end < withoutDot.length && !/\s/.test(withoutDot[end])) {
        end += 1;
      }
      const token = withoutDot.slice(index, end);
      tokens.push(token);
      index = end;
    }

    return tokens
      .map((token) => token.replace(/[,:\u00A0]+$/, ""))
      .filter(Boolean)
      .map((token) => ({
        raw: token,
        upper: token.toUpperCase()
      }));
  }

  function detectKeywords(tokens, config) {
    const keywords = [];
    const phraseEntries = buildPhraseEntries(config.keywordPhrases);

    for (let i = 0; i < tokens.length; i += 1) {
      const match = matchPhraseAt(tokens, i, phraseEntries);
      if (match) {
        const phraseText = tokens
          .slice(i, i + match.length)
          .map((token) => token.raw)
          .join(" ");

        keywords.push({ text: phraseText, label: match.label });
        i += match.length - 1;
        continue;
      }

      const label = config.keywordLabels[tokens[i].upper];
      if (label) {
        keywords.push({ text: tokens[i].raw, label });
      }
    }

    return keywords;
  }

  function buildPhraseEntries(phraseMap) {
    return Object.entries(phraseMap || {})
      .map(([phrase, label]) => ({
        phrase,
        label,
        tokens: phrase.split(/\s+/)
      }))
      .sort((a, b) => b.tokens.length - a.tokens.length);
  }

  function matchPhraseAt(tokens, index, phraseEntries) {
    for (const entry of phraseEntries) {
      if (index + entry.tokens.length > tokens.length) {
        continue;
      }

      let matches = true;
      for (let offset = 0; offset < entry.tokens.length; offset += 1) {
        if (tokens[index + offset].upper !== entry.tokens[offset]) {
          matches = false;
          break;
        }
      }

      if (matches) {
        return {
          phrase: entry.phrase,
          label: entry.label,
          length: entry.tokens.length
        };
      }
    }

    return null;
  }

  function captureValues(tokens, config, commentText) {
    const values = [];
    const descMap = config.valueDescriptions || {};
    const rules = (config.captureRules || []).filter(
      (rule) => rule.afterTokens && rule.afterTokens.length
    );
    const statementDesc = commentText || "";

    for (let index = 0; index < tokens.length; index += 1) {
      let bestRule = null;

      for (const rule of rules) {
        if (!matchesTokens(tokens, index, rule.afterTokens)) {
          continue;
        }

        if (!bestRule || rule.afterTokens.length > bestRule.afterTokens.length) {
          bestRule = rule;
        }
      }

      if (!bestRule) {
        continue;
      }

      const valueIndex = index + bestRule.afterTokens.length;
      if (valueIndex < tokens.length) {
        const captured = captureValue(tokens, valueIndex, bestRule);
        const userDesc = resolveUserDesc(descMap, bestRule.descKey, captured.upper);

        values.push({
          name: bestRule.name,
          value: captured.raw,
          label: bestRule.label || bestRule.name,
          userDesc: userDesc || "",
          codeDesc: statementDesc
        });
      }

      index += bestRule.afterTokens.length - 1;
    }

    return values;
  }

  function captureAssignmentValues(tokens, commentText) {
    if (!Array.isArray(tokens) || tokens.length < 3) {
      return [];
    }

    const statementDesc = commentText || "";
    const target = tokens[0] ? tokens[0].raw : "";
    const op = tokens[1] ? tokens[1].raw : "";
    const expr = tokens
      .slice(2)
      .map((t) => t.raw)
      .join(" ")
      .trim();

    return [
      { name: "target", value: target, label: "target", userDesc: "", codeDesc: statementDesc },
      { name: "op", value: op, label: "op", userDesc: "", codeDesc: statementDesc },
      { name: "expr", value: expr, label: "expr", userDesc: "", codeDesc: statementDesc }
    ];
  }

  function captureValue(tokens, startIndex, rule) {
    if (rule.capture === "rest") {
      const stopTokens = rule.stopTokensUpper || [];
      const parts = [];
      for (let i = startIndex; i < tokens.length; i += 1) {
        if (stopTokens.length && stopTokens.includes(tokens[i].upper)) {
          break;
        }
        parts.push(tokens[i].raw);
      }
      const raw = parts.join(" ").trim();
      return { raw, upper: raw.toUpperCase() };
    }

    const token = tokens[startIndex];
    return token ? { raw: token.raw, upper: token.upper } : { raw: "", upper: "" };
  }

  function matchesTokens(tokens, startIndex, expectedTokens) {
    if (startIndex + expectedTokens.length > tokens.length) {
      return false;
    }

    for (let offset = 0; offset < expectedTokens.length; offset += 1) {
      if (tokens[startIndex + offset].upper !== expectedTokens[offset]) {
        return false;
      }
    }

    return true;
  }

  function resolveUserDesc(descMap, descKey, valueUpper) {
    if (!descKey) {
      return "";
    }

    const map = descMap[descKey];
    if (!map) {
      return "";
    }

    return map[valueUpper] || "";
  }

  return {
    AbapObject,
    normalizeConfig,
    registerConfig,
    getConfigs,
    parseAbapText
  };
});
</script>
  <!-- abap-parser-configs:start -->
  <script>
// inlined from: ./configs.generated/append.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: append.json");
    return;
  }

  const config = {
    "_sourceFile": "append.json",
    "object": "APPEND",
    "match": {
      "startKeyword": "APPEND"
    },
    "keywordLabels": {
      "APPEND": "stmt",
      "TO": "to",
      "LINES": "lines",
      "OF": "of",
      "INITIAL": "initial",
      "LINE": "line",
      "ASSIGNING": "assigning",
      "REFERENCE": "reference",
      "INTO": "into"
    },
    "keywordPhrases": {
      "LINES OF": "lines-of",
      "INITIAL LINE": "initial-line",
      "REFERENCE INTO": "reference-into"
    },
    "captureRules": [
      {
        "after": "APPEND",
        "name": "what",
        "label": "what"
      },
      {
        "after": "APPEND LINES OF",
        "name": "source",
        "label": "source-itab"
      },
      {
        "after": "TO",
        "name": "to",
        "label": "to-itab"
      },
      {
        "after": "ASSIGNING",
        "name": "assigning",
        "label": "assigning"
      },
      {
        "after": "REFERENCE INTO",
        "name": "refInto",
        "label": "reference-into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/assignment.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: assignment.json");
    return;
  }

  const config = {
    "_sourceFile": "assignment.json",
    "object": "ASSIGNMENT",
    "match": {
      "type": "assignment"
    },
    "keywordLabels": {
      "=": "assign",
      "+=": "add-assign",
      "-=": "sub-assign",
      "*=": "mul-assign",
      "/=": "div-assign",
      "?=": "cast"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/call-function.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: call-function.json");
    return;
  }

  const config = {
    "_sourceFile": "call-function.json",
    "object": "CALL_FUNCTION",
    "match": {
      "startPhrase": "CALL FUNCTION"
    },
    "extras": {
      "type": "callFunction"
    },
    "keywordLabels": {
      "CALL": "stmt",
      "FUNCTION": "function",
      "DESTINATION": "destination",
      "IN": "in",
      "BACKGROUND": "background",
      "TASK": "task",
      "EXPORTING": "exporting",
      "IMPORTING": "importing",
      "CHANGING": "changing",
      "TABLES": "tables",
      "EXCEPTIONS": "exceptions"
    },
    "keywordPhrases": {
      "CALL FUNCTION": "call-function",
      "IN BACKGROUND TASK": "in-background-task"
    },
    "captureRules": [
      {
        "after": "CALL FUNCTION",
        "name": "name",
        "label": "function-name",
        "descKey": "name"
      },
      {
        "after": "DESTINATION",
        "name": "destination",
        "label": "destination"
      },
      {
        "after": "EXPORTING",
        "name": "exportingRaw",
        "label": "exporting",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "CHANGING",
          "TABLES",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "IMPORTING",
        "name": "importingRaw",
        "label": "importing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "CHANGING",
          "TABLES",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "TABLES",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "TABLES",
        "name": "tablesRaw",
        "label": "tables",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "CHANGING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "EXCEPTIONS",
        "name": "exceptionsRaw",
        "label": "exceptions",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/call-method.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: call-method.json");
    return;
  }

  const config = {
    "_sourceFile": "call-method.json",
    "object": "CALL_METHOD",
    "match": {
      "startPhrase": "CALL METHOD"
    },
    "extras": {
      "type": "callMethod"
    },
    "keywordLabels": {
      "CALL": "stmt",
      "METHOD": "method",
      "EXPORTING": "exporting",
      "IMPORTING": "importing",
      "CHANGING": "changing",
      "RECEIVING": "receiving",
      "EXCEPTIONS": "exceptions"
    },
    "keywordPhrases": {
      "CALL METHOD": "call-method"
    },
    "captureRules": [
      {
        "after": "CALL METHOD",
        "name": "target",
        "label": "target",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "CHANGING",
          "RECEIVING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "EXPORTING",
        "name": "exportingRaw",
        "label": "exporting",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "CHANGING",
          "RECEIVING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "IMPORTING",
        "name": "importingRaw",
        "label": "importing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "CHANGING",
          "RECEIVING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "RECEIVING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "RECEIVING",
        "name": "receivingRaw",
        "label": "receiving",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "CHANGING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "EXCEPTIONS",
        "name": "exceptionsRaw",
        "label": "exceptions",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/call-transaction.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: call-transaction.json");
    return;
  }

  const config = {
    "_sourceFile": "call-transaction.json",
    "object": "CALL_TRANSACTION",
    "match": {
      "startPhrase": "CALL TRANSACTION"
    },
    "keywordLabels": {
      "CALL": "stmt",
      "TRANSACTION": "transaction",
      "USING": "using",
      "SKIP": "skip",
      "FIRST": "first",
      "SCREEN": "screen",
      "AND": "and",
      "RETURN": "return",
      "MODE": "mode",
      "UPDATE": "update",
      "MESSAGES": "messages",
      "INTO": "into"
    },
    "keywordPhrases": {
      "CALL TRANSACTION": "call-transaction",
      "SKIP FIRST SCREEN": "skip-first-screen",
      "AND RETURN": "and-return",
      "MESSAGES INTO": "messages-into"
    },
    "captureRules": [
      {
        "after": "CALL TRANSACTION",
        "name": "tcode",
        "label": "tcode",
        "descKey": "tcode"
      },
      {
        "after": "USING",
        "name": "using",
        "label": "using"
      },
      {
        "after": "MODE",
        "name": "mode",
        "label": "mode"
      },
      {
        "after": "UPDATE",
        "name": "update",
        "label": "update"
      },
      {
        "after": "MESSAGES INTO",
        "name": "messagesInto",
        "label": "messages-into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/case.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: case.json");
    return;
  }

  const config = {
    "_sourceFile": "case.json",
    "object": "CASE",
    "match": {
      "startKeyword": "CASE"
    },
    "block": {
      "endKeyword": "ENDCASE"
    },
    "keywordLabels": {
      "CASE": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "CASE",
        "name": "expr",
        "label": "expression",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/catch.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: catch.json");
    return;
  }

  const config = {
    "_sourceFile": "catch.json",
    "object": "CATCH",
    "match": {
      "startKeyword": "CATCH"
    },
    "keywordLabels": {
      "CATCH": "stmt",
      "INTO": "into"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "CATCH",
        "name": "exception",
        "label": "exception",
        "capture": "rest",
        "stopTokens": [
          "INTO"
        ]
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/class-data.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: class-data.json");
    return;
  }

  const config = {
    "_sourceFile": "class-data.json",
    "object": "CLASS-DATA",
    "match": {
      "startKeyword": "CLASS-DATA"
    },
    "keywordLabels": {
      "CLASS-DATA": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to",
      "VALUE": "value",
      "LENGTH": "length",
      "DECIMALS": "decimals",
      "READ-ONLY": "read-only"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "CLASS-DATA",
        "name": "name",
        "label": "attr-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like-name",
        "descKey": "like"
      },
      {
        "after": "VALUE",
        "name": "value",
        "label": "value",
        "descKey": "value"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/class-methods.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: class-methods.json");
    return;
  }

  const config = {
    "_sourceFile": "class-methods.json",
    "object": "CLASS-METHODS",
    "match": {
      "startKeyword": "CLASS-METHODS"
    },
    "extras": {
      "type": "methodSignature"
    },
    "keywordLabels": {
      "CLASS-METHODS": "stmt",
      "IMPORTING": "importing",
      "EXPORTING": "exporting",
      "CHANGING": "changing",
      "RETURNING": "returning",
      "RAISING": "raising"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "CLASS-METHODS",
        "name": "name",
        "label": "method-name",
        "descKey": "name"
      },
      {
        "after": "IMPORTING",
        "name": "importingRaw",
        "label": "importing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "CHANGING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "EXPORTING",
        "name": "exportingRaw",
        "label": "exporting",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "CHANGING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "EXPORTING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "RETURNING",
        "name": "returningRaw",
        "label": "returning",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "EXPORTING",
          "CHANGING",
          "RAISING"
        ]
      },
      {
        "after": "RAISING",
        "name": "raisingRaw",
        "label": "raising",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/class.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: class.json");
    return;
  }

  const config = {
    "_sourceFile": "class.json",
    "object": "CLASS",
    "match": {
      "startKeyword": "CLASS"
    },
    "block": {
      "endKeyword": "ENDCLASS"
    },
    "keywordLabels": {
      "CLASS": "stmt",
      "DEFINITION": "definition",
      "IMPLEMENTATION": "implementation",
      "PUBLIC": "public",
      "PROTECTED": "protected",
      "PRIVATE": "private",
      "SECTION": "section",
      "CREATE": "create"
    },
    "keywordPhrases": {
      "PUBLIC SECTION": "public-section",
      "PROTECTED SECTION": "protected-section",
      "PRIVATE SECTION": "private-section",
      "CREATE PUBLIC": "create-public"
    },
    "captureRules": [
      {
        "after": "CLASS",
        "name": "name",
        "label": "class-name",
        "descKey": "name"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/cleanup.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: cleanup.json");
    return;
  }

  const config = {
    "_sourceFile": "cleanup.json",
    "object": "CLEANUP",
    "match": {
      "startKeyword": "CLEANUP"
    },
    "keywordLabels": {
      "CLEANUP": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/clear.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: clear.json");
    return;
  }

  const config = {
    "_sourceFile": "clear.json",
    "object": "CLEAR",
    "match": {
      "startKeyword": "CLEAR"
    },
    "keywordLabels": {
      "CLEAR": "stmt",
      "WITH": "with"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "CLEAR",
        "name": "target",
        "label": "target"
      },
      {
        "after": "WITH",
        "name": "with",
        "label": "with"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/constants.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: constants.json");
    return;
  }

  const config = {
    "_sourceFile": "constants.json",
    "object": "CONSTANTS",
    "match": {
      "startKeyword": "CONSTANTS"
    },
    "keywordLabels": {
      "CONSTANTS": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to",
      "VALUE": "value",
      "LENGTH": "length",
      "DECIMALS": "decimals"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "CONSTANTS",
        "name": "name",
        "label": "const-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like-name",
        "descKey": "like"
      },
      {
        "after": "VALUE",
        "name": "value",
        "label": "value",
        "descKey": "value"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/data.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: data.json");
    return;
  }

  const config = {
    "_sourceFile": "data.json",
    "object": "DATA",
    "match": {
      "startKeyword": "DATA"
    },
    "keywordLabels": {
      "DATA": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "BEGIN": "begin",
      "OF": "of",
      "END": "end",
      "REF": "ref",
      "TO": "to",
      "VALUE": "value",
      "LENGTH": "length",
      "DECIMALS": "decimals",
      "READ-ONLY": "read-only"
    },
    "keywordPhrases": {
      "BEGIN OF": "begin-of",
      "END OF": "end-of",
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "DATA BEGIN OF",
        "name": "name",
        "label": "struct-name",
        "descKey": "name"
      },
      {
        "after": "DATA END OF",
        "name": "name",
        "label": "struct-name",
        "descKey": "name"
      },
      {
        "after": "DATA",
        "name": "name",
        "label": "var-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like-name",
        "descKey": "like"
      },
      {
        "after": "VALUE",
        "name": "value",
        "label": "value",
        "descKey": "value"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/delete-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: delete-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "delete-itab.json",
    "object": "DELETE_ITAB",
    "match": {
      "startKeyword": "DELETE"
    },
    "keywordLabels": {
      "DELETE": "stmt",
      "FROM": "from",
      "INDEX": "index",
      "WHERE": "where",
      "ADJACENT": "adjacent",
      "DUPLICATES": "duplicates",
      "COMPARING": "comparing"
    },
    "keywordPhrases": {
      "ADJACENT DUPLICATES": "adjacent-duplicates",
      "DELETE ADJACENT DUPLICATES": "delete-adjacent-duplicates"
    },
    "captureRules": [
      {
        "after": "DELETE",
        "name": "target",
        "label": "target"
      },
      {
        "after": "FROM",
        "name": "from",
        "label": "from"
      },
      {
        "after": "INDEX",
        "name": "index",
        "label": "index"
      },
      {
        "after": "WHERE",
        "name": "where",
        "label": "where",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/do.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: do.json");
    return;
  }

  const config = {
    "_sourceFile": "do.json",
    "object": "DO",
    "match": {
      "startKeyword": "DO"
    },
    "block": {
      "endKeyword": "ENDDO"
    },
    "keywordLabels": {
      "DO": "stmt",
      "TIMES": "times"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "DO",
        "name": "times",
        "label": "times"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/else.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: else.json");
    return;
  }

  const config = {
    "_sourceFile": "else.json",
    "object": "ELSE",
    "match": {
      "startKeyword": "ELSE"
    },
    "keywordLabels": {
      "ELSE": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/elseif.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: elseif.json");
    return;
  }

  const config = {
    "_sourceFile": "elseif.json",
    "object": "ELSEIF",
    "match": {
      "startKeyword": "ELSEIF"
    },
    "keywordLabels": {
      "ELSEIF": "stmt",
      "AND": "and",
      "OR": "or",
      "NOT": "not",
      "IS": "is",
      "INITIAL": "initial"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "ELSEIF",
        "name": "condition",
        "label": "condition",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/field-symbols.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: field-symbols.json");
    return;
  }

  const config = {
    "_sourceFile": "field-symbols.json",
    "object": "FIELD-SYMBOLS",
    "match": {
      "startKeyword": "FIELD-SYMBOLS"
    },
    "keywordLabels": {
      "FIELD-SYMBOLS": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to",
      "STRUCTURE": "structure"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "FIELD-SYMBOLS",
        "name": "name",
        "label": "fs-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like",
        "descKey": "like"
      },
      {
        "after": "STRUCTURE",
        "name": "structure",
        "label": "structure",
        "descKey": "structure"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/form.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: form.json");
    return;
  }

  const config = {
    "_sourceFile": "form.json",
    "object": "FORM",
    "match": {
      "startKeyword": "FORM"
    },
    "block": {
      "endKeyword": "ENDFORM"
    },
    "extras": {
      "type": "form"
    },
    "keywordLabels": {
      "FORM": "stmt",
      "USING": "using",
      "CHANGING": "changing",
      "TABLES": "tables",
      "RAISING": "raising"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "FORM",
        "name": "name",
        "label": "form-name",
        "descKey": "name"
      },
      {
        "after": "USING",
        "name": "usingRaw",
        "label": "using",
        "capture": "rest",
        "stopTokens": [
          "CHANGING",
          "TABLES",
          "RAISING"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "USING",
          "TABLES",
          "RAISING"
        ]
      },
      {
        "after": "TABLES",
        "name": "tablesRaw",
        "label": "tables",
        "capture": "rest",
        "stopTokens": [
          "USING",
          "CHANGING",
          "RAISING"
        ]
      },
      {
        "after": "RAISING",
        "name": "raisingRaw",
        "label": "raising",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/if.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: if.json");
    return;
  }

  const config = {
    "_sourceFile": "if.json",
    "object": "IF",
    "match": {
      "startKeyword": "IF"
    },
    "block": {
      "endKeyword": "ENDIF"
    },
    "keywordLabels": {
      "IF": "stmt",
      "AND": "and",
      "OR": "or",
      "NOT": "not",
      "IS": "is",
      "INITIAL": "initial"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "IF",
        "name": "condition",
        "label": "condition",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/insert-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: insert-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "insert-itab.json",
    "object": "INSERT_ITAB",
    "match": {
      "startKeyword": "INSERT"
    },
    "keywordLabels": {
      "INSERT": "stmt",
      "INTO": "into",
      "TABLE": "table",
      "LINES": "lines",
      "OF": "of",
      "INDEX": "index",
      "ASSIGNING": "assigning",
      "REFERENCE": "reference"
    },
    "keywordPhrases": {
      "INTO TABLE": "into-table",
      "LINES OF": "lines-of",
      "REFERENCE INTO": "reference-into"
    },
    "captureRules": [
      {
        "after": "INSERT",
        "name": "what",
        "label": "what"
      },
      {
        "after": "INSERT LINES OF",
        "name": "source",
        "label": "source-itab"
      },
      {
        "after": "INTO TABLE",
        "name": "intoTable",
        "label": "into-table"
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      },
      {
        "after": "INDEX",
        "name": "index",
        "label": "index"
      },
      {
        "after": "ASSIGNING",
        "name": "assigning",
        "label": "assigning"
      },
      {
        "after": "REFERENCE INTO",
        "name": "refInto",
        "label": "reference-into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/loop-at-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: loop-at-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "loop-at-itab.json",
    "object": "LOOP_AT_ITAB",
    "match": {
      "startPhrase": "LOOP AT"
    },
    "block": {
      "endKeyword": "ENDLOOP"
    },
    "keywordLabels": {
      "LOOP": "stmt",
      "AT": "at",
      "INTO": "into",
      "ASSIGNING": "assigning",
      "REFERENCE": "reference",
      "WHERE": "where",
      "FROM": "from",
      "TO": "to"
    },
    "keywordPhrases": {
      "LOOP AT": "loop-at",
      "REFERENCE INTO": "reference-into"
    },
    "captureRules": [
      {
        "after": "LOOP AT",
        "name": "itab",
        "label": "itab",
        "descKey": "itab"
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      },
      {
        "after": "ASSIGNING",
        "name": "assigning",
        "label": "assigning"
      },
      {
        "after": "REFERENCE INTO",
        "name": "refInto",
        "label": "reference-into"
      },
      {
        "after": "FROM",
        "name": "from",
        "label": "from"
      },
      {
        "after": "TO",
        "name": "to",
        "label": "to"
      },
      {
        "after": "WHERE",
        "name": "where",
        "label": "where",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/method.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: method.json");
    return;
  }

  const config = {
    "_sourceFile": "method.json",
    "object": "METHOD",
    "match": {
      "startKeyword": "METHOD"
    },
    "block": {
      "endKeyword": "ENDMETHOD"
    },
    "keywordLabels": {
      "METHOD": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "METHOD",
        "name": "name",
        "label": "method-name",
        "descKey": "name"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/methods.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: methods.json");
    return;
  }

  const config = {
    "_sourceFile": "methods.json",
    "object": "METHODS",
    "match": {
      "startKeyword": "METHODS"
    },
    "extras": {
      "type": "methodSignature"
    },
    "keywordLabels": {
      "METHODS": "stmt",
      "IMPORTING": "importing",
      "EXPORTING": "exporting",
      "CHANGING": "changing",
      "RETURNING": "returning",
      "RAISING": "raising"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "METHODS",
        "name": "name",
        "label": "method-name",
        "descKey": "name"
      },
      {
        "after": "IMPORTING",
        "name": "importingRaw",
        "label": "importing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "CHANGING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "EXPORTING",
        "name": "exportingRaw",
        "label": "exporting",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "CHANGING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "EXPORTING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "RETURNING",
        "name": "returningRaw",
        "label": "returning",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "EXPORTING",
          "CHANGING",
          "RAISING"
        ]
      },
      {
        "after": "RAISING",
        "name": "raisingRaw",
        "label": "raising",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/modify-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: modify-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "modify-itab.json",
    "object": "MODIFY_ITAB",
    "match": {
      "startKeyword": "MODIFY"
    },
    "keywordLabels": {
      "MODIFY": "stmt",
      "TABLE": "table",
      "FROM": "from",
      "INDEX": "index",
      "TRANSPORTING": "transporting",
      "WHERE": "where"
    },
    "keywordPhrases": {
      "MODIFY TABLE": "modify-table"
    },
    "captureRules": [
      {
        "after": "MODIFY TABLE",
        "name": "itab",
        "label": "itab"
      },
      {
        "after": "MODIFY",
        "name": "itabOrDbtab",
        "label": "target"
      },
      {
        "after": "FROM",
        "name": "from",
        "label": "from"
      },
      {
        "after": "INDEX",
        "name": "index",
        "label": "index"
      },
      {
        "after": "TRANSPORTING",
        "name": "transporting",
        "label": "transporting",
        "capture": "rest",
        "stopTokens": [
          "WHERE"
        ]
      },
      {
        "after": "WHERE",
        "name": "where",
        "label": "where",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/move-corresponding.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: move-corresponding.json");
    return;
  }

  const config = {
    "_sourceFile": "move-corresponding.json",
    "object": "MOVE-CORRESPONDING",
    "match": {
      "startKeyword": "MOVE-CORRESPONDING"
    },
    "keywordLabels": {
      "MOVE-CORRESPONDING": "stmt",
      "TO": "to",
      "EXPANDING": "expanding",
      "NESTED": "nested",
      "TABLES": "tables",
      "KEEPING": "keeping",
      "TARGET": "target",
      "LINES": "lines"
    },
    "keywordPhrases": {
      "EXPANDING NESTED TABLES": "expanding-nested-tables",
      "KEEPING TARGET LINES": "keeping-target-lines"
    },
    "captureRules": [
      {
        "after": "MOVE-CORRESPONDING",
        "name": "source",
        "label": "source"
      },
      {
        "after": "TO",
        "name": "target",
        "label": "target"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/move.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: move.json");
    return;
  }

  const config = {
    "_sourceFile": "move.json",
    "object": "MOVE",
    "match": {
      "startKeyword": "MOVE"
    },
    "keywordLabels": {
      "MOVE": "stmt",
      "TO": "to"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "MOVE",
        "name": "source",
        "label": "source",
        "capture": "rest",
        "stopTokens": [
          "TO"
        ]
      },
      {
        "after": "TO",
        "name": "target",
        "label": "target",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/parameters.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: parameters.json");
    return;
  }

  const config = {
    "_sourceFile": "parameters.json",
    "object": "PARAMETERS",
    "match": {
      "startKeyword": "PARAMETERS"
    },
    "keywordLabels": {
      "PARAMETERS": "stmt",
      "TYPE": "type",
      "DEFAULT": "default",
      "OBLIGATORY": "obligatory",
      "AS": "as",
      "CHECKBOX": "checkbox",
      "RADIOBUTTON": "radiobutton",
      "LISTBOX": "listbox",
      "VISIBLE": "visible",
      "LENGTH": "length",
      "NO-DISPLAY": "no-display",
      "LOWER": "lower",
      "CASE": "case",
      "MEMORY": "memory",
      "ID": "id",
      "MODIF": "modif",
      "GROUP": "group",
      "DECIMALS": "decimals",
      "NO-EXTENSION": "no-extension"
    },
    "keywordPhrases": {
      "LOWER CASE": "lower-case",
      "NO-DISPLAY": "no-display",
      "AS CHECKBOX": "as-checkbox",
      "AS RADIOBUTTON": "as-radiobutton",
      "AS LISTBOX": "as-listbox",
      "MEMORY ID": "memory-id",
      "MODIF ID": "modif-id",
      "NO-EXTENSION": "no-extension"
    },
    "captureRules": [
      {
        "after": "PARAMETERS",
        "name": "name",
        "label": "param-name",
        "descKey": "name"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "DEFAULT",
        "name": "default",
        "label": "default-value",
        "descKey": "default"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      },
      {
        "after": "GROUP",
        "name": "group",
        "label": "group-name"
      },
      {
        "after": "MEMORY ID",
        "name": "memoryId",
        "label": "memory-id"
      },
      {
        "after": "MODIF ID",
        "name": "modifId",
        "label": "modif-id"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/perform.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: perform.json");
    return;
  }

  const config = {
    "_sourceFile": "perform.json",
    "object": "PERFORM",
    "match": {
      "startKeyword": "PERFORM"
    },
    "extras": {
      "type": "performCall"
    },
    "keywordLabels": {
      "PERFORM": "stmt",
      "IN": "in",
      "PROGRAM": "program",
      "USING": "using",
      "CHANGING": "changing",
      "TABLES": "tables",
      "IF": "if"
    },
    "keywordPhrases": {
      "IN PROGRAM": "in-program"
    },
    "captureRules": [
      {
        "after": "PERFORM",
        "name": "form",
        "label": "form-name",
        "descKey": "form"
      },
      {
        "after": "IN PROGRAM",
        "name": "program",
        "label": "program"
      },
      {
        "after": "USING",
        "name": "usingRaw",
        "label": "using",
        "capture": "rest",
        "stopTokens": [
          "CHANGING",
          "TABLES",
          "IF"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "USING",
          "TABLES",
          "IF"
        ]
      },
      {
        "after": "TABLES",
        "name": "tablesRaw",
        "label": "tables",
        "capture": "rest",
        "stopTokens": [
          "USING",
          "CHANGING",
          "IF"
        ]
      },
      {
        "after": "IF",
        "name": "ifCondition",
        "label": "if",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/ranges.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: ranges.json");
    return;
  }

  const config = {
    "_sourceFile": "ranges.json",
    "object": "RANGES",
    "match": {
      "startKeyword": "RANGES"
    },
    "keywordLabels": {
      "RANGES": "stmt",
      "FOR": "for",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "RANGES",
        "name": "name",
        "label": "range-name",
        "descKey": "name"
      },
      {
        "after": "FOR",
        "name": "for",
        "label": "for",
        "descKey": "for"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like",
        "descKey": "like"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/read-table.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: read-table.json");
    return;
  }

  const config = {
    "_sourceFile": "read-table.json",
    "object": "READ_TABLE",
    "match": {
      "startPhrase": "READ TABLE"
    },
    "keywordLabels": {
      "READ": "stmt",
      "TABLE": "table",
      "WITH": "with",
      "KEY": "key",
      "INDEX": "index",
      "INTO": "into",
      "ASSIGNING": "assigning",
      "REFERENCE": "reference",
      "TRANSPORTING": "transporting",
      "NO": "no",
      "FIELDS": "fields",
      "BINARY": "binary",
      "SEARCH": "search"
    },
    "keywordPhrases": {
      "READ TABLE": "read-table",
      "WITH KEY": "with-key",
      "TRANSPORTING NO FIELDS": "transporting-no-fields",
      "BINARY SEARCH": "binary-search",
      "REFERENCE INTO": "reference-into"
    },
    "captureRules": [
      {
        "after": "READ TABLE",
        "name": "itab",
        "label": "itab"
      },
      {
        "after": "INDEX",
        "name": "index",
        "label": "index"
      },
      {
        "after": "WITH KEY",
        "name": "withKey",
        "label": "with-key",
        "capture": "rest",
        "stopTokens": [
          "INTO",
          "ASSIGNING",
          "REFERENCE",
          "TRANSPORTING",
          "BINARY"
        ]
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      },
      {
        "after": "ASSIGNING",
        "name": "assigning",
        "label": "assigning"
      },
      {
        "after": "REFERENCE INTO",
        "name": "refInto",
        "label": "reference-into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/select-options.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: select-options.json");
    return;
  }

  const config = {
    "_sourceFile": "select-options.json",
    "object": "SELECT-OPTIONS",
    "match": {
      "startKeyword": "SELECT-OPTIONS"
    },
    "keywordLabels": {
      "SELECT-OPTIONS": "stmt",
      "FOR": "for",
      "DEFAULT": "default",
      "OBLIGATORY": "obligatory",
      "NO-EXTENSION": "no-extension",
      "NO": "no",
      "INTERVALS": "intervals",
      "LOWER": "lower",
      "CASE": "case",
      "MEMORY": "memory",
      "ID": "id",
      "MODIF": "modif",
      "VISIBLE": "visible",
      "LENGTH": "length"
    },
    "keywordPhrases": {
      "LOWER CASE": "lower-case",
      "NO-EXTENSION": "no-extension",
      "NO INTERVALS": "no-intervals",
      "MEMORY ID": "memory-id",
      "MODIF ID": "modif-id"
    },
    "captureRules": [
      {
        "after": "SELECT-OPTIONS",
        "name": "name",
        "label": "selopt-name",
        "descKey": "name"
      },
      {
        "after": "FOR",
        "name": "for",
        "label": "for"
      },
      {
        "after": "DEFAULT",
        "name": "default",
        "label": "default"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "MEMORY ID",
        "name": "memoryId",
        "label": "memory-id"
      },
      {
        "after": "MODIF ID",
        "name": "modifId",
        "label": "modif-id"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/select.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: select.json");
    return;
  }

  const config = {
    "_sourceFile": "select.json",
    "object": "SELECT",
    "match": {
      "startKeyword": "SELECT"
    },
    "keywordLabels": {
      "SELECT": "stmt",
      "SINGLE": "single",
      "DISTINCT": "distinct",
      "FROM": "from",
      "INTO": "into",
      "APPENDING": "appending",
      "TABLE": "table",
      "WHERE": "where",
      "ORDER": "order",
      "BY": "by",
      "GROUP": "group",
      "HAVING": "having",
      "UP": "up",
      "TO": "to",
      "ROWS": "rows"
    },
    "keywordPhrases": {
      "INTO TABLE": "into-table",
      "APPENDING TABLE": "appending-table",
      "ORDER BY": "order-by",
      "GROUP BY": "group-by",
      "UP TO": "up-to"
    },
    "captureRules": [
      {
        "after": "SELECT",
        "name": "fields",
        "label": "fields",
        "capture": "rest",
        "stopTokens": [
          "FROM"
        ]
      },
      {
        "after": "FROM",
        "name": "from",
        "label": "from"
      },
      {
        "after": "INTO TABLE",
        "name": "intoTable",
        "label": "into-table"
      },
      {
        "after": "APPENDING TABLE",
        "name": "appendingTable",
        "label": "appending-table"
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      },
      {
        "after": "WHERE",
        "name": "where",
        "label": "where",
        "capture": "rest",
        "stopTokens": [
          "ORDER",
          "GROUP",
          "HAVING"
        ]
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/sort-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: sort-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "sort-itab.json",
    "object": "SORT_ITAB",
    "match": {
      "startKeyword": "SORT"
    },
    "keywordLabels": {
      "SORT": "stmt",
      "BY": "by",
      "ASCENDING": "ascending",
      "DESCENDING": "descending",
      "AS": "as",
      "TEXT": "text",
      "USING": "using",
      "KEY": "key"
    },
    "keywordPhrases": {
      "USING KEY": "using-key",
      "AS TEXT": "as-text"
    },
    "captureRules": [
      {
        "after": "SORT",
        "name": "itab",
        "label": "itab"
      },
      {
        "after": "BY",
        "name": "by",
        "label": "by",
        "capture": "rest",
        "stopTokens": [
          "ASCENDING",
          "DESCENDING",
          "USING"
        ]
      },
      {
        "after": "USING KEY",
        "name": "usingKey",
        "label": "using-key"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/statics.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: statics.json");
    return;
  }

  const config = {
    "_sourceFile": "statics.json",
    "object": "STATICS",
    "match": {
      "startKeyword": "STATICS"
    },
    "keywordLabels": {
      "STATICS": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to",
      "VALUE": "value",
      "LENGTH": "length",
      "DECIMALS": "decimals"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "STATICS",
        "name": "name",
        "label": "var-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like-name",
        "descKey": "like"
      },
      {
        "after": "VALUE",
        "name": "value",
        "label": "value",
        "descKey": "value"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/try.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: try.json");
    return;
  }

  const config = {
    "_sourceFile": "try.json",
    "object": "TRY",
    "match": {
      "startKeyword": "TRY"
    },
    "block": {
      "endKeyword": "ENDTRY"
    },
    "keywordLabels": {
      "TRY": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/types.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: types.json");
    return;
  }

  const config = {
    "_sourceFile": "types.json",
    "object": "TYPES",
    "match": {
      "startKeyword": "TYPES"
    },
    "keywordLabels": {
      "TYPES": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "BEGIN": "begin",
      "OF": "of",
      "END": "end"
    },
    "keywordPhrases": {
      "BEGIN OF": "begin-of",
      "END OF": "end-of"
    },
    "captureRules": [
      {
        "after": "TYPES BEGIN OF",
        "name": "name",
        "label": "type-name"
      },
      {
        "after": "TYPES END OF",
        "name": "name",
        "label": "type-name"
      },
      {
        "after": "TYPES",
        "name": "name",
        "label": "type-name"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/when.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: when.json");
    return;
  }

  const config = {
    "_sourceFile": "when.json",
    "object": "WHEN",
    "match": {
      "startKeyword": "WHEN"
    },
    "keywordLabels": {
      "WHEN": "stmt",
      "OTHERS": "others"
    },
    "keywordPhrases": {
      "WHEN OTHERS": "when-others"
    },
    "captureRules": [
      {
        "after": "WHEN",
        "name": "branch",
        "label": "branch",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <!-- abap-parser-configs:end -->
  <script>
// inlined from: ./variable-descriptions.js
(function () {
  "use strict";

  // Variable/system descriptions registry
  // - Mô tả dùng để hiển thị ở cột `declDesc` (nguồn khai báo).
  // - Không ảnh hưởng parse đúng/sai.
  //
  // Priority (cao -> thấp):
  // 1) Override từ UI (localStorage)  ✅ (bạn edit trực tiếp trong viewer)
  // 2) customByScope / customGlobal  ✅ (file này)
  // 3) comment trên dòng khai báo     ✅ (VD: DATA lv_a TYPE i. "desc)
  //
  // Key gợi ý:
  // - System: "SY-UNAME", "SY-REPID", "SY-SUBRC", "ABAP_TRUE", ...
  // - Custom theo scope: `${scopeLabel}:${NAME}` (đều UPPERCASE)
  //   VD: "GLOBAL:GV_USER"
  //       "FORM:MAIN:LV_B"
  //       "FORM:STEP_B:CV_OUT"

  window.AbapVarDescriptions = {
    system: {
      "SY-UNAME": "Current user name",
      "SY-REPID": "Current program name",
      "SY-SUBRC": "Return code of last ABAP statement",
      "SY-TABIX": "Current table index",

      ABAP_TRUE: "Boolean true",
      ABAP_FALSE: "Boolean false",
      ABAP_UNDEFINED: "Boolean undefined",
      SPACE: "Single space character"
    },

    // Fallback theo name (mọi scope). Key phải là UPPERCASE.
    customGlobal: {
      // "GT_LOG": "Global log table",
    },

    // Ưu tiên theo scopeLabel (phân biệt theo scope). Key + name đều UPPERCASE.
    customByScope: {
      // GLOBAL: {
      //   GV_USER: "User name (source for iv_user)"
      // },
      // "FORM:MAIN": {
      //   LV_B: "Output buffer"
      // }
    }
  };
})();
</script>
  <script>
// inlined from: ./app.js
(function () {
  "use strict";

  const els = {
    fileInput: document.getElementById("fileInput"),
    parseBtn: document.getElementById("parseBtn"),
    searchInput: document.getElementById("searchInput"),
    typeFilter: document.getElementById("typeFilter"),
    showRaw: document.getElementById("showRaw"),
    showKeywords: document.getElementById("showKeywords"),
    showValues: document.getElementById("showValues"),
    showExtras: document.getElementById("showExtras"),
    themeToggle: document.getElementById("themeToggle"),
    expandAllBtn: document.getElementById("expandAllBtn"),
    collapseAllBtn: document.getElementById("collapseAllBtn"),
    clearFiltersBtn: document.getElementById("clearFiltersBtn"),
    descBtn: document.getElementById("descBtn"),
    settingsBtn: document.getElementById("settingsBtn"),
    exportXmlBtn: document.getElementById("exportXmlBtn"),
    inputText: document.getElementById("inputText"),
    inputGutter: document.getElementById("inputGutter"),
    inputGutterContent: document.getElementById("inputGutterContent"),
    output: document.getElementById("output"),
    rightPanelTitle: document.getElementById("rightPanelTitle"),
    rightTabOutputBtn: document.getElementById("rightTabOutputBtn"),
    rightTabDescBtn: document.getElementById("rightTabDescBtn"),
    declDescJsonBtn: document.getElementById("declDescJsonBtn"),
    declDescPanel: document.getElementById("declDescPanel"),
    error: document.getElementById("error"),
    jsonModal: document.getElementById("jsonModal"),
    jsonTitle: document.getElementById("jsonTitle"),
    jsonPre: document.getElementById("jsonPre"),
    jsonCopyBtn: document.getElementById("jsonCopyBtn"),
    jsonCloseBtn: document.getElementById("jsonCloseBtn"),
    declDescSearch: document.getElementById("declDescSearch"),
    declDescMissingOnly: document.getElementById("declDescMissingOnly"),
    declDescTypes: document.getElementById("declDescTypes"),
    declDescSummary: document.getElementById("declDescSummary"),
    declDescTable: document.getElementById("declDescTable"),
    editModal: document.getElementById("editModal"),
    editLabel: document.getElementById("editLabel"),
    editHint: document.getElementById("editHint"),
    editSingleWrap: document.getElementById("editSingleWrap"),
    editDesc: document.getElementById("editDesc"),
    editStructWrap: document.getElementById("editStructWrap"),
    editStructDesc: document.getElementById("editStructDesc"),
    editItemDesc: document.getElementById("editItemDesc"),
    editSkipNormalize: document.getElementById("editSkipNormalize"),
    editSaveBtn: document.getElementById("editSaveBtn"),
    editClearBtn: document.getElementById("editClearBtn"),
    editCancelBtn: document.getElementById("editCancelBtn"),
    rulesBtn: document.getElementById("rulesBtn"),
    rulesModal: document.getElementById("rulesModal"),
    rulesSelect: document.getElementById("rulesSelect"),
    rulesTemplate: document.getElementById("rulesTemplate"),
    rulesError: document.getElementById("rulesError"),
    rulesJson: document.getElementById("rulesJson"),
    rulesNewBtn: document.getElementById("rulesNewBtn"),
    rulesSaveBtn: document.getElementById("rulesSaveBtn"),
    rulesDeleteBtn: document.getElementById("rulesDeleteBtn"),
    rulesDownloadBtn: document.getElementById("rulesDownloadBtn"),
    rulesCloseBtn: document.getElementById("rulesCloseBtn"),
    settingsModal: document.getElementById("settingsModal"),
    settingsNormalizeDesc: document.getElementById("settingsNormalizeDesc"),
    settingsDeclTypes: document.getElementById("settingsDeclTypes"),
    settingsStructTemplate: document.getElementById("settingsStructTemplate"),
    settingsNameTemplates: document.getElementById("settingsNameTemplates"),
    settingsSaveBtn: document.getElementById("settingsSaveBtn"),
    settingsResetBtn: document.getElementById("settingsResetBtn"),
    settingsCloseBtn: document.getElementById("settingsCloseBtn")
  };

  const state = {
    data: null,
    inputMode: "abap",
    inputLineCount: 0,
    inputGutterButtonsByLine: new Map(),
    inputGutterTargetsByLine: new Map(),
    theme: "dark",
    query: "",
    type: "",
    showRaw: true,
    showKeywords: true,
    showValues: true,
    showExtras: true,
    rightTab: "output",
    collapsedIds: new Set(),
    selectedId: "",
    selectedDeclKey: "",
    descOverrides: {},
    descOverridesLegacy: {},
    activeEdit: null,
    haystackById: new Map(),
    inputLineOffsets: [],
    customRules: [],
    activeRuleId: "",
    settings: null
  };

  const DESC_STORAGE_KEY_V2 = "abap-parser-viewer.declDescOverrides.v2";
  const DESC_STORAGE_KEY_LEGACY_V1 = "abap-parser-viewer.descOverrides.v1";
  const RULES_STORAGE_KEY_V1 = "abap-parser-viewer.customConfigs.v1";
  const SETTINGS_STORAGE_KEY_V1 = "abap-parser-viewer.settings.v1";
  const THEME_STORAGE_KEY_V1 = "abap-parser-viewer.theme.v1";

  const DECL_TYPE_OPTIONS = [
    "DATA",
    "TYPES",
    "PARAMETERS",
    "SELECT-OPTIONS",
    "CONSTANTS",
    "RANGES",
    "STATICS",
    "CLASS-DATA",
    "FIELD-SYMBOLS"
  ];

  const NAME_CODE_OPTIONS = [
    { code: "CN", label: "HẰNG" },
    { code: "DS", label: "STRUCT" },
    { code: "DT", label: "TABLE" },
    { code: "DR", label: "RANGETABLE" },
    { code: "DF", label: "BIẾN" },
    { code: "FL", label: "CỜ" },
    { code: "FS", label: "FIELDSYMBOL" }
  ];

  const DEFAULT_SETTINGS = {
    normalizeDeclDesc: true,
    declFilterTypes: ["DATA", "TYPES", "PARAMETERS"],
    structDescTemplate: "{{struct}}-{{item}}",
    nameTemplatesByCode: {
      CN: "HẰNG:{{desc}}",
      DS: "STRUCT:{{desc}}",
      DT: "TABLE:{{desc}}",
      DR: "RANGETABLE:{{desc}}",
      DF: "BIẾN:{{desc}}",
      FL: "CỜ:{{desc}}",
      FS: "FIELDSYMBOL:{{desc}}"
    }
  };

  const SAMPLE_ABAP = [
    "* Demo: show decl source + comment (codeDesc/declDesc) in UI",
    "",
    "* Selection screen (PARAMETERS):",
    "PARAMETERS p_user TYPE syuname DEFAULT sy-uname OBLIGATORY. \"User name (source for iv_user)",
    "PARAMETERS p_flag TYPE abap_bool DEFAULT abap_true AS CHECKBOX. \"Enable demo (source for iv_flag)",
    "",
    "* Local data (DATA):",
    "DATA lv_user TYPE syuname. \"Local copy of user (for demo decl)",
    "DATA lv_flag TYPE abap_bool. \"Local copy of flag (for demo decl)",
    "DATA lv_text TYPE string. \"Output text (target of ev_text)",
    "",
    "*&--------------------------------------------------------------------*",
    "*&    Form  MAIN",
    "*&--------------------------------------------------------------------*",
    "*  --> iv_user    User name",
    "*  --> iv_flag    Enable flag",
    "*  <-- cv_text    Output text",
    "*&--------------------------------------------------------------------*",
    "FORM main",
    "  USING iv_user TYPE syuname",
    "        iv_flag TYPE abap_bool",
    "  CHANGING cv_text TYPE string.",
    "",
    "  CLEAR lv_text. \"Reset output",
    "",
    "  CALL FUNCTION 'Z_DEMO_FM' \"Demo call",
    "    EXPORTING",
    "      iv_user = lv_user",
    "      iv_flag = lv_flag",
    "    IMPORTING",
    "      ev_text = lv_text.",
    "",
    "ENDFORM.",
    "",
    "PERFORM main USING p_user p_flag CHANGING lv_text. \"PERFORM -> source decl + jump"
  ].join("\n");

  function setError(message) {
    els.error.textContent = message ? String(message) : "";
  }

  function setOutputMessage(message) {
    els.output.classList.add("muted");
    els.output.replaceChildren();
    els.output.textContent = message || "";
  }

  function normalizeId(id) {
    if (id === null || id === undefined) {
      return "";
    }
    return String(id);
  }

  function loadStorageObject(key) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) {
        return {};
      }
      const parsed = JSON.parse(raw);
      return parsed && typeof parsed === "object" ? parsed : {};
    } catch {
      return {};
    }
  }

  function loadDescOverrides() {
    return loadStorageObject(DESC_STORAGE_KEY_V2);
  }

  function loadLegacyDescOverrides() {
    return loadStorageObject(DESC_STORAGE_KEY_LEGACY_V1);
  }

  function saveDescOverrides() {
    try {
      localStorage.setItem(DESC_STORAGE_KEY_V2, JSON.stringify(state.descOverrides || {}));
    } catch {
      // ignore
    }
  }

  function loadStorageArray(key) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) {
        return [];
      }
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed : [];
    } catch {
      return [];
    }
  }

  function normalizeSettings(value) {
    const input = value && typeof value === "object" && !Array.isArray(value) ? value : {};

    const normalizeDeclDesc = typeof input.normalizeDeclDesc === "boolean"
      ? input.normalizeDeclDesc
      : DEFAULT_SETTINGS.normalizeDeclDesc;

    const declFilterTypes = Array.isArray(input.declFilterTypes)
      ? input.declFilterTypes
          .map((t) => String(t || "").trim().toUpperCase())
          .filter((t) => t && DECL_TYPE_OPTIONS.includes(t))
      : [];

    const structDescTemplate = typeof input.structDescTemplate === "string" && input.structDescTemplate.trim()
      ? input.structDescTemplate
      : DEFAULT_SETTINGS.structDescTemplate;

    const nameTemplatesByCode = {};
    const inputNameTemplates = input.nameTemplatesByCode && typeof input.nameTemplatesByCode === "object"
      ? input.nameTemplatesByCode
      : {};

    for (const opt of NAME_CODE_OPTIONS) {
      const code = opt.code;
      const rawTemplate = Object.prototype.hasOwnProperty.call(inputNameTemplates, code)
        ? inputNameTemplates[code]
        : DEFAULT_SETTINGS.nameTemplatesByCode[code];

      const template = typeof rawTemplate === "string" && rawTemplate.trim()
        ? rawTemplate
        : DEFAULT_SETTINGS.nameTemplatesByCode[code];

      nameTemplatesByCode[code] = template;
    }

    return {
      normalizeDeclDesc,
      declFilterTypes: declFilterTypes.length ? declFilterTypes : DEFAULT_SETTINGS.declFilterTypes.slice(),
      structDescTemplate,
      nameTemplatesByCode
    };
  }

  function loadSettings() {
    return normalizeSettings(loadStorageObject(SETTINGS_STORAGE_KEY_V1));
  }

  function saveSettings(settings) {
    try {
      localStorage.setItem(SETTINGS_STORAGE_KEY_V1, JSON.stringify(settings || {}));
    } catch {
      // ignore
    }
  }

  function normalizeTheme(value) {
    return value === "light" ? "light" : "dark";
  }

  function loadTheme() {
    try {
      return normalizeTheme(localStorage.getItem(THEME_STORAGE_KEY_V1) || "");
    } catch {
      return "dark";
    }
  }

  function applyTheme(nextTheme, { save } = {}) {
    const normalized = normalizeTheme(nextTheme);
    state.theme = normalized;
    document.documentElement.setAttribute("data-theme", normalized);

    if (els.themeToggle) {
      els.themeToggle.checked = normalized === "dark";
    }

    if (save === false) {
      return;
    }

    try {
      localStorage.setItem(THEME_STORAGE_KEY_V1, normalized);
    } catch {
      // ignore
    }
  }

  function validateRuleConfig(config) {
    if (!config || typeof config !== "object" || Array.isArray(config)) {
      return "Config must be a JSON object.";
    }

    if (!config.object || typeof config.object !== "string") {
      return "Missing config.object (string).";
    }

    if (!config.match || typeof config.match !== "object" || Array.isArray(config.match)) {
      return "Missing config.match (object).";
    }

    const match = config.match;
    const hasMatch =
      (typeof match.startKeyword === "string" && match.startKeyword.trim()) ||
      (typeof match.startPhrase === "string" && match.startPhrase.trim()) ||
      (typeof match.type === "string" && match.type.trim());

    if (!hasMatch) {
      return "match must include startKeyword, startPhrase, or type.";
    }

    if (config.block !== undefined && config.block !== null) {
      if (typeof config.block !== "object" || Array.isArray(config.block)) {
        return "block must be an object (or null).";
      }
      if (typeof config.block.endKeyword !== "string" || !config.block.endKeyword.trim()) {
        return "block.endKeyword must be a non-empty string.";
      }
    }

    if (config.extras !== undefined && config.extras !== null) {
      if (typeof config.extras !== "object" || Array.isArray(config.extras)) {
        return "extras must be an object (or null).";
      }
      if (typeof config.extras.type !== "string" || !config.extras.type.trim()) {
        return "extras.type must be a non-empty string.";
      }
    }

    if (config.keywordLabels !== undefined && config.keywordLabels !== null) {
      if (typeof config.keywordLabels !== "object" || Array.isArray(config.keywordLabels)) {
        return "keywordLabels must be an object.";
      }
    }

    if (config.keywordPhrases !== undefined && config.keywordPhrases !== null) {
      if (typeof config.keywordPhrases !== "object" || Array.isArray(config.keywordPhrases)) {
        return "keywordPhrases must be an object.";
      }
    }

    if (config.captureRules !== undefined && config.captureRules !== null && !Array.isArray(config.captureRules)) {
      return "captureRules must be an array.";
    }

    if (Array.isArray(config.captureRules)) {
      for (const rule of config.captureRules) {
        if (!rule || typeof rule !== "object" || Array.isArray(rule)) {
          return "Each captureRules[] item must be an object.";
        }
        if (typeof rule.after !== "string" || !rule.after.trim()) {
          return "Each captureRules[] item must have after (string).";
        }
        if (typeof rule.name !== "string" || !rule.name.trim()) {
          return "Each captureRules[] item must have name (string).";
        }
      }
    }

    return "";
  }

  function generateRuleId() {
    const time = Date.now();
    const rand = Math.random().toString(16).slice(2, 10);
    return `rule-${time}-${rand}`;
  }

  function normalizeCustomRules(list) {
    const output = [];
    const items = Array.isArray(list) ? list : [];

    for (const item of items) {
      if (!item || typeof item !== "object" || Array.isArray(item)) {
        continue;
      }

      if (item.config && typeof item.config === "object" && !Array.isArray(item.config)) {
        const id = item.id ? String(item.id) : generateRuleId();
        output.push({ id, config: item.config });
        continue;
      }

      if (typeof item.object === "string") {
        output.push({ id: generateRuleId(), config: item });
      }
    }

    return output;
  }

  function loadCustomRules() {
    return normalizeCustomRules(loadStorageArray(RULES_STORAGE_KEY_V1));
  }

  function saveCustomRules() {
    try {
      localStorage.setItem(RULES_STORAGE_KEY_V1, JSON.stringify(state.customRules || []));
    } catch {
      // ignore
    }
  }

  function setRulesError(message) {
    if (!els.rulesError) {
      return;
    }
    els.rulesError.textContent = message ? String(message) : "";
  }

  function getCustomConfigs() {
    const output = [];
    for (const rule of state.customRules || []) {
      if (!rule || !rule.config) {
        continue;
      }
      const error = validateRuleConfig(rule.config);
      if (!error) {
        output.push(rule.config);
      }
    }
    return output;
  }

  function describeRuleOption(rule) {
    if (!rule || !rule.config) {
      return "(invalid rule)";
    }

    const objectType = rule.config.object ? String(rule.config.object) : "RULE";
    const match = rule.config.match && typeof rule.config.match === "object" ? rule.config.match : {};
    const summary = match.startPhrase
      ? `startPhrase=${String(match.startPhrase)}`
      : match.startKeyword
        ? `startKeyword=${String(match.startKeyword)}`
        : match.type
          ? `type=${String(match.type)}`
          : "match=?";

    return `${objectType} (${summary})`;
  }

  function renderRulesSelect() {
    if (!els.rulesSelect) {
      return;
    }

    els.rulesSelect.replaceChildren();
    els.rulesSelect.appendChild(el("option", { text: "(New rule)", attrs: { value: "" } }));

    for (const rule of state.customRules || []) {
      const id = rule && rule.id ? String(rule.id) : "";
      if (!id) {
        continue;
      }
      els.rulesSelect.appendChild(
        el("option", {
          text: describeRuleOption(rule),
          attrs: { value: id }
        })
      );
    }

    els.rulesSelect.value = state.activeRuleId || "";
  }

  function selectRule(ruleId) {
    const id = ruleId ? String(ruleId) : "";
    state.activeRuleId = id;
    setRulesError("");

    if (!els.rulesJson) {
      return;
    }

    if (!id) {
      els.rulesJson.value = "";
      return;
    }

    const rule = (state.customRules || []).find((r) => r && String(r.id) === id) || null;
    if (!rule || !rule.config) {
      els.rulesJson.value = "";
      return;
    }

    try {
      els.rulesJson.value = JSON.stringify(rule.config, null, 2);
    } catch {
      els.rulesJson.value = "";
    }
  }

  function createRuleTemplate(kind) {
    const type = String(kind || "startKeyword");

    if (type === "assignment") {
      return {
        object: "ASSIGNMENT",
        match: { type: "assignment" },
        keywordLabels: {
          "=": "assign",
          "+=": "add-assign",
          "-=": "sub-assign",
          "*=": "mul-assign",
          "/=": "div-assign",
          "?=": "cast"
        },
        keywordPhrases: {},
        captureRules: []
      };
    }

    if (type === "startPhrase") {
      return {
        object: "MY_OBJECT",
        match: { startPhrase: "MY PHRASE" },
        keywordLabels: {
          MY: "stmt"
        },
        keywordPhrases: {
          "MY PHRASE": "my-phrase"
        },
        captureRules: [
          { after: "MY PHRASE", name: "name", label: "name" }
        ]
      };
    }

    return {
      object: "MY_OBJECT",
      match: { startKeyword: "MYKEYWORD" },
      keywordLabels: {
        MYKEYWORD: "stmt"
      },
      keywordPhrases: {},
      captureRules: [
        { after: "MYKEYWORD", name: "name", label: "name" }
      ]
    };
  }

  function startNewRule() {
    state.activeRuleId = "";
    if (els.rulesSelect) {
      els.rulesSelect.value = "";
    }

    const kind = els.rulesTemplate ? els.rulesTemplate.value : "startKeyword";
    const template = createRuleTemplate(kind);

    if (els.rulesJson) {
      els.rulesJson.value = JSON.stringify(template, null, 2);
      els.rulesJson.focus();
    }

    setRulesError("");
  }

  function readRuleFromEditor() {
    const text = els.rulesJson ? els.rulesJson.value || "" : "";
    const trimmed = text.trim();
    if (!trimmed) {
      return { config: null, error: "Rule JSON is empty." };
    }

    try {
      const parsed = JSON.parse(trimmed);
      const config = parsed;
      const error = validateRuleConfig(config);
      if (error) {
        return { config: null, error };
      }
      return { config, error: "" };
    } catch (err) {
      return { config: null, error: `JSON parse error: ${err && err.message ? err.message : err}` };
    }
  }

  function saveRuleFromEditor() {
    const { config, error } = readRuleFromEditor();
    if (error) {
      setRulesError(error);
      return;
    }

    setRulesError("");

    if (state.activeRuleId) {
      const target = (state.customRules || []).find((r) => r && String(r.id) === state.activeRuleId) || null;
      if (target) {
        target.config = config;
      } else {
        state.customRules.push({ id: state.activeRuleId, config });
      }
    } else {
      const id = generateRuleId();
      state.customRules.push({ id, config });
      state.activeRuleId = id;
    }

    saveCustomRules();
    renderRulesSelect();
    if (els.rulesSelect) {
      els.rulesSelect.value = state.activeRuleId || "";
    }
  }

  function deleteActiveRule() {
    if (!state.activeRuleId) {
      setRulesError("Select a saved rule to delete.");
      return;
    }

    state.customRules = (state.customRules || []).filter((r) => r && String(r.id) !== state.activeRuleId);
    state.activeRuleId = "";
    saveCustomRules();
    renderRulesSelect();
    if (els.rulesJson) {
      els.rulesJson.value = "";
    }
    setRulesError("");
  }

  function downloadRuleFromEditor() {
    const { config, error } = readRuleFromEditor();
    if (error) {
      setRulesError(error);
      return;
    }

    setRulesError("");

    const fileBase = config && config.object ? String(config.object).trim() : "rule";
    const fileName = `${fileBase}.json`;
    const content = JSON.stringify(config, null, 2);

    try {
      const blob = new Blob([content], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    } catch (err) {
      setRulesError(`Download failed: ${err && err.message ? err.message : err}`);
    }
  }

  function openRulesModal() {
    if (!els.rulesModal) {
      return;
    }

    if (!els.jsonModal.hidden) {
      closeJsonModal();
    }
    if (!els.editModal.hidden) {
      closeEditModal();
    }

    renderRulesSelect();
    if (state.activeRuleId) {
      selectRule(state.activeRuleId);
    } else if (els.rulesJson && !els.rulesJson.value.trim()) {
      startNewRule();
    }

    els.rulesModal.hidden = false;
  }

  function closeRulesModal() {
    if (!els.rulesModal) {
      return;
    }

    els.rulesModal.hidden = true;
    setRulesError("");
  }

  function renderSettingsModalUi() {
    if (!els.settingsModal) {
      return;
    }

    const settings = state.settings || loadSettings();
    state.settings = settings;

    if (els.settingsNormalizeDesc) {
      els.settingsNormalizeDesc.checked = Boolean(settings.normalizeDeclDesc);
    }

    if (els.settingsDeclTypes) {
      els.settingsDeclTypes.replaceChildren();
      for (const type of DECL_TYPE_OPTIONS) {
        const label = document.createElement("label");
        label.className = "toggle";

        const input = document.createElement("input");
        input.type = "checkbox";
        input.value = type;
        input.checked = Array.isArray(settings.declFilterTypes) && settings.declFilterTypes.includes(type);

        label.appendChild(input);
        label.appendChild(document.createTextNode(type));
        els.settingsDeclTypes.appendChild(label);
      }
    }

    if (els.settingsStructTemplate) {
      els.settingsStructTemplate.value = settings.structDescTemplate || DEFAULT_SETTINGS.structDescTemplate;
    }

    if (els.settingsNameTemplates) {
      els.settingsNameTemplates.replaceChildren();

      const table = document.createElement("table");
      const thead = document.createElement("thead");
      const headRow = document.createElement("tr");
      for (const title of ["code", "label", "template"]) {
        const th = document.createElement("th");
        th.textContent = title;
        headRow.appendChild(th);
      }
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement("tbody");
      for (const opt of NAME_CODE_OPTIONS) {
        const tr = document.createElement("tr");

        const codeCell = document.createElement("td");
        codeCell.textContent = opt.code;
        tr.appendChild(codeCell);

        const labelCell = document.createElement("td");
        labelCell.textContent = opt.label;
        tr.appendChild(labelCell);

        const tplCell = document.createElement("td");
        const input = document.createElement("input");
        input.type = "text";
        input.style.width = "100%";
        input.setAttribute("data-code", opt.code);
        input.value = (settings.nameTemplatesByCode && settings.nameTemplatesByCode[opt.code])
          ? String(settings.nameTemplatesByCode[opt.code] || "")
          : String(DEFAULT_SETTINGS.nameTemplatesByCode[opt.code] || "");

        tplCell.appendChild(input);
        tr.appendChild(tplCell);

        tbody.appendChild(tr);
      }
      table.appendChild(tbody);

      els.settingsNameTemplates.appendChild(table);
    }
  }

  function openSettingsModal() {
    if (!els.settingsModal) {
      return;
    }

    if (!els.jsonModal.hidden) {
      closeJsonModal();
    }
    if (!els.editModal.hidden) {
      closeEditModal();
    }
    if (els.rulesModal && !els.rulesModal.hidden) {
      closeRulesModal();
    }

    renderSettingsModalUi();
    els.settingsModal.hidden = false;
  }

  function closeSettingsModal() {
    if (!els.settingsModal) {
      return;
    }
    els.settingsModal.hidden = true;
  }

  function getDeclsForDescriptionsModal() {
    if (state.data && typeof state.data === "object" && Array.isArray(state.data.decls)) {
      return state.data.decls;
    }

    const decls = [];
    const seen = new Set();

    const addDecl = (decl) => {
      if (!decl || typeof decl !== "object") {
        return;
      }
      const key = getDeclKey(decl) || stringifyDecl(decl);
      if (!key || seen.has(key)) {
        return;
      }
      seen.add(key);
      decls.push(decl);
    };

    walkObjects(state.data && Array.isArray(state.data.objects) ? state.data.objects : [], (obj) => {
      if (obj && Array.isArray(obj.values)) {
        for (const value of obj.values) {
          addDecl(value && value.decl);
        }
      }

      const extras = obj && obj.extras && typeof obj.extras === "object" ? obj.extras : null;
      if (!extras) {
        return;
      }

      const collectFromAssignmentSections = (container, sections) => {
        for (const sectionName of sections) {
          const list = container && Array.isArray(container[sectionName]) ? container[sectionName] : [];
          for (const entry of list) {
            const origin = entry && Array.isArray(entry.originDecls) ? entry.originDecls : [];
            for (const originDecl of origin) {
              addDecl(originDecl);
            }
            addDecl(entry && entry.valueDecl);
          }
        }
      };

      if (extras.callFunction) {
        collectFromAssignmentSections(extras.callFunction, ["exporting", "importing", "changing", "tables", "exceptions"]);
      }

      if (extras.callMethod) {
        collectFromAssignmentSections(extras.callMethod, ["exporting", "importing", "changing", "receiving", "exceptions"]);
      }

      if (extras.performCall) {
        for (const sectionName of ["using", "changing", "tables"]) {
          const list = Array.isArray(extras.performCall[sectionName]) ? extras.performCall[sectionName] : [];
          for (const entry of list) {
            const origin = entry && Array.isArray(entry.originDecls) ? entry.originDecls : [];
            for (const originDecl of origin) {
              addDecl(originDecl);
            }
            addDecl(entry && entry.valueDecl);
          }
        }
      }

      if (extras.form && Array.isArray(extras.form.params)) {
        for (const param of extras.form.params) {
          const origin = param && Array.isArray(param.originDecls) ? param.originDecls : [];
          for (const originDecl of origin) {
            addDecl(originDecl);
          }
        }
      }
    });

    return decls;
  }

  function getDeclCodeDesc(decl) {
    const source = getSourceDeclDesc(decl);
    if (source) {
      return source;
    }
    return getBaseDeclDesc(decl);
  }

  function renderDeclDescCellLines({ structText, itemText }) {
    const wrap = document.createElement("div");
    const structLine = document.createElement("div");
    const structLabel = document.createElement("span");
    structLabel.className = "muted";
    structLabel.textContent = "Struct: ";
    structLine.appendChild(structLabel);
    structLine.appendChild(document.createTextNode(structText || ""));
    wrap.appendChild(structLine);

    const itemLine = document.createElement("div");
    const itemLabel = document.createElement("span");
    itemLabel.className = "muted";
    itemLabel.textContent = "Item: ";
    itemLine.appendChild(itemLabel);
    itemLine.appendChild(document.createTextNode(itemText || ""));
    wrap.appendChild(itemLine);

    return wrap;
  }

  function renderDeclDescPanelUi() {
    if (!els.declDescPanel) {
      return;
    }

    const settings = state.settings || loadSettings();
    state.settings = settings;

    if (els.declDescTypes) {
      els.declDescTypes.replaceChildren();
      for (const type of DECL_TYPE_OPTIONS) {
        const label = document.createElement("label");
        label.className = "toggle";

        const input = document.createElement("input");
        input.type = "checkbox";
        input.value = type;
        input.checked = Array.isArray(settings.declFilterTypes) && settings.declFilterTypes.includes(type);
        input.addEventListener("change", () => {
          const selected = [];
          const inputs = els.declDescTypes ? els.declDescTypes.querySelectorAll("input[type=checkbox]") : [];
          for (const checkbox of Array.from(inputs)) {
            if (checkbox.checked) {
              selected.push(String(checkbox.value || "").trim().toUpperCase());
            }
          }
          state.settings = normalizeSettings({ ...settings, declFilterTypes: selected });
          saveSettings(state.settings);
          renderDeclDescPanelUi();
        });

        label.appendChild(input);
        label.appendChild(document.createTextNode(type));
        els.declDescTypes.appendChild(label);
      }
    }

    const decls = getDeclsForDescriptionsModal();
    const types = new Set((state.settings && Array.isArray(state.settings.declFilterTypes))
      ? state.settings.declFilterTypes
      : DEFAULT_SETTINGS.declFilterTypes);

    const query = els.declDescSearch ? String(els.declDescSearch.value || "").trim().toLowerCase() : "";
    const missingOnly = Boolean(els.declDescMissingOnly && els.declDescMissingOnly.checked);

    const rows = [];
    let totalRows = 0;
    let missingRows = 0;

    for (const decl of decls) {
      if (!decl || typeof decl !== "object" || !decl.objectType || !decl.name) {
        continue;
      }

      const objectType = String(decl.objectType || "").trim().toUpperCase();
      if (objectType === "STRUCT_FIELD") {
        const structType = String(decl.structObjectType || "").trim().toUpperCase();
        if (structType && !types.has(structType)) {
          continue;
        }
      } else if (!types.has(objectType)) {
        continue;
      }

      totalRows += 1;

      const techName = getDeclTechName(decl);
      const scopeLabel = String(decl.scopeLabel || "");

      const isStructField = isStructFieldDecl(decl);
      if (!isStructField) {
        const codeDescRaw = String(getDeclCodeDesc(decl) || "");
        const userEntry = getDeclOverrideEntry(decl);
        const userDescRaw = userEntry.text ? String(userEntry.text) : "";

        const codeDesc = settings.normalizeDeclDesc ? normalizeDeclDescText(decl, codeDescRaw) : codeDescRaw;
        const userDesc = (!settings.normalizeDeclDesc || userEntry.noNormalize)
          ? userDescRaw
          : normalizeDeclDescText(decl, userDescRaw);

        const missing = !codeDescRaw.trim() && !userDescRaw.trim();
        if (missing) {
          missingRows += 1;
        }
        if (missingOnly && !missing) {
          continue;
        }

        const haystack = [
          objectType,
          scopeLabel,
          techName,
          codeDescRaw,
          userDescRaw,
          codeDesc,
          userDesc
        ]
          .filter(Boolean)
          .join("\n")
          .toLowerCase();

        if (query && !haystack.includes(query)) {
          continue;
        }

        rows.push({
          decl,
          objectType,
          scopeLabel,
          techName,
          missing,
          codeDesc,
          userDesc
        });
        continue;
      }

      const structDecl = buildStructDeclFromFieldDecl(decl);
      const structCodeRaw = structDecl ? String(getDeclCodeDesc(structDecl) || "") : "";
      const structUserRaw = structDecl ? String(getDeclOverrideDesc(structDecl) || "") : "";
      const itemCodeRaw = String(getDeclCodeDesc(decl) || "");
      const itemEntry = getDeclOverrideEntry(decl);
      const itemUserRaw = itemEntry.text ? String(itemEntry.text) : "";

      const structCode = structDecl && settings.normalizeDeclDesc ? normalizeDeclDescText(structDecl, structCodeRaw) : structCodeRaw;
      const structUser = structDecl && settings.normalizeDeclDesc ? normalizeDeclDescText(structDecl, structUserRaw) : structUserRaw;
      const itemCode = settings.normalizeDeclDesc ? normalizeDeclDescText(decl, itemCodeRaw) : itemCodeRaw;
      const itemUser = (!settings.normalizeDeclDesc || itemEntry.noNormalize)
        ? itemUserRaw
        : normalizeDeclDescText(decl, itemUserRaw);

      const structMissing = !structCodeRaw.trim() && !structUserRaw.trim();
      const itemMissing = !itemCodeRaw.trim() && !itemUserRaw.trim();
      const missing = structMissing || itemMissing;
      if (missing) {
        missingRows += 1;
      }
      if (missingOnly && !missing) {
        continue;
      }

      const haystack = [
        objectType,
        scopeLabel,
        techName,
        structCodeRaw,
        structUserRaw,
        itemCodeRaw,
        itemUserRaw,
        structCode,
        structUser,
        itemCode,
        itemUser
      ]
        .filter(Boolean)
        .join("\n")
        .toLowerCase();

      if (query && !haystack.includes(query)) {
        continue;
      }

      rows.push({
        decl,
        objectType,
        scopeLabel,
        techName,
        missing,
        structMissing,
        itemMissing,
        structCode,
        structUser,
        itemCode,
        itemUser
      });
    }

    rows.sort((a, b) => {
      const scopeCmp = String(a.scopeLabel || "").localeCompare(String(b.scopeLabel || ""));
      if (scopeCmp) {
        return scopeCmp;
      }
      const typeCmp = String(a.objectType || "").localeCompare(String(b.objectType || ""));
      if (typeCmp) {
        return typeCmp;
      }
      return String(a.techName || "").localeCompare(String(b.techName || ""));
    });

    if (els.declDescSummary) {
      const shown = rows.length;
      els.declDescSummary.textContent = `Showing ${shown} of ${totalRows} decls • Missing: ${missingRows}`;
    }

    if (!els.declDescTable) {
      refreshInputGutterTargets();
      return;
    }

    if (!state.data || !Array.isArray(state.data.objects)) {
      els.declDescTable.replaceChildren(el("div", { className: "muted", text: "No data loaded. Click Render first." }));
      refreshInputGutterTargets();
      return;
    }

    const table = document.createElement("table");
    const thead = document.createElement("thead");
    const headRow = document.createElement("tr");
    for (const title of ["type", "scope", "technical id", "code desc", "user desc", ""]) {
      const th = document.createElement("th");
      th.textContent = title;
      headRow.appendChild(th);
    }
    thead.appendChild(headRow);
    table.appendChild(thead);

    const tbody = document.createElement("tbody");
    for (const row of rows) {
      const tr = document.createElement("tr");
      const declKey = getDeclKey(row.decl);
      if (declKey) {
        tr.setAttribute("data-decl-key", declKey);
        if (declKey === state.selectedDeclKey) {
          tr.classList.add("desc-selected");
        }
      }
      if (row.decl && row.decl.lineStart) {
        tr.setAttribute("data-line-start", String(row.decl.lineStart));
      }

      const typeCell = document.createElement("td");
      typeCell.textContent = row.objectType || "";
      tr.appendChild(typeCell);

      const scopeCell = document.createElement("td");
      scopeCell.textContent = row.scopeLabel || "";
      tr.appendChild(scopeCell);

      const idCell = document.createElement("td");
      const idWrap = document.createElement("div");
      const idLine = document.createElement("div");
      idLine.textContent = row.techName || "";
      const title = buildDeclTitle(row.decl);
      if (title) {
        idLine.title = title;
      }
      if (row.decl && row.decl.lineStart) {
        idLine.style.cursor = "pointer";
        idLine.addEventListener("click", (ev) => {
          ev.stopPropagation();
          selectCodeLines(row.decl.lineStart, row.decl.lineStart);
          if (row.decl.id) {
            setSelectedCard(row.decl.id);
          }
        });
      }
      idWrap.appendChild(idLine);

      if (row.objectType === "STRUCT_FIELD") {
        const pills = document.createElement("div");
        if (row.structMissing) {
          pills.appendChild(el("span", { className: "pill", text: "struct missing" }));
        }
        if (row.itemMissing) {
          pills.appendChild(el("span", { className: "pill", text: "item missing" }));
        }
        if (pills.childNodes.length) {
          idWrap.appendChild(pills);
        }
      } else if (row.missing) {
        idWrap.appendChild(el("span", { className: "pill", text: "missing" }));
      }

      idCell.appendChild(idWrap);
      tr.appendChild(idCell);

      const codeCell = document.createElement("td");
      if (row.objectType === "STRUCT_FIELD") {
        codeCell.appendChild(renderDeclDescCellLines({ structText: row.structCode || "", itemText: row.itemCode || "" }));
      } else {
        codeCell.textContent = row.codeDesc || "";
      }
      tr.appendChild(codeCell);

      const userCell = document.createElement("td");
      if (row.objectType === "STRUCT_FIELD") {
        userCell.appendChild(renderDeclDescCellLines({ structText: row.structUser || "", itemText: row.itemUser || "" }));
      } else {
        userCell.textContent = row.userDesc || "";
      }
      tr.appendChild(userCell);

      const actionCell = document.createElement("td");
      const btn = el("button", {
        className: "icon-btn",
        text: "✎",
        attrs: { type: "button", title: "Edit description", "aria-label": "Edit description" }
      });
      btn.addEventListener("click", (ev) => {
        ev.stopPropagation();
        editDeclDesc(row.decl);
      });
      actionCell.appendChild(btn);
      tr.appendChild(actionCell);

      tbody.appendChild(tr);
    }
    table.appendChild(tbody);

    els.declDescTable.replaceChildren(table);
    refreshInputGutterTargets();
  }

  function setRightTab(nextTab) {
    const tab = nextTab === "descriptions" ? "descriptions" : "output";
    state.rightTab = tab;

    const showDescriptions = tab === "descriptions";
    if (els.output) {
      els.output.hidden = showDescriptions;
    }
    if (els.declDescPanel) {
      els.declDescPanel.hidden = !showDescriptions;
    }

    if (els.rightPanelTitle) {
      els.rightPanelTitle.textContent = showDescriptions ? "Descriptions" : "Output";
    }

    if (els.rightTabOutputBtn) {
      els.rightTabOutputBtn.classList.toggle("active", !showDescriptions);
      els.rightTabOutputBtn.setAttribute("aria-selected", String(!showDescriptions));
    }
    if (els.rightTabDescBtn) {
      els.rightTabDescBtn.classList.toggle("active", showDescriptions);
      els.rightTabDescBtn.setAttribute("aria-selected", String(showDescriptions));
    }
    if (els.declDescJsonBtn) {
      els.declDescJsonBtn.hidden = !showDescriptions;
    }

    if (showDescriptions) {
      renderDeclDescPanelUi();
      setTimeout(() => {
        if (els.declDescSearch) {
          els.declDescSearch.focus();
        }
      }, 0);
    }

    refreshInputGutterTargets();
  }

  function applySettingsFromModal() {
    if (!els.settingsModal) {
      return;
    }

    const next = {
      normalizeDeclDesc: Boolean(els.settingsNormalizeDesc && els.settingsNormalizeDesc.checked),
      declFilterTypes: [],
      structDescTemplate: (els.settingsStructTemplate && els.settingsStructTemplate.value)
        ? String(els.settingsStructTemplate.value || "")
        : DEFAULT_SETTINGS.structDescTemplate,
      nameTemplatesByCode: {}
    };

    if (els.settingsDeclTypes) {
      const inputs = els.settingsDeclTypes.querySelectorAll("input[type=checkbox]");
      for (const input of Array.from(inputs)) {
        if (input.checked) {
          next.declFilterTypes.push(String(input.value || "").trim().toUpperCase());
        }
      }
    }

    const nameInputs = els.settingsNameTemplates
      ? els.settingsNameTemplates.querySelectorAll("input[data-code]")
      : [];

    for (const input of Array.from(nameInputs)) {
      const code = String(input.getAttribute("data-code") || "").trim().toUpperCase();
      if (!code) {
        continue;
      }
      next.nameTemplatesByCode[code] = String(input.value || "");
    }

    state.settings = normalizeSettings(next);
    saveSettings(state.settings);
    state.haystackById = buildSearchIndex(state.data ? state.data.objects : []);
    renderOutput();
  }

  function resetSettingsToDefault() {
    state.settings = normalizeSettings(DEFAULT_SETTINGS);
    saveSettings(state.settings);
    renderSettingsModalUi();
    state.haystackById = buildSearchIndex(state.data ? state.data.objects : []);
    renderOutput();
  }

  function normalizeKeyToken(value) {
    return String(value || "").trim().toUpperCase();
  }

  function getDeclKey(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const scope = normalizeKeyToken(decl.scopeLabel);
    const name = normalizeKeyToken(decl.name);

    if (!scope || !name) {
      return "";
    }

    return `${scope}:${name}`;
  }

  function getLegacyDeclKey(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const type = normalizeKeyToken(decl.objectType);
    const name = normalizeKeyToken(decl.name);

    if (!type || !name) {
      return "";
    }

    return `${type}:NAME:${name}`;
  }

  function normalizeDescOverrideEntry(value) {
    if (typeof value === "string") {
      return { text: String(value || ""), noNormalize: false };
    }
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      return { text: "", noNormalize: false };
    }

    const text = typeof value.text === "string"
      ? value.text
      : typeof value.desc === "string"
        ? value.desc
        : typeof value.value === "string"
          ? value.value
          : "";

    const noNormalize = Boolean(value.noNormalize || value.skipNormalize || value.disableNormalize || value.no_normalize);
    return { text: String(text || ""), noNormalize };
  }

  function getDeclOverrideEntry(decl) {
    const key = getDeclKey(decl);
    if (key && Object.prototype.hasOwnProperty.call(state.descOverrides || {}, key)) {
      return normalizeDescOverrideEntry(state.descOverrides[key]);
    }

    const legacyKey = getLegacyDeclKey(decl);
    if (legacyKey && Object.prototype.hasOwnProperty.call(state.descOverridesLegacy || {}, legacyKey)) {
      return { text: String(state.descOverridesLegacy[legacyKey] || ""), noNormalize: false };
    }

    return { text: "", noNormalize: false };
  }

  function getDeclOverrideDesc(decl) {
    return getDeclOverrideEntry(decl).text;
  }

  function getDeclOverrideNoNormalize(decl) {
    return Boolean(getDeclOverrideEntry(decl).noNormalize);
  }

  function getBaseDeclDesc(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const registry = window.AbapVarDescriptions && typeof window.AbapVarDescriptions === "object"
      ? window.AbapVarDescriptions
      : null;
    if (!registry) {
      return "";
    }

    const nameUpper = normalizeKeyToken(decl.name);
    if (!nameUpper) {
      return "";
    }

    const objectType = normalizeKeyToken(decl.objectType);
    const scopeLabel = normalizeKeyToken(decl.scopeLabel);

    if (objectType === "SYSTEM" || scopeLabel === "SYSTEM") {
      const systemMap = registry.system && typeof registry.system === "object" ? registry.system : null;
      if (systemMap && Object.prototype.hasOwnProperty.call(systemMap, nameUpper)) {
        return String(systemMap[nameUpper] || "");
      }
    }

    const byScope = registry.customByScope && typeof registry.customByScope === "object" ? registry.customByScope : null;
    if (byScope && scopeLabel && Object.prototype.hasOwnProperty.call(byScope, scopeLabel)) {
      const scopeMap = byScope[scopeLabel];
      if (scopeMap && typeof scopeMap === "object" && Object.prototype.hasOwnProperty.call(scopeMap, nameUpper)) {
        return String(scopeMap[nameUpper] || "");
      }
    }

    const globalMap = registry.customGlobal && typeof registry.customGlobal === "object" ? registry.customGlobal : null;
    if (globalMap && Object.prototype.hasOwnProperty.call(globalMap, nameUpper)) {
      return String(globalMap[nameUpper] || "");
    }

    return "";
  }

  function getSourceDeclDesc(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }
    return decl.comment ? String(decl.comment) : "";
  }

  function normalizeDeclDescText(decl, text) {
    const settings = state.settings || DEFAULT_SETTINGS;
    if (!settings.normalizeDeclDesc) {
      return String(text || "").trim();
    }

    const descTrimmed = String(text || "").trim();
    if (!descTrimmed) {
      return "";
    }

    const techName = getDeclTechName(decl);
    const bare = stripAngleBrackets(techName);
    if (bare.length < 3) {
      return descTrimmed;
    }

    const code = bare.slice(1, 3).toUpperCase();
    const templates = settings.nameTemplatesByCode || DEFAULT_SETTINGS.nameTemplatesByCode;
    const template = templates && Object.prototype.hasOwnProperty.call(templates, code) ? String(templates[code] || "") : "";
    if (!template.trim()) {
      return descTrimmed;
    }

    const normalizedDesc = stripDeclCategoryPrefix(descTrimmed);
    const normalized = template.replace(/\{\{desc\}\}/g, normalizedDesc).trim();
    return normalized || descTrimmed;
  }

  function getEffectiveDeclAtomicDesc(decl) {
    const override = getDeclOverrideDesc(decl);
    if (override) {
      return override;
    }

    const source = getSourceDeclDesc(decl);
    if (source) {
      return source;
    }

    return getBaseDeclDesc(decl);
  }

  function getEffectiveDeclAtomicDescNormalized(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const settings = state.settings || DEFAULT_SETTINGS;
    const normalizeEnabled = Boolean(settings.normalizeDeclDesc);

    const overrideEntry = getDeclOverrideEntry(decl);
    const overrideText = overrideEntry.text ? String(overrideEntry.text) : "";
    if (overrideText) {
      if (!normalizeEnabled || overrideEntry.noNormalize) {
        return overrideText;
      }
      return normalizeDeclDescText(decl, overrideText);
    }

    const source = getSourceDeclDesc(decl);
    if (source) {
      return normalizeEnabled ? normalizeDeclDescText(decl, source) : source;
    }

    const base = getBaseDeclDesc(decl);
    return normalizeEnabled ? normalizeDeclDescText(decl, base) : base;
  }

  function buildStructDeclFromFieldDecl(decl) {
    if (!decl || typeof decl !== "object") {
      return null;
    }

    if (!decl.scopeLabel || !decl.structName) {
      return null;
    }

    return {
      id: decl.structId || null,
      objectType: decl.structObjectType || decl.objectType || "STRUCT",
      name: String(decl.structName || ""),
      file: decl.file || "",
      lineStart: decl.structLineStart || null,
      raw: decl.structRaw || "",
      comment: decl.structComment || decl.structTypeComment || "",
      scopeId: decl.scopeId || 0,
      scopeLabel: decl.scopeLabel || "",
      scopeType: decl.scopeType || "",
      scopeName: decl.scopeName || ""
    };
  }

  function formatStructFieldDesc(decl) {
    if (!isStructFieldDecl(decl)) {
      return getEffectiveDeclAtomicDesc(decl);
    }

    const settings = state.settings || DEFAULT_SETTINGS;
    const template = settings.structDescTemplate || DEFAULT_SETTINGS.structDescTemplate;

    const structTech = String(decl.structName || "").trim() || getDeclTechName(decl);
    const itemTech = String(decl.fieldPath || "").trim() || (() => {
      const tech = getDeclTechName(decl);
      const structPrefix = String(decl.structName || "").trim();
      if (structPrefix && tech.toUpperCase().startsWith(`${structPrefix.toUpperCase()}-`)) {
        return tech.slice(structPrefix.length + 1);
      }
      return tech;
    })();

    const structDecl = buildStructDeclFromFieldDecl(decl);
    const structDescRaw = structDecl ? getEffectiveDeclAtomicDescNormalized(structDecl) : "";
    const itemDescRaw = getEffectiveDeclAtomicDescNormalized(decl);

    const structText = String(structDescRaw || "").trim() || structTech;
    const itemText = String(itemDescRaw || "").trim() || itemTech;

    return String(template || DEFAULT_SETTINGS.structDescTemplate)
      .replace(/\{\{struct\}\}/g, structText)
      .replace(/\{\{item\}\}/g, itemText);
  }

  function getEffectiveDeclDesc(decl) {
    if (isStructFieldDecl(decl)) {
      return formatStructFieldDesc(decl);
    }

    return getEffectiveDeclAtomicDescNormalized(decl);
  }

  function openEditModal({ mode, key, structKey, itemKey, label, hint, initialValue, structValue, itemValue, skipNormalize }) {
    const editMode = mode === "structField" ? "structField" : "single";

    if (editMode === "single" && !key) {
      return;
    }

    if (editMode === "structField" && (!structKey || !itemKey)) {
      return;
    }

    if (!els.jsonModal.hidden) {
      closeJsonModal();
    }

    state.activeEdit = editMode === "structField"
      ? { mode: "structField", structKey, itemKey }
      : { mode: "single", key };
    els.editLabel.textContent = label ? String(label) : "";

    const hintText = hint ? String(hint) : "";
    els.editHint.textContent = hintText;
    els.editHint.style.display = hintText ? "block" : "none";

    if (els.editSingleWrap) {
      els.editSingleWrap.hidden = editMode !== "single";
    }
    if (els.editStructWrap) {
      els.editStructWrap.hidden = editMode !== "structField";
    }

    els.editDesc.value = "";
    if (els.editStructDesc) {
      els.editStructDesc.value = "";
    }
    if (els.editItemDesc) {
      els.editItemDesc.value = "";
    }
    if (els.editSkipNormalize) {
      els.editSkipNormalize.checked = Boolean(skipNormalize);
    }

    if (editMode === "single") {
      els.editDesc.value = initialValue ? String(initialValue) : "";
    } else {
      if (els.editStructDesc) {
        els.editStructDesc.value = structValue ? String(structValue) : "";
      }
      if (els.editItemDesc) {
        els.editItemDesc.value = itemValue ? String(itemValue) : "";
      }
    }

    els.editModal.hidden = false;
    setTimeout(() => {
      const target = editMode === "structField" && els.editStructDesc ? els.editStructDesc : els.editDesc;
      target.focus();
    }, 0);
  }

  function closeEditModal() {
    els.editModal.hidden = true;
    els.editDesc.value = "";
    if (els.editStructDesc) {
      els.editStructDesc.value = "";
    }
    if (els.editItemDesc) {
      els.editItemDesc.value = "";
    }
    if (els.editSkipNormalize) {
      els.editSkipNormalize.checked = false;
    }
    state.activeEdit = null;
  }

  function applyEditModal(action) {
    if (!state.activeEdit) {
      return;
    }

    const mode = state.activeEdit.mode === "structField" ? "structField" : "single";
    const skipNormalize = Boolean(els.editSkipNormalize && els.editSkipNormalize.checked);

    if (mode === "single") {
      const key = state.activeEdit.key;
      if (!key) {
        return;
      }

      const value = action === "clear" ? "" : String(els.editDesc.value || "");
      const trimmed = value.trim();
      const stored = skipNormalize ? trimmed : stripDeclCategoryPrefix(trimmed);

      if (!stored) {
        delete state.descOverrides[key];
      } else {
        state.descOverrides[key] = skipNormalize ? { text: stored, noNormalize: true } : stored;
      }
    } else {
      const structKey = state.activeEdit.structKey;
      const itemKey = state.activeEdit.itemKey;
      if (!structKey || !itemKey) {
        return;
      }

      const structValue = action === "clear" ? "" : String((els.editStructDesc && els.editStructDesc.value) || "");
      const itemValue = action === "clear" ? "" : String((els.editItemDesc && els.editItemDesc.value) || "");
      const structTrimmed = structValue.trim();
      const itemTrimmed = itemValue.trim();
      const structStored = stripDeclCategoryPrefix(structTrimmed);
      const itemStored = skipNormalize ? itemTrimmed : stripDeclCategoryPrefix(itemTrimmed);

      if (!structStored) {
        delete state.descOverrides[structKey];
      } else {
        state.descOverrides[structKey] = structStored;
      }

      if (!itemStored) {
        delete state.descOverrides[itemKey];
      } else {
        state.descOverrides[itemKey] = skipNormalize ? { text: itemStored, noNormalize: true } : itemStored;
      }
    }

    saveDescOverrides();
    state.haystackById = buildSearchIndex(state.data ? state.data.objects : []);
    renderOutput();
    if (state.rightTab === "descriptions") {
      renderDeclDescPanelUi();
    }
  }

  function editDeclDesc(decl) {
    if (!decl || !decl.name || !decl.objectType) {
      return;
    }

    const isStructField = isStructFieldDecl(decl);

    const key = getDeclKey(decl);
    if (!key) {
      return;
    }

    const settings = state.settings || DEFAULT_SETTINGS;
    const normalizeEnabled = Boolean(settings.normalizeDeclDesc);

    const currentEntry = getDeclOverrideEntry(decl);
    const current = currentEntry.text ? String(currentEntry.text) : "";
    const effective = getEffectiveDeclDesc(decl);
    const currentDisplay = current
      ? (normalizeEnabled && !currentEntry.noNormalize ? normalizeDeclDescText(decl, current) : current)
      : "";
    const hintParts = [];
    hintParts.push(`Key: ${key}`);
    if (decl.scopeLabel) {
      hintParts.push(`Scope: ${decl.scopeLabel}`);
    }
    if (decl.objectType) {
      hintParts.push(`Type: ${decl.objectType}`);
    }
    if (decl.lineStart) {
      hintParts.push(`Line: ${decl.lineStart}`);
    }
    const base = getBaseDeclDesc(decl);
    const source = getSourceDeclDesc(decl);
    if (base) {
      hintParts.push(`Registry: ${base}`);
    }
    if (source) {
      hintParts.push(`Comment: ${source}`);
    }
    if (decl.raw) {
      hintParts.push(decl.raw);
    }

    if (!isStructField) {
      openEditModal({
        mode: "single",
        key,
        label: `${decl.objectType} ${getDeclTechName(decl)}`,
        hint: hintParts.join(" • "),
        initialValue: currentDisplay || effective,
        skipNormalize: Boolean(currentEntry.noNormalize)
      });
      return;
    }

    const structDecl = buildStructDeclFromFieldDecl(decl);
    const structKey = structDecl ? getDeclKey(structDecl) : "";
    if (!structKey) {
      return;
    }

    const structCurrentEntry = structDecl ? getDeclOverrideEntry(structDecl) : { text: "", noNormalize: false };
    const structCurrent = structCurrentEntry.text ? String(structCurrentEntry.text) : "";
    const structEffective = structDecl ? getEffectiveDeclDesc(structDecl) : "";
    const structCurrentDisplay = structDecl && structCurrent && normalizeEnabled
      ? normalizeDeclDescText(structDecl, structCurrent)
      : structCurrent;

    hintParts.push(`StructKey: ${structKey}`);
    hintParts.push(`ItemKey: ${key}`);

    openEditModal({
      mode: "structField",
      structKey,
      itemKey: key,
      label: `${decl.objectType} ${getDeclTechName(decl)}`,
      hint: hintParts.join(" • "),
      structValue: structCurrentDisplay || structEffective,
      itemValue: currentDisplay || getEffectiveDeclAtomicDescNormalized(decl),
      skipNormalize: Boolean(currentEntry.noNormalize)
    });
  }

  function escapeSelectorValue(value) {
    const text = String(value || "");
    if (window.CSS && typeof window.CSS.escape === "function") {
      return window.CSS.escape(text);
    }
    return text.replace(/"/g, '\\"');
  }

  function safeJson(value, pretty) {
    try {
      return JSON.stringify(value, null, pretty ? 2 : 0);
    } catch {
      return "";
    }
  }

  function sanitizeXmlText(value) {
    const text = String(value ?? "");
    // Keep: TAB (0x9), LF (0xA), CR (0xD)
    return text.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F]/g, "");
  }

  function escapeXmlText(value) {
    return sanitizeXmlText(value)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&apos;");
  }

  function toXmlTagName(key) {
    const raw = String(key || "").trim();
    if (!raw) {
      return "value";
    }

    const normalized = raw.replace(/[^A-Za-z0-9_:-]/g, "_");
    if (!/^[A-Za-z_]/.test(normalized)) {
      return `_${normalized}`;
    }
    return normalized;
  }

  function getArrayItemTagName(keyHint) {
    const key = String(keyHint || "").trim().toLowerCase();
    if (key === "objects" || key === "children") {
      return "object";
    }
    return "item";
  }

  function isDeclLikeObject(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    return (
      typeof value.objectType === "string" &&
      typeof value.name === "string" &&
      typeof value.scopeLabel === "string"
    );
  }

  function appendXmlValue(lines, keyHint, tagName, value, indent) {
    const pad = " ".repeat(indent);

    if (value === undefined) {
      return;
    }

    if (value === null) {
      lines.push(`${pad}<${tagName}/>`);
      return;
    }

    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      lines.push(`${pad}<${tagName}>${escapeXmlText(String(value))}</${tagName}>`);
      return;
    }

    if (Array.isArray(value)) {
      const itemTag = getArrayItemTagName(keyHint);
      lines.push(`${pad}<${tagName}>`);
      for (const item of value) {
        appendXmlValue(lines, itemTag, itemTag, item, indent + 2);
      }
      lines.push(`${pad}</${tagName}>`);
      return;
    }

    if (typeof value === "object") {
      lines.push(`${pad}<${tagName}>`);

      if (isDeclLikeObject(value)) {
        const declDesc = getEffectiveDeclDesc(value);
        if (declDesc) {
          lines.push(`${" ".repeat(indent + 2)}<desc>${escapeXmlText(declDesc)}</desc>`);
        } else {
          lines.push(`${" ".repeat(indent + 2)}<desc/>`);
        }

        const declName = getDeclDisplayName(value) || getDeclTechName(value);
        lines.push(`${" ".repeat(indent + 2)}<name>${escapeXmlText(declName)}</name>`);
      }

      const preferredOrder = [
        "id",
        "parent",
        "objectType",
        "file",
        "lineStart",
        "comment",
        "raw",
        "keywords",
        "values",
        "extras",
        "block",
        "children"
      ];

      const keys = Object.keys(value);
      keys.sort((a, b) => {
        const ai = preferredOrder.indexOf(a);
        const bi = preferredOrder.indexOf(b);
        if (ai !== -1 || bi !== -1) {
          return (ai === -1 ? 999 : ai) - (bi === -1 ? 999 : bi);
        }
        return a.localeCompare(b);
      });

      for (const key of keys) {
        if (key === "desc" && isDeclLikeObject(value)) {
          // computed above
          continue;
        }
        if (key === "name" && isDeclLikeObject(value)) {
          // computed above (normalized via settings)
          continue;
        }
        const childTag = toXmlTagName(key);
        appendXmlValue(lines, key, childTag, value[key], indent + 2);
      }

      lines.push(`${pad}</${tagName}>`);
      return;
    }

    lines.push(`${pad}<${tagName}>${escapeXmlText(String(value))}</${tagName}>`);
  }

  function buildAbapFlowXml(data) {
    const fileName = data && typeof data === "object" ? String(data.file || "") : "";
    const objects = data && typeof data === "object" && Array.isArray(data.objects) ? data.objects : [];

    const lines = ['<?xml version="1.0" encoding="UTF-8"?>', "<abapflowObjects>"];
    if (fileName) {
      lines.push(`  <file>${escapeXmlText(fileName)}</file>`);
    }
    lines.push("  <objects>");
    for (const obj of objects) {
      appendXmlValue(lines, "object", "object", obj, 4);
    }
    lines.push("  </objects>");
    lines.push("</abapflowObjects>");

    return lines.join("\n");
  }

  function walkObjects(roots, visit) {
    const stack = Array.isArray(roots) ? roots.slice().reverse() : [];
    while (stack.length) {
      const node = stack.pop();
      if (!node) {
        continue;
      }
      visit(node);
      const children = Array.isArray(node.children) ? node.children : [];
      for (let i = children.length - 1; i >= 0; i -= 1) {
        stack.push(children[i]);
      }
    }
  }

  function collectDeclSearchTextFromExtras(extras) {
    if (!extras || typeof extras !== "object") {
      return "";
    }

    const decls = [];
    const addDecl = (decl) => {
      if (decl && typeof decl === "object") {
        decls.push(decl);
      }
    };
    const addDeclList = (list) => {
      if (!Array.isArray(list)) {
        return;
      }
      for (const decl of list) {
        addDecl(decl);
      }
    };

    const collectFromAssignmentSections = (obj, sections) => {
      for (const sectionName of sections) {
        const list = obj && Array.isArray(obj[sectionName]) ? obj[sectionName] : [];
        for (const entry of list) {
          addDeclList(entry && entry.originDecls);
          addDecl(entry && entry.valueDecl);
        }
      }
    };

    if (extras.callFunction) {
      collectFromAssignmentSections(extras.callFunction, ["exporting", "importing", "changing", "tables", "exceptions"]);
    }

    if (extras.callMethod) {
      collectFromAssignmentSections(extras.callMethod, ["exporting", "importing", "changing", "receiving", "exceptions"]);
    }

    if (extras.performCall) {
      for (const sectionName of ["using", "changing", "tables"]) {
        const list = Array.isArray(extras.performCall[sectionName]) ? extras.performCall[sectionName] : [];
        for (const entry of list) {
          addDeclList(entry && entry.originDecls);
          addDecl(entry && entry.valueDecl);
        }
      }
    }

    if (extras.form && Array.isArray(extras.form.params)) {
      for (const param of extras.form.params) {
        addDeclList(param && param.originDecls);
      }
    }

    const seen = new Set();
    const parts = [];
    for (const decl of decls) {
      const key = getDeclKey(decl) || stringifyDecl(decl);
      if (!key || seen.has(key)) {
        continue;
      }
      seen.add(key);
      parts.push(String(decl.name || ""));
      const desc = getEffectiveDeclDesc(decl);
      if (desc) {
        parts.push(desc);
      }
    }

    return parts.filter(Boolean).join("\n");
  }

  function buildSearchIndex(objects) {
    const map = new Map();
    walkObjects(objects, (obj) => {
      const id = normalizeId(obj && obj.id);
      if (!id) {
        return;
      }

      const keywordsText = Array.isArray(obj.keywords)
        ? obj.keywords.map((k) => `${k.text || ""} ${k.label || ""}`.trim()).join("\n")
        : "";

      const valuesText = Array.isArray(obj.values)
        ? obj.values
            .map((v) => {
              const declText = stringifyDecl(v && v.decl);
              const declDesc = getEffectiveDeclDesc(v && v.decl);
              return [
                v && v.name ? String(v.name) : "",
                v && v.value ? String(v.value) : "",
                v && v.label ? String(v.label) : "",
                v && v.codeDesc ? String(v.codeDesc) : "",
                v && v.declRef ? String(v.declRef) : "",
                declText,
                declDesc
              ]
                .filter(Boolean)
                .join(" ");
            })
            .join("\n")
        : "";

      const extrasText = obj.extras && typeof obj.extras === "object" ? safeJson(obj.extras, false) : "";
      const extrasDeclText = collectDeclSearchTextFromExtras(obj.extras);

      const haystack = [
        obj.objectType || "",
        obj.raw || "",
        obj.comment || "",
        keywordsText,
        valuesText,
        extrasText,
        extrasDeclText
      ]
        .filter(Boolean)
        .join("\n")
        .toLowerCase();

      map.set(id, haystack);
    });
    return map;
  }

  function computeLineOffsets(text) {
    const value = String(text || "");
    const offsets = [0];
    for (let i = 0; i < value.length; i += 1) {
      if (value[i] === "\n") {
        offsets.push(i + 1);
      }
    }
    return offsets;
  }

  function getSelectionRangeForLines(text, lineStart, lineEnd) {
    const value = String(text || "");
    const offsets = state.inputLineOffsets.length ? state.inputLineOffsets : computeLineOffsets(value);
    const start = Math.max(1, Number(lineStart) || 1);
    const end = Math.max(start, Number(lineEnd) || start);
    const startLineIndex = start - 1;
    const endLineIndex = end - 1;
    const startOffset = offsets[startLineIndex] ?? 0;
    const endOffset = offsets[endLineIndex + 1] ?? value.length;
    return { start: startOffset, end: Math.max(startOffset, endOffset) };
  }

  function selectCodeLines(lineStart, lineEnd) {
    const text = els.inputText.value || "";
    state.inputLineOffsets = computeLineOffsets(text);
    const range = getSelectionRangeForLines(text, lineStart, lineEnd);
    els.inputText.focus();
    els.inputText.setSelectionRange(range.start, range.end);
    syncInputGutterScroll();
  }

  function setSelectedCard(id) {
    const normalized = normalizeId(id);
    if (!normalized) {
      return;
    }

    if (state.selectedId) {
      const prev = els.output.querySelector(`[data-id="${escapeSelectorValue(state.selectedId)}"]`);
      if (prev) {
        prev.classList.remove("selected");
      }
    }

    state.selectedId = normalized;
    const next = els.output.querySelector(`[data-id="${escapeSelectorValue(normalized)}"]`);
    if (next) {
      next.classList.add("selected");
      next.scrollIntoView({ block: "nearest" });
    }
  }

  function setSelectedDeclRow(declKey) {
    const key = String(declKey || "").trim();
    if (!key || !els.declDescTable) {
      return;
    }

    if (state.selectedDeclKey) {
      const prev = els.declDescTable.querySelector(`tr[data-decl-key="${escapeSelectorValue(state.selectedDeclKey)}"]`);
      if (prev) {
        prev.classList.remove("desc-selected");
      }
    }

    state.selectedDeclKey = key;
    const next = els.declDescTable.querySelector(`tr[data-decl-key="${escapeSelectorValue(key)}"]`);
    if (next) {
      next.classList.add("desc-selected");
      next.scrollIntoView({ block: "nearest" });
    }
  }

  function countInputLines(value) {
    const text = String(value || "");
    if (!text) {
      return 1;
    }
    return text.split("\n").length;
  }

  function syncInputGutterScroll() {
    if (!els.inputText || !els.inputGutterContent) {
      return;
    }

    const scrollTop = Number(els.inputText.scrollTop || 0) || 0;
    els.inputGutterContent.style.transform = `translateY(${-scrollTop}px)`;
  }

  function rebuildInputGutter() {
    if (!els.inputText || !els.inputGutterContent) {
      return;
    }

    const trimmed = String(els.inputText.value || "").trim();
    const isJsonLike = (trimmed.startsWith("{") || trimmed.startsWith("[")) && trimmed.length > 1;
    state.inputMode = isJsonLike ? "json" : "abap";

    const lineCount = Math.max(1, countInputLines(els.inputText.value || ""));
    if (lineCount === state.inputLineCount && state.inputGutterButtonsByLine.size) {
      syncInputGutterScroll();
      refreshInputGutterTargets();
      return;
    }

    state.inputLineCount = lineCount;
    state.inputGutterButtonsByLine = new Map();

    const frag = document.createDocumentFragment();
    for (let line = 1; line <= lineCount; line += 1) {
      const row = document.createElement("div");
      row.className = "gutter-line";

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "gutter-jump";
      btn.textContent = "↪";
      btn.hidden = true;
      btn.setAttribute("data-line", String(line));
      row.appendChild(btn);

      const num = document.createElement("span");
      num.className = "gutter-num";
      num.textContent = String(line);
      row.appendChild(num);

      state.inputGutterButtonsByLine.set(line, btn);
      frag.appendChild(row);
    }

    els.inputGutterContent.replaceChildren(frag);
    syncInputGutterScroll();
    refreshInputGutterTargets();
  }

  function computeInputGutterTargetsForOutput() {
    const targets = new Map();
    if (!els.output) {
      return targets;
    }

    const cards = els.output.querySelectorAll(".card[data-id][data-line-start]");
    for (const card of Array.from(cards)) {
      const line = Number(card.getAttribute("data-line-start")) || 0;
      const id = String(card.getAttribute("data-id") || "");
      if (!line || !id || targets.has(line)) {
        continue;
      }
      targets.set(line, { kind: "output", id });
    }

    return targets;
  }

  function computeInputGutterTargetsForDescriptions() {
    const targets = new Map();
    if (!els.declDescTable) {
      return targets;
    }

    const rows = els.declDescTable.querySelectorAll("tr[data-decl-key][data-line-start]");
    for (const row of Array.from(rows)) {
      const line = Number(row.getAttribute("data-line-start")) || 0;
      const declKey = String(row.getAttribute("data-decl-key") || "");
      if (!line || !declKey || targets.has(line)) {
        continue;
      }
      targets.set(line, { kind: "descriptions", declKey });
    }

    return targets;
  }

  function refreshInputGutterTargets() {
    if (!els.inputGutterContent || !state.inputGutterButtonsByLine.size) {
      return;
    }

    if (state.inputMode !== "abap") {
      state.inputGutterTargetsByLine = new Map();
      for (const btn of state.inputGutterButtonsByLine.values()) {
        btn.hidden = true;
      }
      return;
    }

    const targets = state.rightTab === "descriptions"
      ? computeInputGutterTargetsForDescriptions()
      : computeInputGutterTargetsForOutput();

    state.inputGutterTargetsByLine = targets;
    const title = state.rightTab === "descriptions" ? "Jump to Descriptions" : "Jump to Output";
    for (const [line, btn] of state.inputGutterButtonsByLine.entries()) {
      const target = targets.get(line);
      btn.hidden = !target;
      if (target) {
        btn.title = title;
        btn.setAttribute("aria-label", title);
      }
    }
  }

  function onInputGutterClick(ev) {
    const target = ev && ev.target && typeof ev.target.closest === "function"
      ? ev.target.closest("button.gutter-jump")
      : null;
    if (!target) {
      return;
    }

    const line = Number(target.getAttribute("data-line")) || 0;
    if (!line) {
      return;
    }

    const jumpTarget = state.inputGutterTargetsByLine.get(line);
    if (!jumpTarget) {
      return;
    }

    if (state.rightTab === "output" && jumpTarget.kind === "output") {
      setSelectedCard(jumpTarget.id);
      return;
    }

    if (state.rightTab === "descriptions" && jumpTarget.kind === "descriptions") {
      setSelectedDeclRow(jumpTarget.declKey);
    }
  }

  function openJsonModal(value) {
    openTextModal("Object JSON", safeJson(value, true));
  }

  function openTextModal(title, text) {
    if (!els.editModal.hidden) {
      closeEditModal();
    }

    if (els.jsonTitle) {
      els.jsonTitle.textContent = title ? String(title) : "";
    }

    els.jsonPre.textContent = text ? String(text) : "";
    els.jsonModal.hidden = false;
  }

  function closeJsonModal() {
    els.jsonModal.hidden = true;
    if (els.jsonTitle) {
      els.jsonTitle.textContent = "Object JSON";
    }
    els.jsonPre.textContent = "";
  }

  async function copyJsonToClipboard() {
    const text = els.jsonPre.textContent || "";
    if (!text) {
      return;
    }

    if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
      await navigator.clipboard.writeText(text);
      return;
    }

    const selection = window.getSelection();
    if (!selection) {
      return;
    }
    selection.removeAllRanges();
    const range = document.createRange();
    range.selectNodeContents(els.jsonPre);
    selection.addRange(range);
    document.execCommand("copy");
    selection.removeAllRanges();
  }

  function stringifyDecl(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const techName = getDeclTechName(decl);
    const displayName = getDeclDisplayName(decl);

    const parts = [];
    if (decl.objectType) {
      parts.push(String(decl.objectType));
    }
    if (decl.scopeLabel) {
      parts.push(`[${String(decl.scopeLabel)}]`);
    }
    if (displayName) {
      parts.push(displayName);
    }
    if (techName && displayName && techName !== displayName) {
      parts.push(`(${techName})`);
    }
    if (decl.file) {
      parts.push(String(decl.file));
    }
    if (decl.lineStart) {
      parts.push(`#${decl.lineStart}`);
    }
    return parts.join(" ");
  }

  function getDeclTechName(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }
    return decl.name ? String(decl.name) : "";
  }

  function stripAngleBrackets(text) {
    const trimmed = String(text || "").trim();
    if (trimmed.startsWith("<") && trimmed.endsWith(">") && trimmed.length > 2) {
      return trimmed.slice(1, -1);
    }
    return trimmed;
  }

  function stripDeclCategoryPrefix(text) {
    const raw = String(text || "").trim();
    if (!raw) {
      return "";
    }

    const match = raw.match(
      /^\s*(HẰNG|HANG|STRUCT|TABLE|RANGETABLE|BIẾN|BIEN|CỜ|CO|FIELDSYMBOL)\b\s*[:\-\[\]]*\s*/i
    );
    if (!match) {
      return raw;
    }

    let rest = raw.slice(match[0].length).trim();
    // If the prefix included an opening "[" (e.g. "BIẾN:[") then strip ONE trailing "]" (e.g. "...]")
    // so "BIẾN:[desc]" -> "desc" instead of "desc]".
    if (match[0].includes("[") && rest.endsWith("]")) {
      rest = rest.slice(0, -1).trim();
    }
    return rest;
  }

  function isStructFieldDecl(decl) {
    if (!decl || typeof decl !== "object") {
      return false;
    }
    if (decl.objectType === "STRUCT_FIELD") {
      return true;
    }
    return Boolean(decl.structName && decl.fieldPath);
  }

  function getDeclDisplayName(decl) {
    const techName = getDeclTechName(decl);
    if (!techName) {
      return "";
    }

    if (isStructFieldDecl(decl)) {
      return techName;
    }

    const desc = getEffectiveDeclDesc(decl);
    const descTrimmed = String(desc || "").trim();
    if (!descTrimmed) {
      return techName;
    }

    const bare = stripAngleBrackets(techName);
    if (bare.length < 3) {
      return techName;
    }

    const code = bare.slice(1, 3).toUpperCase();
    const settings = state.settings || DEFAULT_SETTINGS;
    const templates = settings.nameTemplatesByCode || DEFAULT_SETTINGS.nameTemplatesByCode;
    const template = templates && Object.prototype.hasOwnProperty.call(templates, code) ? String(templates[code] || "") : "";
    if (!template.trim()) {
      return techName;
    }

    const normalizedDesc = stripDeclCategoryPrefix(descTrimmed);
    const displayName = template.replace(/\{\{desc\}\}/g, normalizedDesc).trim();
    return displayName || techName;
  }

  function buildDeclTitle(decl) {
    if (!decl || typeof decl !== "object") {
      return "";
    }

    const lines = [];
    lines.push(stringifyDecl(decl));

    const desc = getEffectiveDeclDesc(decl);
    if (desc) {
      lines.push(`Desc: ${desc}`);
    }

    if (decl.raw) {
      lines.push(String(decl.raw));
    }

    return lines.filter(Boolean).join("\n");
  }

  function renderDeclNameCell(decl) {
    const text = decl ? getDeclDisplayName(decl) : "";
    const title = buildDeclTitle(decl);
    const cell = el("td", { text, attrs: title ? { title } : {} });

    if (decl && decl.lineStart) {
      cell.style.cursor = "pointer";
      cell.addEventListener("click", (ev) => {
        ev.stopPropagation();
        selectCodeLines(decl.lineStart, decl.lineStart);
        if (decl.id) {
          setSelectedCard(decl.id);
        }
      });
    }

    return cell;
  }

  function renderDeclDescCell(decl) {
    const text = getEffectiveDeclDesc(decl);
    const title = buildDeclTitle(decl);
    const cell = el("td", { attrs: title ? { title } : {} });

    const wrap = el("div", { className: "decl-desc" });
    wrap.appendChild(el("div", { className: "decl-desc-text", text: text || "" }));

    if (decl && decl.name && decl.objectType) {
      const btn = el("button", {
        className: "icon-btn",
        text: "✎",
        attrs: {
          type: "button",
          title: "Edit decl description",
          "aria-label": "Edit decl description"
        }
      });
      btn.addEventListener("click", (ev) => {
        ev.stopPropagation();
        editDeclDesc(decl);
      });
      wrap.appendChild(btn);
    }

    cell.appendChild(wrap);

    return cell;
  }

  function renderDeclListCells(decls, fallbackDecl) {
    const list = Array.isArray(decls) ? decls.filter(Boolean) : [];
    const effectiveList = list.length ? list : fallbackDecl ? [fallbackDecl] : [];

    const nameCell = el("td");
    const descCell = el("td");

    if (!effectiveList.length) {
      return { nameCell, descCell };
    }

    const nameWrap = el("div");
    const descWrap = el("div");

    for (const decl of effectiveList) {
      const nameLine = el("div", { text: decl ? getDeclDisplayName(decl) : "" });
      const title = buildDeclTitle(decl);
      if (title) {
        nameLine.title = title;
      }

      if (decl && decl.lineStart) {
        nameLine.style.cursor = "pointer";
        nameLine.addEventListener("click", (ev) => {
          ev.stopPropagation();
          selectCodeLines(decl.lineStart, decl.lineStart);
          if (decl.id) {
            setSelectedCard(decl.id);
          }
        });
      }

      nameWrap.appendChild(nameLine);

      const descLineWrap = el("div", { className: "decl-desc-line" });
      const descLineText = el("div", { className: "decl-desc-text", text: getEffectiveDeclDesc(decl) || "" });
      if (title) {
        descLineText.title = title;
      }
      descLineWrap.appendChild(descLineText);

      if (decl && decl.name && decl.objectType) {
        const btn = el("button", {
          className: "icon-btn",
          text: "✎",
          attrs: {
            type: "button",
            title: "Edit decl description",
            "aria-label": "Edit decl description"
          }
        });
        btn.addEventListener("click", (ev) => {
          ev.stopPropagation();
          editDeclDesc(decl);
        });
        descLineWrap.appendChild(btn);
      }

      descWrap.appendChild(descLineWrap);
    }

    nameCell.appendChild(nameWrap);
    descCell.appendChild(descWrap);
    return { nameCell, descCell };
  }

  function matchesFilters(obj) {
    const typeOk = !state.type || obj.objectType === state.type;
    if (!typeOk) {
      return false;
    }

    if (!state.query) {
      return true;
    }

    const id = normalizeId(obj && obj.id);
    const haystack = id ? state.haystackById.get(id) : "";
    return haystack ? haystack.includes(state.query) : false;
  }

  function filterTree(obj) {
    const children = Array.isArray(obj.children) ? obj.children : [];
    const filteredChildren = [];
    for (const child of children) {
      const filtered = filterTree(child);
      if (filtered) {
        filteredChildren.push(filtered);
      }
    }

    const selfMatches = matchesFilters(obj);
    if (!selfMatches && !filteredChildren.length) {
      return null;
    }

    return { obj, children: filteredChildren, selfMatches };
  }

  function el(tag, options) {
    const node = document.createElement(tag);
    if (options && options.className) {
      node.className = options.className;
    }
    if (options && options.text !== undefined) {
      node.textContent = options.text;
    }
    if (options && options.attrs) {
      for (const [key, value] of Object.entries(options.attrs)) {
        node.setAttribute(key, String(value));
      }
    }
    return node;
  }

  function renderKeywords(obj) {
    const keywords = Array.isArray(obj.keywords) ? obj.keywords : [];
    if (!keywords.length) {
      return null;
    }

    const wrap = el("div");
    for (const keyword of keywords) {
      wrap.appendChild(
        el("span", {
          className: "pill",
          text: keyword && keyword.text ? String(keyword.text) : "",
          attrs: keyword && keyword.label ? { title: String(keyword.label) } : {}
        })
      );
    }
    return wrap;
  }

  function renderValues(obj) {
    const values = Array.isArray(obj.values) ? obj.values : [];
    if (!values.length) {
      return null;
    }

    const table = el("table");
    const thead = el("thead");
    const headRow = el("tr");
    for (const name of ["name", "value", "label", "codeDesc", "declName", "declDesc"]) {
      headRow.appendChild(el("th", { text: name }));
    }
    thead.appendChild(headRow);
    table.appendChild(thead);

    const tbody = el("tbody");
    for (const entry of values) {
      const row = el("tr");
      row.appendChild(el("td", { text: entry && entry.name ? String(entry.name) : "" }));
      row.appendChild(el("td", { text: entry && entry.value ? String(entry.value) : "" }));
      row.appendChild(el("td", { text: entry && entry.label ? String(entry.label) : "" }));
      row.appendChild(el("td", { text: entry && entry.codeDesc ? String(entry.codeDesc) : "" }));
      row.appendChild(renderDeclNameCell(entry && entry.decl));
      row.appendChild(renderDeclDescCell(entry && entry.decl));
      tbody.appendChild(row);
    }
    table.appendChild(tbody);
    return table;
  }

  function renderAssignmentTable(title, list) {
    const items = Array.isArray(list) ? list : [];
    if (!items.length) {
      return null;
    }

    const section = el("div");
    section.appendChild(el("div", { className: "muted", text: title }));

    const table = el("table");
    const thead = el("thead");
    const headRow = el("tr");
    for (const key of ["name", "value", "ref", "declName", "declDesc"]) {
      headRow.appendChild(el("th", { text: key }));
    }
    thead.appendChild(headRow);
    table.appendChild(thead);

    const tbody = el("tbody");
    for (const entry of items) {
      const row = el("tr");
      row.appendChild(el("td", { text: entry && entry.name ? String(entry.name) : "" }));
      row.appendChild(el("td", { text: entry && entry.value ? String(entry.value) : "" }));
      row.appendChild(el("td", { text: entry && entry.valueRef ? String(entry.valueRef) : "" }));
      const { nameCell, descCell } = renderDeclListCells(entry && entry.originDecls, entry && entry.valueDecl);
      row.appendChild(nameCell);
      row.appendChild(descCell);
      tbody.appendChild(row);
    }
    table.appendChild(tbody);
    section.appendChild(table);
    return section;
  }

  function renderValueListTable(title, list) {
    const items = Array.isArray(list) ? list : [];
    if (!items.length) {
      return null;
    }

    const section = el("div");
    section.appendChild(el("div", { className: "muted", text: title }));

    const table = el("table");
    const thead = el("thead");
    const headRow = el("tr");
    for (const key of ["value", "ref", "declName", "declDesc"]) {
      headRow.appendChild(el("th", { text: key }));
    }
    thead.appendChild(headRow);
    table.appendChild(thead);

    const tbody = el("tbody");
    for (const entry of items) {
      const row = el("tr");
      row.appendChild(el("td", { text: entry && entry.value ? String(entry.value) : "" }));
      row.appendChild(el("td", { text: entry && entry.valueRef ? String(entry.valueRef) : "" }));
      const { nameCell, descCell } = renderDeclListCells(entry && entry.originDecls, entry && entry.valueDecl);
      row.appendChild(nameCell);
      row.appendChild(descCell);
      tbody.appendChild(row);
    }
    table.appendChild(tbody);
    section.appendChild(table);
    return section;
  }

  function renderParamsTable(title, params) {
    const items = Array.isArray(params) ? params : [];
    if (!items.length) {
      return null;
    }

    const section = el("div");
    section.appendChild(el("div", { className: "muted", text: title }));

    const table = el("table");
    const thead = el("thead");
    const headRow = el("tr");
    for (const key of ["section", "name", "typing", "doc", "declName", "declDesc"]) {
      headRow.appendChild(el("th", { text: key }));
    }
    thead.appendChild(headRow);
    table.appendChild(thead);

    const tbody = el("tbody");
    for (const param of items) {
      const row = el("tr");
      row.appendChild(el("td", { text: param && param.section ? String(param.section) : "" }));
      row.appendChild(el("td", { text: param && param.name ? String(param.name) : "" }));
      const typingText = formatTyping(param && param.typing);
      row.appendChild(el("td", { text: typingText }));
      const docText = param && param.doc
        ? [param.doc.direction || "", param.doc.text || ""].filter(Boolean).join(" ")
        : "";
      row.appendChild(el("td", { text: docText }));
      const { nameCell, descCell } = renderDeclListCells(param && param.originDecls);
      row.appendChild(nameCell);
      row.appendChild(descCell);
      tbody.appendChild(row);
    }
    table.appendChild(tbody);
    section.appendChild(table);
    return section;
  }

  function formatTyping(typing) {
    if (!typing) {
      return "";
    }
    if (typeof typing === "string") {
      return typing;
    }
    if (Array.isArray(typing)) {
      return typing.map((item) => formatTyping(item)).filter(Boolean).join(" ");
    }
    if (typeof typing === "object") {
      const kind = typing.kind ? String(typing.kind) : "";
      let value = "";

      if (typeof typing.value === "string") {
        value = typing.value;
      } else if (typing.value && typeof typing.value === "object") {
        if (typeof typing.value.value === "string") {
          value = typing.value.value;
        } else if (typeof typing.value.raw === "string") {
          value = typing.value.raw;
        } else if (typeof typing.value.name === "string") {
          value = typing.value.name;
        } else {
          value = safeJson(typing.value, false);
        }
      } else if (typing.value !== undefined && typing.value !== null) {
        value = String(typing.value);
      }

      return [kind, value].filter(Boolean).join(" ").trim();
    }
    return String(typing);
  }

  function renderNameList(title, items) {
    const list = Array.isArray(items) ? items : [];
    if (!list.length) {
      return null;
    }

    const section = el("div");
    section.appendChild(el("div", { className: "muted", text: title }));

    const wrap = el("div");
    for (const entry of list) {
      wrap.appendChild(el("span", { className: "pill", text: entry && entry.name ? String(entry.name) : "" }));
    }
    section.appendChild(wrap);
    return section;
  }

  function renderExtras(obj) {
    const extras = obj.extras;
    if (!extras || typeof extras !== "object") {
      return null;
    }

    const wrap = el("div", { className: "extras" });
    wrap.appendChild(el("div", { className: "muted", text: "Extras" }));

    if (extras.form) {
      const form = extras.form;
      const titleParts = [form.name ? `FORM ${form.name}` : ""].filter(Boolean);
      if (form.nameFromComment && form.nameFromComment !== form.name) {
        titleParts.push(`(comment: ${form.nameFromComment})`);
      }
      if (titleParts.length) {
        wrap.appendChild(el("div", { className: "muted", text: titleParts.join(" ") }));
      }

      const paramsTable = renderParamsTable("params", form.params);
      if (paramsTable) {
        wrap.appendChild(paramsTable);
      }

      const exceptions = renderNameList("exceptions", form.exceptions);
      if (exceptions) {
        wrap.appendChild(exceptions);
      }

      return wrap;
    }

    if (extras.methodSignature) {
      const signature = extras.methodSignature;
      if (signature.name) {
        wrap.appendChild(el("div", { className: "muted", text: `METHOD ${signature.name}` }));
      }

      const paramsTable = renderParamsTable("params", signature.params);
      if (paramsTable) {
        wrap.appendChild(paramsTable);
      }

      const exceptions = renderNameList("exceptions", signature.exceptions);
      if (exceptions) {
        wrap.appendChild(exceptions);
      }

      return wrap;
    }

    if (extras.callFunction) {
      const call = extras.callFunction;
      wrap.appendChild(el("div", { className: "muted", text: call.name ? `CALL FUNCTION ${call.name}` : "CALL FUNCTION" }));
      if (call.destination) {
        wrap.appendChild(el("div", { className: "muted", text: `DESTINATION ${call.destination}` }));
      }

      for (const sectionName of ["exporting", "importing", "changing", "tables", "exceptions"]) {
        const table = renderAssignmentTable(sectionName, call[sectionName]);
        if (table) {
          wrap.appendChild(table);
        }
      }

      return wrap;
    }

    if (extras.callMethod) {
      const call = extras.callMethod;
      wrap.appendChild(el("div", { className: "muted", text: call.target ? `CALL METHOD ${call.target}` : "CALL METHOD" }));

      for (const sectionName of ["exporting", "importing", "changing", "receiving", "exceptions"]) {
        const table = renderAssignmentTable(sectionName, call[sectionName]);
        if (table) {
          wrap.appendChild(table);
        }
      }

      return wrap;
    }

    if (extras.performCall) {
      const call = extras.performCall;
      wrap.appendChild(el("div", { className: "muted", text: call.form ? `PERFORM ${call.form}` : "PERFORM" }));
      if (call.program) {
        wrap.appendChild(el("div", { className: "muted", text: `IN PROGRAM ${call.program}` }));
      }
      if (call.ifCondition) {
        wrap.appendChild(el("div", { className: "muted", text: `IF ${call.ifCondition}` }));
      }

      for (const sectionName of ["using", "changing", "tables"]) {
        const table = renderValueListTable(sectionName, call[sectionName]);
        if (table) {
          wrap.appendChild(table);
        }
      }

      return wrap;
    }

    wrap.appendChild(el("pre", { text: safeJson(extras, true) }));
    return wrap;
  }

  function renderMeta(obj) {
    const parts = [];
    if (obj.file) {
      parts.push(String(obj.file));
    }
    if (obj.lineStart) {
      parts.push(`line ${obj.lineStart}`);
    }
    if (obj.block && obj.block.lineEnd) {
      parts.push(`end ${obj.block.lineEnd}`);
    }
    if (obj.id !== undefined && obj.id !== null) {
      parts.push(`#${obj.id}`);
    }
    return parts.join(" • ");
  }

  function getObjectLabel(obj) {
    const values = Array.isArray(obj.values) ? obj.values : [];
    for (const key of ["name", "target", "form"]) {
      const match = values.find((v) => v && v.name === key && v.value);
      if (match) {
        return String(match.value);
      }
    }

    if (obj.extras && obj.extras.callFunction && obj.extras.callFunction.name) {
      return String(obj.extras.callFunction.name);
    }
    if (obj.extras && obj.extras.callMethod && obj.extras.callMethod.target) {
      return String(obj.extras.callMethod.target);
    }
    if (obj.extras && obj.extras.performCall && obj.extras.performCall.form) {
      return String(obj.extras.performCall.form);
    }
    if (obj.extras && obj.extras.form && obj.extras.form.name) {
      return String(obj.extras.form.name);
    }
    if (obj.extras && obj.extras.methodSignature && obj.extras.methodSignature.name) {
      return String(obj.extras.methodSignature.name);
    }

    return "";
  }

  function renderNode(nodeInfo) {
    const obj = nodeInfo.obj;
    const id = normalizeId(obj.id);
    const children = nodeInfo.children || [];

    const cardAttrs = {};
    if (id) {
      cardAttrs["data-id"] = id;
    }
    if (obj && obj.lineStart) {
      cardAttrs["data-line-start"] = String(obj.lineStart);
    }

    const card = el("div", {
      className: `card${obj.block ? " block" : ""}${id && id === state.selectedId ? " selected" : ""}`,
      attrs: Object.keys(cardAttrs).length ? cardAttrs : {}
    });

    const header = el("div", { className: "card-header" });
    const label = getObjectLabel(obj);
    const titleText = `${String(obj.objectType || "(unknown)")}${label ? ` ${label}` : ""}`;
    const title = el("h3", { className: "card-title", text: titleText });

    const meta = renderMeta(obj);
    if (meta) {
      title.appendChild(el("span", { className: "muted", text: `  (${meta})` }));
    }

    header.appendChild(title);

    const actions = el("div", { className: "card-actions" });

    const btnCode = el("button", { className: "btn-ghost", text: "Code" });
    btnCode.type = "button";
    btnCode.addEventListener("click", (ev) => {
      ev.stopPropagation();
      setSelectedCard(id);
      const lineEnd = obj.block && obj.block.lineEnd ? obj.block.lineEnd : obj.lineStart;
      selectCodeLines(obj.lineStart, lineEnd);
    });
    actions.appendChild(btnCode);

    const btnJson = el("button", { className: "btn-ghost", text: "JSON" });
    btnJson.type = "button";
    btnJson.addEventListener("click", (ev) => {
      ev.stopPropagation();
      setSelectedCard(id);
      openJsonModal(obj);
    });
    actions.appendChild(btnJson);

    if (children.length) {
      const isCollapsed = state.collapsedIds.has(id);
      const btnCollapse = el("button", { className: "btn-ghost", text: isCollapsed ? "Expand" : "Collapse" });
      btnCollapse.type = "button";
      btnCollapse.addEventListener("click", (ev) => {
        ev.stopPropagation();
        if (state.collapsedIds.has(id)) {
          state.collapsedIds.delete(id);
        } else {
          state.collapsedIds.add(id);
        }
        renderOutput();
        setSelectedCard(id);
      });
      actions.appendChild(btnCollapse);
    }

    header.appendChild(actions);
    card.appendChild(header);

    if (obj.comment) {
      card.appendChild(el("div", { className: "muted", text: String(obj.comment) }));
    }

    if (state.showKeywords) {
      const kw = renderKeywords(obj);
      if (kw) {
        card.appendChild(kw);
      }
    }

    if (state.showValues) {
      const valuesTable = renderValues(obj);
      if (valuesTable) {
        card.appendChild(valuesTable);
      }
    }

    if (state.showRaw && obj.raw) {
      card.appendChild(el("div", { className: "raw", text: String(obj.raw) }));
    }

    if (state.showExtras) {
      const extras = renderExtras(obj);
      if (extras) {
        card.appendChild(extras);
      }
    }

    if (children.length && !state.collapsedIds.has(id)) {
      const childWrap = el("div", { className: "children" });
      for (const child of children) {
        childWrap.appendChild(renderNode(child));
      }
      card.appendChild(childWrap);
    }

    card.addEventListener("click", () => setSelectedCard(id));
    return card;
  }

  function populateTypeFilter(objects) {
    const types = new Set();
    walkObjects(objects, (obj) => {
      if (obj && obj.objectType) {
        types.add(String(obj.objectType));
      }
    });

    const sorted = Array.from(types).sort((a, b) => a.localeCompare(b));
    const current = els.typeFilter.value || "";

    while (els.typeFilter.options.length > 1) {
      els.typeFilter.remove(1);
    }

    for (const type of sorted) {
      const opt = document.createElement("option");
      opt.value = type;
      opt.textContent = type;
      els.typeFilter.appendChild(opt);
    }

    els.typeFilter.value = sorted.includes(current) ? current : "";
  }

  function renderOutput() {
    const scrollTop = els.output.scrollTop;
    setError("");

    if (!state.data || !Array.isArray(state.data.objects)) {
      setOutputMessage("No data loaded.");
      refreshInputGutterTargets();
      return;
    }

    state.query = (els.searchInput.value || "").trim().toLowerCase();
    state.type = els.typeFilter.value || "";
    state.showRaw = Boolean(els.showRaw && els.showRaw.checked);
    state.showKeywords = Boolean(els.showKeywords && els.showKeywords.checked);
    state.showValues = Boolean(els.showValues && els.showValues.checked);
    state.showExtras = Boolean(els.showExtras && els.showExtras.checked);

    const filteredRoots = (state.data.objects || [])
      .map((obj) => filterTree(obj))
      .filter(Boolean);

    if (!filteredRoots.length) {
      setOutputMessage("No matches.");
      refreshInputGutterTargets();
      return;
    }

    const frag = document.createDocumentFragment();
    for (const root of filteredRoots) {
      frag.appendChild(renderNode(root));
    }

    els.output.classList.remove("muted");
    els.output.replaceChildren(frag);
    els.output.scrollTop = scrollTop;

    if (state.selectedId) {
      setSelectedCard(state.selectedId);
    }

    refreshInputGutterTargets();
  }

  function normalizeParsedJson(json) {
    if (Array.isArray(json)) {
      return { file: "", objects: json, decls: [] };
    }
    if (json && typeof json === "object" && Array.isArray(json.objects)) {
      return {
        file: String(json.file || ""),
        objects: json.objects,
        decls: Array.isArray(json.decls) ? json.decls : []
      };
    }
    return null;
  }

  function parseFromTextarea(fileName) {
    const content = els.inputText.value || "";
    const trimmed = content.trim();
    const isJsonInput = (trimmed.startsWith("{") || trimmed.startsWith("[")) && trimmed.length > 1;
    state.inputMode = isJsonInput ? "json" : "abap";
    rebuildInputGutter();
    if (!trimmed) {
      setError("Input is empty.");
      setOutputMessage("No data loaded.");
      return;
    }

    state.inputLineOffsets = computeLineOffsets(content);

    if (isJsonInput) {
      try {
        const json = JSON.parse(trimmed);
        const parsed = normalizeParsedJson(json);
        if (!parsed) {
          throw new Error("JSON parsed, but shape is not { file, objects[] } or objects[].");
        }
        state.data = parsed;
      } catch (err) {
        setError(`JSON parse error: ${err && err.message ? err.message : err}`);
        setOutputMessage("No data loaded.");
        return;
      }
    } else {
      if (!window.AbapParser || typeof window.AbapParser.parseAbapText !== "function") {
        setError("AbapParser not loaded.");
        setOutputMessage("No data loaded.");
        return;
      }

      try {
        const builtInConfigs = typeof window.AbapParser.getConfigs === "function" ? window.AbapParser.getConfigs() : [];
        const customConfigs = getCustomConfigs();
        const configs = [...customConfigs, ...builtInConfigs];
        state.data = window.AbapParser.parseAbapText(content, configs, fileName || "");
      } catch (err) {
        setError(`Parse error: ${err && err.message ? err.message : err}`);
        setOutputMessage("No data loaded.");
        return;
      }
    }

    state.collapsedIds.clear();
    state.selectedId = "";
    state.haystackById = buildSearchIndex(state.data.objects);
    populateTypeFilter(state.data.objects);
    renderOutput();
    if (state.rightTab === "descriptions") {
      renderDeclDescPanelUi();
    }
  }

  function resetUi() {
    els.searchInput.value = "";
    els.typeFilter.value = "";
    els.showRaw.checked = true;
    els.showKeywords.checked = true;
    els.showValues.checked = true;
    els.showExtras.checked = true;
    state.collapsedIds.clear();
    state.selectedId = "";
  }

  function collapseAll() {
    state.collapsedIds.clear();
    walkObjects(state.data ? state.data.objects : [], (obj) => {
      const id = normalizeId(obj && obj.id);
      const children = Array.isArray(obj && obj.children) ? obj.children : [];
      if (id && children.length) {
        state.collapsedIds.add(id);
      }
    });
  }

  function init() {
    state.descOverrides = loadDescOverrides();
    state.descOverridesLegacy = loadLegacyDescOverrides();
    state.customRules = loadCustomRules();
    state.settings = loadSettings();
    applyTheme(loadTheme(), { save: false });

    if (els.inputText && !els.inputText.value.trim()) {
      els.inputText.value = SAMPLE_ABAP;
    }

    rebuildInputGutter();

    if (els.inputText) {
      els.inputText.addEventListener("input", rebuildInputGutter);
      els.inputText.addEventListener("scroll", syncInputGutterScroll);
    }

    if (els.inputGutter) {
      els.inputGutter.addEventListener("click", onInputGutterClick);
      els.inputGutter.addEventListener("wheel", (ev) => {
        if (!els.inputText) {
          return;
        }
        els.inputText.scrollTop += ev.deltaY;
        syncInputGutterScroll();
        ev.preventDefault();
      }, { passive: false });
    }

    if (els.themeToggle) {
      els.themeToggle.addEventListener("change", () => {
        applyTheme(els.themeToggle.checked ? "dark" : "light");
      });
    }

    els.parseBtn.addEventListener("click", () => parseFromTextarea("input.abap"));
    els.searchInput.addEventListener("input", renderOutput);
    els.typeFilter.addEventListener("change", renderOutput);
    els.showRaw.addEventListener("change", renderOutput);
    els.showKeywords.addEventListener("change", renderOutput);
    els.showValues.addEventListener("change", renderOutput);
    els.showExtras.addEventListener("change", renderOutput);

    els.expandAllBtn.addEventListener("click", () => {
      state.collapsedIds.clear();
      renderOutput();
    });

    els.collapseAllBtn.addEventListener("click", () => {
      if (!state.data) {
        return;
      }
      collapseAll();
      renderOutput();
    });

    els.clearFiltersBtn.addEventListener("click", () => {
      resetUi();
      renderOutput();
    });

    els.descBtn.addEventListener("click", () => {
      setRightTab("descriptions");
    });

    if (els.rightTabOutputBtn) {
      els.rightTabOutputBtn.addEventListener("click", () => setRightTab("output"));
    }

    if (els.rightTabDescBtn) {
      els.rightTabDescBtn.addEventListener("click", () => setRightTab("descriptions"));
    }

    if (els.declDescJsonBtn) {
      els.declDescJsonBtn.addEventListener("click", () => {
        openJsonModal({
          storageKey: DESC_STORAGE_KEY_V2,
          overrides: state.descOverrides,
          legacyStorageKey: DESC_STORAGE_KEY_LEGACY_V1,
          legacyOverrides: state.descOverridesLegacy,
          registry: window.AbapVarDescriptions || {}
        });
      });
    }

    if (els.declDescSearch) {
      els.declDescSearch.addEventListener("input", renderDeclDescPanelUi);
    }

    if (els.declDescMissingOnly) {
      els.declDescMissingOnly.addEventListener("change", renderDeclDescPanelUi);
    }

    if (els.rulesBtn) {
      els.rulesBtn.addEventListener("click", openRulesModal);
    }

    if (els.settingsBtn) {
      els.settingsBtn.addEventListener("click", openSettingsModal);
    }

    if (els.exportXmlBtn) {
      els.exportXmlBtn.addEventListener("click", () => {
        if (!state.data || !Array.isArray(state.data.objects)) {
          setError("No parsed data to export. Click Render first.");
          return;
        }
        setError("");
        openTextModal("Export XML", buildAbapFlowXml(state.data));
      });
    }

    els.fileInput.addEventListener("change", async (ev) => {
      const file = ev.target && ev.target.files ? ev.target.files[0] : null;
      if (!file) {
        return;
      }
      const text = await file.text();
      els.inputText.value = text;
      parseFromTextarea(file.name || "");
    });

    if (els.rulesCloseBtn) {
      els.rulesCloseBtn.addEventListener("click", closeRulesModal);
    }
    if (els.rulesModal) {
      els.rulesModal.addEventListener("click", (ev) => {
        if (ev.target === els.rulesModal) {
          closeRulesModal();
        }
      });
    }

    if (els.settingsCloseBtn) {
      els.settingsCloseBtn.addEventListener("click", closeSettingsModal);
    }
    if (els.settingsSaveBtn) {
      els.settingsSaveBtn.addEventListener("click", () => {
        applySettingsFromModal();
        closeSettingsModal();
      });
    }
    if (els.settingsResetBtn) {
      els.settingsResetBtn.addEventListener("click", resetSettingsToDefault);
    }
    if (els.settingsModal) {
      els.settingsModal.addEventListener("click", (ev) => {
        if (ev.target === els.settingsModal) {
          closeSettingsModal();
        }
      });
    }
    if (els.rulesNewBtn) {
      els.rulesNewBtn.addEventListener("click", startNewRule);
    }
    if (els.rulesSaveBtn) {
      els.rulesSaveBtn.addEventListener("click", saveRuleFromEditor);
    }
    if (els.rulesDeleteBtn) {
      els.rulesDeleteBtn.addEventListener("click", deleteActiveRule);
    }
    if (els.rulesDownloadBtn) {
      els.rulesDownloadBtn.addEventListener("click", downloadRuleFromEditor);
    }
    if (els.rulesSelect) {
      els.rulesSelect.addEventListener("change", () => {
        const id = els.rulesSelect.value || "";
        if (!id) {
          startNewRule();
          return;
        }
        selectRule(id);
      });
    }
    if (els.rulesTemplate) {
      els.rulesTemplate.addEventListener("change", () => {
        if (!state.activeRuleId) {
          startNewRule();
        }
      });
    }
    if (els.rulesJson) {
      els.rulesJson.addEventListener("keydown", (ev) => {
        if ((ev.ctrlKey || ev.metaKey) && ev.key === "Enter") {
          ev.preventDefault();
          saveRuleFromEditor();
        }
      });
    }

    els.jsonCloseBtn.addEventListener("click", closeJsonModal);
    els.jsonModal.addEventListener("click", (ev) => {
      if (ev.target === els.jsonModal) {
        closeJsonModal();
      }
    });
    els.jsonCopyBtn.addEventListener("click", () => {
      copyJsonToClipboard().catch((err) => setError(err && err.message ? err.message : err));
    });

    els.editCancelBtn.addEventListener("click", closeEditModal);
    els.editModal.addEventListener("click", (ev) => {
      if (ev.target === els.editModal) {
        closeEditModal();
      }
    });
    els.editSaveBtn.addEventListener("click", () => {
      applyEditModal("save");
      closeEditModal();
    });
    els.editClearBtn.addEventListener("click", () => {
      applyEditModal("clear");
      closeEditModal();
    });

    const onEditKeydown = (ev) => {
      if ((ev.ctrlKey || ev.metaKey) && ev.key === "Enter") {
        ev.preventDefault();
        applyEditModal("save");
        closeEditModal();
      }
    };

    els.editDesc.addEventListener("keydown", onEditKeydown);
    if (els.editStructDesc) {
      els.editStructDesc.addEventListener("keydown", onEditKeydown);
    }
    if (els.editItemDesc) {
      els.editItemDesc.addEventListener("keydown", onEditKeydown);
    }

    window.addEventListener("keydown", (ev) => {
      if (ev.key !== "Escape") {
        return;
      }

      if (!els.editModal.hidden) {
        closeEditModal();
        return;
      }

      if (els.rulesModal && !els.rulesModal.hidden) {
        closeRulesModal();
        return;
      }

      if (!els.jsonModal.hidden) {
        closeJsonModal();
        return;
      }

      if (state.rightTab === "descriptions") {
        setRightTab("output");
        return;
      }
    });

    setRightTab(state.rightTab);
    parseFromTextarea("sample.abap");
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
})();
</script>
</body>
</html>
