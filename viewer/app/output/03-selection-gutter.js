"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/03-selection-gutter.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\n    const rows = els.declDescTable.querySelectorAll(\"tr[data-decl-key][data-line-start]\");\n    for (const row of Array.from(rows)) {\n      const line = Number(row.getAttribute(\"data-line-start\")) || 0;\n      const declKey = String(row.getAttribute(\"data-decl-key\") || \"\");\n      if (!line || !declKey || targets.has(line)) {\n        continue;\n      }\n      targets.set(line, { kind: \"descriptions\", declKey });\n    }\n\n    return targets;\n  }\n\n  function computeInputGutterTargetsForTemplate() {\n    const targets = new Map();\n    if (!els.templatePreviewOutput) {\n      return targets;\n    }\n\n    const blocks = els.templatePreviewOutput.querySelectorAll(\".template-block[data-template-index][data-line-start]\");\n    for (const block of Array.from(blocks)) {\n      const line = Number(block.getAttribute(\"data-line-start\")) || 0;\n      const index = String(block.getAttribute(\"data-template-index\") || \"\");\n      if (!line || !index || targets.has(line)) {\n        continue;\n      }\n      targets.set(line, { kind: \"template\", index });\n    }\n\n    return targets;\n  }\n\n  function refreshInputGutterTargets() {\n    if (!els.inputGutterContent || !state.inputGutterButtonsByLine.size) {\n      return;\n    }\n\n    if (state.inputMode !== \"abap\") {\n      state.inputGutterTargetsByLine = new Map();\n      for (const btn of state.inputGutterButtonsByLine.values()) {\n        btn.hidden = true;\n      }\n      return;\n    }\n\n    let targets = new Map();\n    if (state.rightTab === \"descriptions\") {\n      targets = computeInputGutterTargetsForDescriptions();\n    } else if (state.rightTab === \"output\") {\n      targets = computeInputGutterTargetsForOutput();\n    } else if (state.rightTab === \"template\") {\n      targets = computeInputGutterTargetsForTemplate();\n    }\n\n    state.inputGutterTargetsByLine = targets;\n    const title = state.rightTab === \"descriptions\"\n      ? \"Jump to Descriptions\"\n      : (state.rightTab === \"output\"\n        ? \"Jump to Output\"\n        : (state.rightTab === \"template\" ? \"Jump to Template\" : \"\"));\n    for (const [line, btn] of state.inputGutterButtonsByLine.entries()) {\n      const target = targets.get(line);\n      btn.hidden = !target;\n      if (target) {\n        btn.title = title;\n        btn.setAttribute(\"aria-label\", title);\n      }\n    }\n  }\n\n  function onInputGutterClick(ev) {\n    const target = ev && ev.target && typeof ev.target.closest === \"function\"\n      ? ev.target.closest(\"button.gutter-jump\")\n      : null;\n    if (!target) {\n      return;\n    }\n\n    const line = Number(target.getAttribute(\"data-line\")) || 0;\n    if (!line) {\n      return;\n    }\n\n    const jumpTarget = state.inputGutterTargetsByLine.get(line);\n    if (!jumpTarget) {\n      return;\n    }\n\n    if (state.rightTab === \"output\" && jumpTarget.kind === \"output\") {\n      setSelectedCard(jumpTarget.id, { scroll: true, scrollMode: \"start\" });\n      return;\n    }\n\n    if (state.rightTab === \"template\" && jumpTarget.kind === \"template\") {\n      setSelectedTemplateBlock(jumpTarget.index, { scroll: true, scrollMode: \"start\" });\n      return;\n    }\n\n    if (state.rightTab === \"descriptions\" && jumpTarget.kind === \"descriptions\") {\n      setSelectedDeclRow(jumpTarget.declKey);\n    }\n  }\n\n  function openJsonModal(value) {\n    openTextModal(\"Object JSON\", safeJson(value, true));\n  }\n\n  function openTextModal(title, text) {\n    if (!els.editModal.hidden) {\n      closeEditModal();\n    }\n\n    if (els.jsonTitle) {\n      els.jsonTitle.textContent = title ? String(title) : \"\";\n    }\n\n    els.jsonPre.textContent = text ? String(text) : \"\";\n    els.jsonModal.hidden = false;\n  }\n\n  function closeJsonModal() {\n    els.jsonModal.hidden = true;\n    if (els.jsonTitle) {\n      els.jsonTitle.textContent = \"Object JSON\";\n    }\n    els.jsonPre.textContent = \"\";\n  }\n\n  async function copyJsonToClipboard() {\n    const text = els.jsonPre.textContent || \"\";\n    if (!text) {\n      return;\n    }\n\n    if (navigator.clipboard && typeof navigator.clipboard.writeText === \"function\") {\n      await navigator.clipboard.writeText(text);\n      return;\n    }\n\n    const selection = window.getSelection();\n    if (!selection) {\n      return;\n    }\n    selection.removeAllRanges();\n    const range = document.createRange();\n    range.selectNodeContents(els.jsonPre);\n    selection.addRange(range);\n    document.execCommand(\"copy\");\n    selection.removeAllRanges();\n  }\n\n  function stringifyDecl(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const techName = getDeclTechName(decl);\n    const displayName = getDeclDisplayName(decl);\n\n    const parts = [];\n    if (decl.objectType) {\n      parts.push(String(decl.objectType));\n    }\n    if (decl.scopeLabel) {\n      parts.push(`[${String(decl.scopeLabel)}]`);\n    }\n    if (displayName) {\n      parts.push(displayName);\n    }\n    if (techName && displayName && techName !== displayName) {\n      parts.push(`(${techName})`);\n    }\n    if (decl.file) {\n      parts.push(String(decl.file));\n    }\n    if (decl.lineStart) {\n      parts.push(`#${decl.lineStart}`);\n    }\n    return parts.join(\" \");\n  }\n\n  function getDeclTechName(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n    return decl.name ? String(decl.name) : \"\";\n  }\n\n  function stripAngleBrackets(text) {\n    const trimmed = String(text || \"\").trim();\n    if (trimmed.startsWith(\"<\") && trimmed.endsWith(\">\") && trimmed.length > 2) {\n      return trimmed.slice(1, -1);\n    }\n    return trimmed;\n  }\n\n  function stripDeclCategoryPrefix(text) {\n    const raw = String(text || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const match = raw.match(\n      /^\\s*(HẰNG|HANG|STRUCT|TABLE|RANGETABLE|BIẾN|BIEN|CỜ|CO|FIELDSYMBOL)\\b\\s*[:\\-\\[\\]]*\\s*/i\n    );\n    if (!match) {\n      return raw;\n    }\n\n    let rest = raw.slice(match[0].length).trim();\n    // If the prefix included an opening \"[\" (e.g. \"BIẾN:[\") then strip ONE trailing \"]\" (e.g. \"...]\")\n    // so \"BIẾN:[desc]\" -> \"desc\" instead of \"desc]\".\n    if (match[0].includes(\"[\") && rest.endsWith(\"]\")) {\n      rest = rest.slice(0, -1).trim();\n    }\n    return rest;\n  }\n\n  function isStructFieldDecl(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return false;\n    }\n    if (decl.objectType === \"STRUCT_FIELD\") {\n      return true;\n    }\n    return Boolean(decl.structName && decl.fieldPath);\n  }\n\n  function getDeclDisplayName(decl) {\n    const techName = getDeclTechName(decl);\n    if (!techName) {\n      return \"\";\n    }\n\n    if (isStructFieldDecl(decl)) {\n      return techName;\n    }\n\n    const desc = getEffectiveDeclDesc(decl);\n    const descTrimmed = String(desc || \"\").trim();\n    if (!descTrimmed) {\n      return techName;\n    }\n\n    const settings = state.settings || DEFAULT_SETTINGS;\n    if (settings.normalizeDeclDesc) {\n      return descTrimmed;\n    }\n\n    const bare = stripAngleBrackets(techName);\n    if (bare.length < 3) {\n      return techName;\n    }\n\n    const code = bare.slice(1, 3).toUpperCase();\n    const templates = settings.nameTemplatesByCode || DEFAULT_SETTINGS.nameTemplatesByCode;\n    const template = templates && Object.prototype.hasOwnProperty.call(templates, code) ? String(templates[code] || \"\") : \"\";\n    if (!template.trim()) {\n      return techName;\n    }\n\n    const strippedKnownPrefix = stripDeclCategoryPrefix(descTrimmed);\n    const normalizedDesc = stripDeclTemplateAffixes(strippedKnownPrefix, template);\n    const displayName = template.replace(/\\{\\{desc\\}\\}/g, normalizedDesc).trim();\n    return displayName || techName;\n  }\n\n  function buildDeclTitle(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const lines = [];\n    lines.push(stringifyDecl(decl));\n\n    const desc = getEffectiveDeclDesc(decl);\n    if (desc) {\n      lines.push(`Desc: ${desc}`);\n    }\n\n    if (decl.raw) {\n      lines.push(String(decl.raw));\n    }\n\n    return lines.filter(Boolean).join(\"\\n\");\n  }\n\n  function renderDeclNameCell(decl) {\n    const text = decl ? getDeclDisplayName(decl) : \"\";\n    const title = buildDeclTitle(decl);\n    const cell = el(\"td\", { text, attrs: title ? { title } : {} });\n\n    if (decl && decl.lineStart) {\n      cell.style.cursor = \"pointer\";\n      cell.addEventListener(\"click\", (ev) => {\n        ev.stopPropagation();\n        selectCodeLines(decl.lineStart, decl.lineStart);\n        if (decl.id) {\n          setSelectedCard(decl.id);\n        }\n      });\n    }\n\n    return cell;\n  }\n\n  function renderDeclDescCell(decl) {\n    const text = getEffectiveDeclDesc(decl);\n    const title = buildDeclTitle(decl);\n    const cell = el(\"td\", { attrs: title ? { title } : {} });\n\n    const wrap = el(\"div\", { className: \"decl-desc\" });\n    wrap.appendChild(el(\"div\", { className: \"decl-desc-text\", text: text || \"\" }));\n\n    if (getDeclOverrideStorageKey(decl)) {\n      const btn = el(\"button\", {\n        className: \"icon-btn\",\n        text: \"✎\",\n        attrs: {\n          type: \"button\",\n          title: \"Edit decl description\",\n          \"aria-label\": \"Edit decl description\"\n        }\n      });\n      btn.addEventListener(\"click\", (ev) => {\n        ev.stopPropagation();\n        editDeclDesc(decl);\n      });\n      wrap.appendChild(btn);\n    }\n\n    cell.appendChild(wrap);\n\n    return cell;\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
