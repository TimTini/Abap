"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/03-template-preview.js";
  const partKey = "viewer/app/template/01-path-resolver.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\"use strict\";\n\nwindow.AbapViewerModules = window.AbapViewerModules || {};\nwindow.AbapViewerModules.parts = window.AbapViewerModules.parts || {};\n\n  var PERFORM_TRACE_META_KEY_TEMPLATE = \"__abapPerformTraceBinding\";\n\n  function toInlineCssText(styleMap) {\n    if (!styleMap || typeof styleMap !== \"object\") {\n      return \"\";\n    }\n    const entries = [];\n    for (const [key, value] of Object.entries(styleMap)) {\n      const cssKey = String(key || \"\").trim();\n      const cssValue = String(value || \"\").trim();\n      if (!cssKey || !cssValue) {\n        continue;\n      }\n      entries.push(`${cssKey}:${cssValue}`);\n    }\n    return entries.join(\";\");\n  }\n\n  function normalizeTemplateColorValue(value) {\n    const raw = String(value || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const alias = normalizeTemplateAliasToken(raw);\n    if (!alias || alias === \"default\") {\n      return \"\";\n    }\n    if (alias === \"mau xanh nhat\") {\n      return \"#dbeef4\";\n    }\n    if (alias === \"den\") {\n      return \"#000000\";\n    }\n    return raw;\n  }\n\n  function normalizeTemplateBorderValue(value) {\n    const raw = String(value || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const alias = normalizeTemplateAliasToken(raw);\n    if (!alias || alias === \"default\") {\n      return \"\";\n    }\n    if (alias === \"outside line mong\") {\n      return \"outside-thin\";\n    }\n    return raw;\n  }\n\n  function normalizeTemplateAlignValue(value) {\n    const alias = normalizeTemplateAliasToken(value);\n    if (!alias || alias === \"default\") {\n      return \"\";\n    }\n    if (alias === \"left\" || alias === \"center\" || alias === \"right\") {\n      return alias;\n    }\n    return \"\";\n  }\n\n  function normalizeTemplateVAlignValue(value) {\n    const alias = normalizeTemplateAliasToken(value);\n    if (!alias || alias === \"default\") {\n      return \"\";\n    }\n    if (alias === \"top\") {\n      return \"top\";\n    }\n    if (alias === \"middle\" || alias === \"center\") {\n      return \"middle\";\n    }\n    if (alias === \"bottom\") {\n      return \"bottom\";\n    }\n    return \"\";\n  }\n\n  function parseTemplatePathSegments(pathExpression) {\n    const raw = String(pathExpression || \"\").trim();\n    if (!raw) {\n      return [];\n    }\n\n    const segments = [];\n    let token = \"\";\n    let index = 0;\n\n    const pushToken = () => {\n      const trimmed = token.trim();\n      if (trimmed) {\n        segments.push(trimmed);\n      }\n      token = \"\";\n    };\n\n    while (index < raw.length) {\n      const ch = raw[index];\n      if (ch === \".\") {\n        pushToken();\n        index += 1;\n        continue;\n      }\n\n      if (ch === \"[\") {\n        pushToken();\n        const close = raw.indexOf(\"]\", index + 1);\n        if (close === -1) {\n          return null;\n        }\n        const inside = raw.slice(index + 1, close).trim();\n        if (!/^\\d+$/.test(inside)) {\n          return null;\n        }\n        segments.push(Number(inside));\n        index = close + 1;\n        continue;\n      }\n\n      token += ch;\n      index += 1;\n    }\n\n    pushToken();\n    return segments;\n  }\n\n  function isDeclLikePathSegment(segment) {\n    const key = String(segment || \"\").replace(/\\[\\d+\\]$/, \"\").trim();\n    if (!key) {\n      return false;\n    }\n    if (key.toLowerCase() === \"decl\") {\n      return true;\n    }\n    return /decl$/i.test(key);\n  }\n\n  function isTemplateDeclLikeValue(value) {\n    if (isDeclLikeObject(value)) {\n      return true;\n    }\n    return Boolean(\n      value\n      && typeof value === \"object\"\n      && typeof value.objectType === \"string\"\n      && typeof value.name === \"string\"\n    );\n  }\n\n  function resolveTemplatePathValue(root, pathExpression) {\n    const segments = parseTemplatePathSegments(pathExpression);\n    if (!segments) {\n      return undefined;\n    }\n\n    let current = root;\n    let parent = null;\n    let parentAccessKey = \"\";\n    for (const segment of segments) {\n      if (typeof segment === \"number\") {\n        if (!Array.isArray(current)) {\n          return undefined;\n        }\n        parent = current;\n        parentAccessKey = `[${segment}]`;\n        current = current[segment];\n        continue;\n      }\n\n      const key = String(segment || \"\").trim();\n      if (!key) {\n        continue;\n      }\n\n      if (Array.isArray(current)) {\n        const projected = [];\n        for (const item of current) {\n          if (!item || typeof item !== \"object\") {\n            continue;\n          }\n\n          const keyLower = key.toLowerCase();\n          if (keyLower === \"desc\" && isDeclLikeObject(item)) {\n            projected.push(getEffectiveDeclDesc(item));\n            continue;\n          }\n\n          if (keyLower === \"finaldesc\") {\n            if (isTemplateDeclLikeValue(item)) {\n              projected.push(getFinalDeclDesc(item));\n              continue;\n            }\n            if (hasValueLevelDescFields(item) || isDeclLikeObject(item.decl)) {\n              projected.push(resolveValueLevelFinalDesc(item));\n              continue;\n            }\n          }\n\n          if (Object.prototype.hasOwnProperty.call(item, key)) {\n            projected.push(item[key]);\n          }\n        }\n        if (!projected.length) {\n          return undefined;\n        }\n        parent = null;\n        parentAccessKey = \"\";\n        current = projected;\n        continue;\n      }\n\n      if (!current || typeof current !== \"object\") {\n        return undefined;\n      }\n\n      const keyLower = key.toLowerCase();\n      if (keyLower === \"desc\" && isDeclLikeObject(current)) {\n        return getEffectiveDeclDesc(current);\n      }\n\n      if (keyLower === \"finaldesc\") {\n        const parentLooksDecl = isDeclLikePathSegment(parentAccessKey);\n        if (isTemplateDeclLikeValue(current) || parentLooksDecl) {\n          return getFinalDeclDesc(current);\n        }\n        if (hasValueLevelDescFields(current) || isDeclLikeObject(current.decl)) {\n          return resolveValueLevelFinalDesc(current);\n        }\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(current, key)) {\n        return undefined;\n      }\n      parent = current;\n      parentAccessKey = key;\n      current = current[key];\n    }\n\n    return current;\n  }\n\n  function buildTemplatePathCandidates(tokenExpression) {\n    const raw = String(tokenExpression || \"\").trim();\n    if (!raw) {\n      return [];\n    }\n\n    const candidates = new Set();\n    candidates.add(raw);\n\n    if (/^keyword\\./i.test(raw)) {\n      candidates.add(`keywords.${raw.slice(\"keyword.\".length)}`);\n    }\n\n    return Array.from(candidates);\n  }\n\n  function getTemplateArrayItemTagName(keyHint) {\n    if (typeof getArrayItemTagName === \"function\") {\n      return getArrayItemTagName(keyHint);\n    }\n    const key = String(keyHint || \"\").trim().toLowerCase();\n    if (key === \"objects\" || key === \"children\") {\n      return \"object\";\n    }\n    return \"item\";\n  }\n\n  function normalizeTemplateEntryForPath(value, keyHint, pathParts, ownerContext) {\n    if (typeof normalizeEntryObjectForXml !== \"function\") {\n      return value;\n    }\n    try {\n      return normalizeEntryObjectForXml(value, keyHint, pathParts, ownerContext);\n    } catch {\n      return value;\n    }\n  }\n\n  function getTemplateDeclRenderKey(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n    return (\n      (typeof getDeclKey === \"function\" ? getDeclKey(decl) : \"\")\n      || [\n        decl.objectType || \"\",\n        decl.scopeLabel || \"\",\n        decl.name || \"\",\n        decl.file || \"\",\n        decl.lineStart || \"\"\n      ].join(\"|\")\n    );\n  }\n\n  function dedupeTemplateDecls(list) {\n    const out = [];\n    const seen = new Set();\n    for (const decl of Array.isArray(list) ? list : []) {\n      if (!decl || typeof decl !== \"object\") {\n        continue;\n      }\n      const key = getTemplateDeclRenderKey(decl);\n      if (!key || seen.has(key)) {\n        continue;\n      }\n      seen.add(key);\n      out.push(decl);\n    }\n    return out;\n  }\n\n  function getExpandedPerformBindingContextForTemplate(obj) {\n    if (!obj || typeof obj !== \"object\") {\n      return null;\n    }\n    const bindingContext = obj[PERFORM_TRACE_META_KEY_TEMPLATE];\n    if (!bindingContext || typeof bindingContext !== \"object\") {\n      return null;\n    }\n    if (!(bindingContext.byParamUpper instanceof Map)) {\n      return null;\n    }\n    return bindingContext;\n  }\n\n  function resolveExpandedPerformTemplateTraceDecls(ownerContext, decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return [];\n    }\n    if (String(decl.objectType || \"\").toUpperCase() !== \"FORM_PARAM\") {\n      return [];\n    }\n    const bindingContext = getExpandedPerformBindingContextForTemplate(ownerContext);\n    if (!bindingContext) {\n      return [];\n    }\n    const paramUpper = String(decl.name || \"\").trim().toUpperCase();\n    if (!paramUpper) {\n      return [];\n    }\n    const traceDecls = bindingContext.byParamUpper.get(paramUpper);\n    if (!Array.isArray(traceDecls) || !traceDecls.length) {\n      return [];\n    }\n    return dedupeTemplateDecls(traceDecls);\n  }\n\n  function isTemplateValueEntryLikeObject(value) {\n    if (!value || typeof value !== \"object\" || Array.isArray(value)) {\n      return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(value, \"decl\")) {\n      return false;\n    }\n    return (\n      Object.prototype.hasOwnProperty.call(value, \"value\")\n      || Object.prototype.hasOwnProperty.call(value, \"declRef\")\n      || Object.prototype.hasOwnProperty.call(value, \"name\")\n      || Object.prototype.hasOwnProperty.call(value, \"label\")\n      || hasValueLevelDescFields(value)\n    );\n  }\n\n  function remapTemplateDeclForExpandedPerform(value, ownerContext) {\n    if (!isTemplateValueEntryLikeObject(value)) {\n      return value;\n    }\n\n    const localDecl = value.decl;\n    if (!isDeclLikeObject(localDecl) || String(localDecl.objectType || \"\").toUpperCase() !== \"FORM_PARAM\") {\n      return value;\n    }\n\n    const externalTraceDecls = resolveExpandedPerformTemplateTraceDecls(ownerContext, localDecl);\n    if (!externalTraceDecls.length) {\n      return value;\n    }\n\n    const existingOrigins = Array.isArray(value.originDecls) ? value.originDecls : [];\n    const originDecls = dedupeTemplateDecls([localDecl, ...externalTraceDecls, ...existingOrigins]);\n    return {\n      ...value,\n      decl: externalTraceDecls[0],\n      originDecls\n    };\n  }\n\n  function buildTemplateContextObject(obj, objectIndexOneBased) {\n    const objectIndex = Number(objectIndexOneBased) || 1;\n    const basePathParts = [\"objects\", `object[${objectIndex}]`];\n\n    const cloneRecursive = (value, keyHint, pathParts, ownerContext) => {\n      if (value === null || value === undefined) {\n        return value;\n      }\n      if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n        return value;\n      }\n\n      if (Array.isArray(value)) {\n        const itemTag = getTemplateArrayItemTagName(keyHint);\n        return value.map((item, index) => cloneRecursive(\n          item,\n          itemTag,\n          pathParts.concat(`${itemTag}[${index + 1}]`),\n          ownerContext\n        ));\n      }\n\n      if (typeof value !== \"object\") {\n        return value;\n      }\n\n      const nextOwnerContext = (typeof isAbapStatementObject === \"function\" && isAbapStatementObject(value))\n        ? value\n        : ownerContext;\n      const normalized = normalizeTemplateEntryForPath(value, keyHint, pathParts, nextOwnerContext);\n      if (!normalized || typeof normalized !== \"object\") {\n        return normalized;\n      }\n      const remappedForTrace = remapTemplateDeclForExpandedPerform(normalized, nextOwnerContext);\n\n      const out = {};\n      for (const key of Object.keys(remappedForTrace)) {\n        out[key] = cloneRecursive(\n          remappedForTrace[key],\n          key,\n          pathParts.concat(key),\n          nextOwnerContext\n        );\n      }\n      return out;\n    };\n\n    return cloneRecursive(obj, \"object\", basePathParts, obj);\n  }\n\n  function stringifyTemplateResolvedValue(value) {\n    if (value === undefined || value === null) {\n      return \"\";\n    }\n    if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n      return String(value);\n    }\n    if (Array.isArray(value)) {\n      return value\n        .map((item) => stringifyTemplateResolvedValue(item))\n        .filter((text) => text !== \"\")\n        .join(\"\\n\");\n    }\n    if (isDeclLikeObject(value)) {\n      return getDeclDisplayName(value) || getDeclTechName(value);\n    }\n    if (typeof value === \"object\") {\n      if (hasValueLevelDescFields(value) || isDeclLikeObject(value.decl)) {\n        const finalDesc = resolveValueLevelFinalDesc(value);\n        if (finalDesc) {\n          return finalDesc;\n        }\n      }\n      return safeJson(value, false);\n    }\n    return String(value);\n  }\n\n  function collectTemplateDumpPaths(root) {\n    const out = new Set();\n\n    const walk = (value, path) => {\n      if (path) {\n        out.add(path);\n      }\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i += 1) {\n          const nextPath = path ? `${path}[${i}]` : `[${i}]`;\n          walk(value[i], nextPath);\n        }\n        return;\n      }\n\n      if (typeof value !== \"object\") {\n        return;\n      }\n\n      if (path && isDeclLikeObject(value)) {\n        out.add(`${path}.desc`);\n        out.add(`${path}.finalDesc`);\n      }\n      if (path && (hasValueLevelDescFields(value) || isDeclLikeObject(value.decl))) {\n        out.add(`${path}.finalDesc`);\n      }\n\n      for (const key of Object.keys(value)) {\n        const nextPath = path ? `${path}.${key}` : key;\n        walk(value[key], nextPath);\n      }\n    };\n\n    walk(root, \"\");\n    return Array.from(out).sort((a, b) => a.localeCompare(b));\n  }\n\n  function formatTemplateDumpValue(value) {\n    if (value === undefined || value === null) {\n      return \"\";\n    }\n    const text = String(value);\n    return text\n      .replace(/\\r\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\n\")\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
