"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/03-template-preview.js";
  const partKey = "viewer/app/template/02-grid-and-style.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "      .replace(/\\n/g, \"\\\\n\");\n  }\n\n  function collectTemplateDumpPathValues(root) {\n    const out = new Map();\n\n    const addEntry = (path, value) => {\n      const key = String(path || \"\").trim();\n      if (!key || out.has(key)) {\n        return;\n      }\n      out.set(key, formatTemplateDumpValue(value));\n    };\n\n    const walk = (value, path) => {\n      const currentPath = String(path || \"\");\n      if (value === undefined) {\n        return;\n      }\n\n      if (value === null) {\n        if (currentPath) {\n          addEntry(currentPath, \"\");\n        }\n        return;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n        if (currentPath) {\n          addEntry(currentPath, value);\n        }\n        return;\n      }\n\n      if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i += 1) {\n          const nextPath = currentPath ? `${currentPath}[${i}]` : `[${i}]`;\n          walk(value[i], nextPath);\n        }\n        return;\n      }\n\n      if (typeof value !== \"object\") {\n        if (currentPath) {\n          addEntry(currentPath, String(value));\n        }\n        return;\n      }\n\n      if (currentPath && isDeclLikeObject(value)) {\n        addEntry(`${currentPath}.desc`, getEffectiveDeclDesc(value));\n        addEntry(`${currentPath}.finalDesc`, getFinalDeclDesc(value));\n      }\n      if (currentPath && (hasValueLevelDescFields(value) || isDeclLikeObject(value.decl))) {\n        addEntry(`${currentPath}.finalDesc`, resolveValueLevelFinalDesc(value));\n      }\n\n      const keys = Object.keys(value);\n      keys.sort((a, b) => a.localeCompare(b));\n      for (const key of keys) {\n        const nextPath = currentPath ? `${currentPath}.${key}` : key;\n        walk(value[key], nextPath);\n      }\n    };\n\n    walk(root, \"\");\n    return Array.from(out.entries()).map(([path, value]) => `${path} = ${value}`);\n  }\n\n  function openTemplatePathDump(contextObj, index, obj) {\n    const lines = collectTemplateDumpPathValues(contextObj);\n    const fallback = collectTemplateDumpPaths(contextObj).map((path) => `${path} =`);\n    const dumpText = (lines.length ? lines : fallback).join(\"\\n\");\n    const objectType = obj && obj.objectType ? String(obj.objectType) : \"OBJECT\";\n    const title = `Template Paths #${Number(index) + 1} ${objectType}`;\n\n    if (typeof openTextModal === \"function\") {\n      openTextModal(title, dumpText || \"[No paths]\");\n      return;\n    }\n\n    if (typeof setError === \"function\") {\n      setError(\"Path viewer is unavailable.\");\n    }\n  }\n\n  function resolveTemplatePlaceholderValue(obj, tokenExpression) {\n    const token = String(tokenExpression || \"\").trim();\n    if (!token) {\n      return \"\";\n    }\n\n    if (token === \"__DUMP__\") {\n      return collectTemplateDumpPaths(obj).join(\"\\n\");\n    }\n    if (token === \"__DUMP_VALUES__\" || token === \"__DUMP_WITH_VALUES__\") {\n      return collectTemplateDumpPathValues(obj).join(\"\\n\");\n    }\n\n    const candidates = buildTemplatePathCandidates(token);\n\n    for (const candidate of candidates) {\n      const value = resolveTemplatePathValue(obj, candidate);\n      if (value !== undefined) {\n        return value;\n      }\n    }\n\n    return \"\";\n  }\n\n  function resolveTemplateText(rawText, obj) {\n    const templateText = String(rawText === undefined || rawText === null ? \"\" : rawText);\n    if (!templateText.includes(\"{\")) {\n      return {\n        text: templateText,\n        hasPlaceholder: false,\n        hasTokenValue: false\n      };\n    }\n\n    let hasPlaceholder = false;\n    let hasTokenValue = false;\n    const text = templateText.replace(/\\{([^{}]+)\\}/g, (full, token) => {\n      hasPlaceholder = true;\n      const resolved = resolveTemplatePlaceholderValue(obj, token);\n      const resolvedText = stringifyTemplateResolvedValue(resolved);\n      if (resolvedText !== \"\") {\n        hasTokenValue = true;\n      }\n      return resolvedText;\n    });\n\n    return {\n      text,\n      hasPlaceholder,\n      hasTokenValue\n    };\n  }\n\n  function createTemplateCellModel() {\n    return {\n      text: \"\",\n      style: {},\n      hidden: false,\n      rowspan: 1,\n      colspan: 1,\n      hasPlaceholder: false,\n      hasTokenValue: false\n    };\n  }\n\n  function buildTemplateCellStyle(rangeConfig, position) {\n    const cfg = rangeConfig && typeof rangeConfig === \"object\" ? rangeConfig : {};\n    const style = {};\n\n    const background = normalizeTemplateColorValue(cfg.background);\n    if (background) {\n      style[\"background-color\"] = background;\n    }\n\n    const fontColor = normalizeTemplateColorValue(cfg[\"font color\"]);\n    if (fontColor) {\n      style.color = fontColor;\n    }\n\n    const fontSize = Number(cfg[\"font size\"]);\n    if (Number.isFinite(fontSize) && fontSize > 0) {\n      style[\"font-size\"] = `${fontSize}pt`;\n    }\n\n    const fontFamilyRaw = String(cfg[\"font family\"] || \"\").trim();\n    if (fontFamilyRaw && normalizeTemplateAliasToken(fontFamilyRaw) !== \"default\") {\n      style[\"font-family\"] = fontFamilyRaw;\n    }\n\n    if (cfg.bold === true) {\n      style[\"font-weight\"] = \"700\";\n    }\n    if (cfg.italic === true) {\n      style[\"font-style\"] = \"italic\";\n    }\n    if (cfg.underline === true) {\n      style[\"text-decoration\"] = \"underline\";\n    }\n\n    const align = normalizeTemplateAlignValue(cfg.align);\n    if (align) {\n      style[\"text-align\"] = align;\n    }\n\n    const valign = normalizeTemplateVAlignValue(cfg.valign);\n    if (valign) {\n      style[\"vertical-align\"] = valign;\n    }\n\n    if (cfg.wrap === true) {\n      style[\"white-space\"] = \"pre-wrap\";\n    } else if (cfg.wrap === false) {\n      style[\"white-space\"] = \"nowrap\";\n    }\n\n    const border = normalizeTemplateBorderValue(cfg.border);\n    if (border === \"outside-thin\") {\n      const borderLine = \"0.5pt solid #000000\";\n      if (position && position.isMergeAnchor) {\n        style.border = borderLine;\n      } else {\n        style[\"border-top\"] = position && position.isTop ? borderLine : \"none\";\n        style[\"border-right\"] = position && position.isRight ? borderLine : \"none\";\n        style[\"border-bottom\"] = position && position.isBottom ? borderLine : \"none\";\n        style[\"border-left\"] = position && position.isLeft ? borderLine : \"none\";\n      }\n    } else if (border) {\n      style.border = border;\n    }\n\n    return style;\n  }\n\n  function parseTemplateOptionBoolean(value, fallback) {\n    if (typeof value === \"boolean\") {\n      return value;\n    }\n    if (typeof value === \"number\") {\n      if (value === 1) {\n        return true;\n      }\n      if (value === 0) {\n        return false;\n      }\n      return fallback;\n    }\n    const token = String(value || \"\").trim().toLowerCase();\n    if (!token) {\n      return fallback;\n    }\n    if (token === \"1\" || token === \"true\" || token === \"yes\" || token === \"y\" || token === \"on\") {\n      return true;\n    }\n    if (token === \"0\" || token === \"false\" || token === \"no\" || token === \"n\" || token === \"off\") {\n      return false;\n    }\n    return fallback;\n  }\n\n  function parseTemplateOptionNumber(value, fallback, min, max) {\n    const fallbackValue = Number.isFinite(Number(fallback)) ? Number(fallback) : 0;\n    const minValue = Number.isFinite(Number(min)) ? Number(min) : fallbackValue;\n    const maxValue = Number.isFinite(Number(max)) ? Number(max) : fallbackValue;\n\n    let numeric = NaN;\n    if (typeof value === \"number\") {\n      numeric = value;\n    } else if (typeof value === \"string\") {\n      const token = value.trim();\n      if (token) {\n        numeric = Number(token);\n      }\n    }\n\n    if (!Number.isFinite(numeric)) {\n      return fallbackValue;\n    }\n\n    const normalized = Math.round(numeric);\n    return Math.max(minValue, Math.min(maxValue, normalized));\n  }\n\n  function getTemplateOptionByPath(source, path) {\n    if (!source || typeof source !== \"object\" || Array.isArray(source)) {\n      return undefined;\n    }\n    const parts = String(path || \"\").split(\".\").map((item) => String(item || \"\").trim()).filter(Boolean);\n    if (!parts.length) {\n      return undefined;\n    }\n\n    let current = source;\n    for (const part of parts) {\n      if (!current || typeof current !== \"object\" || Array.isArray(current)) {\n        return undefined;\n      }\n      if (!Object.prototype.hasOwnProperty.call(current, part)) {\n        return undefined;\n      }\n      current = current[part];\n    }\n    return current;\n  }\n\n  function readTemplateOptionValue(sources, paths) {\n    const sourceList = Array.isArray(sources) ? sources : [];\n    const pathList = Array.isArray(paths) ? paths : [];\n    for (const source of sourceList) {\n      for (const path of pathList) {\n        const value = getTemplateOptionByPath(source, path);\n        if (value !== undefined) {\n          return value;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  function normalizeTemplatePreviewOptions(optionSource, templateDef, rangeSource) {\n    const sources = [optionSource, templateDef, rangeSource];\n    const hideEmptyRows = parseTemplateOptionBoolean(readTemplateOptionValue(sources, [\n      \"hideEmptyRows\",\n      \"removeEmptyRows\",\n      \"compact.removeEmptyRows\"\n    ]), true);\n    const hideRowsWithoutValues = parseTemplateOptionBoolean(readTemplateOptionValue(sources, [\n      \"hideRowsWithoutValues\",\n      \"removeEmptyRowsAdvanced\",\n      \"removeEmptyRowsAdv\",\n      \"compact.removeEmptyRowsAdvanced\",\n      \"compact.removeEmptyRowsAdv\"\n    ]), true);\n    const expandMultilineRows = parseTemplateOptionBoolean(readTemplateOptionValue(sources, [\n      \"expandMultilineRows\",\n      \"expandArrayRows\",\n      \"arrayToRows\"\n    ]), false);\n    const squareCells = parseTemplateOptionBoolean(readTemplateOptionValue(sources, [\n      \"squareCells\",\n      \"squareCellsEnabled\",\n      \"fixedSquareCells\"\n    ]), true);\n    const squareCellSize = parseTemplateOptionNumber(readTemplateOptionValue(sources, [\n      \"squareCellSize\",\n      \"squareCellSizePx\",\n      \"cellSize\",\n      \"cellSizePx\"\n    ]), 18, 16, 240);\n\n    return {\n      hideEmptyRows,\n      hideRowsWithoutValues,\n      expandMultilineRows,\n      squareCells,\n      squareCellSize\n    };\n  }\n\n  function isTemplateRangeMetaKey(rawKey) {\n    const key = String(rawKey || \"\").trim().toLowerCase();\n    if (!key) {\n      return false;\n    }\n    return (\n      key === \"_options\"\n      || key === \"options\"\n      || key === \"ranges\"\n      || key === \"compact\"\n      || key === \"hideemptyrows\"\n      || key === \"hiderowswithoutvalues\"\n      || key === \"expandmultilinerows\"\n      || key === \"removeemptyrows\"\n      || key === \"removeemptyrowsadvanced\"\n      || key === \"removeemptyrowsadv\"\n      || key === \"expandarrayrows\"\n      || key === \"arraytorows\"\n      || key === \"squarecells\"\n      || key === \"squarecellsenabled\"\n      || key === \"fixedsquarecells\"\n      || key === \"squarecellsize\"\n      || key === \"squarecellsizepx\"\n      || key === \"cellsize\"\n      || key === \"cellsizepx\"\n    );\n  }\n\n  function resolveTemplateDefinitionForPreview(definition) {\n    if (!definition || typeof definition !== \"object\" || Array.isArray(definition)) {\n      return {\n        map: null,\n        options: normalizeTemplatePreviewOptions(null, null, null)\n      };\n    }\n\n    const hasRanges = definition.ranges && typeof definition.ranges === \"object\" && !Array.isArray(definition.ranges);\n    const rangeSource = hasRanges ? definition.ranges : definition;\n    const optionSource = (definition._options && typeof definition._options === \"object\" && !Array.isArray(definition._options))\n      ? definition._options\n      : ((definition.options && typeof definition.options === \"object\" && !Array.isArray(definition.options))\n        ? definition.options\n        : null);\n    const options = normalizeTemplatePreviewOptions(optionSource, definition, rangeSource);\n\n    const map = {};\n    for (const [key, value] of Object.entries(rangeSource)) {\n      if (isTemplateRangeMetaKey(key)) {\n        continue;\n      }\n      map[key] = value;\n    }\n\n    return { map, options };\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
