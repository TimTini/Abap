"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/03-template-preview.js";
  const partKey = "viewer/app/template/04-copy-import-export.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    temp.style.top = \"0\";\n    temp.setAttribute(\"contenteditable\", \"true\");\n    temp.innerHTML = safeHtml || safeText.replace(/\\n/g, \"<br>\");\n    document.body.appendChild(temp);\n\n    const selection = window.getSelection();\n    if (!selection) {\n      document.body.removeChild(temp);\n      throw new Error(\"Clipboard selection is unavailable.\");\n    }\n\n    selection.removeAllRanges();\n    const range = document.createRange();\n    range.selectNodeContents(temp);\n    selection.addRange(range);\n    const copied = document.execCommand(\"copy\");\n    selection.removeAllRanges();\n    document.body.removeChild(temp);\n\n    if (!copied) {\n      throw new Error(\"Copy failed in this browser.\");\n    }\n  }\n\n  async function copyHtmlWithFallback(html, plainText) {\n    const safeHtml = String(html || \"\");\n    const safeText = String(plainText || \"\");\n    const clipboard = typeof navigator !== \"undefined\" && navigator ? navigator.clipboard : null;\n    let lastClipboardError = null;\n\n    if (\n      safeHtml\n      && clipboard\n      && typeof clipboard.write === \"function\"\n      && typeof window.ClipboardItem === \"function\"\n    ) {\n      try {\n        const item = new window.ClipboardItem({\n          \"text/html\": new Blob([safeHtml], { type: \"text/html\" }),\n          \"text/plain\": new Blob([safeText], { type: \"text/plain\" })\n        });\n        await clipboard.write([item]);\n        return;\n      } catch (err) {\n        lastClipboardError = err;\n      }\n    }\n\n    if (clipboard && typeof clipboard.writeText === \"function\") {\n      try {\n        await clipboard.writeText(safeText);\n        return;\n      } catch (err) {\n        lastClipboardError = err;\n      }\n    }\n\n    const temp = document.createElement(\"div\");\n    temp.style.position = \"fixed\";\n    temp.style.left = \"-99999px\";\n    temp.style.top = \"0\";\n    temp.setAttribute(\"contenteditable\", \"true\");\n    temp.innerHTML = safeHtml || safeText.replace(/\\n/g, \"<br>\");\n    document.body.appendChild(temp);\n\n    const selection = window.getSelection();\n    if (!selection) {\n      document.body.removeChild(temp);\n      if (lastClipboardError) {\n        throw lastClipboardError;\n      }\n      throw new Error(\"Clipboard selection is unavailable.\");\n    }\n\n    selection.removeAllRanges();\n    const range = document.createRange();\n    range.selectNodeContents(temp);\n    selection.addRange(range);\n    const copied = document.execCommand(\"copy\");\n    selection.removeAllRanges();\n    document.body.removeChild(temp);\n\n    if (!copied) {\n      if (lastClipboardError) {\n        throw lastClipboardError;\n      }\n      throw new Error(\"Copy failed in this browser.\");\n    }\n  }\n\n  function resolveTemplateMapForObject(obj, config) {\n    const templates = config && typeof config === \"object\" && config.templates && typeof config.templates === \"object\"\n      ? config.templates\n      : {};\n    const objectType = obj && obj.objectType ? String(obj.objectType) : \"\";\n    if (objectType && Object.prototype.hasOwnProperty.call(templates, objectType)) {\n      const resolved = resolveTemplateDefinitionForPreview(templates[objectType]);\n      return { key: objectType, map: resolved.map, options: resolved.options };\n    }\n    if (Object.prototype.hasOwnProperty.call(templates, \"DEFAULT\")) {\n      const resolved = resolveTemplateDefinitionForPreview(templates.DEFAULT);\n      return { key: \"DEFAULT\", map: resolved.map, options: resolved.options };\n    }\n    const resolved = resolveTemplateDefinitionForPreview(null);\n    return { key: \"\", map: null, options: resolved.options };\n  }\n\n  function buildTemplatePlainTextFromBlock(block) {\n    if (!block) {\n      return \"\";\n    }\n    return String(block.innerText || block.textContent || \"\").trim();\n  }\n\n  function isTemplateCopyTableOnlyEnabled() {\n    return Boolean(els.templateCopyTableOnly && els.templateCopyTableOnly.checked);\n  }\n\n  function buildTemplateCopyPayloadFromBlock(block) {\n    if (!block || typeof block.cloneNode !== \"function\") {\n      return { node: null, text: \"\" };\n    }\n\n    const clone = block.cloneNode(true);\n    const actionButtons = clone.querySelectorAll(\"[data-template-action]\");\n    for (const actionBtn of Array.from(actionButtons)) {\n      actionBtn.remove();\n    }\n\n    if (isTemplateCopyTableOnlyEnabled()) {\n      const table = clone.querySelector(\".template-preview-table\");\n      if (table) {\n        return {\n          node: table.cloneNode(true),\n          text: buildTemplatePlainTextFromBlock(table)\n        };\n      }\n    }\n\n    return {\n      node: clone,\n      text: buildTemplatePlainTextFromBlock(clone)\n    };\n  }\n\n  function getRenderableObjectListForTemplate() {\n    const out = [];\n    const roots = Array.isArray(state.renderObjects) ? state.renderObjects : [];\n\n    const appendNode = (obj, depth) => {\n      if (!obj || typeof obj !== \"object\") {\n        return;\n      }\n      out.push({ obj, depth: Math.max(0, Number(depth) || 0) });\n\n      const children = Array.isArray(obj.children) ? obj.children : [];\n      for (const child of children) {\n        appendNode(child, (Number(depth) || 0) + 1);\n      }\n    };\n\n    for (const root of roots) {\n      appendNode(root, 0);\n    }\n\n    return out;\n  }\n\n  function renderTemplatePreview() {\n    if (!els.templatePreviewOutput) {\n      return;\n    }\n\n    if (!state.data || !Array.isArray(state.renderObjects)) {\n      setTemplatePreviewMessage(\"No data loaded.\");\n      return;\n    }\n\n    const config = state.templateConfig && typeof state.templateConfig === \"object\"\n      ? state.templateConfig\n      : getDefaultTemplateConfig();\n\n    const check = validateTemplateConfig(config);\n    if (!check.valid) {\n      setTemplatePreviewMessage(\"Template config is invalid.\");\n      setTemplateConfigError(check.errors.join(\"\\n\"));\n      return;\n    }\n\n    const items = getRenderableObjectListForTemplate();\n    if (!items.length) {\n      setTemplatePreviewMessage(\"No renderable objects.\");\n      return;\n    }\n\n    const fragment = document.createDocumentFragment();\n    for (let index = 0; index < items.length; index += 1) {\n      const item = items[index];\n      const obj = item.obj;\n      const depth = Math.max(0, Number(item.depth) || 0);\n      const templateContextObj = buildTemplateContextObject(obj, index + 1);\n      const resolved = resolveTemplateMapForObject(obj, config);\n\n      const blockAttrs = { \"data-template-index\": String(index), \"data-depth\": String(depth) };\n      const lineStart = Number(obj && obj.lineStart) || 0;\n      if (lineStart > 0) {\n        blockAttrs[\"data-line-start\"] = String(lineStart);\n      }\n      const block = el(\"div\", { className: \"template-block\", attrs: blockAttrs });\n      const indentPx = Math.min(120, depth * 12);\n      if (indentPx > 0) {\n        block.style.marginLeft = `${indentPx}px`;\n      } else {\n        block.style.marginLeft = \"\";\n      }\n      const header = el(\"div\", { className: \"template-block-header\" });\n\n      const left = el(\"div\");\n      const label = getObjectLabel(obj);\n      const titleText = `${index + 1}. ${String(obj.objectType || \"OBJECT\")}${label ? ` ${label}` : \"\"}`;\n      left.appendChild(el(\"h4\", { className: \"template-block-title\", text: titleText }));\n      const meta = renderMeta(obj);\n      const keyText = resolved.key ? `template=${resolved.key}` : \"template=missing\";\n      left.appendChild(el(\"div\", { className: \"template-block-meta\", text: [meta, keyText].filter(Boolean).join(\" â€¢ \") }));\n      header.appendChild(left);\n\n      const actions = el(\"div\", { className: \"template-block-actions\" });\n      const codeBtn = el(\"button\", {\n        className: \"secondary\",\n        text: \"Code\",\n        attrs: { type: \"button\", \"data-template-action\": \"code\" }\n      });\n      codeBtn.addEventListener(\"click\", () => {\n        const selectedIndex = String(index);\n        if (typeof setSelectedTemplateBlock === \"function\") {\n          setSelectedTemplateBlock(selectedIndex);\n        } else {\n          state.selectedTemplateIndex = selectedIndex;\n        }\n        if (lineStart > 0 && typeof selectCodeLines === \"function\") {\n          const lineEnd = Number(obj && obj.block && obj.block.lineEnd) || lineStart;\n          selectCodeLines(lineStart, lineEnd);\n        }\n      });\n      actions.appendChild(codeBtn);\n\n      const pathsBtn = el(\"button\", {\n        className: \"secondary\",\n        text: \"Paths\",\n        attrs: { type: \"button\", \"data-template-action\": \"paths\" }\n      });\n      pathsBtn.addEventListener(\"click\", (ev) => {\n        if (ev && typeof ev.stopPropagation === \"function\") {\n          ev.stopPropagation();\n        }\n        openTemplatePathDump(templateContextObj, index, obj);\n      });\n      actions.appendChild(pathsBtn);\n\n      const copyBtn = el(\"button\", {\n        className: \"secondary\",\n        text: \"Copy\",\n        attrs: { type: \"button\", \"data-template-action\": \"copy\" }\n      });\n      copyBtn.addEventListener(\"click\", async () => {\n        try {\n          const payload = buildTemplateCopyPayloadFromBlock(block);\n          if (!payload.node) {\n            setError(\"Nothing to copy.\");\n            return;\n          }\n          await copyHtmlWithFallback(payload.node.outerHTML, payload.text);\n          setError(\"\");\n        } catch (err) {\n          setError(`Copy failed: ${err && err.message ? err.message : err}`);\n        }\n      });\n      actions.appendChild(copyBtn);\n      header.appendChild(actions);\n      block.appendChild(header);\n      block.addEventListener(\"click\", () => {\n        const selectedIndex = String(index);\n        if (typeof setSelectedTemplateBlock === \"function\") {\n          setSelectedTemplateBlock(selectedIndex, { scroll: false });\n        } else {\n          state.selectedTemplateIndex = selectedIndex;\n        }\n      });\n\n      if (!resolved.map || typeof resolved.map !== \"object\") {\n        block.appendChild(el(\"div\", { className: \"template-empty\", text: \"[Missing template]\" }));\n        fragment.appendChild(block);\n        continue;\n      }\n\n      const model = buildTemplateGridModel(templateContextObj, resolved.map, resolved.options);\n      if (model.errors.length) {\n        block.appendChild(el(\"div\", { className: \"template-error\", text: model.errors.join(\"\\n\") }));\n      }\n\n      const table = renderTemplateTable(model);\n      if (table) {\n        block.appendChild(table);\n      } else {\n        block.appendChild(el(\"div\", { className: \"template-empty\", text: \"[Missing template]\" }));\n      }\n\n      fragment.appendChild(block);\n    }\n\n    els.templatePreviewOutput.classList.remove(\"muted\");\n    els.templatePreviewOutput.replaceChildren(fragment);\n    state.templatePreviewCache = { count: items.length };\n    if (state.selectedTemplateIndex !== \"\" && typeof setSelectedTemplateBlock === \"function\") {\n      setSelectedTemplateBlock(state.selectedTemplateIndex, { scroll: false });\n    }\n    if (typeof refreshInputGutterTargets === \"function\") {\n      refreshInputGutterTargets();\n    }\n  }\n\n  function syncTemplateEditorFromState() {\n    if (!els.templateConfigJson) {\n      return;\n    }\n    const pretty = safeJson(state.templateConfig || getDefaultTemplateConfig(), true);\n    state.templateConfigDraft = pretty;\n    els.templateConfigJson.value = pretty;\n  }\n\n  function applyTemplateConfigObject(config, options) {\n    const opts = options && typeof options === \"object\" ? options : {};\n    const check = validateTemplateConfig(config);\n    if (!check.valid) {\n      setTemplateConfigError(check.errors.join(\"\\n\"));\n      return false;\n    }\n\n    const next = cloneJsonValue(config);\n    if (!next || typeof next !== \"object\") {\n      setTemplateConfigError(\"Cannot clone template config.\");\n      return false;\n    }\n\n    state.templateConfig = next;\n    if (opts.save !== false) {\n      saveTemplateConfig(next);\n    }\n    setTemplateConfigError(\"\");\n    syncTemplateEditorFromState();\n    renderTemplatePreview();\n    return true;\n  }\n\n  function applyTemplateConfigFromEditor() {\n    const raw = els.templateConfigJson ? String(els.templateConfigJson.value || \"\").trim() : \"\";\n    if (!raw) {\n      setTemplateConfigError(\"Template config JSON is empty.\");\n      return;\n    }\n\n    let parsed = null;\n    try {\n      parsed = JSON.parse(raw);\n    } catch (err) {\n      setTemplateConfigError(`JSON parse error: ${err && err.message ? err.message : err}`);\n      return;\n    }\n\n    applyTemplateConfigObject(parsed, { save: true });\n  }\n\n  function resetTemplateConfig() {\n    applyTemplateConfigObject(getDefaultTemplateConfig(), { save: true });\n  }\n\n  function exportTemplateConfig() {\n    const config = state.templateConfig || getDefaultTemplateConfig();\n    const content = safeJson(config, true);\n    const fileName = \"abap-template-config.json\";\n\n    try {\n      const blob = new Blob([content], { type: \"application/json\" });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = fileName;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n      setError(\"\");\n    } catch (err) {\n      setError(`Export failed: ${err && err.message ? err.message : err}`);\n    }\n  }\n\n  async function importTemplateConfigFromFile(file) {\n    if (!file) {\n      return;\n    }\n\n    let text = \"\";\n    try {\n      text = await file.text();\n    } catch (err) {\n      setTemplateConfigError(`Import failed: ${err && err.message ? err.message : err}`);\n      return;\n    }\n\n    try {\n      const parsed = JSON.parse(text);\n      const applied = applyTemplateConfigObject(parsed, { save: true });\n      if (applied) {\n        setError(\"\");\n      }\n    } catch (err) {\n      setTemplateConfigError(`Import JSON parse error: ${err && err.message ? err.message : err}`);\n    }\n  }\n\n  async function copyAllTemplateBlocks() {\n    if (!els.templatePreviewOutput) {\n      return;\n    }\n    const blocks = Array.from(els.templatePreviewOutput.querySelectorAll(\".template-block\"));\n    if (!blocks.length) {\n      setError(\"Nothing to copy.\");\n      return;\n    }\n\n    const wrapper = document.createElement(\"div\");\n    const plainLines = [];\n    const tableOnly = isTemplateCopyTableOnlyEnabled();\n    for (const block of blocks) {\n      const payload = buildTemplateCopyPayloadFromBlock(block);\n      if (!payload.node) {\n        continue;\n      }\n      wrapper.appendChild(payload.node);\n      if (tableOnly) {\n        wrapper.appendChild(document.createElement(\"br\"));\n      }\n      plainLines.push(payload.text);\n    }\n\n    if (!wrapper.childNodes.length) {\n      setError(\"Nothing to copy.\");\n      return;\n    }\n\n    await copyHtmlWithFallback(wrapper.innerHTML, plainLines.filter(Boolean).join(\"\\n\\n\"));\n  }\n\nwindow.AbapViewerModules.factories = window.AbapViewerModules.factories || {};\nwindow.AbapViewerModules.factories[\"03-template-preview\"] = function registerTemplatePreview(runtime) {\n  const targetRuntime = runtime || (window.AbapViewerRuntime = window.AbapViewerRuntime || {});\n  targetRuntime.api = targetRuntime.api || {};\n  targetRuntime.api.renderTemplatePreview = renderTemplatePreview;\n  targetRuntime.api.applyTemplateConfigFromEditor = applyTemplateConfigFromEditor;\n  window.AbapViewerModules.parts[\"03-template-preview\"] = true;\n};\nwindow.AbapViewerModules.factories[\"03-template-preview\"](window.AbapViewerRuntime);\n\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
