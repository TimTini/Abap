<!doctype html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ABAP Flow - Template editor</title>
        <style>
    /* css/app.css */
    :root {
      --bg: #0b0f17;
      --panel: #111827;
      --panel2: #0f172a;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: #273244;
      --accent: #60a5fa;
      --danger: #ef4444;
      --ok: #22c55e;
      --shadow: 0 8px 28px rgba(0, 0, 0, 0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 800px at 20% -10%, rgba(96, 165, 250, 0.22), transparent 60%),
        radial-gradient(1000px 700px at 100% 10%, rgba(34, 197, 94, 0.16), transparent 55%),
        var(--bg);
      color: var(--text);
    }

    .app-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 14px 18px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .app-header__title h1 {
      font-size: 16px;
      margin: 0;
      letter-spacing: 0.2px;
    }

    .app-header__subtitle {
      margin-top: 2px;
      font-size: 12px;
      color: var(--muted);
    }

    .app-header__actions {
      display: flex;
      gap: 10px;
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      border-radius: 10px;
      padding: 9px 12px;
      font-size: 13px;
      cursor: pointer;
    }

    .btn:hover {
      border-color: rgba(255, 255, 255, 0.18);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn-primary {
      border-color: rgba(96, 165, 250, 0.55);
      background: rgba(96, 165, 250, 0.16);
    }

    .app-main {
      height: calc(100% - 58px);
      padding: 14px;
      display: grid;
      grid-template-columns: 1fr 1.25fr;
      gap: 14px;
    }

    .app-main.app-main--resizable {
      grid-template-columns: minmax(320px, var(--main-left, 44vw)) 12px minmax(420px, 1fr);
      gap: 0;
    }

    .app-splitter {
      cursor: col-resize;
      touch-action: none;
      position: relative;
      border-left: 1px solid rgba(255, 255, 255, 0.04);
      border-right: 1px solid rgba(255, 255, 255, 0.04);
    }

    .app-splitter::before {
      content: "";
      position: absolute;
      top: 14px;
      bottom: 14px;
      left: 50%;
      width: 4px;
      transform: translateX(-50%);
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.10);
    }

    .app-splitter:hover::before {
      background: rgba(96, 165, 250, 0.45);
    }

    .app-splitter.is-dragging::before {
      background: rgba(96, 165, 250, 0.70);
    }

    .panel {
      background: rgba(17, 24, 39, 0.76);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .panel__title {
      padding: 12px 14px;
      font-size: 13px;
      color: var(--muted);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.55);
    }

    .panel__footer {
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.35);
      padding: 10px 12px;
    }

    .status-bar {
      font-size: 12px;
      color: var(--muted);
    }

    .code-input {
      flex: 1;
      width: 100%;
      resize: none;
      border: 0;
      outline: none;
      padding: 12px;
      background: transparent;
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.45;
      white-space: pre;
    }

    .code-editor {
      position: relative;
      flex: 1;
      min-height: 0;
    }

    .code-editor .code-input {
      height: 100%;
      padding-left: 38px;
    }

    .code-markers {
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 26px;
      pointer-events: none;
      border-right: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.20);
    }

    .code-marker {
      position: absolute;
      left: 6px;
      width: 14px;
      height: 14px;
      padding: 0;
      border-radius: 6px;
      border: 1px solid rgba(96, 165, 250, 0.55);
      background: rgba(96, 165, 250, 0.18);
      color: rgba(191, 219, 254, 0.95);
      cursor: pointer;
      font-size: 10px;
      line-height: 1;
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      opacity: 0.75;
      transition: transform 120ms ease, opacity 120ms ease, border-color 120ms ease;
    }

    .code-marker:hover {
      opacity: 1;
      transform: scale(1.08);
      border-color: rgba(96, 165, 250, 0.75);
    }

    .code-markers.is-hidden {
      display: none;
    }

    .tabs {
      display: flex;
      gap: 6px;
      padding: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.55);
    }

    .tab {
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.03);
      color: var(--muted);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 13px;
      cursor: pointer;
    }

    .tab.is-active {
      border-color: rgba(96, 165, 250, 0.55);
      color: var(--text);
      background: rgba(96, 165, 250, 0.14);
    }

    .tab-panels {
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    .tab-panel {
      display: none;
      height: 100%;
      overflow: auto;
    }

    .tab-panel.is-active {
      display: block;
    }

    .split {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      height: 100%;
      min-height: 0;
    }

    .split__left,
    .split__right {
      min-height: 0;
    }

    .split__left {
      border-right: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      flex-direction: column;
    }

    .toolbar {
      padding: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }

    .objcfg-toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .objcfg-toolbar .input {
      flex: 1;
    }

    .objcfg-toolbar--bottom {
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      border-bottom: 0;
      margin-top: auto;
    }

    .objcfg-list {
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .objcfg-item {
      appearance: none;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(255, 255, 255, 0.03);
      color: var(--text);
      border-radius: 12px;
      padding: 9px 10px;
      cursor: pointer;
      text-align: left;
    }

    .objcfg-item:hover {
      border-color: rgba(255, 255, 255, 0.18);
    }

    .objcfg-item.is-active {
      border-color: rgba(96, 165, 250, 0.55);
      background: rgba(96, 165, 250, 0.12);
    }

    .objcfg-item.is-disabled {
      opacity: 0.62;
    }

    .objcfg-item__title {
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.2;
    }

    .objcfg-item__meta {
      margin-top: 4px;
      font-size: 11px;
      color: var(--muted);
    }

    .objcfg-editor__head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .objcfg-editor__title {
      font-size: 13px;
      color: var(--text);
      font-weight: 650;
    }

    .objcfg-editor__badges {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .objcfg-editor__actions {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .objcfg-label {
      margin-top: 12px;
      display: grid;
      gap: 6px;
    }

    .objcfg-label__text {
      font-size: 12px;
      color: var(--muted);
    }

    .objcfg-json {
      width: 100%;
      min-height: 320px;
      resize: vertical;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(255, 255, 255, 0.03);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.4;
      white-space: pre;
    }

    .objcfg-json.objcfg-json--small {
      min-height: 110px;
      resize: vertical;
    }

    .objcfg-advanced {
      margin-top: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(15, 23, 42, 0.18);
      border-radius: 14px;
      padding: 10px 12px 12px;
    }

    .objcfg-advanced__summary {
      cursor: pointer;
      color: var(--muted);
      font-size: 12px;
      user-select: none;
    }

    .objcfg-advanced[open] > .objcfg-advanced__summary {
      margin-bottom: 10px;
    }

    .objcfg-right {
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 0;
    }

    .objcfg-right > .details {
      flex: 1;
      min-height: 0;
      overflow: auto;
    }

    .objcfg-gen {
      margin: 12px 12px 0;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(15, 23, 42, 0.18);
      border-radius: 14px;
      padding: 10px 12px 12px;
    }

    .objcfg-gen[open] > .objcfg-advanced__summary {
      margin-bottom: 10px;
    }

    .objcfg-gen__row {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .objcfg-gen__row .input {
      flex: 1;
    }

    .objcfg-gen__output {
      margin: 10px 0 0;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(11, 15, 23, 0.35);
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.4;
      white-space: pre;
      max-height: 240px;
      overflow: auto;
    }

    .objcfg-quick {
      margin-top: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(15, 23, 42, 0.18);
      border-radius: 14px;
      padding: 10px 12px;
    }

    .objcfg-quick__error {
      color: var(--muted);
      font-size: 12px;
      padding: 6px 0;
    }

    .objcfg-form {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      align-items: end;
    }

    .objcfg-field {
      display: grid;
      gap: 6px;
    }

    .objcfg-field__label {
      font-size: 12px;
      color: var(--muted);
    }

    .objcfg-field--checkbox {
      align-items: center;
      grid-template-columns: 1fr auto;
    }

    .objcfg-field--wide {
      grid-column: 1 / -1;
    }

    .objcfg-sub {
      margin-top: 12px;
    }

    .objcfg-sub__title {
      font-size: 12px;
      color: var(--muted);
      font-weight: 650;
      margin-bottom: 8px;
    }

    .objcfg-sub__grid {
      display: grid;
      grid-template-columns: 1fr 220px;
      gap: 10px;
      align-items: end;
    }

    .objcfg-mini-table {
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(11, 15, 23, 0.35);
    }

    .objcfg-mini-table__head {
      display: grid;
      grid-template-columns: 1fr 120px 110px;
      gap: 10px;
      padding: 8px 10px;
      font-size: 11px;
      color: var(--muted);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.35);
    }

    .objcfg-mini-table__head.objcfg-mini-table__head--4 {
      grid-template-columns: 1fr 140px 1fr 110px;
    }

    .objcfg-mini-table__row {
      display: grid;
      grid-template-columns: 1fr 120px 110px;
      gap: 10px;
      padding: 8px 10px;
      align-items: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .objcfg-mini-table__row.objcfg-mini-table__row--4 {
      grid-template-columns: 1fr 140px 1fr 110px;
    }

    .objcfg-mini-table__row:last-child {
      border-bottom: 0;
    }

    .objcfg-mini-table__input {
      width: 100%;
    }

    .objcfg-mini-table__empty {
      padding: 10px;
      color: var(--muted);
      font-size: 12px;
    }

    .objcfg-templates {
      margin-top: 12px;
    }

    .objcfg-templates__row {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .objcfg-templates__row .input {
      flex: 1;
    }

    .objcfg-templates__list {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .objcfg-templates__empty {
      font-size: 12px;
      color: var(--muted);
      padding: 8px 0;
    }

    .objcfg-templates__item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(15, 23, 42, 0.25);
      border-radius: 12px;
      padding: 8px 10px;
    }

    .objcfg-templates__item-text {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text);
    }

    .objcfg-templates__remove {
      padding: 7px 10px;
    }

    .input {
      width: 100%;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      border-radius: 10px;
      padding: 9px 10px;
      font-size: 13px;
      outline: none;
    }

    select.input {
      color-scheme: dark;
    }

    select.input option,
    select.input optgroup {
      background: #0f172a;
      color: var(--text);
    }

    .table-wrap {
      flex: 1;
      min-height: 0;
      overflow: auto;
    }

    .table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .table th,
    .table td {
      padding: 9px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      vertical-align: top;
    }

    .table th {
      position: sticky;
      top: 0;
      background: rgba(15, 23, 42, 0.95);
      color: var(--muted);
      font-weight: 600;
      text-align: left;
    }

    .table tbody tr {
      cursor: pointer;
    }

    .table tbody tr:hover {
      background: rgba(255, 255, 255, 0.04);
    }

    .table tbody tr.is-selected {
      background: rgba(96, 165, 250, 0.16);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      font-size: 11px;
      color: var(--muted);
    }

    .badge.badge-ok {
      border-color: rgba(34, 197, 94, 0.6);
      color: #bbf7d0;
    }

    .badge.badge-danger {
      border-color: rgba(239, 68, 68, 0.6);
      color: #fecaca;
    }

    .details {
      padding: 12px 14px;
      font-size: 13px;
      min-height: 0;
    }

    .details.empty,
    .json-output.empty,
    .trace-results.empty {
      color: var(--muted);
    }

    .details h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
    }

    .details .meta {
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 12px;
    }

    .kv {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 8px 12px;
      font-size: 12px;
      margin-bottom: 10px;
    }

    .kv .k {
      color: var(--muted);
    }

    .section {
      margin-top: 14px;
    }

    .section__title {
      font-size: 12px;
      color: var(--muted);
      margin: 10px 0 6px;
    }

    .textarea {
      width: 100%;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      border-radius: 10px;
      padding: 9px 10px;
      font-size: 13px;
      outline: none;
      resize: vertical;
      min-height: 44px;
      font-family: var(--sans);
    }

    .textarea:focus {
      border-color: rgba(96, 165, 250, 0.55);
    }

    .anno-grid {
      display: grid;
      gap: 8px;
    }

    .anno-label {
      font-size: 12px;
      color: var(--muted);
    }

    .anno-code {
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 12px;
      color: var(--text);
      white-space: pre-wrap;
    }

    .anno-code--empty {
      color: var(--muted);
    }

    .anno-actions {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .anno-status {
      font-size: 12px;
      color: var(--muted);
    }

    .anno-summary {
      margin-top: 6px;
      color: var(--muted);
      font-size: 12px;
      font-family: var(--sans);
      white-space: pre-wrap;
    }

    .anno-summary__k {
      font-weight: 650;
      margin-right: 6px;
    }

    .param-item {
      margin: 8px 0;
    }

    .param-notes {
      margin-top: 6px;
      font-family: var(--sans);
    }

    .param-notes__summary {
      cursor: pointer;
      color: var(--muted);
      font-size: 12px;
      user-select: none;
    }

    .param-notes__body {
      margin-top: 8px;
    }

    .list {
      margin: 0;
      padding-left: 16px;
      font-family: var(--mono);
      font-size: 12px;
    }

    .list li {
      margin: 4px 0;
    }

    .decl-group {
      list-style: none;
      margin: 6px 0;
      padding: 0;
    }

    .decl-group__header {
      display: flex;
      gap: 8px;
      align-items: flex-start;
    }

    .decl-group__toggle {
      width: 22px;
      height: 22px;
      line-height: 22px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.04);
      color: var(--muted);
      cursor: pointer;
      user-select: none;
    }

    .decl-group__toggle:hover {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
    }

    .decl-group__header-content {
      flex: 1;
    }

    .decl-group__fields {
      margin-top: 4px;
      padding-left: 24px;
    }

    .decl-group.is-collapsed .decl-group__fields {
      display: none;
    }

    .diagram-host {
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      margin: 12px;
      background: rgba(11, 15, 23, 0.40);
      min-height: 520px;
      overflow: auto;
    }

    .sequence-host {
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      margin: 12px;
      background: rgba(11, 15, 23, 0.40);
      min-height: 520px;
      overflow: hidden;
    }

    .sequence-host.empty {
      padding: 12px;
      color: var(--muted);
    }

    .seq-scroll {
      height: 520px;
      overflow: auto;
    }

    .seq-grid {
      display: grid;
      grid-template-columns: 360px 1fr;
      align-items: start;
      min-height: 520px;
    }

    .seq-labels {
      position: sticky;
      left: 0;
      z-index: 3;
      background: rgba(11, 15, 23, 0.85);
      border-right: 1px solid rgba(255, 255, 255, 0.06);
    }

    .seq-header {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      color: var(--muted);
      font-size: 12px;
      background: rgba(15, 23, 42, 0.45);
    }

    .seq-row-label {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      transition: background 120ms ease;
    }

    .seq-row-label.is-hover {
      background: rgba(96, 165, 250, 0.10);
    }

    .seq-row-label.is-hover .seq-row-title {
      color: rgba(191, 219, 254, 0.95);
      text-shadow: 0 0 12px rgba(96, 165, 250, 0.30);
    }

    .seq-row-title {
      font-size: 12px;
      font-weight: 650;
      color: var(--text);
    }

    .seq-row-desc {
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
      white-space: pre-wrap;
    }

    .seq-row-params {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .chip {
      appearance: none;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      border-radius: 999px;
      padding: 5px 8px;
      font-size: 11px;
      cursor: pointer;
      text-align: left;
    }

    .chip:hover {
      border-color: rgba(96, 165, 250, 0.55);
    }

    .seq-canvas {
      position: relative;
      z-index: 1;
    }

    .seq-svg {
      display: block;
    }

    .seq-hover-line {
      pointer-events: none;
      stroke: rgba(96, 165, 250, 0.30);
      stroke-width: 3;
      stroke-linecap: round;
      transition: opacity 120ms ease;
    }

    .hint {
      padding: 0 12px 12px;
      color: var(--muted);
      font-size: 12px;
    }

    .form-grid {
      padding: 12px;
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 10px;
      align-items: end;
    }

    .form-grid label {
      display: grid;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .form-grid__actions {
      padding-bottom: 1px;
    }

    .trace-results {
      padding: 12px;
    }

    .json-output {
      padding: 12px;
      margin: 0;
      font-family: var(--mono);
      font-size: 12px;
      white-space: pre;
      overflow: auto;
    }

    .source-link {
      color: var(--accent);
      text-decoration: none;
    }

    .source-link:hover {
      text-decoration: underline;
    }

    .trace-node__header {
      margin-top: 12px;
      font-size: 13px;
      font-weight: 650;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .trace-node__toggle {
      width: 22px;
      height: 22px;
      padding: 0;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(255, 255, 255, 0.03);
      color: var(--muted);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      line-height: 1;
      transition: transform 120ms ease, border-color 120ms ease, color 120ms ease;
    }

    .trace-node__toggle:hover {
      border-color: rgba(96, 165, 250, 0.55);
      color: var(--text);
    }

    .trace-node.is-collapsed > :not(.trace-node__header) {
      display: none;
    }

    .trace-node.is-collapsed > .trace-node__header .trace-node__toggle {
      transform: rotate(-90deg);
    }

    .trace-node__meta {
      color: var(--muted);
      font-size: 12px;
      margin-top: 2px;
      margin-bottom: 6px;
    }

    .trace-node__notes {
      margin-top: 4px;
      margin-bottom: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.25);
      color: var(--text);
      font-size: 12px;
      white-space: pre-wrap;
    }

    .trace-node__notes--object {
      border-left: 3px solid rgba(96, 165, 250, 0.35);
    }

    .trace-node__notes--var {
      border-left: 3px solid rgba(167, 139, 250, 0.35);
    }

    .trace-node__notes-title {
      font-family: var(--sans);
      font-weight: 650;
      font-size: 12px;
      margin-bottom: 6px;
    }

    .trace-node__notes .param-notes {
      margin-top: 8px;
    }

    .trace-node__notes .param-notes__summary {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.02);
      color: var(--muted);
    }

    .trace-node__notes .param-notes__summary:hover {
      border-color: rgba(96, 165, 250, 0.55);
      color: var(--text);
    }

    .trace-node__notes .param-notes[open] .param-notes__summary {
      border-color: rgba(96, 165, 250, 0.45);
      color: var(--text);
    }

    .trace-note__k {
      color: var(--muted);
      font-weight: 650;
    }

    .trace-node__call {
      color: var(--muted);
      font-size: 12px;
      margin: 10px 0 2px;
      font-family: var(--mono);
    }

    .trace-node__writes {
      margin-top: 4px;
      margin-bottom: 10px;
    }

    @media (max-width: 1100px) {
      .app-main {
        grid-template-columns: 1fr;
        height: auto;
      }
      .split {
        grid-template-columns: 1fr;
      }
      .split__left {
        border-right: 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }
      .form-grid {
        grid-template-columns: 1fr;
      }
    }

    </style>
        <style>
    /* css/templates.css */
    .app-header__actions {
      align-items: center;
    }

    .flow-separator {
      margin: 16px 0 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.55);
      color: var(--muted);
      font-size: 12px;
      font-weight: 650;
    }

    .flow-note {
      margin: 10px 0 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.35);
      color: var(--muted);
      font-size: 12px;
    }

    .conversion-results,
    .original-performs {
      padding: 12px 14px;
      font-size: 13px;
      min-height: 0;
      overflow: auto;
    }

    .conversion-results.empty,
    .original-performs.empty {
      color: var(--muted);
    }

    .template-block {
      margin-bottom: 16px;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.25);
    }

    .template-block.is-clickable {
      cursor: pointer;
    }

    .template-block.is-clickable:hover {
      border-color: rgba(96, 165, 250, 0.35);
    }

    .template-block.is-selected {
      border-color: rgba(96, 165, 250, 0.55);
      box-shadow: 0 0 0 1px rgba(96, 165, 250, 0.10);
    }

    .template-block.is-multi-selected {
      border-color: rgba(34, 197, 94, 0.55);
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.10);
    }

    .template-block.is-cycle .template-block__header {
      color: rgba(252, 165, 165, 0.95);
    }

    .template-block__header {
      font-size: 13px;
      font-weight: 650;
      margin-bottom: 8px;
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .template-block__header-left {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .template-block__select {
      width: 16px;
      height: 16px;
      accent-color: var(--ok);
    }

    .template-block__toggle {
      width: 26px;
      height: 26px;
      padding: 0;
      border-radius: 9px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(255, 255, 255, 0.03);
      color: var(--muted);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      line-height: 1;
      transition: transform 120ms ease, border-color 120ms ease, color 120ms ease;
    }

    .template-block__toggle:hover {
      border-color: rgba(96, 165, 250, 0.35);
      color: var(--text);
    }

    .template-block.is-collapsed .template-block__toggle {
      transform: rotate(-90deg);
    }

    .template-block.is-collapsed .template-block__table {
      display: none;
    }

    .template-block.is-tree-hidden {
      display: none;
    }

    .template-block__title {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .template-block__actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }

    .templates-toolbar {
      position: sticky;
      top: 0;
      z-index: 5;
      margin: 0 0 12px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.55);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .templates-toolbar__count {
      font-size: 12px;
      color: var(--muted);
    }

    .templates-toolbar__actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .btn.btn-sm {
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 9px;
    }

    .template-block__meta {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .template-block__original {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      margin: 0;
      padding: 8px;
      background: rgba(15, 23, 42, 0.35);
      border-radius: 6px;
      white-space: pre-wrap;
    }

    .template-block__table {
      margin-top: 10px;
      padding: 10px;
      overflow: auto;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(11, 15, 23, 0.35);
    }

    .excel-like-table {
      font-size: 12px;
      color: var(--text);
      background: transparent;
    }

    .excel-like-table td.label {
      color: #111;
    }

    .demo-error {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(239, 68, 68, 0.35);
      background: rgba(239, 68, 68, 0.08);
      color: #fecaca;
      font-size: 12px;
    }

    @media (max-width: 1100px) {

    }

    .template-line {
      margin: 6px 0;
      font-family: var(--mono);
      font-size: 12px;
    }

    .template-line__label {
      color: var(--accent);
      font-weight: 650;
      margin-right: 8px;
    }

    .template-line__value {
      color: var(--text);
    }

    .param-list {
      margin-left: 20px;
    }

    .param-item {
      margin: 4px 0;
      color: var(--text);
    }

    .param-item__name {
      color: var(--accent);
      font-weight: 650;
    }

    .param-item__type {
      color: var(--muted);
      margin-left: 8px;
    }

    .param-item__desc {
      color: var(--muted);
      font-style: italic;
      margin-left: 8px;
    }

    .original-perform {
      margin-bottom: 12px;
      padding: 10px;
      border-radius: 8px;
      background: rgba(15, 23, 42, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-family: var(--mono);
      font-size: 12px;
      white-space: pre-wrap;
    }

    .original-perform__header {
      font-weight: 650;
      color: var(--text);
      margin-bottom: 6px;
    }

    .original-perform__code {
      color: var(--muted);
    }

    .copy-success {
      color: var(--ok);
      font-size: 12px;
      margin-top: 8px;
      animation: fadeInOut 2s ease-in-out;
    }

    @keyframes fadeInOut {
      0%, 100% { opacity: 0; }
      50% { opacity: 1; }
    }

    .excel-like-table td[data-bind$=".description"] {
      cursor: text;
    }

    .excel-like-table td[data-bind$=".description"]:hover {
      box-shadow: inset 0 0 0 2px rgba(96, 165, 250, 0.55);
    }

    .demo-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: rgba(0, 0, 0, 0.55);
      z-index: 2000;
    }

    .demo-modal__dialog {
      width: min(720px, 96vw);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(15, 23, 42, 0.96);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.40);
      padding: 14px;
    }

    .demo-modal__title {
      font-size: 13px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 10px;
    }

    .demo-modal__textarea {
      width: 100%;
      min-height: 120px;
      resize: vertical;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
    }

    .demo-modal__hint {
      margin-top: 10px;
      color: var(--muted);
      font-size: 12px;
    }

    .demo-modal__actions {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    </style>
        <style>
    /* css/template_editor.css */
    .editor-main {
      grid-template-columns: minmax(320px, var(--editor-left, 52vw)) 12px minmax(320px, 1fr);
      gap: 0;
    }

    .editor-splitter {
      cursor: col-resize;
      touch-action: none;
      position: relative;
      border-left: 1px solid rgba(255, 255, 255, 0.04);
      border-right: 1px solid rgba(255, 255, 255, 0.04);
    }

    .editor-splitter::before {
      content: "";
      position: absolute;
      top: 14px;
      bottom: 14px;
      left: 50%;
      width: 4px;
      transform: translateX(-50%);
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.10);
    }

    .editor-splitter:hover::before {
      background: rgba(96, 165, 250, 0.45);
    }

    .editor-splitter.is-dragging::before {
      background: rgba(96, 165, 250, 0.70);
    }

    .template-editor {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 12px;
      min-height: 0;
    }

    .template-editor__row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .template-editor__row--3 {
      grid-template-columns: 1fr 1fr 1fr;
    }

    .template-editor__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .template-editor__json {
      flex: 1;
      min-height: 220px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .template-editor__json textarea {
      flex: 1;
    }

    .template-editor__context {
      margin-top: 8px;
    }

    .template-editor__context textarea {
      font-family: var(--mono);
      font-size: 12px;
    }

    .template-editor-preview {
      padding: 12px;
      overflow: auto;
      min-height: 0;
    }

    .template-editor-preview .excel-like-table {
      background: #fff;
    }

    .template-editor-preview-toolbar {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .template-editor-preview-toolbar__row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .template-editor-preview-toolbar__selected {
      min-width: 120px;
      color: rgba(255, 255, 255, 0.82);
    }

    .template-editor-preview-toolbar__field {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .template-editor-preview-toolbar__border {
      min-width: 260px;
      flex: 1;
    }

    .input-color {
      width: 44px;
      padding: 0;
      height: 34px;
    }

    .input-span {
      width: 90px;
    }

    .template-editor-preview td.is-selected {
      outline: 2px solid #60a5fa;
      outline-offset: -2px;
    }

    .template-editor-preview td.is-editing {
      outline: 2px solid #fbbf24;
      outline-offset: -2px;
    }

    .template-editor-preview textarea.cell-editor {
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      border: none;
      outline: none;
      padding: 6px 8px;
      resize: none;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.25;
      background: rgba(255, 255, 255, 0.92);
      color: #111;
    }

    .excel-paste-modal {
      position: fixed;
      inset: 0;
      z-index: 1000;
      display: grid;
      place-items: center;
    }

    .excel-paste-modal[hidden] {
      display: none;
    }

    .excel-paste-modal__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.68);
    }

    .excel-paste-modal__panel {
      position: relative;
      width: min(820px, calc(100vw - 32px));
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(18, 18, 18, 0.95);
      box-shadow: 0 20px 70px rgba(0, 0, 0, 0.45);
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .excel-paste-modal__title {
      font-weight: 700;
      color: rgba(255, 255, 255, 0.92);
    }

    .excel-paste-modal__hint {
      color: rgba(255, 255, 255, 0.74);
      font-size: 13px;
      line-height: 1.35;
    }

    .excel-paste-modal__target {
      min-height: 180px;
      max-height: 40vh;
      overflow: auto;
      border-radius: 12px;
      border: 1px dashed rgba(255, 255, 255, 0.22);
      background: rgba(255, 255, 255, 0.04);
      padding: 10px;
      outline: none;
    }

    .excel-paste-modal__target:focus {
      border-color: rgba(96, 165, 250, 0.70);
      box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.18);
    }

    .excel-paste-modal__actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    </style>
  </head>
  <body>
    <header class="app-header">
      <div class="app-header__title">
        <h1>Template editor</h1>
        <div class="app-header__subtitle">Edit + save templates (localStorage)</div>
      </div>
      <div class="app-header__actions">
        <a class="btn" href="index.html">Back</a>
      </div>
    </header>

    <main class="app-main editor-main">
      <section class="panel panel-left">
        <div class="panel__title">Template</div>
        <div class="template-editor">
          <div class="template-editor__row">
            <label>
              Template
              <select id="tplSelect" class="input"></select>
            </label>
            <label>
              Load
              <button id="btnLoadTemplate" class="btn btn-primary" type="button">Load</button>
            </label>
          </div>

          <div class="template-editor__row template-editor__row--3">
            <label>
              Template id
              <input id="tplId" class="input" type="text" placeholder="my.template.id" />
            </label>
            <label>
              Label
              <input id="tplLabel" class="input" type="text" placeholder="Template label" />
            </label>
            <label>
              Source (objectId)
              <select id="tplSource" class="input"></select>
            </label>
          </div>

          <div class="template-editor__row template-editor__row--3">
            <label>
              <input id="tplAuto" type="checkbox" />
              Auto
            </label>
            <label>
              <input id="tplPreferred" type="checkbox" />
              Active for this object
            </label>
            <label>
              When (optional)
              <div class="template-editor__row">
                <input id="tplWhenPath" class="input" type="text" placeholder="itabOp.kind" />
                <input id="tplWhenEquals" class="input" type="text" placeholder="READ" />
              </div>
            </label>
          </div>

          <div class="template-editor__row">
            <label>
              <input id="tplCompactRemoveEmptyRows" type="checkbox" />
              Xóa dòng rỗng (compact)
            </label>
          </div>

          <div class="template-editor__actions">
            <button id="btnNewTemplate" class="btn" type="button">New</button>
            <button id="btnSaveTemplate" class="btn btn-primary" type="button">Save</button>
            <button id="btnSaveNewTemplate" class="btn" type="button">Save new</button>
            <button id="btnDeleteTemplate" class="btn" type="button">Delete saved</button>
            <button id="btnDeleteRow" class="btn" type="button">Delete row</button>
            <button id="btnDeleteCol" class="btn" type="button">Delete col</button>
            <button id="btnPasteExcel" class="btn" type="button">Paste from Excel</button>
          </div>

          <div class="template-editor__json">
            <div class="panel__title">Template JSON</div>
            <textarea id="tplJson" class="code-input" spellcheck="false" placeholder="{ ... }"></textarea>
          </div>

          <div class="template-editor__context">
            <div class="section__title">Preview context (optional JSON)</div>
            <textarea
              id="ctxJson"
              class="textarea"
              rows="4"
              spellcheck="false"
              placeholder="Paste context JSON to preview filled template..."
              style="font-family:var(--mono);font-size:12px"
            ></textarea>
          </div>
        </div>
        <div class="panel__footer">
          <div id="statusBar" class="status-bar">Ready.</div>
        </div>
      </section>

      <div id="editorSplitter" class="editor-splitter" role="separator" aria-orientation="vertical" tabindex="0"></div>

      <section class="panel panel-right">
        <div class="panel__title">Preview</div>
        <div class="hint">Tip: click a cell to select, double-click to edit. Shift+Enter for newline.</div>
        <div class="template-editor-preview-toolbar">
            <div class="template-editor-preview-toolbar__row">
              <div class="template-editor-preview-toolbar__selected">
                Selected: <span id="selAddr">-</span>
              </div>
              <button id="btnCopyExcel" class="btn btn-primary" type="button">Copy to Excel</button>
              <button id="btnPreviewDeleteRow" class="btn" type="button" disabled>Delete row</button>
              <button id="btnPreviewDeleteCol" class="btn" type="button" disabled>Delete col</button>
              <button id="btnClearFormat" class="btn" type="button" disabled>Clear format</button>
            </div>
          <div class="template-editor-preview-toolbar__row">
            <label class="template-editor-preview-toolbar__field">
              Bg
              <input id="selBgColor" class="input input-color" type="color" value="#ffffff" disabled />
            </label>
            <label class="template-editor-preview-toolbar__field">
              Text
              <input id="selTextColor" class="input input-color" type="color" value="#111111" disabled />
            </label>
            <label class="template-editor-preview-toolbar__field template-editor-preview-toolbar__border">
              Border
              <input id="selBorder" class="input" type="text" placeholder="1px solid #222" disabled />
            </label>
            <button id="btnApplyBorder" class="btn" type="button" disabled>Apply</button>
          </div>
        </div>
        <div id="previewHost" class="template-editor-preview empty">Load a template to preview.</div>
      </section>
    </main>

    <div id="excelPasteModal" class="excel-paste-modal" hidden>
      <div class="excel-paste-modal__backdrop"></div>
      <div class="excel-paste-modal__panel" role="dialog" aria-modal="true" aria-label="Paste from Excel">
        <div class="excel-paste-modal__title">Paste from Excel</div>
        <div class="excel-paste-modal__hint">
          1) Copy a formatted cell range in Excel (Ctrl+C). 2) Click the box below and paste (Ctrl+V). This will import
          table + styles into the Template JSON.
        </div>
        <div id="excelPasteTarget" class="excel-paste-modal__target" contenteditable="true" spellcheck="false" tabindex="0"></div>
        <div class="excel-paste-modal__actions">
          <button id="btnExcelPasteCancel" class="btn" type="button">Cancel</button>
        </div>
      </div>
    </div>

        <script>
    // js/namespace.js
    (function () {
      "use strict";

      if (!window.AbapFlow) {
        window.AbapFlow = {};
      }

      if (!window.AbapFlow.version) {
        window.AbapFlow.version = "0.1.0";
      }
    })();


    </script>
        <script>
    // js/utils.js
    (function (ns) {
      "use strict";

      const utils = {};

      utils.normalizeNewlines = function (text) {
        if (text == null) return "";
        return String(text).replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      };

      utils.splitLines = function (text) {
        return utils.normalizeNewlines(text).split("\n");
      };

      utils.computeLineStartOffsets = function (text) {
        const normalized = utils.normalizeNewlines(text);
        const offsets = [0];
        for (let i = 0; i < normalized.length; i++) {
          if (normalized[i] === "\n") offsets.push(i + 1);
        }
        offsets.push(normalized.length);
        return offsets;
      };

      utils.isFullLineComment = function (line) {
        const t = String(line || "").trimStart();
        return t.startsWith("*");
      };

      utils.splitInlineComment = function (line) {
        const s = String(line || "");
        let out = "";
        let comment = "";
        let inString = false;

        for (let i = 0; i < s.length; i++) {
          const ch = s[i];
          if (ch === "'") {
            out += ch;
            if (inString) {
              if (i + 1 < s.length && s[i + 1] === "'") {
                out += s[i + 1];
                i++;
              } else {
                inString = false;
              }
            } else {
              inString = true;
            }
            continue;
          }

          if (!inString && ch === '"') {
            comment = s.slice(i + 1);
            break;
          }
          out += ch;
        }

        return { code: out, comment };
      };

      utils.stripInlineComment = function (line) {
        return utils.splitInlineComment(line).code;
      };

      utils.normalizeSpaces = function (s) {
        return String(s || "")
          .replace(/\s+/g, " ")
          .trim();
      };

      utils.stripTrailingPeriod = function (s) {
        return String(s || "").replace(/\.\s*$/, "");
      };

      utils.cleanIdentifierToken = function (token) {
        return String(token || "")
          .trim()
          .replace(/^[\(\[\{]+/, "")
          .replace(/[\)\]\}\.,;]+$/, "")
          .trim();
      };

      utils.unwrapValueToken = function (token) {
        const t = String(token || "").trim();
        const m = /^VALUE\((.+)\)$/i.exec(t);
        return m ? m[1].trim() : t;
      };

      utils.isIdentifier = function (token) {
        const t = utils.cleanIdentifierToken(token);
        return /^[A-Za-z_][A-Za-z0-9_\/]*(?:[-~][A-Za-z0-9_\/]+)*$/.test(t);
      };

      utils.splitByCommaOutsideQuotes = function (s) {
        const out = [];
        let buf = "";
        let inString = false;

        for (let i = 0; i < s.length; i++) {
          const ch = s[i];
          if (ch === "'") {
            buf += ch;
            if (inString) {
              if (i + 1 < s.length && s[i + 1] === "'") {
                buf += s[i + 1];
                i++;
              } else {
                inString = false;
              }
            } else {
              inString = true;
            }
            continue;
          }

          if (!inString && ch === ",") {
            out.push(buf);
            buf = "";
            continue;
          }
          buf += ch;
        }

        out.push(buf);
        return out;
      };

      utils.collectStatements = function (lines, startLine, endLine) {
        const statements = [];
        let current = "";
        let stmtStart = null;

        const from = Math.max(1, startLine || 1);
        const to = Math.min(lines.length, endLine || lines.length);

        for (let ln = from; ln <= to; ln++) {
          const rawLine = lines[ln - 1] || "";
          if (utils.isFullLineComment(rawLine)) continue;

          const codeLine = utils.stripInlineComment(rawLine);
          if (!codeLine.trim()) continue;

          if (stmtStart == null) stmtStart = ln;

          let inString = false;
          for (let i = 0; i < codeLine.length; i++) {
            const ch = codeLine[i];
            current += ch;

            if (ch === "'") {
              if (inString) {
                if (i + 1 < codeLine.length && codeLine[i + 1] === "'") {
                  current += codeLine[i + 1];
                  i++;
                } else {
                  inString = false;
                }
              } else {
                inString = true;
              }
              continue;
            }

            if (!inString && ch === ".") {
              statements.push({ startLine: stmtStart, endLine: ln, text: current });
              current = "";
              stmtStart = null;
            }
          }

          if (stmtStart != null) current += "\n";
        }

        return statements;
      };

      utils.escapeHtml = function (s) {
        return String(s ?? "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      };

      utils.nowIso = function nowIso() {
        return new Date().toISOString();
      };

      utils.safeJsonParse = function safeJsonParse(text) {
        try {
          return { ok: true, value: JSON.parse(text) };
        } catch (err) {
          return { ok: false, error: String(err?.message || err) };
        }
      };

      utils.extractSource = function extractSource(model, sourceRef) {
        if (!model || !Array.isArray(model.lines) || !sourceRef) return "";
        const start = Math.max(1, Math.floor(Number(sourceRef.startLine || 1)));
        const end = Math.min(model.lines.length, Math.floor(Number(sourceRef.endLine || start)));
        return model.lines.slice(start - 1, end).join("\n").trim();
      };

      ns.utils = utils;
    })(window.AbapFlow);

    </script>
        <script>
    // js/template_defs_store.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      const STORAGE_KEY = "abapflow-template-defs";
      const SCHEMA = "abapflow-template-defs";
      const VERSION = 1;

      function nowIso() {
        if (utils && typeof utils.nowIso === "function") return utils.nowIso();
        return new Date().toISOString();
      }

      function safeParse(jsonText) {
        if (utils && typeof utils.safeJsonParse === "function") return utils.safeJsonParse(jsonText);
        try {
          return { ok: true, value: JSON.parse(String(jsonText || "")) };
        } catch (e) {
          return { ok: false, error: String(e?.message || e) };
        }
      }

      function asNonEmptyString(x) {
        const s = String(x ?? "").trim();
        return s ? s : "";
      }

      function isPlainObject(x) {
        return Boolean(x) && typeof x === "object" && !Array.isArray(x);
      }

      function normalizeWhen(when) {
        if (!isPlainObject(when)) return null;
        const path = asNonEmptyString(when.path);
        const equals = asNonEmptyString(when.equals);
        if (!path || !equals) return null;
        return { path, equals };
      }

      function normalizeTemplateMeta(meta) {
        if (!isPlainObject(meta)) return {};
        const label = asNonEmptyString(meta.label);
        const source = asNonEmptyString(meta.source);
        const auto = meta.auto != null ? Boolean(meta.auto) : true;
        const custom = Boolean(meta.custom);
        const when = normalizeWhen(meta.when);
        return {
          ...(label ? { label } : {}),
          ...(source ? { source } : {}),
          auto,
          custom,
          ...(when ? { when } : {}),
        };
      }

      function normalizeStore(value) {
        const out = {
          schema: SCHEMA,
          version: VERSION,
          updatedAt: nowIso(),
          templates: {},
          preferredBySource: {},
        };

        if (!isPlainObject(value)) return out;

        const schema = asNonEmptyString(value.schema);
        const version = Number(value.version);
        if (schema !== SCHEMA || !Number.isFinite(version) || version <= 0) return out;

        const templates = isPlainObject(value.templates) ? value.templates : {};
        for (const [idRaw, entry] of Object.entries(templates)) {
          const id = asNonEmptyString(idRaw);
          if (!id) continue;
          if (!isPlainObject(entry)) continue;
          const config = entry.config;
          if (!isPlainObject(config)) continue;
          const meta = normalizeTemplateMeta(entry.meta);
          out.templates[id] = { updatedAt: asNonEmptyString(entry.updatedAt) || nowIso(), config, meta };
        }

        const pref = isPlainObject(value.preferredBySource) ? value.preferredBySource : {};
        for (const [srcRaw, tidRaw] of Object.entries(pref)) {
          const src = asNonEmptyString(srcRaw);
          const tid = asNonEmptyString(tidRaw);
          if (!src || !tid) continue;
          out.preferredBySource[src] = tid;
        }

        out.updatedAt = asNonEmptyString(value.updatedAt) || out.updatedAt;
        return out;
      }

      function loadStore() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return normalizeStore(null);
          const parsed = safeParse(raw);
          if (!parsed.ok) return normalizeStore(null);
          return normalizeStore(parsed.value);
        } catch (_) {
          return normalizeStore(null);
        }
      }

      function saveStore(store) {
        const normalized = normalizeStore(store);
        normalized.updatedAt = nowIso();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(normalized));
        return normalized;
      }

      function getTemplateConfig(templateId) {
        const id = asNonEmptyString(templateId);
        if (!id) return null;
        const store = loadStore();
        return store.templates?.[id]?.config || null;
      }

      function upsertTemplate(templateId, config, meta) {
        const id = asNonEmptyString(templateId);
        if (!id) return { ok: false, error: "Template id is required." };
        if (!isPlainObject(config)) return { ok: false, error: "Template config must be an object." };

        const store = loadStore();
        const nextMeta = normalizeTemplateMeta(meta);
        const existing = store.templates?.[id];

        store.templates[id] = {
          updatedAt: nowIso(),
          config,
          meta: { ...(existing?.meta || {}), ...nextMeta },
        };

        const saved = saveStore(store);
        return { ok: true, store: saved };
      }

      function deleteTemplate(templateId) {
        const id = asNonEmptyString(templateId);
        if (!id) return { ok: false, error: "Template id is required." };

        const store = loadStore();
        const existed = Boolean(store.templates?.[id]);
        if (existed) delete store.templates[id];

        for (const [src, tid] of Object.entries(store.preferredBySource || {})) {
          if (String(tid || "") === id) delete store.preferredBySource[src];
        }

        const saved = saveStore(store);
        return { ok: true, existed, store: saved };
      }

      function listCustomTemplateEntries() {
        const store = loadStore();
        const out = [];

        for (const [id, entry] of Object.entries(store.templates || {})) {
          if (!entry || typeof entry !== "object") continue;
          const meta = entry.meta || {};
          if (!meta.custom) continue;
          const source = asNonEmptyString(meta.source);
          if (!source) continue;
          const label = asNonEmptyString(meta.label) || id;
          out.push({
            id,
            label,
            source,
            objectId: source,
            auto: meta.auto !== false,
            when: meta.when || null,
            config: entry.config,
          });
        }

        out.sort((a, b) => a.id.localeCompare(b.id));
        return out;
      }

      function getPreferredTemplateId(sourceId) {
        const src = asNonEmptyString(sourceId);
        if (!src) return "";
        const store = loadStore();
        return asNonEmptyString(store.preferredBySource?.[src]);
      }

      function setPreferredTemplateId(sourceId, templateId) {
        const src = asNonEmptyString(sourceId);
        const tid = asNonEmptyString(templateId);
        if (!src) return { ok: false, error: "Source id is required." };

        const store = loadStore();
        if (tid) store.preferredBySource[src] = tid;
        else delete store.preferredBySource[src];

        const saved = saveStore(store);
        return { ok: true, store: saved };
      }

      ns.templateDefs = {
        STORAGE_KEY,
        loadStore,
        saveStore,
        getTemplateConfig,
        upsertTemplate,
        deleteTemplate,
        listCustomTemplateEntries,
        getPreferredTemplateId,
        setPreferredTemplateId,
      };
    })(window.AbapFlow);


    </script>
        <script>
    // js/abap_objects/custom_store.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      const STORAGE_KEY = "abapflow-abap-objects-custom";
      const SCHEMA = "abapflow-abap-objects-custom";
      const VERSION = 1;

      function nowIso() {
        if (utils && typeof utils.nowIso === "function") return utils.nowIso();
        return new Date().toISOString();
      }

      function safeParse(jsonText) {
        if (utils && typeof utils.safeJsonParse === "function") return utils.safeJsonParse(jsonText);
        try {
          return { ok: true, value: JSON.parse(String(jsonText || "")) };
        } catch (e) {
          return { ok: false, error: String(e?.message || e) };
        }
      }

      function asNonEmptyString(x) {
        const s = String(x ?? "").trim();
        return s ? s : "";
      }

      function isPlainObject(x) {
        return Boolean(x) && typeof x === "object" && !Array.isArray(x);
      }

      function deepClone(value) {
        if (value == null) return value;

        if (value instanceof RegExp) {
          return new RegExp(value.source, value.flags);
        }

        if (Array.isArray(value)) return value.map((x) => deepClone(x));

        if (typeof value === "object") {
          const out = {};
          for (const [k, v] of Object.entries(value)) out[k] = deepClone(v);
          return out;
        }

        return value;
      }

      function normalizeStore(value) {
        const out = {
          schema: SCHEMA,
          version: VERSION,
          updatedAt: nowIso(),
          objects: {},
          disabled: {},
        };

        if (!isPlainObject(value)) return out;
        if (asNonEmptyString(value.schema) !== SCHEMA) return out;
        const v = Number(value.version);
        if (!Number.isFinite(v) || v <= 0) return out;

        const objects = isPlainObject(value.objects) ? value.objects : {};
        for (const [keyRaw, obj] of Object.entries(objects)) {
          if (!isPlainObject(obj)) continue;
          const id = asNonEmptyString(obj.id) || asNonEmptyString(keyRaw);
          if (!id) continue;
          out.objects[id] = { ...obj, id };
        }

        const disabled = isPlainObject(value.disabled) ? value.disabled : {};
        for (const [keyRaw, flag] of Object.entries(disabled)) {
          const id = asNonEmptyString(keyRaw);
          if (!id) continue;
          if (flag) out.disabled[id] = true;
        }

        out.updatedAt = asNonEmptyString(value.updatedAt) || out.updatedAt;
        return out;
      }

      function loadStore() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return normalizeStore(null);
          const parsed = safeParse(raw);
          if (!parsed.ok) return normalizeStore(null);
          return normalizeStore(parsed.value);
        } catch (_) {
          return normalizeStore(null);
        }
      }

      function saveStore(store) {
        const normalized = normalizeStore(store);
        normalized.updatedAt = nowIso();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(normalized));
        return normalized;
      }

      function clearStore() {
        try {
          localStorage.removeItem(STORAGE_KEY);
        } catch (_) {}
      }

      function upsertObjectDef(objectDef) {
        const obj = isPlainObject(objectDef) ? objectDef : null;
        const id = asNonEmptyString(obj?.id);
        if (!id) return { ok: false, error: "Object id is required." };

        const store = loadStore();
        store.objects[id] = deepClone({ ...obj, id });
        const saved = saveStore(store);
        return { ok: true, store: saved };
      }

      function deleteObjectDef(objectId) {
        const id = asNonEmptyString(objectId);
        if (!id) return { ok: false, error: "Object id is required." };

        const store = loadStore();
        const existed = Boolean(store.objects?.[id]);
        if (existed) delete store.objects[id];
        const saved = saveStore(store);
        return { ok: true, existed, store: saved };
      }

      function setObjectDisabled(objectId, disabled) {
        const id = asNonEmptyString(objectId);
        if (!id) return { ok: false, error: "Object id is required." };

        const store = loadStore();
        if (disabled) store.disabled[id] = true;
        else delete store.disabled[id];
        const saved = saveStore(store);
        return { ok: true, store: saved };
      }

      function exportJson() {
        return JSON.stringify(loadStore(), null, 2);
      }

      function importJson(jsonText, options) {
        const mode = asNonEmptyString(options?.mode).toLowerCase() || "merge";
        const parsed = safeParse(jsonText);
        if (!parsed.ok) return { ok: false, error: parsed.error || "Invalid JSON." };
        const incoming = normalizeStore(parsed.value);

        if (mode === "replace") {
          const saved = saveStore(incoming);
          return { ok: true, store: saved };
        }

        const store = loadStore();
        for (const [id, obj] of Object.entries(incoming.objects || {})) {
          store.objects[id] = deepClone(obj);
        }
        for (const [id, flag] of Object.entries(incoming.disabled || {})) {
          if (flag) store.disabled[id] = true;
        }

        const saved = saveStore(store);
        return { ok: true, store: saved };
      }

      function getEffectiveConfig(masterConfig) {
        const base = isPlainObject(masterConfig) ? masterConfig : {};
        const store = loadStore();

        const out = deepClone(base);
        const baseObjects = Array.isArray(out.objects) ? out.objects : [];

        const byLower = new Map();
        for (let i = 0; i < baseObjects.length; i++) {
          const id = asNonEmptyString(baseObjects[i]?.id);
          if (!id) continue;
          const lower = id.toLowerCase();
          if (!byLower.has(lower)) byLower.set(lower, i);
        }

        const custom = [];
        for (const [id, obj] of Object.entries(store.objects || {})) {
          const oid = asNonEmptyString(obj?.id) || asNonEmptyString(id);
          if (!oid) continue;
          const lower = oid.toLowerCase();
          const cloned = deepClone({ ...(obj || {}), id: oid });
          if (byLower.has(lower)) baseObjects[byLower.get(lower)] = cloned;
          else custom.push(cloned);
        }

        custom.sort((a, b) => asNonEmptyString(a?.id).localeCompare(asNonEmptyString(b?.id)));

        const disabledSet = new Set(
          Object.entries(store.disabled || {})
            .filter(([, flag]) => Boolean(flag))
            .map(([id]) => String(id).trim().toLowerCase())
            .filter(Boolean),
        );

        out.objects = baseObjects
          .concat(custom)
          .filter((obj) => !disabledSet.has(asNonEmptyString(obj?.id).toLowerCase()));

        return { config: out, store };
      }

      ns.abapObjects = ns.abapObjects || {};
      ns.abapObjects.customStore = {
        STORAGE_KEY,
        loadStore,
        saveStore,
        clearStore,
        upsertObjectDef,
        deleteObjectDef,
        setObjectDisabled,
        exportJson,
        importJson,
        getEffectiveConfig,
      };
    })(window.AbapFlow);


    </script>
        <script>
    // abap_objects.config.js
    (function (ns) {
      "use strict";

      // MASTER CONFIG (edit this file to add new ABAP Objects + templates).
      //
      // Design goals:
      // - Add an ABAP Object by declaration (config + optional template file).
      // - Avoid editing multiple JS files when adding new objects.
      //
      // Notes:
      // - This is still a lightweight parser (not a full ABAP compiler).
      // - Regex can be RegExp objects or strings.

      const IDENT = String.raw`[A-Za-z_][A-Za-z0-9_\/]*`;
      const IDENT_PATH = String.raw`${IDENT}(?:(?:[-~]|->|=>)[A-Za-z0-9_\/]+)*`;

      ns.abapObjectsMasterConfig = {
        schema: "abapflow-abap-objects-master-config",
        version: 1,

        // Parser configuration used by `web/js/parser.js`.
        parserConfig: {
          version: 1,

          routineBlocks: [
            // FORM ... ENDFORM.
            {
              kind: "FORM",
              start: /^FORM\b/i,
              end: /^ENDFORM\b/i,
              endRequiresPeriod: true,
              header: {
                name: new RegExp(String.raw`^FORM\s+(${IDENT})\b\s*(.*)$`, "i"),
                clauseOrder: ["TABLES", "USING", "CHANGING", "RAISING"],
                paramIgnoreTokens: ["OPTIONAL", "DEFAULT", "TYPE", "LIKE"],
              },
            },

            // METHOD ... ENDMETHOD.
            {
              kind: "METHOD",
              start: /^METHOD\s+/i,
              end: /^ENDMETHOD\b/i,
              endRequiresPeriod: true,
              header: { name: new RegExp(String.raw`^METHOD\s+(${IDENT})\b`, "i") },
            },

            // FUNCTION ... ENDFUNCTION.
            {
              kind: "FUNCTION",
              start: /^FUNCTION\s+/i,
              end: /^ENDFUNCTION\b/i,
              endRequiresPeriod: true,
              header: { name: new RegExp(String.raw`^FUNCTION\s+(${IDENT})\b`, "i") },
            },

            // MODULE ... ENDMODULE.
            {
              kind: "MODULE",
              start: /^MODULE\s+/i,
              end: /^ENDMODULE\b/i,
              endRequiresPeriod: true,
              header: { name: new RegExp(String.raw`^MODULE\s+(${IDENT})\b`, "i") },
            },
          ],

          events: {
            exact: ["INITIALIZATION", "START-OF-SELECTION", "END-OF-SELECTION", "AT LINE-SELECTION", "AT USER-COMMAND"],
            prefixes: ["AT SELECTION-SCREEN", "TOP-OF-PAGE", "END-OF-PAGE"],
          },

          statements: {
            calls: [
              // PERFORM <subr> [TABLES ...] [USING ...] [CHANGING ...].
              {
                kind: "PERFORM",
                pattern: new RegExp(String.raw`^PERFORM\s+(${IDENT})\b\s*(.*)$`, "i"),
                calleeKind: "FORM",
                clauseOrder: ["TABLES", "USING", "CHANGING"],
              },

              // CALL FUNCTION 'Z_FOO'. (creates a call edge but does not parse EXPORTING/CHANGING mappings)
              {
                kind: "CALL_FUNCTION",
                pattern: /^CALL FUNCTION\s+'([^']+)'/i,
                calleeKind: "FUNCTION",
              },
            ],

            declarations: {
              globalKinds: ["DATA", "CONSTANTS", "PARAMETERS"],
              localKinds: ["DATA", "CONSTANTS"],
              ignorePatterns: {
                DATA: [/^DATA\(/i, /\bBEGIN\s+OF\b/i, /\bEND\s+OF\b/i],
                CONSTANTS: [/\bBEGIN\s+OF\b/i, /\bEND\s+OF\b/i],
              },
            },

            writes: {
              rules: [
                { regex: new RegExp(String.raw`^(${IDENT_PATH})\s*=\s*`) },
                { regex: new RegExp(String.raw`^CLEAR\s+(${IDENT_PATH})\b`, "i") },
                { whenStartsWith: "APPEND", regex: new RegExp(String.raw`\bTO\b\s+(${IDENT_PATH})\b`, "i") },
                { whenStartsWith: "CONCATENATE", regex: new RegExp(String.raw`\bINTO\b\s+(${IDENT_PATH})\b`, "i") },
              ],
            },

            // Legacy: still used for Data Trace. ABAP Objects parsing is handled by `abap_objects/loader.js`.
            assignments: {
              rules: [{ regex: new RegExp(String.raw`^(${IDENT_PATH})\s*=\s*(.+)$`) }],
            },

            // Legacy: still used for indentation heuristics. ABAP Objects parsing is handled by `abap_objects/loader.js`.
            conditionals: {
              rules: [
                { kind: "IF", regex: /^IF\s+(.+)$/i },
                { kind: "ELSEIF", regex: /^ELSEIF\s+(.+)$/i },
              ],
            },
          },
        },

        // ABAP Objects that can be parsed + rendered via templates.
        objects: [
          {
            id: "performCall",
            kind: "callEdge",
            label: "PERFORM",
            match: { toKeyPrefix: "FORM:" },
            builder: { kind: "performCall" },
            templates: [
              {
                id: "perform.excel-like-table",
                label: "PERFORM Excel-like table",
                auto: true,
                file: "js/abap_objects/templates/perform.excel-like-table.js",
              },
            ],
          },

          {
            id: "assignment",
            kind: "statement",
            label: "Assignments (lhs = rhs)",
            parse: { kind: "assignment", continueAfterMatch: true },
            builder: { kind: "assignment" },
            templates: [
              {
                id: "assignment.excel-like-table",
                label: "Assignments Excel-like table",
                auto: true,
                file: "js/abap_objects/templates/assignment.excel-like-table.js",
              },
            ],
          },

          {
            id: "if",
            kind: "statement",
            label: "IF / ELSEIF",
            parse: { kind: "conditional" },
            builder: { kind: "if" },
            templates: [
              {
                id: "if.excel-like-table",
                label: "IF / ELSEIF Excel-like table",
                auto: true,
                file: "js/abap_objects/templates/if.excel-like-table.js",
              },
            ],
          },

          {
            id: "message",
            kind: "statement",
            label: "MESSAGE",
            parse: { kind: "message" },
            builder: { kind: "message" },
            templates: [
              {
                id: "message.excel-like-table",
                label: "MESSAGE Excel-like table",
                auto: true,
                file: "js/abap_objects/templates/message.excel-like-table.js",
              },
            ],
          },

          {
            id: "itabOp",
            kind: "statement",
            label: "READ/COLLECT/MODIFY/DELETE ITAB",
            parse: { kind: "itabOp" },
            builder: { kind: "itabOp" },
            templates: [
              {
                id: "itabRead.excel-like-table",
                label: "READ TABLE Excel-like table",
                auto: true,
                when: { path: "itabOp.kind", equals: "READ" },
                file: "js/abap_objects/templates/itabRead.excel-like-table.js",
              },
              {
                id: "itabCollect.excel-like-table",
                label: "COLLECT Excel-like table",
                auto: true,
                when: { path: "itabOp.kind", equals: "COLLECT" },
                file: "js/abap_objects/templates/itabCollect.excel-like-table.js",
              },
              {
                id: "itabModify.excel-like-table",
                label: "MODIFY ITAB Excel-like table",
                auto: true,
                when: { path: "itabOp.kind", equals: "MODIFY" },
                file: "js/abap_objects/templates/itabModify.excel-like-table.js",
              },
              {
                id: "itabDelete.excel-like-table",
                label: "DELETE ITAB Excel-like table",
                auto: true,
                when: { path: "itabOp.kind", equals: "DELETE" },
                file: "js/abap_objects/templates/itabDelete.excel-like-table.js",
              },
            ],
          },

          {
            id: "append",
            kind: "statement",
            label: "APPEND",
            parse: {
              kind: "regex",
              regex: /^APPEND\s+(.+?)\s+TO\s+(.+?)(?=\s+SORTED\s+BY\b|\s+(?:ASSIGNING|REFERENCE|INTO)\b|$)(?:\s+SORTED\s+BY\s+(.+?)(?=\s+(?:ASSIGNING|REFERENCE|INTO)\b|$))?(?:\s+(.*))?$/i,
              fields: { line: 1, itab: 2, sortedBy: 3, result: 4 },
            },
            builder: { kind: "append" },
            templates: [
              {
                id: "append.excel-like-table",
                label: "APPEND Excel-like table",
                auto: true,
                file: "js/abap_objects/templates/append.excel-like-table.js",
              },
            ],
          },
        ],
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/abap_objects/schema.js
    (function (ns) {
      "use strict";

      function isPlainObject(x) {
        return Boolean(x) && typeof x === "object" && !Array.isArray(x);
      }

      function asNonEmptyString(x) {
        const s = String(x ?? "").trim();
        return s ? s : "";
      }

      function pushErr(errors, path, message) {
        errors.push({ path: String(path || ""), message: String(message || "Invalid value") });
      }

      function validateTemplateEntry(tpl, path, errors) {
        if (!isPlainObject(tpl)) {
          pushErr(errors, path, "Template must be an object.");
          return;
        }
        const id = asNonEmptyString(tpl.id);
        if (!id) pushErr(errors, `${path}.id`, "Template id is required.");

        const label = asNonEmptyString(tpl.label);
        if (!label) pushErr(errors, `${path}.label`, "Template label is required.");

        if (tpl.file != null && typeof tpl.file !== "string") {
          pushErr(errors, `${path}.file`, "Template file path must be a string.");
        }

        if (tpl.auto != null && typeof tpl.auto !== "boolean") {
          pushErr(errors, `${path}.auto`, "Template auto must be boolean.");
        }
      }

      function validateObjectDef(obj, index, errors) {
        const path = `objects[${index}]`;
        if (!isPlainObject(obj)) {
          pushErr(errors, path, "Object must be an object.");
          return;
        }

        const id = asNonEmptyString(obj.id);
        if (!id) pushErr(errors, `${path}.id`, "Object id is required.");

        const kind = asNonEmptyString(obj.kind).toLowerCase();
        if (!kind || !["statement", "calledge"].includes(kind)) {
          pushErr(errors, `${path}.kind`, "Object kind must be 'statement' or 'callEdge'.");
        }

        const builderKind = asNonEmptyString(obj?.builder?.kind);
        if (!builderKind) pushErr(errors, `${path}.builder.kind`, "Builder kind is required.");

        if (kind === "statement") {
          const parseKind = asNonEmptyString(obj?.parse?.kind).toLowerCase();
          if (!parseKind) pushErr(errors, `${path}.parse.kind`, "Parse kind is required for statement objects.");

          if (parseKind === "regex") {
            const rx = obj?.parse?.regex;
            const isRe = rx instanceof RegExp;
            const isStr = typeof rx === "string" && asNonEmptyString(rx);
            if (!isRe && !isStr) {
              pushErr(errors, `${path}.parse.regex`, "parse.regex must be a RegExp or a non-empty pattern string.");
            }

            if (obj?.parse?.flags != null && typeof obj.parse.flags !== "string") {
              pushErr(errors, `${path}.parse.flags`, "parse.flags must be a string.");
            }

            if (obj?.parse?.fields != null && !isPlainObject(obj.parse.fields)) {
              pushErr(errors, `${path}.parse.fields`, "parse.fields must be an object.");
            } else if (isPlainObject(obj?.parse?.fields)) {
              for (const [k, v] of Object.entries(obj.parse.fields)) {
                const n = Number(v);
                if (!asNonEmptyString(k)) continue;
                if (!Number.isFinite(n) || n < 0) pushErr(errors, `${path}.parse.fields.${k}`, "Field index must be a number >= 0.");
              }
            }
          }
        }

        if (kind === "calledge") {
          const toKeyPrefix = asNonEmptyString(obj?.match?.toKeyPrefix);
          if (!toKeyPrefix) pushErr(errors, `${path}.match.toKeyPrefix`, "match.toKeyPrefix is required for callEdge objects.");
        }

        if (obj.templates != null) {
          if (!Array.isArray(obj.templates)) {
            pushErr(errors, `${path}.templates`, "templates must be an array.");
          } else {
            for (let i = 0; i < obj.templates.length; i++) {
              validateTemplateEntry(obj.templates[i], `${path}.templates[${i}]`, errors);
            }
          }
        }
      }

      function validateMasterConfig(config) {
        const errors = [];

        if (!isPlainObject(config)) {
          pushErr(errors, "", "Config must be an object.");
          return { ok: false, errors };
        }

        const schema = asNonEmptyString(config.schema);
        if (!schema) pushErr(errors, "schema", "schema is required.");

        const version = Number(config.version);
        if (!Number.isFinite(version) || version <= 0) pushErr(errors, "version", "version must be a positive number.");

        if (config.parserConfig != null && !isPlainObject(config.parserConfig)) {
          pushErr(errors, "parserConfig", "parserConfig must be an object.");
        }

        if (!Array.isArray(config.objects)) {
          pushErr(errors, "objects", "objects must be an array.");
        } else {
          const seen = new Set();
          for (let i = 0; i < config.objects.length; i++) {
            const id = asNonEmptyString(config.objects?.[i]?.id);
            if (id) {
              const lower = id.toLowerCase();
              if (seen.has(lower)) pushErr(errors, `objects[${i}].id`, `Duplicate object id: ${id}`);
              else seen.add(lower);
            }
            validateObjectDef(config.objects[i], i, errors);
          }
        }

        return { ok: errors.length === 0, errors };
      }

      ns.abapObjects = ns.abapObjects || {};
      ns.abapObjects.schema = {
        validateMasterConfig,
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/abap_objects/parsers.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;
      const { AbapAssignment, AbapIfStatement, AbapMessageStatement, AbapItabOperation } = ns.model || {};

      function asRegex(value, flags) {
        if (!value) return null;
        if (value instanceof RegExp) return value;
        if (typeof value === "string") return new RegExp(value, flags || "i");
        return null;
      }

      function regexExec(re, text) {
        if (!re) return null;
        re.lastIndex = 0;
        return re.exec(text);
      }

      function splitTokensOutsideStrings(text) {
        const s = String(text ?? "");
        const tokens = [];
        let buf = "";
        let inString = false;
        let inTemplate = false;

        for (let i = 0; i < s.length; i++) {
          const ch = s[i];

          if (ch === "'" && !inTemplate) {
            buf += ch;
            if (inString) {
              if (i + 1 < s.length && s[i + 1] === "'") {
                buf += s[i + 1];
                i++;
              } else {
                inString = false;
              }
            } else {
              inString = true;
            }
            continue;
          }

          if (!inString && ch === "|") {
            buf += ch;
            inTemplate = !inTemplate;
            continue;
          }

          if (!inString && !inTemplate && /\s/.test(ch)) {
            const t = buf.trim();
            if (t) tokens.push(t);
            buf = "";
            continue;
          }

          buf += ch;
        }

        const last = buf.trim();
        if (last) tokens.push(last);
        return tokens;
      }

      function normalizeStatement(stmtText) {
        return utils.normalizeSpaces(utils.stripTrailingPeriod(String(stmtText ?? "")));
      }

      function parseAssignmentStatement(stmtText, sourceRef, cfg) {
        if (!AbapAssignment) return null;
        const statement = normalizeStatement(stmtText);
        if (!statement) return null;

        const rules = Array.isArray(cfg?.statements?.assignments?.rules) ? cfg.statements.assignments.rules : [];
        for (const rule of rules) {
          const re = asRegex(rule?.regex, rule?.flags);
          const m = regexExec(re, statement);
          if (!m) continue;
          const lhs = String(m[1] || "").trim();
          const rhs = String(m[2] || "").trim();
          if (!lhs || !rhs) continue;
          return new AbapAssignment(lhs, rhs, statement, sourceRef);
        }
        return null;
      }

      function parseConditionalStatement(stmtText, sourceRef, cfg) {
        if (!AbapIfStatement) return null;
        const statement = normalizeStatement(stmtText);
        if (!statement) return null;

        const rules = Array.isArray(cfg?.statements?.conditionals?.rules) ? cfg.statements.conditionals.rules : [];
        for (const rule of rules) {
          const re = asRegex(rule?.regex, rule?.flags);
          const m = regexExec(re, statement);
          if (!m) continue;
          const kind = String(rule?.kind || "").trim().toUpperCase() || "IF";
          const condition = String(m[1] || "").trim();
          if (!condition) continue;
          return new AbapIfStatement(kind, condition, sourceRef);
        }
        return null;
      }

      function parseMessageStatement(stmtText, sourceRef, cfg) {
        if (!AbapMessageStatement) return null;
        const statement = normalizeStatement(stmtText);
        const tokens = splitTokensOutsideStrings(statement);
        if (tokens.length < 2) return null;
        if (String(tokens[0] || "").toUpperCase() !== "MESSAGE") return null;

        const opts = cfg?.statements?.messages;
        if (opts && opts.enabled === false) return null;

        let idx = 1;
        let msgType = "";
        let msgClass = "";
        let msgNo = "";
        let text = "";

        const t1 = String(tokens[idx] || "").trim();
        const t1u = t1.toUpperCase();

        if (t1u === "ID") {
          msgClass = String(tokens[idx + 1] || "").trim();
          idx += 2;

          while (idx < tokens.length) {
            const u = String(tokens[idx] || "").toUpperCase();
            if (u === "WITH" || u === "DISPLAY" || u === "RAISING" || u === "INTO") break;
            if (u === "TYPE" && idx + 1 < tokens.length) {
              msgType = String(tokens[idx + 1] || "").trim();
              idx += 2;
              continue;
            }
            if (u === "NUMBER" && idx + 1 < tokens.length) {
              msgNo = String(tokens[idx + 1] || "").trim();
              idx += 2;
              continue;
            }
            idx++;
          }
        } else {
          const m = /^([A-Za-z])(\d+)\(([^)]+)\)$/.exec(t1);
          if (m) {
            msgType = String(m[1] || "").trim();
            msgNo = String(m[2] || "").trim();
            msgClass = String(m[3] || "").trim();
            idx += 1;
          } else {
            const parts = [];
            while (idx < tokens.length) {
              const u = String(tokens[idx] || "").toUpperCase();
              if (u === "WITH" || u === "DISPLAY" || u === "RAISING" || u === "INTO") break;
              parts.push(tokens[idx]);
              idx++;
            }
            text = parts.join(" ").trim();
          }
        }

        let displayLike = "";
        let into = "";
        let raising = "";
        const withArgs = [];

        while (idx < tokens.length) {
          const u = String(tokens[idx] || "").toUpperCase();

          if (u === "DISPLAY" && String(tokens[idx + 1] || "").toUpperCase() === "LIKE") {
            displayLike = String(tokens[idx + 2] || "").trim();
            idx += 3;
            continue;
          }

          if (u === "WITH") {
            idx += 1;
            while (idx < tokens.length && withArgs.length < 4) {
              const peek = String(tokens[idx] || "").toUpperCase();
              if (peek === "DISPLAY" || peek === "RAISING" || peek === "INTO") break;
              withArgs.push(String(tokens[idx] || "").trim());
              idx++;
            }
            continue;
          }

          if (u === "INTO") {
            into = String(tokens[idx + 1] || "").trim();
            idx += 2;
            continue;
          }

          if (u === "RAISING") {
            raising = String(tokens[idx + 1] || "").trim();
            idx += 2;
            continue;
          }

          idx += 1;
        }

        return new AbapMessageStatement({
          msgType,
          msgClass,
          msgNo,
          text,
          displayLike,
          with: withArgs,
          into,
          raising,
          statement,
          sourceRef,
        });
      }

      function parseItabOperation(stmtText, sourceRef, cfg) {
        if (!AbapItabOperation) return null;
        const statement = normalizeStatement(stmtText);
        const tokens = splitTokensOutsideStrings(statement);
        if (tokens.length < 2) return null;

        const opts = cfg?.statements?.itabOps;
        if (opts && opts.enabled === false) return null;

        const head = String(tokens[0] || "").toUpperCase();

        function joinFrom(startIndex, stopSet) {
          const parts = [];
          let i = startIndex;
          for (; i < tokens.length; i++) {
            const u = String(tokens[i] || "").toUpperCase();
            if (stopSet.has(u)) break;
            parts.push(tokens[i]);
          }
          return { text: parts.join(" ").trim(), next: i };
        }

        if (head === "READ" && String(tokens[1] || "").toUpperCase() === "TABLE") {
          const table = String(tokens[2] || "").trim();
          if (!table) return null;

          let target = "";
          let conditionText = "";
          let conditionKind = "";
          let binarySearch = false;

          for (let i = 3; i < tokens.length; i++) {
            const u = String(tokens[i] || "").toUpperCase();

            if (u === "BINARY" && String(tokens[i + 1] || "").toUpperCase() === "SEARCH") {
              binarySearch = true;
              i += 1;
              continue;
            }

            if (u === "INTO" && !target) {
              target = String(tokens[i + 1] || "").trim();
              continue;
            }

            if (u === "ASSIGNING" && !target) {
              target = String(tokens[i + 1] || "").trim();
              continue;
            }

            if (u === "REFERENCE" && String(tokens[i + 1] || "").toUpperCase() === "INTO" && !target) {
              target = String(tokens[i + 2] || "").trim();
              continue;
            }

            if (u === "INDEX" && !conditionText) {
              conditionKind = "index";
              conditionText = String(tokens[i + 1] || "").trim();
              continue;
            }

            if (u === "WITH" && !conditionText) {
              const next = String(tokens[i + 1] || "").toUpperCase();
              const next2 = String(tokens[i + 2] || "").toUpperCase();
              let start = -1;
              if (next === "KEY") start = i + 2;
              else if (next === "TABLE" && next2 === "KEY") start = i + 3;

              if (start >= 0) {
                const stop = new Set(["BINARY", "INTO", "ASSIGNING", "TRANSPORTING", "REFERENCE", "COMPARING"]);
                const collected = joinFrom(start, stop);
                conditionKind = "key";
                conditionText = collected.text;
              }
              continue;
            }

            if (u === "FROM" && !conditionText) {
              conditionKind = "from";
              conditionText = String(tokens[i + 1] || "").trim();
              continue;
            }
          }

          return new AbapItabOperation("READ", { table, target, conditionText, conditionKind, binarySearch, statement }, sourceRef);
        }

        if (head === "COLLECT") {
          const intoIdx = tokens.findIndex((t) => String(t || "").toUpperCase() === "INTO");
          if (intoIdx < 0 || intoIdx + 1 >= tokens.length) return null;

          const target = tokens.slice(1, intoIdx).join(" ").trim();
          const table = String(tokens[intoIdx + 1] || "").trim();
          if (!table) return null;

          return new AbapItabOperation("COLLECT", { table, target, conditionText: "", conditionKind: "", binarySearch: false, statement }, sourceRef);
        }

        if (head === "MODIFY") {
          let idx = 1;
          if (String(tokens[idx] || "").toUpperCase() === "TABLE") idx++;
          const table = String(tokens[idx] || "").trim();
          if (!table) return null;

          let target = "";
          let conditionText = "";
          let conditionKind = "";

          for (let i = idx + 1; i < tokens.length; i++) {
            const u = String(tokens[i] || "").toUpperCase();
            if (u === "FROM" && !target) {
              const stop = new Set(["TRANSPORTING", "WHERE", "INDEX"]);
              target = joinFrom(i + 1, stop).text;
              continue;
            }
            if (u === "WHERE" && !conditionText) {
              conditionKind = "where";
              conditionText = tokens.slice(i + 1).join(" ").trim();
              break;
            }
            if (u === "INDEX" && !conditionText) {
              conditionKind = "index";
              conditionText = String(tokens[i + 1] || "").trim();
              continue;
            }
          }

          return new AbapItabOperation("MODIFY", { table, target, conditionText, conditionKind, binarySearch: false, statement }, sourceRef);
        }

        if (head === "DELETE") {
          let idx = 1;
          if (String(tokens[idx] || "").toUpperCase() === "TABLE") idx++;
          if (String(tokens[idx] || "").toUpperCase() === "ADJACENT") return null;
          const table = String(tokens[idx] || "").trim();
          if (!table) return null;

          let target = "";
          let conditionText = "";
          let conditionKind = "";

          for (let i = idx + 1; i < tokens.length; i++) {
            const u = String(tokens[i] || "").toUpperCase();
            if (u === "FROM" && !target) {
              const stop = new Set(["WHERE", "INDEX", "USING", "KEY"]);
              target = joinFrom(i + 1, stop).text;
              continue;
            }
            if (u === "WHERE" && !conditionText) {
              conditionKind = "where";
              conditionText = tokens.slice(i + 1).join(" ").trim();
              break;
            }
            if (u === "INDEX" && !conditionText) {
              conditionKind = "index";
              conditionText = String(tokens[i + 1] || "").trim();
              continue;
            }
            if (u === "WITH" && !conditionText) {
              const next = String(tokens[i + 1] || "").toUpperCase();
              const next2 = String(tokens[i + 2] || "").toUpperCase();
              let start = -1;
              if (next === "KEY") start = i + 2;
              else if (next === "TABLE" && next2 === "KEY") start = i + 3;
              if (start >= 0) {
                conditionKind = "key";
                conditionText = tokens.slice(start).join(" ").trim();
                break;
              }
            }
          }

          return new AbapItabOperation("DELETE", { table, target, conditionText, conditionKind, binarySearch: false, statement }, sourceRef);
        }

        return null;
      }

      function parseRegexStatement(stmtText, sourceRef, parseSpec) {
        const statement = normalizeStatement(stmtText);
        if (!statement) return null;

        const re = asRegex(parseSpec?.regex, parseSpec?.flags);
        const m = regexExec(re, statement);
        if (!m) return null;

        const fields = parseSpec?.fields && typeof parseSpec.fields === "object" ? parseSpec.fields : null;
        const out = { statement, sourceRef };
        if (!fields) return out;

        for (const [key, idx] of Object.entries(fields)) {
          const n = Number(idx);
          if (!Number.isFinite(n) || n < 0) continue;
          out[String(key)] = String(m[n] ?? "").trim();
        }
        return out;
      }

      ns.abapObjects = ns.abapObjects || {};
      ns.abapObjects.parsers = {
        splitTokensOutsideStrings,
        normalizeStatement,
        parseAssignmentStatement,
        parseConditionalStatement,
        parseMessageStatement,
        parseItabOperation,
        parseRegexStatement,
      };
    })(window.AbapFlow);


    </script>
        <script>
    // js/abap_objects/loader.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      ns.abapObjects = ns.abapObjects || {};
      const schema = ns.abapObjects.schema;
      const parsers = ns.abapObjects.parsers;

      const state = {
        readyPromise: null,
        config: null,
        templatesById: new Map(),
        registry: null,
      };

      function asNonEmptyString(x) {
        const s = String(x ?? "").trim();
        return s ? s : "";
      }

      function deepCloneJson(value) {
        return deepClone(value);
      }

      function deepClone(value) {
        if (value == null) return value;

        if (value instanceof RegExp) {
          return new RegExp(value.source, value.flags);
        }

        if (Array.isArray(value)) {
          return value.map((x) => deepClone(x));
        }

        if (typeof value === "object") {
          const out = {};
          for (const [k, v] of Object.entries(value)) out[k] = deepClone(v);
          return out;
        }

        return value;
      }

      function formatSchemaErrors(errors) {
        const list = Array.isArray(errors) ? errors : [];
        if (!list.length) return "Invalid config.";
        return list.map((e) => `${e.path || "(root)"}: ${e.message || "Invalid value"}`).join("\n");
      }

      function defaultLoadScript(url) {
        return new Promise((resolve, reject) => {
          if (typeof document === "undefined") {
            reject(new Error("No DOM available to load scripts."));
            return;
          }
          const src = String(url || "").trim();
          if (!src) {
            reject(new Error("Empty script url."));
            return;
          }

          const el = document.createElement("script");
          el.src = src;
          el.async = false;
          el.onload = () => resolve(true);
          el.onerror = () => reject(new Error(`Failed to load script: ${src}`));
          document.head.appendChild(el);
        });
      }

      function defineTemplate(id, config) {
        const tid = asNonEmptyString(id);
        if (!tid) return;
        state.templatesById.set(tid, config || {});
      }

      function getTemplateConfig(id) {
        const tid = asNonEmptyString(id);
        return tid ? state.templatesById.get(tid) || null : null;
      }

      function compileObjectDefs(config) {
        const objects = Array.isArray(config?.objects) ? config.objects : [];

        const objectsById = new Map();
        const statementObjects = [];
        const callEdgeObjects = [];
        const templates = [];

        for (const obj of objects) {
          const id = asNonEmptyString(obj?.id);
          if (!id) continue;
          const kind = asNonEmptyString(obj?.kind).toLowerCase();
          const label = asNonEmptyString(obj?.label) || id;

          const def = {
            id,
            kind,
            label,
            parse: obj?.parse || null,
            match: obj?.match || null,
            builder: obj?.builder || null,
            templates: Array.isArray(obj?.templates) ? obj.templates : [],
          };
          objectsById.set(id, def);

          if (kind === "statement") statementObjects.push(def);
          if (kind === "calledge") callEdgeObjects.push(def);

          for (const t of def.templates) {
            const tid = asNonEmptyString(t?.id);
            if (!tid) continue;
            templates.push({
              id: tid,
              label: asNonEmptyString(t?.label) || tid,
              objectId: id,
              source: id,
              auto: t?.auto !== false,
              when: t?.when || null,
              file: asNonEmptyString(t?.file),
            });
          }
        }

        return { objectsById, statementObjects, callEdgeObjects, templates };
      }

      function parseStatementByObject(def, stmtText, sourceRef, cfg) {
        const kind = asNonEmptyString(def?.parse?.kind).toLowerCase();
        if (!kind) return null;

        if (kind === "assignment") return parsers.parseAssignmentStatement(stmtText, sourceRef, cfg);
        if (kind === "conditional") return parsers.parseConditionalStatement(stmtText, sourceRef, cfg);
        if (kind === "message") return parsers.parseMessageStatement(stmtText, sourceRef, cfg);
        if (kind === "itabop") return parsers.parseItabOperation(stmtText, sourceRef, cfg);
        if (kind === "regex") return parsers.parseRegexStatement(stmtText, sourceRef, def.parse);

        return null;
      }

      function buildContext(def, model, routine, payload, options) {
        const kind = asNonEmptyString(def?.builder?.kind).toLowerCase();
        const tc = ns.templateConverter;
        if (!tc) return null;

        if (kind === "performcall") return tc.buildPerformContext(model, payload, options);
        if (kind === "assignment") return tc.buildAssignmentContext(model, routine, payload, options);
        if (kind === "if") return tc.buildIfContext(model, routine, payload, options);
        if (kind === "message") return tc.buildMessageContext(model, routine, payload, options);
        if (kind === "itabop") return tc.buildItabOpContext(model, routine, payload, options);
        if (kind === "append") return tc.buildAppendContext(model, routine, payload, options);

        if (kind === "mapping") return buildContextByMapping(model, routine, payload, def, options);
        return null;
      }

      function describeExprWithOrigin(model, routineKey, exprText, options) {
        const text = String(exprText ?? "").trim();
        if (!text) return { text: "", originKey: "" };
        if (ns.desc?.describeExpressionWithOrigin) return ns.desc.describeExpressionWithOrigin(model, routineKey, text, options);
        return { text, originKey: "" };
      }

      function buildExprNode(model, routineKey, exprText, options) {
        const text = String(exprText ?? "").trim();
        if (!text) return { text: "", description: "", originKey: "" };
        const described = describeExprWithOrigin(model, routineKey, text, options);
        return {
          text,
          description: String(described.text || "").trim() || text,
          originKey: String(described.originKey || ""),
        };
      }

      function buildContextByMapping(model, routine, payload, def, options) {
        const routineKey = String(routine?.key || "");
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;
        const mapping = def?.builder?.fields && typeof def.builder.fields === "object" ? def.builder.fields : {};

        function splitExprList(text) {
          const s = String(text ?? "").trim();
          if (!s) return [];
          const tokenize =
            parsers && typeof parsers.splitTokensOutsideStrings === "function"
              ? parsers.splitTokensOutsideStrings
              : (x) => String(x || "").split(/\s+/).filter(Boolean);

          const tokens = tokenize(s);
          const out = [];
          for (let i = 0; i < tokens.length; i++) {
            const t = String(tokens[i] || "");
            const tUpper = t.toUpperCase();
            const n1 = tokens[i + 1];
            const n2 = tokens[i + 2];

            if (tUpper === "LINES" && String(n1 || "").toUpperCase() === "OF" && n2 != null) {
              out.push(`LINES OF ${String(n2)}`.trim());
              i += 2;
              continue;
            }

            out.push(t);
          }
          return out.filter(Boolean);
        }

        const ctx = {
          routine: { key: routineKey, kind: String(routine?.kind || ""), name: String(routine?.name || "") },
          object: { id: String(def?.id || ""), label: String(def?.label || ""), statement: String(payload?.statement || payload?.raw || "") },
        };

        for (const [outKey, spec] of Object.entries(mapping)) {
          const t = String(spec?.type || "expr").trim().toLowerCase();
          const from = String(spec?.from || "").trim();
          const raw = from && payload && typeof payload === "object" ? payload[from] : "";

          if (t === "text") {
            ctx[outKey] = String(raw ?? "");
            continue;
          }

          if (t === "exprlist") {
            const list = Array.isArray(raw) ? raw : splitExprList(raw);
            ctx[outKey] = list.map((x) => buildExprNode(model, routineKey, x, { callPath }));
            continue;
          }

          ctx[outKey] = buildExprNode(model, routineKey, raw, { callPath });
        }

        const pairs = [];
        for (const [outKey, spec] of Object.entries(mapping)) {
          const t = String(spec?.type || "expr").trim().toLowerCase();
          const keyword = asNonEmptyString(spec?.label) || asNonEmptyString(outKey);
          if (!keyword) continue;

          if (t === "exprlist") {
            const list = Array.isArray(ctx[outKey]) ? ctx[outKey] : [];
            for (let i = 0; i < list.length; i++) {
              const node = list[i];
              const text = asNonEmptyString(node?.text) || asNonEmptyString(node?.description);
              if (!text) continue;
              pairs.push({ keyword: i === 0 ? keyword : "", value: node });
            }
            continue;
          }

          if (t === "text") {
            const raw = asNonEmptyString(ctx[outKey]);
            if (!raw) continue;
            if (spec?.presentOnly) {
              pairs.push({ keyword, value: { text: "", description: "", originKey: "" } });
            } else {
              pairs.push({ keyword, value: { text: raw, description: raw, originKey: "" } });
            }
            continue;
          }

          const node = ctx[outKey];
          const text = asNonEmptyString(node?.text) || asNonEmptyString(node?.description);
          if (!text) continue;
          pairs.push({ keyword, value: node });
        }

        ctx.pairs = pairs;
        return ctx;
      }

      function installTemplateRegistry(templates) {
        ns.templateRegistry = ns.templateRegistry || { templates: {}, order: [] };
        ns.templateRegistry.templates = ns.templateRegistry.templates || {};
        ns.templateRegistry.order = Array.isArray(ns.templateRegistry.order) ? ns.templateRegistry.order : [];

        ns.templateRegistry.templates = {};
        ns.templateRegistry.order = [];

        for (const t of templates) {
          const cfg = getTemplateConfig(t.id);
          if (!cfg) continue;
          ns.templateRegistry.templates[t.id] = {
            id: t.id,
            label: t.label,
            source: t.source,
            auto: t.auto !== false,
            objectId: t.objectId,
            when: t.when || null,
            config: cfg,
          };
          ns.templateRegistry.order.push(t.id);
        }
      }

      function init(options) {
        if (state.readyPromise) return state.readyPromise;

        state.readyPromise = (async () => {
          if (!schema?.validateMasterConfig) throw new Error("ABAP Objects schema module not loaded.");
          if (!parsers) throw new Error("ABAP Objects parsers module not loaded.");

          let config = options?.config || ns.abapObjectsMasterConfig;
          if (!options?.config) {
            const customStore = ns.abapObjects?.customStore || null;
            if (customStore && typeof customStore.getEffectiveConfig === "function") {
              config = customStore.getEffectiveConfig(config)?.config || config;
            }
          }
          const validation = schema.validateMasterConfig(config);
          if (!validation.ok) {
            throw new Error(formatSchemaErrors(validation.errors));
          }

          state.config = config;

          if (config?.parserConfig && typeof config.parserConfig === "object") {
            ns.parserConfig = deepCloneJson(config.parserConfig);
          }

          const compiled = compileObjectDefs(config);
          state.registry = {
            ...compiled,
            parseStatementItems(model, routine, statementText, sourceRef, cfg) {
              const out = [];
              for (const objDef of compiled.statementObjects) {
                const parsed = parseStatementByObject(objDef, statementText, sourceRef, cfg);
                if (!parsed) continue;
                out.push({
                  objectId: objDef.id,
                  kind: "statement",
                  payload: parsed,
                  sourceRef: parsed?.sourceRef || sourceRef || null,
                  continueAfterMatch: Boolean(objDef?.parse?.continueAfterMatch),
                });
                if (!objDef?.parse?.continueAfterMatch) break;
              }
              return out;
            },
            matchCallEdge(edge) {
              const toKey = String(edge?.toKey || "");
              for (const objDef of compiled.callEdgeObjects) {
                const prefix = asNonEmptyString(objDef?.match?.toKeyPrefix);
                if (prefix && toKey.toUpperCase().startsWith(prefix.toUpperCase())) return objDef;
              }
              return null;
            },
            buildContext,
          };

          const loadScript = typeof options?.loadScript === "function" ? options.loadScript : defaultLoadScript;

          const filesToLoad = compiled.templates.map((t) => t.file).filter(Boolean);
          const uniqueFiles = Array.from(new Set(filesToLoad));
          for (const file of uniqueFiles) await loadScript(file);

          const templateDefs = ns.templateDefs || null;
          if (templateDefs && typeof templateDefs.getTemplateConfig === "function") {
            for (const t of compiled.templates) {
              const override = templateDefs.getTemplateConfig(t.id);
              if (override) defineTemplate(t.id, override);
            }
          }

          for (const t of compiled.templates) {
            if (!getTemplateConfig(t.id)) throw new Error(`Template not registered: ${t.id} (${t.file})`);
          }

          let templatesForRegistry = compiled.templates;

          if (templateDefs && typeof templateDefs.listCustomTemplateEntries === "function") {
            const custom = templateDefs.listCustomTemplateEntries();
            const seen = new Set(compiled.templates.map((t) => String(t?.id || "").trim().toLowerCase()).filter(Boolean));

            const merged = [];
            for (const t of custom) {
              const id = asNonEmptyString(t?.id).toLowerCase();
              if (!id || seen.has(id)) continue;
              if (t?.config) defineTemplate(t.id, t.config);
              merged.push({
                id: asNonEmptyString(t.id),
                label: asNonEmptyString(t.label) || asNonEmptyString(t.id),
                objectId: asNonEmptyString(t.objectId) || asNonEmptyString(t.source),
                source: asNonEmptyString(t.source),
                auto: t.auto !== false,
                when: t.when || null,
                file: "",
              });
            }

            templatesForRegistry = merged.concat(compiled.templates);
          }

          installTemplateRegistry(templatesForRegistry);
          return state.registry;
        })();

        return state.readyPromise;
      }

      function whenReady() {
        return init();
      }

      function reset() {
        state.readyPromise = null;
        state.config = null;
        state.registry = null;
        state.templatesById.clear();
      }

      ns.abapObjects.defineTemplate = defineTemplate;
      ns.abapObjects.getTemplateConfig = getTemplateConfig;
      ns.abapObjects.init = init;
      ns.abapObjects.whenReady = whenReady;
      ns.abapObjects.getRegistry = () => state.registry;
      ns.abapObjects.getConfig = () => state.config;
      ns.abapObjects.reset = reset;
    })(window.AbapFlow);

    </script>
        <script>
    // js/table_renderer.js
    (function (ns) {
      "use strict";

      function normalizeAddress(addr) {
        const s = String(addr || "").trim().toUpperCase();
        const m = /^([A-Z]+)(\d+)$/.exec(s);
        if (!m) return "";
        return `${m[1]}${Number(m[2])}`;
      }

      function colToIndex(colLetters) {
        const s = String(colLetters || "").trim().toUpperCase();
        if (!/^[A-Z]+$/.test(s)) return 0;
        let n = 0;
        for (let i = 0; i < s.length; i++) {
          n = n * 26 + (s.charCodeAt(i) - 64);
        }
        return n;
      }

      function indexToCol(index1) {
        let n = Number(index1);
        if (!Number.isFinite(n) || n <= 0) return "";
        n = Math.floor(n);
        let s = "";
        while (n > 0) {
          const rem = (n - 1) % 26;
          s = String.fromCharCode(65 + rem) + s;
          n = Math.floor((n - 1) / 26);
        }
        return s;
      }

      function parseAddress(addr) {
        const s = String(addr || "").trim().toUpperCase();
        const m = /^([A-Z]+)(\d+)$/.exec(s);
        if (!m) return null;
        const col = colToIndex(m[1]);
        const row = Number(m[2]);
        if (!Number.isFinite(col) || !Number.isFinite(row) || col <= 0 || row <= 0) return null;
        return { col, row };
      }

      function addrFromRC(col1, row1) {
        return `${indexToCol(col1)}${row1}`;
      }

      function cssTextForClasses(css, classes) {
        if (!css || typeof css !== "object") return "";
        if (!Array.isArray(classes)) return "";
        let out = "";
        for (const cls of classes) {
          const rule = css[String(cls || "").trim()];
          if (!rule) continue;
          const t = String(rule).trim();
          if (!t) continue;
          out += t.endsWith(";") ? t : `${t};`;
        }
        return out;
      }

      function buildColumnWidths(config, cols) {
        const explicit = new Map();
        const colWidths = config?.grid?.colWidths && typeof config.grid.colWidths === "object" ? config.grid.colWidths : {};

        for (const [key, value] of Object.entries(colWidths)) {
          const idx = colToIndex(key);
          const w = Number(value);
          if (!idx || idx > cols || !Number.isFinite(w) || w <= 0) continue;
          explicit.set(idx, w);
        }

        const widths = new Map(explicit);

        const merges = Array.isArray(config?.merges) ? config.merges : [];
        for (const merge of merges) {
          const start = parseAddress(merge?.start);
          if (!start) continue;
          const colspan = Number(merge?.colspan || 1);
          if (!Number.isFinite(colspan) || colspan < 2) continue;

          const startCol = start.col;
          const endCol = Math.min(cols, startCol + colspan - 1);
          const total = explicit.get(startCol);
          if (!Number.isFinite(total)) continue;

          let hasOtherExplicit = false;
          for (let c = startCol + 1; c <= endCol; c++) {
            if (explicit.has(c)) {
              hasOtherExplicit = true;
              break;
            }
          }
          if (hasOtherExplicit) continue;

          const each = total / (endCol - startCol + 1);
          for (let c = startCol; c <= endCol; c++) widths.set(c, each);
        }

        const fallback = Number(config?.grid?.defaultColWidth);
        const defaultColWidth = Number.isFinite(fallback) && fallback > 0 ? fallback : 40;
        for (let c = 1; c <= cols; c++) {
          if (!widths.has(c)) widths.set(c, defaultColWidth);
        }
        return widths;
      }

      function buildRowHeights(config, rows) {
        const rowHeights = config?.grid?.rowHeights && typeof config.grid.rowHeights === "object" ? config.grid.rowHeights : {};
        const heights = new Map();
        for (const [key, value] of Object.entries(rowHeights)) {
          const r = Number(key);
          const h = Number(value);
          if (!Number.isFinite(r) || !Number.isFinite(h) || r <= 0 || h <= 0) continue;
          heights.set(r, h);
        }

        const fallback = Number(config?.grid?.defaultRowHeight);
        const defaultRowHeight = Number.isFinite(fallback) && fallback > 0 ? fallback : 30;
        for (let r = 1; r <= rows; r++) {
          if (!heights.has(r)) heights.set(r, defaultRowHeight);
        }
        return heights;
      }

      function buildMergeMaps(config, rows, cols) {
        const skip = new Set();
        const startMap = new Map();
        const merges = Array.isArray(config?.merges) ? config.merges : [];

        for (const merge of merges) {
          const start = parseAddress(merge?.start);
          if (!start) continue;
          const rowspan = Math.max(1, Math.floor(Number(merge?.rowspan || 1)));
          const colspan = Math.max(1, Math.floor(Number(merge?.colspan || 1)));
          const startRow = start.row;
          const startCol = start.col;
          if (startRow > rows || startCol > cols) continue;

          const endRow = Math.min(rows, startRow + rowspan - 1);
          const endCol = Math.min(cols, startCol + colspan - 1);
          const startAddr = addrFromRC(startCol, startRow);
          startMap.set(startAddr, { rowspan: endRow - startRow + 1, colspan: endCol - startCol + 1 });

          for (let r = startRow; r <= endRow; r++) {
            for (let c = startCol; c <= endCol; c++) {
              if (r === startRow && c === startCol) continue;
              skip.add(addrFromRC(c, r));
            }
          }
        }

        return { skip, startMap };
      }

      function renderExcelLikeTable(config) {
        if (!config || config.type !== "excel-like-table") {
          const el = document.createElement("div");
          el.className = "demo-error";
          el.textContent = "Unsupported template type.";
          return el;
        }

        const rows = Math.max(1, Math.floor(Number(config?.grid?.rows || 1)));
        const cols = Math.max(1, Math.floor(Number(config?.grid?.cols || 1)));

        const table = document.createElement("table");
        table.className = "excel-like-table";
        table.style.borderCollapse = "collapse";
        table.style.tableLayout = "fixed";

        const cellMap = new Map();
        const cells = Array.isArray(config.cells) ? config.cells : [];
        for (const c of cells) {
          const addr = normalizeAddress(c?.addr);
          if (!addr) continue;
          cellMap.set(addr, c);
        }

        const colWidths = buildColumnWidths(config, cols);
        const rowHeights = buildRowHeights(config, rows);
        const { skip, startMap } = buildMergeMaps(config, rows, cols);

        let baseClasses = [];
        if (Array.isArray(config?.defaultCellClass)) {
          baseClasses = config.defaultCellClass.map((x) => String(x || "").trim()).filter(Boolean);
        } else if (typeof config?.defaultCellClass === "string" && config.defaultCellClass.trim()) {
          baseClasses = [config.defaultCellClass.trim()];
        } else if (config?.css?.cell) {
          baseClasses = ["cell"];
        }

        const colgroup = document.createElement("colgroup");
        let totalWidth = 0;
        for (let c = 1; c <= cols; c++) {
          const w = Number(colWidths.get(c));
          const col = document.createElement("col");
          if (Number.isFinite(w) && w > 0) {
            col.style.width = `${w}px`;
            totalWidth += w;
          }
          colgroup.appendChild(col);
        }
        table.appendChild(colgroup);
        if (totalWidth > 0) table.style.width = `${totalWidth}px`;

        for (let r = 1; r <= rows; r++) {
          const tr = document.createElement("tr");
          const h = Number(rowHeights.get(r));
          if (Number.isFinite(h) && h > 0) tr.style.height = `${h}px`;

          for (let c = 1; c <= cols; c++) {
            const addr = addrFromRC(c, r);
            if (skip.has(addr)) continue;

            const td = document.createElement("td");
            td.dataset.addr = addr;

            const cellCfg = cellMap.get(addr);
            if (cellCfg) {
              td.textContent = String(cellCfg.text ?? "");
              const bind = String(cellCfg.bind || "").trim();
              if (bind) {
                td.dataset.bind = bind;
                if (/\.description$/.test(bind)) td.title = "Double-click để sửa mô tả (local/global).";
              }
            }

            const combined = [];
            for (const cls of baseClasses) combined.push(cls);
            if (Array.isArray(cellCfg?.class)) {
              for (const cls of cellCfg.class) combined.push(String(cls || "").trim());
            }

            const seen = new Set();
            const classes = combined.filter((x) => {
              const t = String(x || "").trim();
              if (!t || seen.has(t)) return false;
              seen.add(t);
              return true;
            });

            if (classes.length) {
              td.className = classes.join(" ");
              const styleText = cssTextForClasses(config.css, classes);
              const cellStyle = cellCfg && typeof cellCfg === "object" ? String(cellCfg.style || "").trim() : "";
              const mergedStyle = `${styleText || ""}${cellStyle ? (cellStyle.endsWith(";") ? cellStyle : `${cellStyle};`) : ""}`;
              if (mergedStyle) td.style.cssText = mergedStyle;
            } else if (cellCfg && typeof cellCfg === "object") {
              const cellStyle = String(cellCfg.style || "").trim();
              if (cellStyle) td.style.cssText = cellStyle.endsWith(";") ? cellStyle : `${cellStyle};`;
            }

            const merge = startMap.get(addr);
            if (merge) {
              if (merge.rowspan > 1) td.rowSpan = merge.rowspan;
              if (merge.colspan > 1) td.colSpan = merge.colspan;
            }

            tr.appendChild(td);
          }

          table.appendChild(tr);
        }

        return table;
      }

      ns.tableRenderer = {
        renderExcelLikeTable,
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/template_converter.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      const desc = ns.desc || null;
      const IDENT_PATH_RE = desc?.IDENT_PATH_RE ? new RegExp(desc.IDENT_PATH_RE.source, "g") : /[A-Za-z_][A-Za-z0-9_\/]*(?:(?:->|=>|[-~])[A-Za-z0-9_\/]+)*/g;
      const pickDescription =
        typeof desc?.pickDescription === "function"
          ? desc.pickDescription
          : (entity, fallbackName) => {
              if (!entity) return String(fallbackName || "").trim();
              const user = String(entity.userDescription || "").trim();
              if (user) return user;
              const code = String(entity.description || "").trim();
              if (code) return code;
              return String(fallbackName || entity.variableName || entity.name || "").trim();
            };
      const maskStringsAndTemplates =
        typeof desc?.maskStringsAndTemplates === "function"
          ? desc.maskStringsAndTemplates
          : (s) => {
              // ABAP strings: '...'; escaped by doubling: ''
              const noStrings = String(s || "").replace(/'(?:[^']|'')*'/g, " ");
              // ABAP string templates: |...|  (best-effort)
              return noStrings.replace(/\|[^|]*\|/g, " ");
            };
      const rootFromPath =
        typeof desc?.rootFromPath === "function"
          ? desc.rootFromPath
          : (path) => {
              const s = String(path || "").trim();
              if (!s) return "";
              const root = s.split(/(?:->|=>|[-~])/)[0] || "";
              const m = /^[A-Za-z_][A-Za-z0-9_\/]*/.exec(root.trim());
              return m ? m[0] : "";
            };

      const extractSource =
        typeof utils?.extractSource === "function"
          ? utils.extractSource
          : (model, sourceRef) => {
              if (!model || !Array.isArray(model.lines) || !sourceRef) return "";
              const start = Math.max(1, Math.floor(Number(sourceRef.startLine || 1)));
              const end = Math.min(model.lines.length, Math.floor(Number(sourceRef.endLine || start)));
              return model.lines.slice(start - 1, end).join("\n").trim();
            };

      function pickNote(entity) {
        if (!entity) return "";
        const user = String(entity.userNote || "").trim();
        if (user) return user;
        return String(entity.note || "").trim();
      }

      function resolveBestSymbol(model, routineKey, expr) {
        const resolver = ns.lineage?.resolveSymbol;
        const rk = String(routineKey || "").trim();
        if (!resolver || !model || !rk) return { root: "", scope: "unknown", decl: null };

        const sanitized = maskStringsAndTemplates(expr);
        IDENT_PATH_RE.lastIndex = 0;
        const tokens = [];
        let m = null;
        while ((m = IDENT_PATH_RE.exec(sanitized))) {
          const token = String(m[0] || "").trim();
          if (token) tokens.push(token);
        }

        for (const token of tokens) {
          const root = rootFromPath(token);
          if (!root) continue;
          const res = resolver(model, rk, root);
          if (res && String(res.scope || "").toLowerCase() !== "unknown") return { root, scope: res.scope, decl: res.decl || null };
        }

        const fallbackRoot = tokens.length ? rootFromPath(tokens[0]) : "";
        if (!fallbackRoot) return { root: "", scope: "unknown", decl: null };
        const fallback = resolver(model, rk, fallbackRoot);
        return { root: fallbackRoot, scope: fallback?.scope || "unknown", decl: fallback?.decl || null };
      }

      function extractPerformEdges(model) {
        const edges = model && Array.isArray(model.edges) ? model.edges : [];
        return edges.filter((e) => String(e?.toKey || "").toUpperCase().startsWith("FORM:"));
      }

      function extractAssignments(model) {
        const out = [];
        const nodes = Array.from(model?.nodes?.values ? model.nodes.values() : []);
        for (const routine of nodes) {
          const assigns = Array.isArray(routine?.assignments) ? routine.assignments : [];
          for (const a of assigns) {
            if (!a || !a.sourceRef) continue;
            out.push({ routine, assignment: a });
          }
        }

        out.sort((a, b) => Number(a?.assignment?.sourceRef?.startLine || 0) - Number(b?.assignment?.sourceRef?.startLine || 0));
        return out;
      }

      function extractIfStatements(model) {
        const out = [];
        const nodes = Array.from(model?.nodes?.values ? model.nodes.values() : []);
        for (const routine of nodes) {
          const list = Array.isArray(routine?.ifStatements) ? routine.ifStatements : [];
          for (const st of list) {
            if (!st || !st.sourceRef) continue;
            out.push({ routine, ifStatement: st });
          }
        }

        out.sort((a, b) => Number(a?.ifStatement?.sourceRef?.startLine || 0) - Number(b?.ifStatement?.sourceRef?.startLine || 0));
        return out;
      }

      function extractMessages(model) {
        const out = [];
        const nodes = Array.from(model?.nodes?.values ? model.nodes.values() : []);
        for (const routine of nodes) {
          const list = Array.isArray(routine?.messages) ? routine.messages : [];
          for (const msg of list) {
            if (!msg || !msg.sourceRef) continue;
            out.push({ routine, message: msg });
          }
        }

        out.sort((a, b) => Number(a?.message?.sourceRef?.startLine || 0) - Number(b?.message?.sourceRef?.startLine || 0));
        return out;
      }

      function extractItabOperations(model) {
        const out = [];
        const nodes = Array.from(model?.nodes?.values ? model.nodes.values() : []);
        for (const routine of nodes) {
          const list = Array.isArray(routine?.itabOps) ? routine.itabOps : [];
          for (const op of list) {
            if (!op || !op.sourceRef) continue;
            out.push({ routine, itabOp: op });
          }
        }

        out.sort((a, b) => Number(a?.itabOp?.sourceRef?.startLine || 0) - Number(b?.itabOp?.sourceRef?.startLine || 0));
        return out;
      }

      function buildArgMappings(model, callerKey, actuals, formals, options) {
        const a = Array.isArray(actuals) ? actuals : [];
        const f = Array.isArray(formals) ? formals : [];
        const len = a.length;
        if (len === 0) return [];

        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;

        const out = [];
        for (let i = 0; i < len; i++) {
          const formal = f[i] || null;
          const actualText = a[i] != null ? String(a[i]) : "";
          const described = desc?.describeExpressionWithOrigin
            ? desc.describeExpressionWithOrigin(model, callerKey, actualText, { callPath })
            : { text: "", originKey: "" };
          out.push({
            actual: actualText,
            name: formal ? String(formal.name || "") : "",
            dataType: formal ? String(formal.dataType || "") : "",
            description: String(described.text || "").trim() || actualText.trim() || (formal ? String(formal.name || "") : ""),
            originKey: String(described.originKey || ""),
            note: formal ? pickNote(formal) : "",
          });
        }
        return out;
      }

      function buildPerformContext(model, edge, options) {
        const toKey = String(edge?.toKey || "");
        const fromKey = String(edge?.fromKey || "");

        const callee = model?.nodes?.get(toKey) || null;
        const caller = model?.nodes?.get(fromKey) || null;

        const params = Array.isArray(callee?.params) ? callee.params : [];
        const formalTables = params.filter((p) => String(p?.kind || "").toUpperCase() === "TABLES");
        const formalUsing = params.filter((p) => String(p?.kind || "").toUpperCase() === "USING");
        const formalChanging = params.filter((p) => String(p?.kind || "").toUpperCase() === "CHANGING");
        const formalRaising = params.filter((p) => String(p?.kind || "").toUpperCase() === "RAISING");

        const args = edge?.args || {};
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;
        const tables = buildArgMappings(model, fromKey, args.tables, formalTables, { callPath });
        const using = buildArgMappings(model, fromKey, args.using, formalUsing, { callPath });
        const changing = buildArgMappings(model, fromKey, args.changing, formalChanging, { callPath });
        const raising = formalRaising.map((p) => ({
          name: String(p?.name || ""),
          description: pickDescription(p, p?.name),
          originKey: ns.notes?.makeParamKey ? ns.notes.makeParamKey(toKey, String(p?.name || "")) : "",
          note: pickNote(p),
        }));

        const performName = String(edge?.targetName || callee?.name || "").trim();

        const presence = {
          tables: tables.length > 0,
          using: using.length > 0,
          changing: changing.length > 0,
          raising: raising.length > 0,
        };

        return {
          perform: {
            key: toKey,
            name: performName,
            description: pickDescription(callee, performName),
            note: pickNote(callee),
            originKey: toKey,
          },
          caller: {
            key: fromKey,
            name: String(caller?.name || "").trim(),
          },
          presence,
          tables,
          using,
          changing,
          raising,
        };
      }

      function buildAssignmentContext(model, routine, assignment, options) {
        const r = routine || null;
        const a = assignment || null;

        const lhsText = String(a?.lhs || "");
        const rhsText = String(a?.rhs || "");

        const routineKey = String(r?.key || "");
        const lhsResolved = resolveBestSymbol(model, routineKey, lhsText);
        const rhsResolved = resolveBestSymbol(model, routineKey, rhsText);
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;

        const lhsDesc = desc?.describeExpressionWithOrigin
          ? desc.describeExpressionWithOrigin(model, routineKey, lhsText, { callPath })
          : { text: pickDescription(lhsResolved.decl, lhsResolved.root || lhsText), originKey: "" };

        const rhsDesc = desc?.describeExpressionWithOrigin
          ? desc.describeExpressionWithOrigin(model, routineKey, rhsText, { callPath })
          : { text: pickDescription(rhsResolved.decl, rhsResolved.root || rhsText), originKey: "" };

        return {
          routine: {
            key: String(r?.key || ""),
            kind: String(r?.kind || ""),
            name: String(r?.name || ""),
          },
          assignment: {
            lhs: lhsText,
            rhs: rhsText,
            statement: String(a?.statement || ""),
          },
          item: {
            text: lhsText,
            root: lhsResolved.root,
            scope: String(lhsResolved.scope || "unknown"),
            description: String(lhsDesc.text || "").trim() || lhsText.trim() || lhsResolved.root,
            note: pickNote(lhsResolved.decl),
            originKey: String(lhsDesc.originKey || ""),
          },
          value: {
            text: rhsText,
            root: rhsResolved.root,
            scope: String(rhsResolved.scope || "unknown"),
            description: String(rhsDesc.text || "").trim() || rhsText.trim() || rhsResolved.root,
            note: pickNote(rhsResolved.decl),
            originKey: String(rhsDesc.originKey || ""),
          },
        };
      }

      function buildIfContext(model, routine, ifStatement, options) {
        const r = routine || null;
        const st = ifStatement || null;

        const routineKey = String(r?.key || "");
        const kind = String(st?.kind || "IF").trim().toUpperCase() || "IF";
        const condition = String(st?.condition || "").trim();
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;

        const parsed = typeof ns.logic?.parseIfExpression === "function" ? ns.logic.parseIfExpression(condition) : [{ item1: condition, operator: "", item2: "", association: "", raw: condition }];

        const conditions = (parsed || []).map((c) => {
          const item1Text = String(c?.item1 || "").trim();
          const item2Text = String(c?.item2 || "").trim();

          const item1Resolved = resolveBestSymbol(model, routineKey, item1Text);
          const item2Resolved = item2Text ? resolveBestSymbol(model, routineKey, item2Text) : { root: "", scope: "unknown", decl: null };

          const item1Desc = desc?.describeExpressionWithOrigin
            ? desc.describeExpressionWithOrigin(model, routineKey, item1Text, { callPath })
            : { text: pickDescription(item1Resolved.decl, item1Text) || item1Text, originKey: "" };

          const item2Desc =
            item2Text && desc?.describeExpressionWithOrigin
              ? desc.describeExpressionWithOrigin(model, routineKey, item2Text, { callPath })
              : { text: pickDescription(item2Resolved.decl, item2Text) || item2Text, originKey: "" };

          return {
            item1: {
              text: item1Text,
              root: item1Resolved.root,
              scope: String(item1Resolved.scope || "unknown"),
              description: String(item1Desc.text || "").trim() || item1Text,
              note: pickNote(item1Resolved.decl),
              originKey: String(item1Desc.originKey || ""),
            },
            operator: String(c?.operator || "").trim(),
            item2: {
              text: item2Text,
              root: item2Resolved.root,
              scope: String(item2Resolved.scope || "unknown"),
              description: String(item2Desc.text || "").trim() || item2Text,
              note: pickNote(item2Resolved.decl),
              originKey: String(item2Desc.originKey || ""),
            },
            association: String(c?.association || "").trim().toUpperCase(),
            raw: String(c?.raw || "").trim(),
          };
        });

        return {
          routine: {
            key: routineKey,
            kind: String(r?.kind || ""),
            name: String(r?.name || ""),
          },
          if: { kind, condition },
          conditions,
        };
      }

      function describeExprWithOrigin(model, routineKey, exprText, options) {
        const text = String(exprText ?? "").trim();
        if (!text) return { text: "", originKey: "" };
        if (desc?.describeExpressionWithOrigin) return desc.describeExpressionWithOrigin(model, routineKey, text, options);
        return { text, originKey: "" };
      }

      function buildExprNode(model, routineKey, exprText, options) {
        const text = String(exprText ?? "").trim();
        if (!text) return { text: "", description: "", originKey: "" };
        const described = describeExprWithOrigin(model, routineKey, text, options);
        return {
          text,
          description: String(described.text || "").trim() || text,
          originKey: String(described.originKey || ""),
        };
      }

      const KEY_COND_START_RE =
        /[A-Za-z_][A-Za-z0-9_\/]*(?:(?:->|=>|[-~])[A-Za-z0-9_\/]+)*\s*(?:<=|>=|<>|=|<|>|EQ|NE|GT|LT|GE|LE)\b/gi;

      function splitKeyConditionTerms(text) {
        const raw = String(text || "").trim();
        if (!raw) return [];

        const masked = desc?.maskStringsAndTemplates ? desc.maskStringsAndTemplates(raw) : raw;

        KEY_COND_START_RE.lastIndex = 0;
        const starts = [];
        let m = null;
        while ((m = KEY_COND_START_RE.exec(masked))) starts.push(Number(m.index || 0));
        if (starts.length <= 1) return [raw];

        const out = [];
        for (let i = 0; i < starts.length; i++) {
          const start = starts[i];
          const end = i + 1 < starts.length ? starts[i + 1] : raw.length;
          const term = raw.slice(start, end).trim();
          if (term) out.push(term);
        }
        return out;
      }

      function buildConditionOperand(model, routineKey, exprText, options) {
        const text = String(exprText ?? "").trim();
        if (!text) return { text: "", root: "", scope: "unknown", description: "", note: "", originKey: "" };

        const resolved = resolveBestSymbol(model, routineKey, text);
        const described = describeExprWithOrigin(model, routineKey, text, options);

        return {
          text,
          root: resolved.root,
          scope: String(resolved.scope || "unknown"),
          description: String(described.text || "").trim() || text,
          note: pickNote(resolved.decl),
          originKey: String(described.originKey || ""),
        };
      }

      function buildMessageContext(model, routine, message, options) {
        const r = routine || null;
        const msg = message || null;
        const routineKey = String(r?.key || "");
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;

        const msgClass = buildExprNode(model, routineKey, msg?.msgClass || "", { callPath });
        const msgNo = buildExprNode(model, routineKey, msg?.msgNo || "", { callPath });
        const displayLike = buildExprNode(model, routineKey, msg?.displayLike || "", { callPath });
        const into = buildExprNode(model, routineKey, msg?.into || "", { callPath });
        const raising = buildExprNode(model, routineKey, msg?.raising || "", { callPath });
        const messageText = buildExprNode(model, routineKey, msg?.text || "", { callPath });

        const withArgs = Array.isArray(msg?.with) ? msg.with : [];
        const withNodes = withArgs.map((x) => buildExprNode(model, routineKey, x, { callPath }));

        return {
          routine: {
            key: routineKey,
            kind: String(r?.kind || ""),
            name: String(r?.name || ""),
          },
          message: {
            msgType: String(msg?.msgType || "").trim(),
            statement: String(msg?.statement || "").trim(),
          },
          msgClass,
          msgNo,
          displayLike,
          with: withNodes,
          into,
          raising,
          messageText,
          labels: {
            msgClass: msgClass.text ? "Message class" : "",
            msgNo: msgNo.text ? "Message No." : "",
            with1: withNodes.length >= 1 ? "Message variable &1" : "",
            with2: withNodes.length >= 2 ? "Message variable &2" : "",
            with3: withNodes.length >= 3 ? "Message variable &3" : "",
            with4: withNodes.length >= 4 ? "Message variable &4" : "",
            into: into.text ? "Đích lưu" : "",
            raising: raising.text ? "Raising" : "",
            displayLike: displayLike.text ? "Display like" : "",
            messageText: messageText.text ? "Message text" : "",
          },
        };
      }

      function buildItabOpContext(model, routine, itabOp, options) {
        const r = routine || null;
        const op = itabOp || null;
        const routineKey = String(r?.key || "");
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;

        const kind = String(op?.kind || "").trim().toUpperCase();
        const table = buildExprNode(model, routineKey, op?.table || "", { callPath });
        const target = buildExprNode(model, routineKey, op?.target || "", { callPath });

        const condText = String(op?.conditionText || "").trim();
        const condKind = String(op?.conditionKind || "").trim().toLowerCase();

        let parsed = [];
        if (condText) {
          if (condKind === "where" && typeof ns.logic?.parseIfExpression === "function") {
            parsed = ns.logic.parseIfExpression(condText);
          } else if (condKind === "key" && typeof ns.logic?.parseSimpleCondition === "function") {
            const terms = splitKeyConditionTerms(condText);
            for (let i = 0; i < terms.length; i++) {
              const p = ns.logic.parseSimpleCondition(terms[i]);
              parsed.push({ ...p, association: i < terms.length - 1 ? "AND" : "" });
            }
          } else if (condKind === "index") {
            parsed = [{ item1: "INDEX", operator: "=", item2: condText, association: "", raw: `INDEX = ${condText}` }];
          } else if (condKind === "from") {
            parsed = [{ item1: condText, operator: "FROM", item2: "", association: "", raw: `FROM ${condText}` }];
          } else if (typeof ns.logic?.parseIfExpression === "function") {
            parsed = ns.logic.parseIfExpression(condText);
          } else {
            parsed = [{ item1: condText, operator: "", item2: "", association: "", raw: condText }];
          }
        }

        const conditions = (parsed || []).map((c) => {
          const item1Text = String(c?.item1 || "").trim();
          const item2Text = String(c?.item2 || "").trim();

          return {
            item1: buildConditionOperand(model, routineKey, item1Text, { callPath }),
            operator: String(c?.operator || "").trim(),
            item2: buildConditionOperand(model, routineKey, item2Text, { callPath }),
            association: String(c?.association || "").trim().toUpperCase(),
            raw: String(c?.raw || "").trim(),
          };
        });

        const binarySearch = Boolean(op?.binarySearch);

        const targetLabelByKind =
          kind === "READ" ? "Đích lưu" : kind === "COLLECT" ? "Nguồn" : kind === "MODIFY" ? "Nguồn" : kind === "DELETE" ? "Nguồn" : "Target";

        return {
          routine: {
            key: routineKey,
            kind: String(r?.kind || ""),
            name: String(r?.name || ""),
          },
          itabOp: {
            kind,
            statement: String(op?.statement || "").trim(),
            binarySearch,
            conditionKind: condKind,
            conditionText: condText,
          },
          table,
          target,
          conditions,
          labels: {
            target: target.text ? targetLabelByKind : "",
            conditions: conditions.length ? "Điều kiện" : "",
            condItem1: conditions.length ? "Item 1" : "",
            condOperator: conditions.length ? "Operator" : "",
            condItem2: conditions.length ? "Item 2" : "",
            condAssoc: conditions.length ? "Associations" : "",
            binarySearch: binarySearch ? "* Binarysearch" : "",
          },
        };
      }

      function buildAppendContext(model, routine, append, options) {
        const r = routine || null;
        const a = append || null;

        const routineKey = String(r?.key || "");
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;

        const line = buildExprNode(model, routineKey, a?.line || "", { callPath });
        const itab = buildExprNode(model, routineKey, a?.itab || "", { callPath });
        const sortedBy = buildExprNode(model, routineKey, a?.sortedBy || "", { callPath });
        const result = buildExprNode(model, routineKey, a?.result || "", { callPath });

        return {
          routine: {
            key: routineKey,
            kind: String(r?.kind || ""),
            name: String(r?.name || ""),
          },
          append: {
            statement: String(a?.statement || "").trim(),
          },
          line,
          itab,
          sortedBy,
          result,
          labels: {
            sortedBy: sortedBy.text ? "Sorted By" : "",
          },
        };
      }

      function resolvePath(obj, path) {
        const raw = String(path || "").trim();
        if (!raw) return undefined;

        let cur = obj;
        const parts = raw.split(".").map((p) => p.trim()).filter(Boolean);

        for (const part of parts) {
          if (cur == null) return undefined;
          const m = /^([A-Za-z0-9_$]+)(.*)$/.exec(part);
          if (!m) return undefined;
          const prop = m[1];
          let rest = m[2] || "";
          cur = cur[prop];

          while (rest) {
            const m2 = /^\[(\d+)\](.*)$/.exec(rest);
            if (!m2) return undefined;
            const idx = Number(m2[1]);
            if (!Number.isFinite(idx)) return undefined;
            cur = cur == null ? undefined : cur[idx];
            rest = m2[2] || "";
          }
        }

        return cur;
      }

      function fillText(text, context, options) {
        const s = String(text ?? "");
        const preserveUnresolved = Boolean(options?.preserveUnresolved);
        return s.replace(/\{([^}]+)\}/g, (m, expr) => {
          const value = resolvePath(context, expr);
          if (value == null) return preserveUnresolved ? m : "";
          if (typeof value === "string") return value;
          if (typeof value === "number" || typeof value === "boolean") return String(value);
          return preserveUnresolved ? m : "";
        });
      }

      function replaceListIndexInText(text, listName, fromIndex, toIndex) {
        const s = String(text ?? "");
        const from = Number(fromIndex);
        const to = Number(toIndex);
        if (!Number.isFinite(from) || !Number.isFinite(to)) return s;
        const re = new RegExp(`\\{${listName}\\[${from}\\]`, "g");
        return s.replace(re, `{${listName}[${to}]`);
      }

      function fillTemplateConfig(templateConfig, context, options) {
        const cfg = JSON.parse(JSON.stringify(templateConfig || {}));
        if (!cfg || typeof cfg !== "object") return cfg;

        const sectionLabels =
          templateConfig?.sectionLabels && typeof templateConfig.sectionLabels === "object" ? templateConfig.sectionLabels : {};
        const presence = context?.presence && typeof context.presence === "object" ? context.presence : {};
        const labels = {
          ...(context?.labels && typeof context.labels === "object" ? context.labels : {}),
          tables: presence.tables ? String(sectionLabels.tables ?? "Table") : "",
          using: presence.using ? String(sectionLabels.using ?? "Using") : "",
          changing: presence.changing ? String(sectionLabels.changing ?? "Changing") : "",
          raising: presence.raising ? String(sectionLabels.raising ?? "Raising") : "",
        };
        const ctx = { ...(context || {}), labels };

        if (Array.isArray(cfg.cells)) {
          for (const cell of cfg.cells) {
            if (!cell || typeof cell !== "object") continue;
            if (cell.text == null) continue;

            const rawText = String(cell.text ?? "");
            const bindMatch = /^\{([^}]+)\}$/.exec(rawText.trim());
            if (bindMatch) cell.bind = String(bindMatch[1] || "").trim();

            cell.text = fillText(rawText, ctx, options);
          }
        }

        return cfg;
      }

      function parseCellAddr(addr) {
        const s = String(addr || "").trim().toUpperCase();
        const m = /^([A-Z]+)(\d+)$/.exec(s);
        if (!m) return null;
        return { col: m[1], row: Number(m[2]) };
      }

      function shiftAddrRow(addr, afterRow, delta) {
        const parsed = parseCellAddr(addr);
        if (!parsed) return addr;
        if (parsed.row > afterRow) return `${parsed.col}${parsed.row + delta}`;
        return `${parsed.col}${parsed.row}`;
      }

      function shiftRowHeights(rowHeights, afterRow, delta) {
        const src = rowHeights && typeof rowHeights === "object" ? rowHeights : {};
        const out = {};
        for (const [k, v] of Object.entries(src)) {
          const r = Number(k);
          if (!Number.isFinite(r) || r <= 0) continue;
          const nr = r > afterRow ? r + delta : r;
          out[String(nr)] = v;
        }
        return out;
      }

      function scanRepeatSections(cells) {
        const info = new Map();
        const re = /\{([A-Za-z_][A-Za-z0-9_]*)\[(\d+)\]\.[^}]*\}/g;

        for (const cell of cells) {
          const a = parseCellAddr(cell?.addr);
          if (!a) continue;
          const text = String(cell?.text ?? "");
          re.lastIndex = 0;
          let m;
          while ((m = re.exec(text))) {
            const list = m[1];
            const idx = Number(m[2]);
            if (!Number.isFinite(idx) || idx < 0) continue;

            if (!info.has(list)) {
              info.set(list, { maxIndex: -1, rowForIndex: new Map(), rowsUsed: new Set() });
            }
            const cur = info.get(list);
            cur.maxIndex = Math.max(cur.maxIndex, idx);
            cur.rowsUsed.add(a.row);
            if (!cur.rowForIndex.has(idx)) cur.rowForIndex.set(idx, a.row);
          }
        }

        return info;
      }

      function expandExcelLikeTableTemplate(templateConfig, context) {
        const cfg = JSON.parse(JSON.stringify(templateConfig || {}));
        if (!cfg || typeof cfg !== "object") return cfg;
        if (cfg.type !== "excel-like-table") return cfg;
        if (!cfg.grid || typeof cfg.grid !== "object") return cfg;
        if (!Array.isArray(cfg.cells)) return cfg;

        const merges = Array.isArray(cfg.merges) ? cfg.merges : [];
        cfg.merges = merges;

        const info = scanRepeatSections(cfg.cells);
        const sections = [];

        for (const [list, data] of info.entries()) {
          const maxIndex = Number(data?.maxIndex);
          if (!Number.isFinite(maxIndex) || maxIndex < 0) continue;

          const rows = Array.from(data.rowsUsed || []).filter((r) => Number.isFinite(r) && r > 0).sort((a, b) => a - b);
          if (!rows.length) continue;

          sections.push({
            list,
            baseCount: maxIndex + 1,
            baseIndex: maxIndex,
            startRow: rows[0],
            endRow: rows[rows.length - 1],
            templateRow: data.rowForIndex?.get(maxIndex) || rows[rows.length - 1],
          });
        }

        sections.sort((a, b) => b.startRow - a.startRow);

        function insertRowsAfter(afterRow, count, section) {
          if (count <= 0) return;

          cfg.cells = cfg.cells.map((cell) => {
            const addr = shiftAddrRow(cell?.addr, afterRow, count);
            return { ...cell, addr };
          });

          cfg.merges = cfg.merges.map((m) => {
            const start = shiftAddrRow(m?.start, afterRow, count);
            return { ...m, start };
          });

          cfg.grid.rowHeights = shiftRowHeights(cfg.grid.rowHeights, afterRow, count);
          cfg.grid.rows = Math.max(1, Math.floor(Number(cfg.grid.rows || 1)) + count);

          const rowCells = cfg.cells
            .filter((cell) => parseCellAddr(cell?.addr)?.row === section.templateRow)
            .map((cell) => ({ ...cell }));
          const rowMerges = cfg.merges
            .filter((m) => parseCellAddr(m?.start)?.row === section.templateRow)
            .map((m) => ({ ...m }));
          const baseHeight =
            cfg.grid.rowHeights?.[String(section.templateRow)] ?? cfg.grid.rowHeights?.[Number(section.templateRow)] ?? null;

          for (let i = 1; i <= count; i++) {
            const newRow = afterRow + i;
            const newIndex = section.baseIndex + i;

            for (const baseCell of rowCells) {
              const parsed = parseCellAddr(baseCell?.addr);
              if (!parsed) continue;
              const newAddr = `${parsed.col}${newRow}`;
              const text = replaceListIndexInText(baseCell?.text, section.list, section.baseIndex, newIndex);
              let nextText = text;
              if (parsed.col === "A" && /\{labels\./.test(nextText)) nextText = "";
              cfg.cells.push({ ...baseCell, addr: newAddr, text: nextText });
            }

            for (const baseMerge of rowMerges) {
              const parsed = parseCellAddr(baseMerge?.start);
              if (!parsed) continue;
              cfg.merges.push({ ...baseMerge, start: `${parsed.col}${newRow}` });
            }

            if (baseHeight != null) cfg.grid.rowHeights[String(newRow)] = baseHeight;
          }
        }

        for (const section of sections) {
          const want = Array.isArray(context?.[section.list]) ? context[section.list].length : 0;
          const baseCount = section.baseCount;
          if (want <= baseCount) continue;
          insertRowsAfter(section.endRow, want - baseCount, section);
        }

        return cfg;
      }

      function compactExcelLikeTableConfig(cfg) {
        if (!cfg || cfg.type !== "excel-like-table") return cfg;
        if (!cfg.grid || typeof cfg.grid !== "object") return cfg;
        if (!cfg.compact?.removeEmptyRows) return cfg;
        if (!Array.isArray(cfg.cells)) return cfg;

        const totalRows = Math.max(1, Math.floor(Number(cfg.grid.rows || 1)));
        const rowsWithText = new Set([1]);

        for (const cell of cfg.cells) {
          const parsed = parseCellAddr(cell?.addr);
          if (!parsed) continue;
          if (parsed.row < 1 || parsed.row > totalRows) continue;
          const text = String(cell?.text ?? "").trim();
          if (text) rowsWithText.add(parsed.row);
        }

        const keepRows = Array.from(rowsWithText).filter((r) => r >= 1 && r <= totalRows).sort((a, b) => a - b);
        if (keepRows.length === totalRows) return cfg;

        const rowMap = new Map();
        for (let i = 0; i < keepRows.length; i++) rowMap.set(keepRows[i], i + 1);

        cfg.cells = cfg.cells
          .map((cell) => {
            const parsed = parseCellAddr(cell?.addr);
            if (!parsed) return null;
            const newRow = rowMap.get(parsed.row);
            if (!newRow) return null;
            return { ...cell, addr: `${parsed.col}${newRow}` };
          })
          .filter(Boolean);

        if (Array.isArray(cfg.merges)) {
          cfg.merges = cfg.merges
            .map((merge) => {
              const parsed = parseCellAddr(merge?.start);
              if (!parsed) return null;
              const newRow = rowMap.get(parsed.row);
              if (!newRow) return null;
              return { ...merge, start: `${parsed.col}${newRow}` };
            })
            .filter(Boolean);
        }

        const oldHeights = cfg.grid.rowHeights && typeof cfg.grid.rowHeights === "object" ? cfg.grid.rowHeights : {};
        const newHeights = {};
        for (const oldRow of keepRows) {
          const newRow = rowMap.get(oldRow);
          const h = oldHeights[oldRow] ?? oldHeights[String(oldRow)];
          if (newRow && h != null) newHeights[String(newRow)] = h;
        }
        cfg.grid.rowHeights = newHeights;
        cfg.grid.rows = keepRows.length;
        return cfg;
      }

      function convertPerforms(model, templateConfig) {
        const edges = extractPerformEdges(model)
          .slice()
          .sort((a, b) => Number(a?.sourceRef?.startLine || 0) - Number(b?.sourceRef?.startLine || 0));
        return edges.map((edge) => {
          const context = buildPerformContext(model, edge);
          const expandedTemplate = expandExcelLikeTableTemplate(templateConfig, context);
          const filledConfig = compactExcelLikeTableConfig(fillTemplateConfig(expandedTemplate, context));
          const original = extractSource(model, edge.sourceRef) || `PERFORM ${context.perform.name}`;
          return { edge, context, filledConfig, original };
        });
      }

      function convertAssignments(model, templateConfig) {
        const items = extractAssignments(model);
        return items.map(({ routine, assignment }) => {
          const context = buildAssignmentContext(model, routine, assignment);
          const filledConfig = compactExcelLikeTableConfig(fillTemplateConfig(templateConfig, context));
          const original = extractSource(model, assignment.sourceRef) || `${context.assignment.lhs} = ${context.assignment.rhs}`;
          return {
            routineKey: String(routine?.key || ""),
            routineName: String(routine?.name || ""),
            routineKind: String(routine?.kind || ""),
            assignment,
            context,
            filledConfig,
            original,
            sourceRef: assignment?.sourceRef || null,
          };
        });
      }

      function convertIfStatements(model, templateConfig) {
        const items = extractIfStatements(model);
        return items.map(({ routine, ifStatement }) => {
          const context = buildIfContext(model, routine, ifStatement);
          const expanded = expandExcelLikeTableTemplate(templateConfig, context);
          const filledConfig = compactExcelLikeTableConfig(fillTemplateConfig(expanded, context));
          const original = extractSource(model, ifStatement.sourceRef) || `${context.if?.kind || "IF"} ${context.if?.condition || ""}`;
          return {
            routineKey: String(routine?.key || ""),
            routineName: String(routine?.name || ""),
            routineKind: String(routine?.kind || ""),
            ifStatement,
            context,
            filledConfig,
            original,
            sourceRef: ifStatement?.sourceRef || null,
          };
        });
      }

      ns.templateConverter = {
        extractPerformEdges,
        extractAssignments,
        extractIfStatements,
        extractMessages,
        extractItabOperations,
        buildPerformContext,
        buildAssignmentContext,
        buildIfContext,
        buildMessageContext,
        buildItabOpContext,
        buildAppendContext,
        fillTemplateConfig,
        expandExcelLikeTableTemplate,
        compactExcelLikeTableConfig,
        convertPerforms,
        convertAssignments,
        convertIfStatements,
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/template_excel_import.js
    (function (ns) {
      "use strict";

      function stripCssComments(cssText) {
        return String(cssText || "")
          .replace(/<!--|-->/g, "")
          .replace(/\/\*[\s\S]*?\*\//g, "");
      }

      function indexToCol(index1) {
        let n = Number(index1);
        if (!Number.isFinite(n) || n <= 0) return "";
        n = Math.floor(n);
        let s = "";
        while (n > 0) {
          const rem = (n - 1) % 26;
          s = String.fromCharCode(65 + rem) + s;
          n = Math.floor((n - 1) / 26);
        }
        return s;
      }

      function addrFromRC(colIndex, row) {
        return `${indexToCol(colIndex)}${row}`;
      }

      function parseStyleDeclarations(styleText) {
        const map = new Map();
        const raw = String(styleText || "").trim();
        if (!raw) return map;

        const parts = raw.split(";");
        for (const part of parts) {
          const t = String(part || "").trim();
          if (!t) continue;
          const idx = t.indexOf(":");
          if (idx <= 0) continue;
          const prop = t.slice(0, idx).trim().toLowerCase();
          const value = t.slice(idx + 1).trim();
          if (!prop) continue;
          map.set(prop, value);
        }
        return map;
      }

      function serializeStyleDeclarations(map) {
        if (!map || map.size === 0) return "";
        return Array.from(map.entries())
          .map(([k, v]) => `${k}:${v}`)
          .join(";")
          .concat(";");
      }

      function cssSizeToPx(value) {
        const raw = String(value ?? "").trim().toLowerCase();
        if (!raw) return 0;

        const m = /^(-?\d+(?:\.\d+)?)(px|pt|in|cm|mm)?$/.exec(raw);
        if (!m) return 0;

        const n = Number(m[1]);
        if (!Number.isFinite(n)) return 0;
        const unit = String(m[2] || "px").toLowerCase();

        const factors = { px: 1, pt: 96 / 72, in: 96, cm: 96 / 2.54, mm: 96 / 25.4 };
        const f = factors[unit] || 1;
        const px = n * f;
        if (!Number.isFinite(px) || px <= 0) return 0;
        return Math.max(1, Math.round(px));
      }

      function normalizeExcelCssValue(prop, valueRaw) {
        const propKey = String(prop || "").trim().toLowerCase();
        let value = String(valueRaw ?? "").trim();
        if (!value) return "";

        value = value.replace(/\bwindowtext\b/gi, "#000").replace(/\bwindow\b/gi, "#fff");
        if (propKey === "text-align" && value.toLowerCase() === "general") return "left";
        return value;
      }

      function parseMsoBorderAltToCss(valueRaw) {
        const raw = String(valueRaw ?? "").trim();
        if (!raw) return "";
        if (/^(none|0)\b/i.test(raw)) return "";

        const tokens = raw
          .replace(/["']/g, "")
          .trim()
          .split(/\s+/)
          .filter(Boolean)
          .map((t) => normalizeExcelCssValue("border", t));

        if (!tokens.length) return "";

        let width = "";
        let style = "";
        let color = "";

        for (const t of tokens) {
          if (!width && /^-?\d+(?:\.\d+)?(px|pt|in|cm|mm)$/i.test(t)) {
            width = t;
            continue;
          }
          if (!style && /^(solid|dashed|dotted|double|groove|ridge|inset|outset)$/i.test(t)) {
            style = t.toLowerCase();
            continue;
          }
          if (!color && (t.startsWith("#") || /^rgba?\(/i.test(t) || /^[a-z]+$/i.test(t))) {
            color = t;
            continue;
          }
        }

        if (!width) width = "1px";
        if (!style) style = "solid";
        if (!color) color = "#000";

        return `${width} ${style} ${color}`;
      }

      function filterExcelStyleDecls(map) {
        if (!(map instanceof Map)) return new Map();
        const out = new Map();

        for (const [kRaw, vRaw] of map.entries()) {
          const k = String(kRaw || "").trim().toLowerCase();
          if (!k) continue;

          const v = normalizeExcelCssValue(k, vRaw);
          if (!v) continue;

          if (k === "mso-number-format") continue;
          if (k.startsWith("mso-border") && k.endsWith("-alt")) {
            const cssBorder = parseMsoBorderAltToCss(vRaw);
            if (!cssBorder) continue;
            const side = /^mso-border-(top|right|bottom|left)-alt$/i.exec(k)?.[1];
            out.set(side ? `border-${side}` : "border", cssBorder);
            continue;
          }
          if (k.startsWith("mso-")) continue;

          if (
            k.startsWith("border") ||
            k === "background" ||
            k === "background-color" ||
            k === "color" ||
            k === "font" ||
            k === "font-weight" ||
            k === "font-style" ||
            k === "font-size" ||
            k === "font-family" ||
            k.startsWith("padding") ||
            k === "line-height" ||
            k === "text-decoration" ||
            k === "text-align" ||
            k === "vertical-align" ||
            k === "white-space"
          ) {
            out.set(k, v);
          }
        }

        return out;
      }

      function mergeStyleDecls(target, source) {
        if (!(target instanceof Map) || !(source instanceof Map)) return;
        for (const [k, v] of source.entries()) target.set(k, v);
      }

      function parseExcelCss(doc) {
        const baseTd = new Map();
        const baseTh = new Map();
        const byClass = new Map();

        const styleEls = doc ? Array.from(doc.querySelectorAll("style")) : [];
        const allCss = stripCssComments(styleEls.map((s) => String(s.textContent || "")).join("\n"));

        const re = /([^{}]+)\{([^}]*)\}/g;
        let m;
        while ((m = re.exec(allCss))) {
          const selText = String(m[1] || "").trim();
          if (!selText || selText.startsWith("@")) continue;

          const decls = filterExcelStyleDecls(parseStyleDeclarations(m[2]));
          if (!decls.size) continue;

          const selectors = selText
            .split(",")
            .map((x) => String(x || "").trim())
            .filter(Boolean);

          for (const sel of selectors) {
            const s = sel.toLowerCase();
            if (s === "td") {
              mergeStyleDecls(baseTd, decls);
              continue;
            }
            if (s === "th") {
              mergeStyleDecls(baseTh, decls);
              continue;
            }

            const clsOnly = /^\.([a-z0-9_-]+)$/i.exec(sel);
            const tdCls = /^td\.([a-z0-9_-]+)$/i.exec(sel);
            const thCls = /^th\.([a-z0-9_-]+)$/i.exec(sel);
            const cls = clsOnly?.[1] || tdCls?.[1] || thCls?.[1] || "";
            if (!cls) continue;

            if (!byClass.has(cls)) byClass.set(cls, new Map());
            mergeStyleDecls(byClass.get(cls), decls);
          }
        }

        return { baseTd, baseTh, byClass };
      }

      function buildExcelCellStyle(cellEl, cssMeta) {
        const tag = String(cellEl?.tagName || "").toUpperCase();
        const merged = new Map();

        const base = tag === "TH" ? cssMeta?.baseTh : cssMeta?.baseTd;
        if (base instanceof Map) mergeStyleDecls(merged, base);

        const classList = cellEl?.classList ? Array.from(cellEl.classList) : [];
        for (const c of classList) {
          const cls = String(c || "").trim();
          if (!cls) continue;
          const decls = cssMeta?.byClass?.get ? cssMeta.byClass.get(cls) : null;
          if (decls instanceof Map) mergeStyleDecls(merged, decls);
        }

        const attrStyle = new Map();
        const bg = String(cellEl?.getAttribute?.("bgcolor") || "").trim();
        if (bg) attrStyle.set("background-color", normalizeExcelCssValue("background-color", bg));
        const align = String(cellEl?.getAttribute?.("align") || "").trim();
        if (align) attrStyle.set("text-align", normalizeExcelCssValue("text-align", align));
        const valign = String(cellEl?.getAttribute?.("valign") || "").trim();
        if (valign) attrStyle.set("vertical-align", normalizeExcelCssValue("vertical-align", valign));
        if (cellEl?.hasAttribute?.("nowrap")) attrStyle.set("white-space", "nowrap");
        if (attrStyle.size) mergeStyleDecls(merged, filterExcelStyleDecls(attrStyle));

        const inline = filterExcelStyleDecls(parseStyleDeclarations(cellEl?.getAttribute?.("style") || ""));
        if (inline.size) mergeStyleDecls(merged, inline);

        return serializeStyleDeclarations(merged);
      }

      function sanitizeExcelText(text) {
        let s = String(text ?? "")
          .replace(/\r\n/g, "\n")
          .replace(/\r/g, "\n")
          .replace(/\u00a0/g, " ");

        // Excel/clipboard sometimes injects invisible Unicode chars that break placeholder parsing:
        // - ZERO WIDTH SPACE/JOINER/NBSP equivalents
        // - WORD JOINER, BOM, SOFT HYPHEN
        s = s.replace(/[\u200B-\u200D\u2060\uFEFF\u00AD]/g, "");

        // Drop other ASCII control chars (except \n and \t).
        s = s.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F]/g, "");

        try {
          if (typeof s.normalize === "function") s = s.normalize("NFC");
        } catch (_) {
          // ignore
        }

        return s;
      }

      function getExcelCellText(cellEl) {
        if (!cellEl) return "";
        let text = "";
        try {
          const clone = cellEl.cloneNode(true);
          clone
            .querySelectorAll?.("br")
            ?.forEach((br) => br.replaceWith(clone.ownerDocument.createTextNode("\n")));
          text = String(clone.textContent || "");
        } catch (_) {
          text = String(cellEl.textContent || "");
        }
        return sanitizeExcelText(text).trimEnd();
      }

      function pickBestTable(doc) {
        const tables = doc ? Array.from(doc.querySelectorAll("table")) : [];
        if (tables.length === 0) return null;
        if (tables.length === 1) return tables[0];
        let best = tables[0];
        let bestScore = 0;
        for (const t of tables) {
          const score = t.querySelectorAll("td,th").length;
          if (score > bestScore) {
            bestScore = score;
            best = t;
          }
        }
        return best;
      }

      function parsePlainTsvGrid(plainText) {
        const raw = String(plainText ?? "")
          .replace(/\r\n/g, "\n")
          .replace(/\r/g, "\n");
        if (!raw.trim()) return null;
        const lines = raw.split("\n");
        while (lines.length && !lines[lines.length - 1]) lines.pop();
        if (!lines.length) return null;
        return lines.map((l) => String(l).split("\t"));
      }

      function pickSquareCellSize(colWidths, rowHeights, fallbackPx) {
        const fallback = Math.max(8, Math.floor(Number(fallbackPx || 32)));

        const widths = [];
        for (const v of Object.values(colWidths || {})) {
          const n = Math.floor(Number(v));
          if (Number.isFinite(n) && n > 0) widths.push(n);
        }

        const heights = [];
        for (const v of Object.values(rowHeights || {})) {
          const n = Math.floor(Number(v));
          if (Number.isFinite(n) && n > 0) heights.push(n);
        }

        function median(list) {
          const arr = list.slice().sort((a, b) => a - b);
          if (!arr.length) return 0;
          const mid = Math.floor(arr.length / 2);
          if (arr.length % 2) return arr[mid];
          return Math.round((arr[mid - 1] + arr[mid]) / 2);
        }

        const mw = median(widths);
        const mh = median(heights);
        const picked = mw && mh ? Math.round((mw + mh) / 2) : mw || mh || fallback;
        return Math.max(8, Math.min(200, picked));
      }

      function buildTemplateConfigFromPlainGrid(plainGrid) {
        const rows = Math.max(1, plainGrid?.length || 0);
        let cols = 1;
        for (const row of plainGrid || []) cols = Math.max(cols, Array.isArray(row) ? row.length : 0);

        const cells = [];
        for (let r = 0; r < rows; r++) {
          const row = plainGrid?.[r] || [];
          for (let c = 0; c < cols; c++) {
            const v = row[c];
            if (v == null) continue;
            const text = sanitizeExcelText(v).trimEnd();
            if (!text) continue;
            cells.push({ addr: addrFromRC(c + 1, r + 1), text, class: ["cell"] });
          }
        }

        return {
          type: "excel-like-table",
          grid: { rows, cols, defaultColWidth: 32, defaultRowHeight: 32 },
          css: { cell: "padding:2px 4px;vertical-align:middle;background:#fff;color:#111;white-space:pre-wrap;" },
          defaultCellClass: ["cell"],
          merges: [],
          cells,
        };
      }

      function buildTemplateConfigFromExcelHtml(html, plainText) {
        const raw = String(html || "").trim();
        if (typeof DOMParser === "undefined") return { ok: false, error: "DOMParser not available in this environment." };
        const plainGrid = parsePlainTsvGrid(plainText);
        if (!raw) {
          if (plainGrid) return { ok: true, config: buildTemplateConfigFromPlainGrid(plainGrid) };
          return { ok: false, error: "Clipboard HTML is empty." };
        }

        const doc = new DOMParser().parseFromString(raw, "text/html");
        const table = pickBestTable(doc);
        if (!table) return { ok: false, error: "No <table> found in clipboard HTML. (Copy from Excel cells, not plain text.)" };

        const cssMeta = parseExcelCss(doc);
        const colWidths = {};
        const rowHeights = {};

        const colEls = Array.from(table.querySelectorAll("col"));
        for (let i = 0; i < colEls.length; i++) {
          const el = colEls[i];
          const w = cssSizeToPx(el?.style?.width) || cssSizeToPx(el?.getAttribute?.("width"));
          if (!w) continue;
          colWidths[indexToCol(i + 1)] = w;
        }

        const rows = Array.from(table.querySelectorAll("tr"));
        const occupied = [];
        let maxCol = 0;

        const cells = [];

        for (let r = 0; r < rows.length; r++) {
          const tr = rows[r];
          const rowNum = r + 1;

          const h = cssSizeToPx(tr?.style?.height) || cssSizeToPx(tr?.getAttribute?.("height"));
          if (h) rowHeights[String(rowNum)] = h;

          if (!occupied[r]) occupied[r] = [];
          let col = 1;
          let lastReal = null;
          let lastRealColspan = 1;

          const rowCells = Array.from(tr.children).filter((el) => /^(TD|TH)$/i.test(String(el?.tagName || "")));
          for (const cellEl of rowCells) {
            while (occupied[r] && occupied[r][col]) col++;

            const rawStyle = String(cellEl?.getAttribute?.("style") || "");
            const flags = {
              ignoreCol: /mso-ignore\s*:\s*colspan/i.test(rawStyle),
              ignoreRow: /mso-ignore\s*:\s*rowspan/i.test(rawStyle),
              displayNone: /display\s*:\s*none/i.test(rawStyle),
              visibilityHidden: /visibility\s*:\s*hidden/i.test(rawStyle),
            };

            const spanCols = Math.max(1, Math.floor(Number(cellEl?.getAttribute?.("colspan") || 1)));
            const spanRows = Math.max(1, Math.floor(Number(cellEl?.getAttribute?.("rowspan") || 1)));
            const text = getExcelCellText(cellEl);

            function markOccupied(startRowIdx0, startCol1, rowspan, colspan) {
              const rs = Math.max(1, Math.floor(Number(rowspan || 1)));
              const cs = Math.max(1, Math.floor(Number(colspan || 1)));
              for (let rr = 0; rr < rs; rr++) {
                const rowIdx = startRowIdx0 + rr;
                if (!occupied[rowIdx]) occupied[rowIdx] = [];
                for (let cc = 0; cc < cs; cc++) occupied[rowIdx][startCol1 + cc] = true;
              }
            }

            if (flags.displayNone) {
              if (text && lastReal && !String(lastReal.text || "").trim()) lastReal.text = text;
              continue;
            }

            // Excel clipboard may use colspan/rowspan or "mso-ignore:*" filler cells to represent overflow text.
            // We don't import merges, but we must still keep column positions aligned.
            const isFiller = flags.ignoreCol || flags.ignoreRow || flags.visibilityHidden;
            if (isFiller) {
              const hasOwnText = Boolean(String(text || "").trim());
              if (hasOwnText && (!lastReal || String(lastReal.text || "").trim())) {
                // If a filler-marked cell actually contains text, keep it as a real cell.
              } else {
                if (text && lastReal && !String(lastReal.text || "").trim()) lastReal.text = text;

                // If the previous real cell already has colspan > 1, filler "mso-ignore:colspan" cells are usually redundant.
                if (flags.ignoreCol && !flags.ignoreRow && !flags.visibilityHidden && lastReal && lastRealColspan > 1 && spanCols === 1 && spanRows === 1) {
                  continue;
                }

                markOccupied(r, col, spanRows, spanCols);
                maxCol = Math.max(maxCol, col + spanCols - 1);
                col += spanCols;
                continue;
              }
            }

            const addr = addrFromRC(col, rowNum);
            const style = buildExcelCellStyle(cellEl, cssMeta);
            let entry = null;
            if (style || text) {
              entry = { addr, text, class: ["cell"] };
              if (style) entry.style = style;
              cells.push(entry);
            }

            markOccupied(r, col, spanRows, spanCols);
            maxCol = Math.max(maxCol, col + spanCols - 1);
            col += spanCols;
            if (entry) {
              lastReal = entry;
              lastRealColspan = spanCols;
            }
          }
        }

        const cellSize = pickSquareCellSize(colWidths, rowHeights, 32);

        const cfg = {
          type: "excel-like-table",
          grid: {
            rows: Math.max(1, rows.length),
            cols: Math.max(1, maxCol || colEls.length || 1),
            defaultColWidth: cellSize,
            defaultRowHeight: cellSize,
          },
          css: {
            cell: "padding:2px 4px;vertical-align:middle;background:#fff;color:#111;white-space:pre-wrap;",
          },
          defaultCellClass: ["cell"],
          merges: [],
          cells,
        };

        return { ok: true, config: cfg };
      }

      ns.templateExcelImport = {
        buildTemplateConfigFromExcelHtml,
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/template_excel_export.js
    (function (ns) {
      "use strict";

      function escapeHtml(text) {
        return String(text ?? "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function setCellHtmlFromText(cellEl, text) {
        const normalized = String(text ?? "")
          .replace(/\r\n/g, "\n")
          .replace(/\r/g, "\n")
          .replace(/\u00a0/g, " ");
        cellEl.innerHTML = escapeHtml(normalized).replace(/\n/g, "<br>");
      }

      function normalizeColorToHex(colorRaw) {
        const raw = String(colorRaw || "").trim();
        if (!raw) return "";
        if (/^(transparent|none)$/i.test(raw)) return "";

        const hex = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.exec(raw);
        if (hex) {
          const h = hex[1].toLowerCase();
          if (h.length === 3) return `#${h[0]}${h[0]}${h[1]}${h[1]}${h[2]}${h[2]}`;
          return `#${h}`;
        }

        const rgb = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*([\d.]+)\s*)?\)$/i.exec(raw);
        if (rgb) {
          const alpha = rgb[4] != null ? Number(rgb[4]) : 1;
          if (!Number.isFinite(alpha) || alpha <= 0) return "";
          const r = Math.max(0, Math.min(255, Number(rgb[1])));
          const g = Math.max(0, Math.min(255, Number(rgb[2])));
          const b = Math.max(0, Math.min(255, Number(rgb[3])));
          const toHex = (n) => n.toString(16).padStart(2, "0");
          return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        return raw;
      }

      function parseCssBorder(cssBorder) {
        const raw = String(cssBorder || "").trim();
        if (!raw) return null;
        if (/^0(?:px|pt)?\s+/i.test(raw)) return null;

        const m = /^(\d+(?:\.\d+)?)(px|pt)?\s+([a-z]+)\s+(.+)$/i.exec(raw);
        if (!m) return null;

        const width = Number(m[1]);
        if (!Number.isFinite(width) || width <= 0) return null;

        const unit = String(m[2] || "px").toLowerCase();
        const style = String(m[3] || "").toLowerCase();
        const color = normalizeColorToHex(m[4]);

        if (!style || style === "none" || style === "hidden") return null;
        if (!color) return null;

        let pt = width;
        if (unit === "px") pt = (width * 72) / 96;
        pt = Math.max(0.25, pt);
        const ptText = `${Math.round(pt * 100) / 100}pt`;

        return { style, color, ptText };
      }

      function borderToExcelCss(cssBorder) {
        const parts = parseCssBorder(cssBorder);
        if (!parts) return { css: "", msoAlt: "" };
        return {
          css: `${parts.ptText} ${parts.style} ${parts.color}`,
          msoAlt: `${parts.style} ${parts.color} ${parts.ptText}`,
        };
      }

      function inlineComputedCellStyles(dstCell, srcCell) {
        if (!dstCell || !srcCell || typeof window === "undefined" || typeof window.getComputedStyle !== "function") return;

        let cs = null;
        try {
          cs = window.getComputedStyle(srcCell);
        } catch (_) {
          cs = null;
        }
        if (!cs) return;

        const top = borderToExcelCss(cs.borderTop);
        const right = borderToExcelCss(cs.borderRight);
        const bottom = borderToExcelCss(cs.borderBottom);
        const left = borderToExcelCss(cs.borderLeft);

        dstCell.style.border = "none";
        if (top.css) dstCell.style.borderTop = top.css;
        if (right.css) dstCell.style.borderRight = right.css;
        if (bottom.css) dstCell.style.borderBottom = bottom.css;
        if (left.css) dstCell.style.borderLeft = left.css;

        if (top.msoAlt) dstCell.style.setProperty("mso-border-top-alt", top.msoAlt);
        if (right.msoAlt) dstCell.style.setProperty("mso-border-right-alt", right.msoAlt);
        if (bottom.msoAlt) dstCell.style.setProperty("mso-border-bottom-alt", bottom.msoAlt);
        if (left.msoAlt) dstCell.style.setProperty("mso-border-left-alt", left.msoAlt);

        if (top.msoAlt && top.msoAlt === right.msoAlt && top.msoAlt === bottom.msoAlt && top.msoAlt === left.msoAlt) {
          dstCell.style.setProperty("mso-border-alt", top.msoAlt);
        }

        if (cs.backgroundColor && cs.backgroundColor !== "rgba(0, 0, 0, 0)" && cs.backgroundColor !== "transparent") {
          dstCell.style.backgroundColor = cs.backgroundColor;
        }
        if (cs.color) dstCell.style.color = cs.color;

        if (cs.fontWeight) dstCell.style.fontWeight = cs.fontWeight;
        if (cs.fontStyle) dstCell.style.fontStyle = cs.fontStyle;
        if (cs.fontSize) dstCell.style.fontSize = cs.fontSize;
        if (cs.fontFamily) dstCell.style.fontFamily = cs.fontFamily;
        if (cs.lineHeight) dstCell.style.lineHeight = cs.lineHeight;

        if (cs.textAlign) dstCell.style.textAlign = cs.textAlign;
        if (cs.verticalAlign) dstCell.style.verticalAlign = cs.verticalAlign;
        if (cs.whiteSpace) dstCell.style.whiteSpace = cs.whiteSpace;

        if (cs.paddingTop) dstCell.style.paddingTop = cs.paddingTop;
        if (cs.paddingRight) dstCell.style.paddingRight = cs.paddingRight;
        if (cs.paddingBottom) dstCell.style.paddingBottom = cs.paddingBottom;
        if (cs.paddingLeft) dstCell.style.paddingLeft = cs.paddingLeft;

        const styleAttr = String(dstCell.getAttribute("style") || "").trim();
        if (!/mso-number-format\s*:/i.test(styleAttr)) {
          const suffix = 'mso-number-format:"\\@";';
          dstCell.setAttribute("style", (styleAttr ? (styleAttr.endsWith(";") ? styleAttr : `${styleAttr};`) : "") + suffix);
        }
      }

      function cleanCloneOfTable(table) {
        const clone = table.cloneNode(true);

        clone.setAttribute("cellpadding", "0");
        clone.setAttribute("cellspacing", "0");
        clone.setAttribute("border", "1");
        clone.style.borderCollapse = "collapse";
        clone.style.borderSpacing = "0";
        clone.style.setProperty("mso-table-lspace", "0pt");
        clone.style.setProperty("mso-table-rspace", "0pt");

        const srcCells = table.querySelectorAll("td,th");
        const dstCells = clone.querySelectorAll("td,th");
        let tableBorderAlt = "";
        for (let i = 0; i < dstCells.length; i++) {
          const td = dstCells[i];
          const src = srcCells[i] || null;
          td.classList.remove("is-selected", "is-editing");
          td.removeAttribute("data-addr");
          td.removeAttribute("data-bind");
          td.removeAttribute("title");

          const editor = td.querySelector("textarea.cell-editor");
          const text = editor ? String(editor.value ?? editor.textContent ?? "") : String(td.textContent ?? "");
          setCellHtmlFromText(td, text);

          td.querySelectorAll("textarea.cell-editor").forEach((ta) => ta.remove());
          inlineComputedCellStyles(td, src);

          if (!tableBorderAlt) {
            const s = String(td.getAttribute("style") || "");
            const m = /mso-border-alt\s*:\s*([^;]+);?/i.exec(s);
            if (m) tableBorderAlt = String(m[1] || "").trim();
          }
        }

        if (tableBorderAlt) {
          clone.style.setProperty("mso-border-alt", tableBorderAlt);
          clone.style.setProperty("mso-border-insideh", tableBorderAlt);
          clone.style.setProperty("mso-border-insidev", tableBorderAlt);
        }

        return clone;
      }

      function wrapExcelHtmlFragment(fragmentHtml) {
        const frag = String(fragmentHtml || "");
        return (
          '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">' +
          "<head><meta charset=\"utf-8\"></head>" +
          "<body><!--StartFragment-->" +
          frag +
          "<!--EndFragment--></body></html>"
        );
      }

      function tableToHtml(table) {
        const clone = cleanCloneOfTable(table);
        return clone.outerHTML;
      }

      function tableToTsv(table) {
        const rows = Array.from(table?.rows || []);
        const occupied = [];
        const grid = [];
        let maxCols = 0;

        for (let r = 0; r < rows.length; r++) {
          const tr = rows[r];
          if (!occupied[r]) occupied[r] = [];
          const row = [];
          let col = 0;

          const cells = Array.from(tr?.cells || []);
          for (const cell of cells) {
            while (occupied[r][col]) col++;

            const rowspan = Math.max(1, Math.floor(Number(cell?.rowSpan || 1)));
            const colspan = Math.max(1, Math.floor(Number(cell?.colSpan || 1)));
            const text = String(cell?.innerText ?? cell?.textContent ?? "")
              .replace(/\r\n/g, "\n")
              .replace(/\r/g, "\n")
              .replace(/\u00a0/g, " ")
              .trimEnd();

            row[col] = text;

            for (let rr = 0; rr < rowspan; rr++) {
              const rowIdx = r + rr;
              if (!occupied[rowIdx]) occupied[rowIdx] = [];
              for (let cc = 0; cc < colspan; cc++) {
                occupied[rowIdx][col + cc] = true;
              }
            }

            col += colspan;
            maxCols = Math.max(maxCols, col);
          }

          grid[r] = row;
        }

        const lines = [];
        for (let r = 0; r < grid.length; r++) {
          const row = grid[r] || [];
          const out = [];
          for (let c = 0; c < maxCols; c++) out.push(String(row[c] ?? ""));
          lines.push(out.join("\t"));
        }
        return lines.join("\n");
      }

      async function copyHtmlToClipboard(html, plainText) {
        const h = String(html || "");
        const t = String(plainText || "");

        if (document?.execCommand) {
          const host = document.createElement("div");
          host.contentEditable = "true";
          host.style.position = "fixed";
          host.style.left = "-10000px";
          host.style.top = "0";
          host.style.width = "1px";
          host.style.height = "1px";
          host.style.opacity = "0";
          host.innerHTML = h;

          document.body.appendChild(host);
          try {
            host.focus();
          } catch (_) {}

          const range = document.createRange();
          range.selectNodeContents(host);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);

          let ok = false;
          try {
            ok = Boolean(document.execCommand("copy"));
          } catch (_) {
            ok = false;
          }

          sel.removeAllRanges();
          host.remove();

          if (ok) return { ok: true, method: "execCommand" };
        }

        if (navigator?.clipboard?.write && typeof ClipboardItem !== "undefined") {
          const wrapped = wrapExcelHtmlFragment(h);
          const item = new ClipboardItem({
            "text/html": new Blob([wrapped], { type: "text/html" }),
            ...(t ? { "text/plain": new Blob([t], { type: "text/plain" }) } : {}),
          });
          await navigator.clipboard.write([item]);
          return { ok: true, method: "clipboard.write" };
        }

        if (navigator?.clipboard?.writeText) {
          await navigator.clipboard.writeText(t || "");
          return { ok: true, method: "writeText" };
        }

        return { ok: false, error: "Clipboard API not available." };
      }

      async function copyExcelLikeTableToClipboard(tableEl) {
        if (!tableEl) return { ok: false, error: "No table to copy." };
        const html = tableToHtml(tableEl);
        const tsv = tableToTsv(tableEl);
        return await copyHtmlToClipboard(html, tsv);
      }

      ns.templateExcelExport = {
        copyExcelLikeTableToClipboard,
        toExcelHtml: (tableEl) => (tableEl ? wrapExcelHtmlFragment(tableToHtml(tableEl)) : ""),
        toHtml: (tableEl) => (tableEl ? tableToHtml(tableEl) : ""),
        toTsv: (tableEl) => (tableEl ? tableToTsv(tableEl) : ""),
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/template_editor_ui.js
    (function (ns) {
      "use strict";

      const store = ns.templateDefs || null;
      let selectedAddr = "";
      const EDITOR_SPLIT_KEY = "abapflow-template-editor-left-px";

      function $(id) {
        return document.getElementById(id);
      }

      function asNonEmptyString(x) {
        const s = String(x ?? "").trim();
        return s ? s : "";
      }

      function setStatus(message, isError) {
        const el = $("statusBar");
        if (!el) return;
        el.textContent = String(message || "");
        el.style.color = isError ? "#fecaca" : "";
      }

      function parseJsonStrict(text) {
        const raw = String(text || "").trim();
        if (!raw) return { ok: false, error: "Empty JSON." };
        try {
          return { ok: true, value: JSON.parse(raw) };
        } catch (e) {
          return { ok: false, error: String(e?.message || e) };
        }
      }

      function validateTemplateConfig(cfg) {
        if (!cfg || typeof cfg !== "object") return "Template config must be an object.";
        if (cfg.type !== "excel-like-table") return 'Only type "excel-like-table" is supported.';
        return "";
      }

      function normalizeAddress(addr) {
        return String(addr || "").trim().toUpperCase();
      }

      function colToIndex(colLetters) {
        const s = String(colLetters || "").trim().toUpperCase();
        if (!/^[A-Z]+$/.test(s)) return 0;
        let n = 0;
        for (let i = 0; i < s.length; i++) n = n * 26 + (s.charCodeAt(i) - 64);
        return n;
      }

      function indexToCol(index1) {
        let n = Number(index1);
        if (!Number.isFinite(n) || n <= 0) return "";
        n = Math.floor(n);
        let s = "";
        while (n > 0) {
          const rem = (n - 1) % 26;
          s = String.fromCharCode(65 + rem) + s;
          n = Math.floor((n - 1) / 26);
        }
        return s;
      }

      function parseAddress(addr) {
        const s = normalizeAddress(addr);
        const m = /^([A-Z]+)(\d+)$/.exec(s);
        if (!m) return null;
        const colIndex = colToIndex(m[1]);
        const row = Number(m[2]);
        if (!Number.isFinite(colIndex) || !Number.isFinite(row) || colIndex <= 0 || row <= 0) return null;
        return { col: m[1], colIndex, row };
      }

      function addrFromRC(colIndex, row) {
        return `${indexToCol(colIndex)}${row}`;
      }

      function listRegistryTemplates() {
        const templates =
          ns.templateRegistry?.templates && typeof ns.templateRegistry.templates === "object" ? ns.templateRegistry.templates : {};
        const order = Array.isArray(ns.templateRegistry?.order)
          ? ns.templateRegistry.order
          : Object.keys(templates).sort((a, b) => a.localeCompare(b));

        const out = [];
        for (const id of order) {
          const t = templates[id];
          if (!t || typeof t !== "object") continue;
          out.push({ ...t, id: String(t.id || id) });
        }
        return out;
      }

      function listAllTemplates() {
        const registry = listRegistryTemplates();
        const map = new Map(registry.map((t) => [t.id, { ...t, _origin: "registry" }]));

        const custom = store && typeof store.listCustomTemplateEntries === "function" ? store.listCustomTemplateEntries() : [];
        for (const t of custom) {
          if (!t || typeof t !== "object") continue;
          const id = asNonEmptyString(t.id);
          if (!id || map.has(id)) continue;
          map.set(id, { ...t, _origin: "store" });
        }

        return Array.from(map.values()).sort((a, b) => String(a.id || "").localeCompare(String(b.id || "")));
      }

      function populateTemplateSelect(selectedId) {
        const sel = $("tplSelect");
        if (!sel) return;

        const templates = listAllTemplates();
        sel.replaceChildren();

        for (const t of templates) {
          const opt = document.createElement("option");
          opt.value = String(t.id || "");

          const label = String(t.label || "").trim();
          const src = String(t.source || t.objectId || "").trim();
          const parts = [opt.value];
          if (label && label !== opt.value) parts.push(`- ${label}`);
          if (src) parts.push(`(${src})`);
          opt.textContent = parts.join(" ");

          sel.appendChild(opt);
        }

        const want = asNonEmptyString(selectedId);
        if (want && Array.from(sel.options).some((o) => o.value === want)) sel.value = want;
      }

      function populateSourceSelect(selectedId) {
        const sel = $("tplSource");
        if (!sel) return;

        const reg = ns.abapObjects?.getRegistry?.() || null;
        const ids = reg?.objectsById?.keys ? Array.from(reg.objectsById.keys()) : [];
        ids.sort((a, b) => String(a).localeCompare(String(b)));

        sel.replaceChildren();
        for (const id of ids) {
          const opt = document.createElement("option");
          opt.value = String(id || "");
          opt.textContent = opt.value;
          sel.appendChild(opt);
        }

        const want = asNonEmptyString(selectedId);
        if (want && Array.from(sel.options).some((o) => o.value === want)) sel.value = want;
      }

      function getTemplateMeta(templateId) {
        const id = asNonEmptyString(templateId);
        const regEntry = ns.templateRegistry?.templates?.[id] || null;
        const stored = store && typeof store.loadStore === "function" ? store.loadStore().templates?.[id] || null : null;
        const meta = stored?.meta || {};

        const label = asNonEmptyString(meta.label) || asNonEmptyString(regEntry?.label) || id;
        const source = asNonEmptyString(meta.source) || asNonEmptyString(regEntry?.source) || asNonEmptyString(regEntry?.objectId);
        const auto = meta.auto != null ? meta.auto !== false : regEntry?.auto !== false;
        const when = meta.when || regEntry?.when || null;
        const custom = Boolean(meta.custom) || (!regEntry && Boolean(stored));

        return { id, label, source, auto, when, custom };
      }

      function getTemplateConfig(templateId) {
        const id = asNonEmptyString(templateId);
        if (!id) return null;

        const override = store && typeof store.getTemplateConfig === "function" ? store.getTemplateConfig(id) : null;
        if (override) return override;

        return ns.templateRegistry?.templates?.[id]?.config || null;
      }

      function loadTemplate(templateId) {
        const id = asNonEmptyString(templateId);
        if (!id) return;

        const cfg = getTemplateConfig(id);
        if (!cfg) {
          setStatus(`Template config not found: ${id}`, true);
          return;
        }

        const meta = getTemplateMeta(id);

        $("tplId").value = meta.id;
        $("tplLabel").value = meta.label;
        populateSourceSelect(meta.source);

        $("tplAuto").checked = meta.auto !== false;
        $("tplWhenPath").value = String(meta.when?.path || "");
        $("tplWhenEquals").value = String(meta.when?.equals || "");

        const preferredId = store && typeof store.getPreferredTemplateId === "function" ? store.getPreferredTemplateId(meta.source) : "";
        $("tplPreferred").checked = preferredId === id;

        writeTemplateJson(cfg);
        renderPreview();

        setStatus(`Loaded: ${id}`, false);
      }

      function buildWhenFromForm() {
        const path = asNonEmptyString($("tplWhenPath")?.value);
        const equals = asNonEmptyString($("tplWhenEquals")?.value);
        if (!path || !equals) return null;
        return { path, equals };
      }

      function readTemplateJsonFromEditor() {
        const parsed = parseJsonStrict($("tplJson")?.value);
        if (!parsed.ok) return parsed;

        const err = validateTemplateConfig(parsed.value);
        if (err) return { ok: false, error: err };
        return parsed;
      }

      function syncCompactFormFromConfig(cfg) {
        const el = $("tplCompactRemoveEmptyRows");
        if (!el) return;
        el.checked = Boolean(cfg?.compact?.removeEmptyRows);
      }

      function syncCompactFormFromEditorJson() {
        const parsed = readTemplateJsonFromEditor();
        if (!parsed.ok) return;
        syncCompactFormFromConfig(parsed.value);
      }

      function applyCompactFormToConfig(cfg) {
        if (!cfg || typeof cfg !== "object") return;
        const el = $("tplCompactRemoveEmptyRows");
        if (!el) return;

        if (el.checked) {
          if (!cfg.compact || typeof cfg.compact !== "object") cfg.compact = {};
          cfg.compact.removeEmptyRows = true;
          return;
        }

        if (cfg.compact && typeof cfg.compact === "object") {
          delete cfg.compact.removeEmptyRows;
          if (!Object.keys(cfg.compact).length) delete cfg.compact;
        }
      }

      function writeTemplateJson(cfg) {
        $("tplJson").value = JSON.stringify(cfg, null, 2);
        syncCompactFormFromConfig(cfg);
      }

      function upsertCellText(cfg, addrRaw, textValue) {
        if (!cfg || typeof cfg !== "object") return;
        cfg.cells = Array.isArray(cfg.cells) ? cfg.cells : [];

        const addr = normalizeAddress(addrRaw);
        if (!addr) return;

        const text = String(textValue ?? "");
        const idx = cfg.cells.findIndex((c) => normalizeAddress(c?.addr) === addr);
        if (idx >= 0) {
          cfg.cells[idx] = { ...(cfg.cells[idx] || {}), addr, text };
          return;
        }
        cfg.cells.push({ addr, text });
      }

      function parseStyleDeclarations(styleText) {
        const map = new Map();
        const raw = String(styleText || "").trim();
        if (!raw) return map;

        const parts = raw.split(";");
        for (const part of parts) {
          const t = String(part || "").trim();
          if (!t) continue;
          const idx = t.indexOf(":");
          if (idx <= 0) continue;
          const prop = t.slice(0, idx).trim().toLowerCase();
          const value = t.slice(idx + 1).trim();
          if (!prop) continue;
          map.set(prop, value);
        }
        return map;
      }

      function serializeStyleDeclarations(map) {
        if (!map || map.size === 0) return "";
        return Array.from(map.entries())
          .map(([k, v]) => `${k}:${v}`)
          .join(";")
          .concat(";");
      }

      function upsertCellStyleProp(cfg, addrRaw, propRaw, valueRaw) {
        if (!cfg || typeof cfg !== "object") return;
        cfg.cells = Array.isArray(cfg.cells) ? cfg.cells : [];

        const addr = normalizeAddress(addrRaw);
        if (!addr) return;

        const prop = String(propRaw || "").trim().toLowerCase();
        if (!prop) return;
        const value = String(valueRaw ?? "").trim();

        const idx = cfg.cells.findIndex((c) => normalizeAddress(c?.addr) === addr);
        const existing = idx >= 0 ? cfg.cells[idx] : null;
        const next = { ...(existing || {}), addr };

        const decls = parseStyleDeclarations(next.style);
        if (!value) decls.delete(prop);
        else decls.set(prop, value);

        const style = serializeStyleDeclarations(decls);
        if (style) next.style = style;
        else delete next.style;

        if (idx >= 0) cfg.cells[idx] = next;
        else cfg.cells.push(next);
      }

      function clearCellStyle(cfg, addrRaw) {
        if (!cfg || typeof cfg !== "object") return;
        cfg.cells = Array.isArray(cfg.cells) ? cfg.cells : [];
        const addr = normalizeAddress(addrRaw);
        if (!addr) return;
        const idx = cfg.cells.findIndex((c) => normalizeAddress(c?.addr) === addr);
        if (idx < 0) return;
        const existing = cfg.cells[idx] || {};
        if (existing.style == null) return;
        const next = { ...existing };
        delete next.style;
        cfg.cells[idx] = next;
      }

      function hex2(x) {
        return String(x || "").padStart(2, "0");
      }

      function rgbToHex(r, g, b) {
        const rr = Math.max(0, Math.min(255, Math.floor(Number(r))));
        const gg = Math.max(0, Math.min(255, Math.floor(Number(g))));
        const bb = Math.max(0, Math.min(255, Math.floor(Number(b))));
        return `#${hex2(rr.toString(16))}${hex2(gg.toString(16))}${hex2(bb.toString(16))}`.toLowerCase();
      }

      function parseCssColorToHex(colorText, fallback) {
        const raw = String(colorText || "").trim();
        if (!raw) return fallback || "";
        const s = raw.toLowerCase();
        if (s === "transparent") return fallback || "";

        const hex = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.exec(raw);
        if (hex) {
          const h = hex[1];
          if (h.length === 3) return `#${h[0]}${h[0]}${h[1]}${h[1]}${h[2]}${h[2]}`.toLowerCase();
          return `#${h}`.toLowerCase();
        }

        const m = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i.exec(s);
        if (m) return rgbToHex(m[1], m[2], m[3]);

        return fallback || "";
      }

      function setPreviewToolbarEnabled(enabled) {
        const on = Boolean(enabled);
        const ids = ["btnPreviewDeleteRow", "btnPreviewDeleteCol", "btnClearFormat", "selBgColor", "selTextColor", "selBorder", "btnApplyBorder"];
        for (const id of ids) {
          const el = $(id);
          if (el) el.disabled = !on;
        }
      }

      function syncPreviewToolbarFromSelection() {
        const label = $("selAddr");
        if (label) label.textContent = selectedAddr || "-";

        if (!selectedAddr) {
          setPreviewToolbarEnabled(false);
          return;
        }

        const host = $("previewHost");
        const td = host ? host.querySelector(`td[data-addr="${selectedAddr}"]`) : null;
        if (!td || !window.getComputedStyle) {
          setPreviewToolbarEnabled(false);
          return;
        }

        const css = window.getComputedStyle(td);
        const bg = parseCssColorToHex(css.backgroundColor, "#ffffff");
        const fg = parseCssColorToHex(css.color, "#111111");

        const bgEl = $("selBgColor");
        const fgEl = $("selTextColor");
        const borderEl = $("selBorder");

        if (bgEl && bg) bgEl.value = bg;
        if (fgEl && fg) fgEl.value = fg;
        if (borderEl) borderEl.value = String(css.border || "").trim();

        setPreviewToolbarEnabled(true);
      }

      function initEditorSplitter() {
        const main = document.querySelector(".app-main.editor-main");
        const splitter = $("editorSplitter");
        const leftPanel = document.querySelector(".panel.panel-left");

        if (!main || !splitter || !leftPanel) return;

        function readStored() {
          try {
            const n = Number(localStorage.getItem(EDITOR_SPLIT_KEY));
            return Number.isFinite(n) && n > 0 ? n : 0;
          } catch (_) {
            return 0;
          }
        }

        function writeStored(px) {
          try {
            localStorage.setItem(EDITOR_SPLIT_KEY, String(Math.round(px)));
          } catch (_) {}
        }

        function clampLeft(px) {
          const mainW = main.getBoundingClientRect().width;
          const splitterW = splitter.getBoundingClientRect().width;
          const minLeft = 320;
          const minRight = 320;
          const maxLeft = Math.max(minLeft, mainW - minRight - splitterW);
          return Math.max(minLeft, Math.min(maxLeft, px));
        }

        function applyLeft(px) {
          main.style.setProperty("--editor-left", `${Math.round(px)}px`);
        }

        const stored = readStored();
        if (stored) applyLeft(clampLeft(stored));

        let dragging = false;
        let startX = 0;
        let startLeft = 0;
        let lastApplied = 0;

        function onMove(e) {
          if (!dragging) return;
          const dx = Number(e.clientX) - startX;
          const next = clampLeft(startLeft + dx);
          if (Math.abs(next - lastApplied) < 1) return;
          lastApplied = next;
          applyLeft(next);
        }

        function stopDrag() {
          if (!dragging) return;
          dragging = false;
          splitter.classList.remove("is-dragging");
          document.body.style.cursor = "";
          document.body.style.userSelect = "";
          if (lastApplied) writeStored(lastApplied);
          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", stopDrag);
          window.removeEventListener("pointercancel", stopDrag);
        }

        splitter.addEventListener("pointerdown", (e) => {
          if (!e || typeof e.clientX !== "number") return;
          dragging = true;
          splitter.classList.add("is-dragging");
          splitter.setPointerCapture?.(e.pointerId);
          startX = e.clientX;
          startLeft = leftPanel.getBoundingClientRect().width;
          lastApplied = startLeft;
          document.body.style.cursor = "col-resize";
          document.body.style.userSelect = "none";
          window.addEventListener("pointermove", onMove);
          window.addEventListener("pointerup", stopDrag);
          window.addEventListener("pointercancel", stopDrag);
        });

        splitter.addEventListener("keydown", (e) => {
          if (!e) return;
          if (e.key !== "ArrowLeft" && e.key !== "ArrowRight") return;
          e.preventDefault();
          const delta = e.key === "ArrowLeft" ? -24 : 24;
          const cur = leftPanel.getBoundingClientRect().width;
          const next = clampLeft(cur + delta);
          applyLeft(next);
          writeStored(next);
        });

        window.addEventListener("resize", () => {
          const cur = leftPanel.getBoundingClientRect().width;
          const next = clampLeft(cur);
          if (Math.abs(next - cur) >= 1) applyLeft(next);
        });
      }

      function shiftRowHeightsOnDelete(rowHeights, delRow) {
        const src = rowHeights && typeof rowHeights === "object" ? rowHeights : {};
        const out = {};
        for (const [k, v] of Object.entries(src)) {
          const r = Number(k);
          if (!Number.isFinite(r) || r <= 0) continue;
          if (r === delRow) continue;
          const nr = r > delRow ? r - 1 : r;
          out[String(nr)] = v;
        }
        return out;
      }

      function shiftColWidthsOnDelete(colWidths, delColIndex) {
        const src = colWidths && typeof colWidths === "object" ? colWidths : {};
        const out = {};
        for (const [k, v] of Object.entries(src)) {
          const idx = colToIndex(k);
          if (!idx) continue;
          if (idx === delColIndex) continue;
          const nidx = idx > delColIndex ? idx - 1 : idx;
          const nk = indexToCol(nidx);
          if (!nk) continue;
          out[nk] = v;
        }
        return out;
      }

      function deleteRow(cfg, delRow) {
        if (!cfg || cfg.type !== "excel-like-table") return { ok: false, error: "Invalid template config." };
        const grid = cfg.grid && typeof cfg.grid === "object" ? cfg.grid : null;
        if (!grid) return { ok: false, error: "Missing grid." };

        const rows = Math.max(1, Math.floor(Number(grid.rows || 1)));
        const cols = Math.max(1, Math.floor(Number(grid.cols || 1)));
        const r = Math.floor(Number(delRow));
        if (!Number.isFinite(r) || r < 1 || r > rows) return { ok: false, error: `Row out of range: ${delRow}` };

        const cells = Array.isArray(cfg.cells) ? cfg.cells : [];
        cfg.cells = cells
          .map((c) => {
            const a = parseAddress(c?.addr);
            if (!a) return c;
            if (a.row === r) return null;
            const nr = a.row > r ? a.row - 1 : a.row;
            return { ...c, addr: addrFromRC(a.colIndex, nr) };
          })
          .filter(Boolean);

        grid.rowHeights = shiftRowHeightsOnDelete(grid.rowHeights, r);
        grid.rows = Math.max(1, rows - 1);
        cfg.merges = [];

        return { ok: true, row: r };
      }

      function deleteCol(cfg, delColIndex) {
        if (!cfg || cfg.type !== "excel-like-table") return { ok: false, error: "Invalid template config." };
        const grid = cfg.grid && typeof cfg.grid === "object" ? cfg.grid : null;
        if (!grid) return { ok: false, error: "Missing grid." };

        const rows = Math.max(1, Math.floor(Number(grid.rows || 1)));
        const cols = Math.max(1, Math.floor(Number(grid.cols || 1)));
        const cidx = Math.floor(Number(delColIndex));
        if (!Number.isFinite(cidx) || cidx < 1 || cidx > cols) return { ok: false, error: `Column out of range: ${delColIndex}` };

        const cells = Array.isArray(cfg.cells) ? cfg.cells : [];
        cfg.cells = cells
          .map((c) => {
            const a = parseAddress(c?.addr);
            if (!a) return c;
            if (a.colIndex === cidx) return null;
            const nc = a.colIndex > cidx ? a.colIndex - 1 : a.colIndex;
            return { ...c, addr: addrFromRC(nc, a.row) };
          })
          .filter(Boolean);

        grid.colWidths = shiftColWidthsOnDelete(grid.colWidths, cidx);
        grid.cols = Math.max(1, cols - 1);
        cfg.merges = [];

        return { ok: true, colIndex: cidx, col: indexToCol(cidx) };
      }

      function highlightSelectedCell() {
        const host = $("previewHost");
        if (!host) return;
        host.querySelectorAll("td.is-selected").forEach((td) => td.classList.remove("is-selected"));
        if (!selectedAddr) return;
        const td = host.querySelector(`td[data-addr="${selectedAddr}"]`);
        if (td) td.classList.add("is-selected");
      }

      function selectCell(addr) {
        selectedAddr = normalizeAddress(addr);
        highlightSelectedCell();
        syncPreviewToolbarFromSelection();
        if (selectedAddr) setStatus(`Selected: ${selectedAddr}`, false);
      }

      function cancelCellEdit(td) {
        td?.classList?.remove("is-editing");
        renderPreview();
        highlightSelectedCell();
      }

      function startCellEdit(td, addr) {
        const host = $("previewHost");
        if (!host || !td) return;

        const parsed = readTemplateJsonFromEditor();
        if (!parsed.ok) {
          setStatus(String(parsed.error || "Invalid template JSON."), true);
          return;
        }

        const cfg = parsed.value;
        const cellAddr = normalizeAddress(addr);
        if (!cellAddr) return;
        selectedAddr = cellAddr;

        const existing = Array.isArray(cfg.cells) ? cfg.cells.find((c) => normalizeAddress(c?.addr) === cellAddr) : null;
        const initial = existing ? String(existing.text ?? "") : "";

        host.querySelectorAll("td.is-editing").forEach((x) => x.classList.remove("is-editing"));
        td.classList.add("is-editing");
        td.textContent = "";

        const editor = document.createElement("textarea");
        editor.className = "cell-editor";
        editor.value = initial;
        editor.rows = 1;
        td.appendChild(editor);
        editor.focus();
        editor.setSelectionRange(editor.value.length, editor.value.length);

        let finished = false;
        function finish(commit) {
          if (finished) return;
          finished = true;

          if (!commit) {
            cancelCellEdit(td);
            return;
          }

          const nextCfg = readTemplateJsonFromEditor();
          if (!nextCfg.ok) {
            setStatus(String(nextCfg.error || "Invalid template JSON."), true);
            cancelCellEdit(td);
            return;
          }

          upsertCellText(nextCfg.value, cellAddr, editor.value);
          writeTemplateJson(nextCfg.value);
          renderPreview();
          highlightSelectedCell();
          setStatus(`Updated: ${cellAddr}`, false);
        }

        editor.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            e.preventDefault();
            finish(false);
            return;
          }
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            finish(true);
          }
        });
        editor.addEventListener("blur", () => finish(true));
      }

      function deleteSelectedRow() {
        const parsedSel = parseAddress(selectedAddr);
        const row = parsedSel?.row;
        if (!row) {
          const raw = window.prompt("Row number to delete:", "");
          const n = Math.floor(Number(raw));
          if (!Number.isFinite(n) || n <= 0) {
            setStatus("Invalid row number.", true);
            return;
          }
          selectedAddr = `A${n}`;
          return deleteSelectedRow();
        }

        const parsed = readTemplateJsonFromEditor();
        if (!parsed.ok) {
          setStatus(String(parsed.error || "Invalid template JSON."), true);
          return;
        }

        const rows = Math.max(1, Math.floor(Number(parsed.value?.grid?.rows || 1)));
        if (row > rows) {
          setStatus("Row is outside template grid. Clear Preview context and try again.", true);
          return;
        }

        if (!window.confirm(`Delete row ${row}?`)) return;
        const res = deleteRow(parsed.value, row);
        if (!res.ok) {
          setStatus(String(res.error || "Delete row failed."), true);
          return;
        }
        writeTemplateJson(parsed.value);
        selectedAddr = "";
        renderPreview();
        setStatus(`Deleted row ${row}.`, false);
      }

      function deleteSelectedCol() {
        const parsedSel = parseAddress(selectedAddr);
        let colIndex = parsedSel?.colIndex;

        if (!colIndex) {
          const raw = window.prompt("Column letter to delete (A, B, C...):", "");
          const idx = colToIndex(raw);
          if (!idx) {
            setStatus("Invalid column letter.", true);
            return;
          }
          selectedAddr = `${indexToCol(idx)}1`;
          colIndex = idx;
        }

        const parsed = readTemplateJsonFromEditor();
        if (!parsed.ok) {
          setStatus(String(parsed.error || "Invalid template JSON."), true);
          return;
        }

        const cols = Math.max(1, Math.floor(Number(parsed.value?.grid?.cols || 1)));
        if (colIndex > cols) {
          setStatus("Column is outside template grid. Clear Preview context and try again.", true);
          return;
        }

        const colLetter = indexToCol(colIndex);
        if (!window.confirm(`Delete column ${colLetter}?`)) return;
        const res = deleteCol(parsed.value, colIndex);
        if (!res.ok) {
          setStatus(String(res.error || "Delete column failed."), true);
          return;
        }
        writeTemplateJson(parsed.value);
        selectedAddr = "";
        renderPreview();
        setStatus(`Deleted column ${colLetter}.`, false);
      }

      function renderPreview() {
        const host = $("previewHost");
        if (!host) return;

        const parsed = readTemplateJsonFromEditor();
        if (!parsed.ok) {
          host.textContent = String(parsed.error || "Invalid template JSON.");
          host.classList.add("empty");
          setStatus(String(parsed.error || "Invalid template JSON."), true);
          return;
        }

        let cfg = parsed.value;

        const ctxRaw = asNonEmptyString($("ctxJson")?.value);
        if (ctxRaw) {
          const ctxParsed = parseJsonStrict(ctxRaw);
          if (!ctxParsed.ok) {
            setStatus(`Context JSON error: ${ctxParsed.error}`, true);
          } else if (ns.templateConverter) {
            try {
              const expanded = ns.templateConverter.expandExcelLikeTableTemplate(cfg, ctxParsed.value);
              const filled = ns.templateConverter.fillTemplateConfig(expanded, ctxParsed.value, { preserveUnresolved: true });
              cfg = ns.templateConverter.compactExcelLikeTableConfig(filled);
            } catch (e) {
              setStatus(`Preview build error: ${String(e?.message || e)}`, true);
            }
          }
        }

        try {
          host.classList.remove("empty");
          host.textContent = "";
          host.appendChild(ns.tableRenderer.renderExcelLikeTable(cfg));
          highlightSelectedCell();
          syncPreviewToolbarFromSelection();
        } catch (e) {
          host.textContent = String(e?.message || e);
          host.classList.add("empty");
          setStatus(`Preview render error: ${String(e?.message || e)}`, true);
        }
      }

      let previewTimer = null;
      function schedulePreview() {
        if (previewTimer) window.clearTimeout(previewTimer);
        previewTimer = window.setTimeout(() => {
          previewTimer = null;
          renderPreview();
        }, 250);
      }

      function newTemplate() {
        $("tplId").value = "";
        $("tplLabel").value = "";
        $("tplAuto").checked = true;
        $("tplPreferred").checked = false;
        $("tplCompactRemoveEmptyRows").checked = false;
        $("tplWhenPath").value = "";
        $("tplWhenEquals").value = "";
        if ($("tplSource")?.options?.length) $("tplSource").value = $("tplSource").options[0].value;
        $("ctxJson").value = "";

        const skeleton = {
          type: "excel-like-table",
          grid: {
            rows: 8,
            cols: 8,
            defaultColWidth: 32,
            defaultRowHeight: 32,
          },
          css: {
            cell: "border:1px solid #222;padding:2px 4px;vertical-align:middle;background:#fff;color:#111;white-space:pre-wrap;",
          },
          merges: [],
          cells: [{ addr: "A1", text: "Title", class: ["cell"] }],
        };
        writeTemplateJson(skeleton);
        renderPreview();
        setStatus("New template skeleton created.", false);
      }

      function saveTemplate(mode) {
        if (!store || typeof store.upsertTemplate !== "function") {
          setStatus("Template store not available.", true);
          return;
        }

        const selectedId = asNonEmptyString($("tplSelect")?.value);
        const id = mode === "new" ? asNonEmptyString($("tplId")?.value) : selectedId;
        if (!id) {
          setStatus("Template id is required.", true);
          return;
        }

        const parsed = readTemplateJsonFromEditor();
        if (!parsed.ok) {
          setStatus(String(parsed.error || "Invalid template JSON."), true);
          return;
        }

        const metaFromForm = {
          label: asNonEmptyString($("tplLabel")?.value) || id,
          source: asNonEmptyString($("tplSource")?.value),
          auto: Boolean($("tplAuto")?.checked),
          when: buildWhenFromForm(),
        };

        const regEntry = ns.templateRegistry?.templates?.[id] || null;
        const stored = store.loadStore?.().templates?.[id] || null;
        const isCustom = Boolean(stored?.meta?.custom) || (!regEntry && mode === "new");

        const res = store.upsertTemplate(id, parsed.value, { ...metaFromForm, custom: isCustom });
        if (!res.ok) {
          setStatus(String(res.error || "Save failed."), true);
          return;
        }

        const preferred = Boolean($("tplPreferred")?.checked);
        if (preferred && metaFromForm.source) store.setPreferredTemplateId?.(metaFromForm.source, id);
        if (!preferred && metaFromForm.source) {
          const cur = store.getPreferredTemplateId?.(metaFromForm.source);
          if (cur === id) store.setPreferredTemplateId?.(metaFromForm.source, "");
        }

        populateTemplateSelect(id);
        if ($("tplSelect")?.value !== id) $("tplSelect").value = id;
        setStatus(`Saved (${mode === "new" ? "new" : "override"}): ${id}. Reload pages to apply.`, false);
      }

      function deleteSaved() {
        if (!store || typeof store.deleteTemplate !== "function") {
          setStatus("Template store not available.", true);
          return;
        }

        const id = asNonEmptyString($("tplSelect")?.value);
        if (!id) return;

        if (!window.confirm(`Delete saved template/override: ${id}?`)) return;
        const res = store.deleteTemplate(id);
        if (!res.ok) {
          setStatus(String(res.error || "Delete failed."), true);
          return;
        }

        populateTemplateSelect("");
        setStatus(res.existed ? `Deleted: ${id}. Reload pages to apply.` : `Nothing to delete for: ${id}`, false);
      }

      function wireUi() {
        $("btnLoadTemplate")?.addEventListener("click", () => loadTemplate($("tplSelect")?.value));
        $("btnNewTemplate")?.addEventListener("click", newTemplate);
        $("btnSaveTemplate")?.addEventListener("click", () => saveTemplate("save"));
        $("btnSaveNewTemplate")?.addEventListener("click", () => saveTemplate("new"));
        $("btnDeleteTemplate")?.addEventListener("click", deleteSaved);
        $("btnDeleteRow")?.addEventListener("click", deleteSelectedRow);
        $("btnDeleteCol")?.addEventListener("click", deleteSelectedCol);
        $("tplCompactRemoveEmptyRows")?.addEventListener("change", () => {
          const parsed = readTemplateJsonFromEditor();
          if (!parsed.ok) {
            setStatus(String(parsed.error || "Invalid template JSON."), true);
            return;
          }

          applyCompactFormToConfig(parsed.value);
          writeTemplateJson(parsed.value);
          renderPreview();
          setStatus(`Compact removeEmptyRows: ${$("tplCompactRemoveEmptyRows").checked ? "ON" : "OFF"}.`, false);
        });
        $("btnCopyExcel")?.addEventListener("click", async () => {
          const exporter = ns.templateExcelExport || null;
          const table = $("previewHost")?.querySelector("table.excel-like-table") || null;
          const res = exporter?.copyExcelLikeTableToClipboard ? await exporter.copyExcelLikeTableToClipboard(table) : { ok: false, error: "Excel export module not loaded." };
          setStatus(String(res.ok ? `Copied to clipboard (${res.method || "copy"}). Paste into Excel.` : res.error || "Copy failed."), !res.ok);
        });
        $("btnPasteExcel")?.addEventListener("click", () => {
          const modal = $("excelPasteModal");
          const target = $("excelPasteTarget");
          if (!modal || !target) return;
          modal.hidden = false;
          target.textContent = "";
          window.setTimeout(() => target.focus(), 0);
        });
        $("btnExcelPasteCancel")?.addEventListener("click", () => {
          const modal = $("excelPasteModal");
          if (modal) modal.hidden = true;
        });
        $("excelPasteModal")?.addEventListener("click", (e) => {
          const modal = $("excelPasteModal");
          if (!modal) return;
          const panel = e?.target?.closest ? e.target.closest(".excel-paste-modal__panel") : null;
          if (panel) return;
          modal.hidden = true;
        });
        $("excelPasteTarget")?.addEventListener("keydown", (e) => {
          if (e.key !== "Escape") return;
          const modal = $("excelPasteModal");
          if (modal) modal.hidden = true;
        });
        $("excelPasteTarget")?.addEventListener("paste", (e) => {
          const ev = e || window.event;
          const html = ev?.clipboardData?.getData ? ev.clipboardData.getData("text/html") : "";
          const plain = ev?.clipboardData?.getData ? ev.clipboardData.getData("text/plain") : "";
          if (ev?.preventDefault) ev.preventDefault();

          const importer = ns.templateExcelImport || null;
          if (!importer?.buildTemplateConfigFromExcelHtml) {
            setStatus("Excel import module not loaded.", true);
            return;
          }

          const res = importer.buildTemplateConfigFromExcelHtml(html, plain);
          if (!res.ok) {
            setStatus(res.error || "Paste failed.", true);
            return;
          }

          writeTemplateJson(res.config);
          selectedAddr = "";
          renderPreview();
          setStatus("Imported from Excel clipboard.", false);

          const modal = $("excelPasteModal");
          if (modal) modal.hidden = true;
        });

        $("btnPreviewDeleteRow")?.addEventListener("click", deleteSelectedRow);
        $("btnPreviewDeleteCol")?.addEventListener("click", deleteSelectedCol);

        $("selBgColor")?.addEventListener("input", () => {
          if (!selectedAddr) return;
          const parsed = readTemplateJsonFromEditor();
          if (!parsed.ok) return;
          upsertCellStyleProp(parsed.value, selectedAddr, "background", $("selBgColor").value);
          writeTemplateJson(parsed.value);
          renderPreview();
        });

        $("selTextColor")?.addEventListener("input", () => {
          if (!selectedAddr) return;
          const parsed = readTemplateJsonFromEditor();
          if (!parsed.ok) return;
          upsertCellStyleProp(parsed.value, selectedAddr, "color", $("selTextColor").value);
          writeTemplateJson(parsed.value);
          renderPreview();
        });

        $("btnApplyBorder")?.addEventListener("click", () => {
          if (!selectedAddr) return;
          const parsed = readTemplateJsonFromEditor();
          if (!parsed.ok) return;
          const border = asNonEmptyString($("selBorder")?.value);
          upsertCellStyleProp(parsed.value, selectedAddr, "border", border);
          writeTemplateJson(parsed.value);
          renderPreview();
        });

        $("selBorder")?.addEventListener("keydown", (e) => {
          if (e.key !== "Enter") return;
          e.preventDefault();
          $("btnApplyBorder")?.click();
        });

        $("btnClearFormat")?.addEventListener("click", () => {
          if (!selectedAddr) return;
          const parsed = readTemplateJsonFromEditor();
          if (!parsed.ok) return;
          clearCellStyle(parsed.value, selectedAddr);
          writeTemplateJson(parsed.value);
          renderPreview();
          setStatus(`Cleared format: ${selectedAddr}`, false);
        });

        const previewHost = $("previewHost");
        previewHost?.addEventListener("click", (e) => {
          if (e?.target?.closest && e.target.closest("textarea.cell-editor")) return;
          const td = e?.target?.closest ? e.target.closest("td[data-addr]") : null;
          if (!td) return;
          selectCell(td.dataset.addr);
        });
        previewHost?.addEventListener("dblclick", (e) => {
          if (e?.target?.closest && e.target.closest("textarea.cell-editor")) return;
          const td = e?.target?.closest ? e.target.closest("td[data-addr]") : null;
          if (!td) return;
          if (td.classList.contains("is-editing")) return;
          startCellEdit(td, td.dataset.addr);
        });

        $("tplSelect")?.addEventListener("change", () => loadTemplate($("tplSelect")?.value));
        $("tplJson")?.addEventListener("input", () => {
          syncCompactFormFromEditorJson();
          schedulePreview();
        });
        $("ctxJson")?.addEventListener("input", schedulePreview);
      }

      async function init() {
        setStatus("Loading templates...", false);

        try {
          if (ns.abapObjects?.whenReady) await ns.abapObjects.whenReady();
        } catch (e) {
          setStatus(`Failed to load templates: ${String(e?.message || e)}`, true);
          return;
        }

        populateSourceSelect("");
        populateTemplateSelect("");
        initEditorSplitter();
        wireUi();

        const sel = $("tplSelect");
        if (sel && sel.options.length) {
          loadTemplate(sel.value);
        } else {
          setStatus("No templates found.", true);
        }
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })(window.AbapFlow);

    </script>
  <script>
(function(){
  'use strict';
  var ns = window.AbapFlow = window.AbapFlow || {};
  var map = ns.__inlineScriptBySrc = ns.__inlineScriptBySrc || {};
  Object.assign(map, {"js/abap_objects/templates/append.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const appendExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    grid: {\n      rows: 2,\n      cols: 4,\n      colWidths: {\n        A: 160,\n        B: 520,\n        C: 80,\n        D: 740,\n      },\n      rowHeights: {\n        1: 34,\n        2: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n      center: \"text-align:center;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Append\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"{line.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"C1\", text: \"TO\", class: [\"cell\", \"header\", \"center\"] },\n      { addr: \"D1\", text: \"{itab.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A2\", text: \"{labels.sortedBy}\", class: [\"cell\", \"header\"] },\n      { addr: \"B2\", text: \"{sortedBy.description}\", class: [\"cell\", \"wrap\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"append.excel-like-table\", appendExcelLikeTable);\n})(window.AbapFlow);\n", "js/abap_objects/templates/assignment.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const assignmentExcelLikeTable = {\n    type: \"excel-like-table\",\n    grid: {\n      rows: 2,\n      cols: 2,\n      colWidths: {\n        A: 420,\n        B: 700,\n      },\n      rowHeights: {\n        1: 34,\n        2: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Item\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"Value\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A2\", text: \"{item.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B2\", text: \"{value.description}\", class: [\"cell\", \"wrap\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"assignment.excel-like-table\", assignmentExcelLikeTable);\n})(window.AbapFlow);\n", "js/abap_objects/templates/if.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const ifExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    grid: {\n      rows: 3,\n      cols: 4,\n      colWidths: {\n        A: 420,\n        B: 220,\n        C: 520,\n        D: 220,\n      },\n      rowHeights: {\n        1: 34,\n        2: 30,\n        3: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n      center: \"text-align:center;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Item 1\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"Operator\", class: [\"cell\", \"header\"] },\n      { addr: \"C1\", text: \"Item 2\", class: [\"cell\", \"header\"] },\n      { addr: \"D1\", text: \"Associations\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A2\", text: \"{conditions[0].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B2\", text: \"{conditions[0].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C2\", text: \"{conditions[0].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D2\", text: \"{conditions[0].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A3\", text: \"{conditions[1].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B3\", text: \"{conditions[1].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C3\", text: \"{conditions[1].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D3\", text: \"{conditions[1].association}\", class: [\"cell\", \"mono\", \"center\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"if.excel-like-table\", ifExcelLikeTable);\n})(window.AbapFlow);\n", "js/abap_objects/templates/itabCollect.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const itabCollectExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    grid: {\n      rows: 7,\n      cols: 4,\n      colWidths: {\n        A: 420,\n        B: 220,\n        C: 520,\n        D: 220,\n      },\n      rowHeights: {\n        1: 30,\n        2: 30,\n        3: 30,\n        4: 30,\n        5: 30,\n        6: 30,\n        7: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n      center: \"text-align:center;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Internal table\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"{table.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A2\", text: \"{labels.target}\", class: [\"cell\", \"header\"] },\n      { addr: \"B2\", text: \"{target.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A3\", text: \"{labels.conditions}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A4\", text: \"{labels.condItem1}\", class: [\"cell\", \"header\"] },\n      { addr: \"B4\", text: \"{labels.condOperator}\", class: [\"cell\", \"header\"] },\n      { addr: \"C4\", text: \"{labels.condItem2}\", class: [\"cell\", \"header\"] },\n      { addr: \"D4\", text: \"{labels.condAssoc}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A5\", text: \"{conditions[0].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B5\", text: \"{conditions[0].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C5\", text: \"{conditions[0].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D5\", text: \"{conditions[0].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A6\", text: \"{conditions[1].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B6\", text: \"{conditions[1].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C6\", text: \"{conditions[1].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D6\", text: \"{conditions[1].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A7\", text: \"{labels.binarySearch}\", class: [\"cell\", \"header\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"itabCollect.excel-like-table\", itabCollectExcelLikeTable);\n})(window.AbapFlow);\n\n", "js/abap_objects/templates/itabDelete.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const itabDeleteExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    grid: {\n      rows: 7,\n      cols: 4,\n      colWidths: {\n        A: 420,\n        B: 220,\n        C: 520,\n        D: 220,\n      },\n      rowHeights: {\n        1: 30,\n        2: 30,\n        3: 30,\n        4: 30,\n        5: 30,\n        6: 30,\n        7: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n      center: \"text-align:center;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Internal table\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"{table.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A2\", text: \"{labels.target}\", class: [\"cell\", \"header\"] },\n      { addr: \"B2\", text: \"{target.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A3\", text: \"{labels.conditions}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A4\", text: \"{labels.condItem1}\", class: [\"cell\", \"header\"] },\n      { addr: \"B4\", text: \"{labels.condOperator}\", class: [\"cell\", \"header\"] },\n      { addr: \"C4\", text: \"{labels.condItem2}\", class: [\"cell\", \"header\"] },\n      { addr: \"D4\", text: \"{labels.condAssoc}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A5\", text: \"{conditions[0].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B5\", text: \"{conditions[0].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C5\", text: \"{conditions[0].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D5\", text: \"{conditions[0].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A6\", text: \"{conditions[1].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B6\", text: \"{conditions[1].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C6\", text: \"{conditions[1].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D6\", text: \"{conditions[1].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A7\", text: \"{labels.binarySearch}\", class: [\"cell\", \"header\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"itabDelete.excel-like-table\", itabDeleteExcelLikeTable);\n})(window.AbapFlow);\n\n", "js/abap_objects/templates/itabModify.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const itabModifyExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    grid: {\n      rows: 7,\n      cols: 4,\n      colWidths: {\n        A: 420,\n        B: 220,\n        C: 520,\n        D: 220,\n      },\n      rowHeights: {\n        1: 30,\n        2: 30,\n        3: 30,\n        4: 30,\n        5: 30,\n        6: 30,\n        7: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n      center: \"text-align:center;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Internal table\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"{table.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A2\", text: \"{labels.target}\", class: [\"cell\", \"header\"] },\n      { addr: \"B2\", text: \"{target.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A3\", text: \"{labels.conditions}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A4\", text: \"{labels.condItem1}\", class: [\"cell\", \"header\"] },\n      { addr: \"B4\", text: \"{labels.condOperator}\", class: [\"cell\", \"header\"] },\n      { addr: \"C4\", text: \"{labels.condItem2}\", class: [\"cell\", \"header\"] },\n      { addr: \"D4\", text: \"{labels.condAssoc}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A5\", text: \"{conditions[0].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B5\", text: \"{conditions[0].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C5\", text: \"{conditions[0].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D5\", text: \"{conditions[0].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A6\", text: \"{conditions[1].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B6\", text: \"{conditions[1].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C6\", text: \"{conditions[1].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D6\", text: \"{conditions[1].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A7\", text: \"{labels.binarySearch}\", class: [\"cell\", \"header\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"itabModify.excel-like-table\", itabModifyExcelLikeTable);\n})(window.AbapFlow);\n\n", "js/abap_objects/templates/itabRead.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const itabReadExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    grid: {\n      rows: 7,\n      cols: 4,\n      colWidths: {\n        A: 420,\n        B: 220,\n        C: 520,\n        D: 220,\n      },\n      rowHeights: {\n        1: 30,\n        2: 30,\n        3: 30,\n        4: 30,\n        5: 30,\n        6: 30,\n        7: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n      center: \"text-align:center;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Internal table\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"{table.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A2\", text: \"{labels.target}\", class: [\"cell\", \"header\"] },\n      { addr: \"B2\", text: \"{target.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A3\", text: \"{labels.conditions}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A4\", text: \"{labels.condItem1}\", class: [\"cell\", \"header\"] },\n      { addr: \"B4\", text: \"{labels.condOperator}\", class: [\"cell\", \"header\"] },\n      { addr: \"C4\", text: \"{labels.condItem2}\", class: [\"cell\", \"header\"] },\n      { addr: \"D4\", text: \"{labels.condAssoc}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A5\", text: \"{conditions[0].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B5\", text: \"{conditions[0].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C5\", text: \"{conditions[0].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D5\", text: \"{conditions[0].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A6\", text: \"{conditions[1].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B6\", text: \"{conditions[1].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C6\", text: \"{conditions[1].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D6\", text: \"{conditions[1].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A7\", text: \"{labels.binarySearch}\", class: [\"cell\", \"header\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"itabRead.excel-like-table\", itabReadExcelLikeTable);\n})(window.AbapFlow);\n\n", "js/abap_objects/templates/message.excel-like-table.js": "(function (ns) {\n    \"use strict\";\n\n    const messageExcelLikeTable = {\n        type: \"excel-like-table\",\n        compact: {\n            removeEmptyRows: true,\n        },\n        grid: {\n            rows: 8,\n            cols: 6,\n            colWidths: {\n                A: 260,\n                B: 360,\n                C: 220,\n                D: 420,\n                E: 220,\n                F: 260,\n            },\n            rowHeights: {\n                1: 30,\n                2: 30,\n                3: 30,\n                4: 30,\n                5: 30,\n                6: 30,\n                7: 30,\n                8: 30,\n            },\n        },\n        css: {\n            header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n            cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n            mono: \"font-family:Consolas,monospace;\",\n            wrap: \"white-space:normal;line-height:1.25;\",\n            center: \"text-align:center;\",\n        },\n        cells: [\n            {\n                addr: \"A1\",\n                text: \"{labels.msgClass}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B1\",\n                text: \"{msgClass.description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"C1\",\n                text: \"{labels.msgNo}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"D1\",\n                text: \"{msgNo.description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"E1\",\n                text: \"{labels.displayLike}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"F1\",\n                text: \"{displayLike.description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A2\",\n                text: \"{labels.messageText}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B2\",\n                text: \"{messageText.description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A3\",\n                text: \"{labels.with1}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B3\",\n                text: \"{with[0].description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A4\",\n                text: \"{labels.with2}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B4\",\n                text: \"{with[1].description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A5\",\n                text: \"{labels.with3}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B5\",\n                text: \"{with[2].description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A6\",\n                text: \"{labels.with4}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B6\",\n                text: \"{with[3].description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A7\",\n                text: \"{labels.into}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B7\",\n                text: \"{into.description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A8\",\n                text: \"{labels.raising}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B8\",\n                text: \"{raising.description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n        ],\n    };\n\n    ns.abapObjects?.defineTemplate?.(\"message.excel-like-table\", messageExcelLikeTable);\n})(window.AbapFlow);\n", "js/abap_objects/templates/perform.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const performExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    sectionLabels: {\n      tables: \"Table\",\n      using: \"Using\",\n      changing: \"Changing\",\n      raising: \"Raising\",\n    },\n    grid: {\n      rows: 9,\n      cols: 3,\n      colWidths: {\n        A: 160,\n        B: 190,\n        C: 860,\n      },\n      rowHeights: {\n        1: 34,\n        2: 30,\n        3: 30,\n        4: 30,\n        5: 30,\n        6: 30,\n        7: 30,\n        8: 30,\n        9: 30,\n      },\n    },\n    css: {\n      label: \"background:#f4b183;font-weight:600;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n    },\n    defaultCellClass: [\"gap\"],\n    cells: [\n      { addr: \"A1\", text: \"Thực hiện\", class: [\"cell\", \"label\"] },\n      { addr: \"B1\", text: \"{perform.name}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C1\", text: \"{perform.description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A2\", text: \"{labels.tables}\", class: [\"cell\", \"label\"] },\n      { addr: \"B2\", text: \"{tables[0].actual}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C2\", text: \"{tables[0].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A3\", text: \"\", class: [\"cell\", \"label\"] },\n      { addr: \"B3\", text: \"{tables[1].actual}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C3\", text: \"{tables[1].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A4\", text: \"{labels.using}\", class: [\"cell\", \"label\"] },\n      { addr: \"B4\", text: \"{using[0].actual}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C4\", text: \"{using[0].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A5\", text: \"\", class: [\"cell\", \"label\"] },\n      { addr: \"B5\", text: \"{using[1].actual}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C5\", text: \"{using[1].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A6\", text: \"{labels.changing}\", class: [\"cell\", \"label\"] },\n      { addr: \"B6\", text: \"{changing[0].actual}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C6\", text: \"{changing[0].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A7\", text: \"\", class: [\"cell\", \"label\"] },\n      { addr: \"B7\", text: \"{changing[1].actual}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C7\", text: \"{changing[1].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A8\", text: \"{labels.raising}\", class: [\"cell\", \"label\"] },\n      { addr: \"B8\", text: \"{raising[0].name}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C8\", text: \"{raising[0].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A9\", text: \"\", class: [\"cell\", \"label\"] },\n      { addr: \"B9\", text: \"{raising[1].name}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C9\", text: \"{raising[1].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"perform.excel-like-table\", performExcelLikeTable);\n})(window.AbapFlow);\n\n"});

  var head = document && document.head;
  if (!head || head.__abapflowInlinePatched) return;
  head.__abapflowInlinePatched = true;

  var origAppend = head.appendChild.bind(head);
  head.appendChild = function(node){
    try {
      if (node && node.tagName === 'SCRIPT' && (node.src || node.getAttribute('src'))) {
        var attr = node.getAttribute ? (node.getAttribute('src') || '') : '';
        var key = String(attr || '').replace(/\\/g, '/').replace(/^\.\//, '');
        if (!key) {
          var abs = String(node.src || '');
          var base = String(document.baseURI || '').replace(/[^\/]*$/, '');
          if (abs && base && abs.indexOf(base) === 0) key = abs.slice(base.length);
          else key = abs;
          key = String(key || '').replace(/\\/g, '/').replace(/^\.\//, '');
        }

        if (key && map && typeof map === 'object' && Object.prototype.hasOwnProperty.call(map, key)) {
          var code = String(map[key] || '');
          node.removeAttribute && node.removeAttribute('src');
          node.textContent = code + "\n//# sourceURL=" + key;
          var onload = node.onload;
          var res = origAppend(node);
          if (typeof onload === 'function') setTimeout(function(){ onload.call(node); }, 0);
          return res;
        }
      }
    } catch (_) {
      // ignore and fall back
    }
    return origAppend(node);
  };
})();
</script>
</body>
</html>
