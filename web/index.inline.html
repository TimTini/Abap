<!doctype html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ABAP Flow Analyzer (Offline)</title>
        <style>
    /* css/app.css */
    :root {
      --bg: #0b0f17;
      --panel: #111827;
      --panel2: #0f172a;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: #273244;
      --accent: #60a5fa;
      --danger: #ef4444;
      --ok: #22c55e;
      --shadow: 0 8px 28px rgba(0, 0, 0, 0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 800px at 20% -10%, rgba(96, 165, 250, 0.22), transparent 60%),
        radial-gradient(1000px 700px at 100% 10%, rgba(34, 197, 94, 0.16), transparent 55%),
        var(--bg);
      color: var(--text);
    }

    .app-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 14px 18px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .app-header__title h1 {
      font-size: 16px;
      margin: 0;
      letter-spacing: 0.2px;
    }

    .app-header__subtitle {
      margin-top: 2px;
      font-size: 12px;
      color: var(--muted);
    }

    .app-header__actions {
      display: flex;
      gap: 10px;
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      border-radius: 10px;
      padding: 9px 12px;
      font-size: 13px;
      cursor: pointer;
    }

    .btn:hover {
      border-color: rgba(255, 255, 255, 0.18);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn-primary {
      border-color: rgba(96, 165, 250, 0.55);
      background: rgba(96, 165, 250, 0.16);
    }

    .app-main {
      height: calc(100% - 58px);
      padding: 14px;
      display: grid;
      grid-template-columns: 1fr 1.25fr;
      gap: 14px;
    }

    .app-main.app-main--resizable {
      grid-template-columns: minmax(320px, var(--main-left, 44vw)) 12px minmax(420px, 1fr);
      gap: 0;
    }

    .app-splitter {
      cursor: col-resize;
      touch-action: none;
      position: relative;
      border-left: 1px solid rgba(255, 255, 255, 0.04);
      border-right: 1px solid rgba(255, 255, 255, 0.04);
    }

    .app-splitter::before {
      content: "";
      position: absolute;
      top: 14px;
      bottom: 14px;
      left: 50%;
      width: 4px;
      transform: translateX(-50%);
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.10);
    }

    .app-splitter:hover::before {
      background: rgba(96, 165, 250, 0.45);
    }

    .app-splitter.is-dragging::before {
      background: rgba(96, 165, 250, 0.70);
    }

    .panel {
      background: rgba(17, 24, 39, 0.76);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .panel__title {
      padding: 12px 14px;
      font-size: 13px;
      color: var(--muted);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.55);
    }

    .panel__footer {
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.35);
      padding: 10px 12px;
    }

    .status-bar {
      font-size: 12px;
      color: var(--muted);
    }

    .code-input {
      flex: 1;
      width: 100%;
      resize: none;
      border: 0;
      outline: none;
      padding: 12px;
      background: transparent;
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.45;
      white-space: pre;
    }

    .code-editor {
      position: relative;
      flex: 1;
      min-height: 0;
    }

    .code-editor .code-input {
      height: 100%;
      padding-left: 38px;
    }

    .code-markers {
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 26px;
      pointer-events: none;
      border-right: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.20);
    }

    .code-marker {
      position: absolute;
      left: 6px;
      width: 14px;
      height: 14px;
      padding: 0;
      border-radius: 6px;
      border: 1px solid rgba(96, 165, 250, 0.55);
      background: rgba(96, 165, 250, 0.18);
      color: rgba(191, 219, 254, 0.95);
      cursor: pointer;
      font-size: 10px;
      line-height: 1;
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      opacity: 0.75;
      transition: transform 120ms ease, opacity 120ms ease, border-color 120ms ease;
    }

    .code-marker:hover {
      opacity: 1;
      transform: scale(1.08);
      border-color: rgba(96, 165, 250, 0.75);
    }

    .code-markers.is-hidden {
      display: none;
    }

    .tabs {
      display: flex;
      gap: 6px;
      padding: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.55);
    }

    .tab {
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.03);
      color: var(--muted);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 13px;
      cursor: pointer;
    }

    .tab.is-active {
      border-color: rgba(96, 165, 250, 0.55);
      color: var(--text);
      background: rgba(96, 165, 250, 0.14);
    }

    .tab-panels {
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    .tab-panel {
      display: none;
      height: 100%;
      overflow: auto;
    }

    .tab-panel.is-active {
      display: block;
    }

    .split {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      height: 100%;
      min-height: 0;
    }

    .split__left,
    .split__right {
      min-height: 0;
    }

    .split__left {
      border-right: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      flex-direction: column;
    }

    .toolbar {
      padding: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }

    .objcfg-toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .objcfg-toolbar .input {
      flex: 1;
    }

    .objcfg-toolbar--bottom {
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      border-bottom: 0;
      margin-top: auto;
    }

    .objcfg-list {
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .objcfg-item {
      appearance: none;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(255, 255, 255, 0.03);
      color: var(--text);
      border-radius: 12px;
      padding: 9px 10px;
      cursor: pointer;
      text-align: left;
    }

    .objcfg-item:hover {
      border-color: rgba(255, 255, 255, 0.18);
    }

    .objcfg-item.is-active {
      border-color: rgba(96, 165, 250, 0.55);
      background: rgba(96, 165, 250, 0.12);
    }

    .objcfg-item.is-disabled {
      opacity: 0.62;
    }

    .objcfg-item__title {
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.2;
    }

    .objcfg-item__meta {
      margin-top: 4px;
      font-size: 11px;
      color: var(--muted);
    }

    .objcfg-editor__head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .objcfg-editor__title {
      font-size: 13px;
      color: var(--text);
      font-weight: 650;
    }

    .objcfg-editor__badges {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .objcfg-editor__actions {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .objcfg-label {
      margin-top: 12px;
      display: grid;
      gap: 6px;
    }

    .objcfg-label__text {
      font-size: 12px;
      color: var(--muted);
    }

    .objcfg-json {
      width: 100%;
      min-height: 320px;
      resize: vertical;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(255, 255, 255, 0.03);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.4;
      white-space: pre;
    }

    .objcfg-json.objcfg-json--small {
      min-height: 110px;
      resize: vertical;
    }

    .objcfg-advanced {
      margin-top: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(15, 23, 42, 0.18);
      border-radius: 14px;
      padding: 10px 12px 12px;
    }

    .objcfg-advanced__summary {
      cursor: pointer;
      color: var(--muted);
      font-size: 12px;
      user-select: none;
    }

    .objcfg-advanced[open] > .objcfg-advanced__summary {
      margin-bottom: 10px;
    }

    .objcfg-right {
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 0;
    }

    .objcfg-right > .details {
      flex: 1;
      min-height: 0;
      overflow: auto;
    }

    .objcfg-gen {
      margin: 12px 12px 0;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(15, 23, 42, 0.18);
      border-radius: 14px;
      padding: 10px 12px 12px;
    }

    .objcfg-gen[open] > .objcfg-advanced__summary {
      margin-bottom: 10px;
    }

    .objcfg-gen__row {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .objcfg-gen__row .input {
      flex: 1;
    }

    .objcfg-gen__output {
      margin: 10px 0 0;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(11, 15, 23, 0.35);
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.4;
      white-space: pre;
      max-height: 240px;
      overflow: auto;
    }

    .objcfg-quick {
      margin-top: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(15, 23, 42, 0.18);
      border-radius: 14px;
      padding: 10px 12px;
    }

    .objcfg-quick__error {
      color: var(--muted);
      font-size: 12px;
      padding: 6px 0;
    }

    .objcfg-form {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      align-items: end;
    }

    .objcfg-field {
      display: grid;
      gap: 6px;
    }

    .objcfg-field__label {
      font-size: 12px;
      color: var(--muted);
    }

    .objcfg-field--checkbox {
      align-items: center;
      grid-template-columns: 1fr auto;
    }

    .objcfg-field--wide {
      grid-column: 1 / -1;
    }

    .objcfg-sub {
      margin-top: 12px;
    }

    .objcfg-sub__title {
      font-size: 12px;
      color: var(--muted);
      font-weight: 650;
      margin-bottom: 8px;
    }

    .objcfg-sub__grid {
      display: grid;
      grid-template-columns: 1fr 220px;
      gap: 10px;
      align-items: end;
    }

    .objcfg-mini-table {
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(11, 15, 23, 0.35);
    }

    .objcfg-mini-table__head {
      display: grid;
      grid-template-columns: 1fr 120px 110px;
      gap: 10px;
      padding: 8px 10px;
      font-size: 11px;
      color: var(--muted);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.35);
    }

    .objcfg-mini-table__head.objcfg-mini-table__head--4 {
      grid-template-columns: 1fr 140px 1fr 110px;
    }

    .objcfg-mini-table__row {
      display: grid;
      grid-template-columns: 1fr 120px 110px;
      gap: 10px;
      padding: 8px 10px;
      align-items: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .objcfg-mini-table__row.objcfg-mini-table__row--4 {
      grid-template-columns: 1fr 140px 1fr 110px;
    }

    .objcfg-mini-table__row:last-child {
      border-bottom: 0;
    }

    .objcfg-mini-table__input {
      width: 100%;
    }

    .objcfg-mini-table__empty {
      padding: 10px;
      color: var(--muted);
      font-size: 12px;
    }

    .objcfg-templates {
      margin-top: 12px;
    }

    .objcfg-templates__row {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .objcfg-templates__row .input {
      flex: 1;
    }

    .objcfg-templates__list {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .objcfg-templates__empty {
      font-size: 12px;
      color: var(--muted);
      padding: 8px 0;
    }

    .objcfg-templates__item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(15, 23, 42, 0.25);
      border-radius: 12px;
      padding: 8px 10px;
    }

    .objcfg-templates__item-text {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text);
    }

    .objcfg-templates__remove {
      padding: 7px 10px;
    }

    .input {
      width: 100%;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      border-radius: 10px;
      padding: 9px 10px;
      font-size: 13px;
      outline: none;
    }

    select.input {
      color-scheme: dark;
    }

    select.input option,
    select.input optgroup {
      background: #0f172a;
      color: var(--text);
    }

    .table-wrap {
      flex: 1;
      min-height: 0;
      overflow: auto;
    }

    .table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .table th,
    .table td {
      padding: 9px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      vertical-align: top;
    }

    .table th {
      position: sticky;
      top: 0;
      background: rgba(15, 23, 42, 0.95);
      color: var(--muted);
      font-weight: 600;
      text-align: left;
    }

    .table tbody tr {
      cursor: pointer;
    }

    .table tbody tr:hover {
      background: rgba(255, 255, 255, 0.04);
    }

    .table tbody tr.is-selected {
      background: rgba(96, 165, 250, 0.16);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      font-size: 11px;
      color: var(--muted);
    }

    .badge.badge-ok {
      border-color: rgba(34, 197, 94, 0.6);
      color: #bbf7d0;
    }

    .badge.badge-danger {
      border-color: rgba(239, 68, 68, 0.6);
      color: #fecaca;
    }

    .details {
      padding: 12px 14px;
      font-size: 13px;
      min-height: 0;
    }

    .details.empty,
    .json-output.empty,
    .trace-results.empty {
      color: var(--muted);
    }

    .details h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
    }

    .details .meta {
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 12px;
    }

    .kv {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 8px 12px;
      font-size: 12px;
      margin-bottom: 10px;
    }

    .kv .k {
      color: var(--muted);
    }

    .section {
      margin-top: 14px;
    }

    .section__title {
      font-size: 12px;
      color: var(--muted);
      margin: 10px 0 6px;
    }

    .textarea {
      width: 100%;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      border-radius: 10px;
      padding: 9px 10px;
      font-size: 13px;
      outline: none;
      resize: vertical;
      min-height: 44px;
      font-family: var(--sans);
    }

    .textarea:focus {
      border-color: rgba(96, 165, 250, 0.55);
    }

    .anno-grid {
      display: grid;
      gap: 8px;
    }

    .anno-label {
      font-size: 12px;
      color: var(--muted);
    }

    .anno-code {
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 12px;
      color: var(--text);
      white-space: pre-wrap;
    }

    .anno-code--empty {
      color: var(--muted);
    }

    .anno-actions {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .anno-status {
      font-size: 12px;
      color: var(--muted);
    }

    .anno-summary {
      margin-top: 6px;
      color: var(--muted);
      font-size: 12px;
      font-family: var(--sans);
      white-space: pre-wrap;
    }

    .anno-summary__k {
      font-weight: 650;
      margin-right: 6px;
    }

    .param-item {
      margin: 8px 0;
    }

    .param-notes {
      margin-top: 6px;
      font-family: var(--sans);
    }

    .param-notes__summary {
      cursor: pointer;
      color: var(--muted);
      font-size: 12px;
      user-select: none;
    }

    .param-notes__body {
      margin-top: 8px;
    }

    .list {
      margin: 0;
      padding-left: 16px;
      font-family: var(--mono);
      font-size: 12px;
    }

    .list li {
      margin: 4px 0;
    }

    .decl-group {
      list-style: none;
      margin: 6px 0;
      padding: 0;
    }

    .decl-group__header {
      display: flex;
      gap: 8px;
      align-items: flex-start;
    }

    .decl-group__toggle {
      width: 22px;
      height: 22px;
      line-height: 22px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.04);
      color: var(--muted);
      cursor: pointer;
      user-select: none;
    }

    .decl-group__toggle:hover {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
    }

    .decl-group__header-content {
      flex: 1;
    }

    .decl-group__fields {
      margin-top: 4px;
      padding-left: 24px;
    }

    .decl-group.is-collapsed .decl-group__fields {
      display: none;
    }

    .diagram-host {
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      margin: 12px;
      background: rgba(11, 15, 23, 0.40);
      min-height: 520px;
      overflow: auto;
    }

    .sequence-host {
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      margin: 12px;
      background: rgba(11, 15, 23, 0.40);
      min-height: 520px;
      overflow: hidden;
    }

    .sequence-host.empty {
      padding: 12px;
      color: var(--muted);
    }

    .seq-scroll {
      height: 520px;
      overflow: auto;
    }

    .seq-grid {
      display: grid;
      grid-template-columns: 360px 1fr;
      align-items: start;
      min-height: 520px;
    }

    .seq-labels {
      position: sticky;
      left: 0;
      z-index: 3;
      background: rgba(11, 15, 23, 0.85);
      border-right: 1px solid rgba(255, 255, 255, 0.06);
    }

    .seq-header {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      color: var(--muted);
      font-size: 12px;
      background: rgba(15, 23, 42, 0.45);
    }

    .seq-row-label {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      transition: background 120ms ease;
    }

    .seq-row-label.is-hover {
      background: rgba(96, 165, 250, 0.10);
    }

    .seq-row-label.is-hover .seq-row-title {
      color: rgba(191, 219, 254, 0.95);
      text-shadow: 0 0 12px rgba(96, 165, 250, 0.30);
    }

    .seq-row-title {
      font-size: 12px;
      font-weight: 650;
      color: var(--text);
    }

    .seq-row-desc {
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
      white-space: pre-wrap;
    }

    .seq-row-params {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .chip {
      appearance: none;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      border-radius: 999px;
      padding: 5px 8px;
      font-size: 11px;
      cursor: pointer;
      text-align: left;
    }

    .chip:hover {
      border-color: rgba(96, 165, 250, 0.55);
    }

    .seq-canvas {
      position: relative;
      z-index: 1;
    }

    .seq-svg {
      display: block;
    }

    .seq-hover-line {
      pointer-events: none;
      stroke: rgba(96, 165, 250, 0.30);
      stroke-width: 3;
      stroke-linecap: round;
      transition: opacity 120ms ease;
    }

    .hint {
      padding: 0 12px 12px;
      color: var(--muted);
      font-size: 12px;
    }

    .form-grid {
      padding: 12px;
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 10px;
      align-items: end;
    }

    .form-grid label {
      display: grid;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .form-grid__actions {
      padding-bottom: 1px;
    }

    .trace-results {
      padding: 12px;
    }

    .json-output {
      padding: 12px;
      margin: 0;
      font-family: var(--mono);
      font-size: 12px;
      white-space: pre;
      overflow: auto;
    }

    .source-link {
      color: var(--accent);
      text-decoration: none;
    }

    .source-link:hover {
      text-decoration: underline;
    }

    .trace-node__header {
      margin-top: 12px;
      font-size: 13px;
      font-weight: 650;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .trace-node__toggle {
      width: 22px;
      height: 22px;
      padding: 0;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(255, 255, 255, 0.03);
      color: var(--muted);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      line-height: 1;
      transition: transform 120ms ease, border-color 120ms ease, color 120ms ease;
    }

    .trace-node__toggle:hover {
      border-color: rgba(96, 165, 250, 0.55);
      color: var(--text);
    }

    .trace-node.is-collapsed > :not(.trace-node__header) {
      display: none;
    }

    .trace-node.is-collapsed > .trace-node__header .trace-node__toggle {
      transform: rotate(-90deg);
    }

    .trace-node__meta {
      color: var(--muted);
      font-size: 12px;
      margin-top: 2px;
      margin-bottom: 6px;
    }

    .trace-node__notes {
      margin-top: 4px;
      margin-bottom: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.25);
      color: var(--text);
      font-size: 12px;
      white-space: pre-wrap;
    }

    .trace-node__notes--object {
      border-left: 3px solid rgba(96, 165, 250, 0.35);
    }

    .trace-node__notes--var {
      border-left: 3px solid rgba(167, 139, 250, 0.35);
    }

    .trace-node__notes-title {
      font-family: var(--sans);
      font-weight: 650;
      font-size: 12px;
      margin-bottom: 6px;
    }

    .trace-node__notes .param-notes {
      margin-top: 8px;
    }

    .trace-node__notes .param-notes__summary {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.02);
      color: var(--muted);
    }

    .trace-node__notes .param-notes__summary:hover {
      border-color: rgba(96, 165, 250, 0.55);
      color: var(--text);
    }

    .trace-node__notes .param-notes[open] .param-notes__summary {
      border-color: rgba(96, 165, 250, 0.45);
      color: var(--text);
    }

    .trace-note__k {
      color: var(--muted);
      font-weight: 650;
    }

    .trace-node__call {
      color: var(--muted);
      font-size: 12px;
      margin: 10px 0 2px;
      font-family: var(--mono);
    }

    .trace-node__writes {
      margin-top: 4px;
      margin-bottom: 10px;
    }

    @media (max-width: 1100px) {
      .app-main {
        grid-template-columns: 1fr;
        height: auto;
      }
      .split {
        grid-template-columns: 1fr;
      }
      .split__left {
        border-right: 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }
      .form-grid {
        grid-template-columns: 1fr;
      }
    }

    </style>
        <style>
    /* css/templates.css */
    .app-header__actions {
      align-items: center;
    }

    .flow-separator {
      margin: 16px 0 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.55);
      color: var(--muted);
      font-size: 12px;
      font-weight: 650;
    }

    .flow-note {
      margin: 10px 0 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.35);
      color: var(--muted);
      font-size: 12px;
    }

    .conversion-results,
    .original-performs {
      padding: 12px 14px;
      font-size: 13px;
      min-height: 0;
      overflow: auto;
    }

    .conversion-results.empty,
    .original-performs.empty {
      color: var(--muted);
    }

    .template-block {
      margin-bottom: 16px;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.25);
    }

    .template-block.is-clickable {
      cursor: pointer;
    }

    .template-block.is-clickable:hover {
      border-color: rgba(96, 165, 250, 0.35);
    }

    .template-block.is-selected {
      border-color: rgba(96, 165, 250, 0.55);
      box-shadow: 0 0 0 1px rgba(96, 165, 250, 0.10);
    }

    .template-block.is-multi-selected {
      border-color: rgba(34, 197, 94, 0.55);
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.10);
    }

    .template-block.is-cycle .template-block__header {
      color: rgba(252, 165, 165, 0.95);
    }

    .template-block__header {
      font-size: 13px;
      font-weight: 650;
      margin-bottom: 8px;
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .template-block__header-left {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .template-block__select {
      width: 16px;
      height: 16px;
      accent-color: var(--ok);
    }

    .template-block__toggle {
      width: 26px;
      height: 26px;
      padding: 0;
      border-radius: 9px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(255, 255, 255, 0.03);
      color: var(--muted);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      line-height: 1;
      transition: transform 120ms ease, border-color 120ms ease, color 120ms ease;
    }

    .template-block__toggle:hover {
      border-color: rgba(96, 165, 250, 0.35);
      color: var(--text);
    }

    .template-block.is-collapsed .template-block__toggle {
      transform: rotate(-90deg);
    }

    .template-block.is-collapsed .template-block__table {
      display: none;
    }

    .template-block.is-tree-hidden {
      display: none;
    }

    .template-block__title {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .template-block__actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }

    .templates-toolbar {
      position: sticky;
      top: 0;
      z-index: 5;
      margin: 0 0 12px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(15, 23, 42, 0.55);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .templates-toolbar__count {
      font-size: 12px;
      color: var(--muted);
    }

    .templates-toolbar__actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .btn.btn-sm {
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 9px;
    }

    .template-block__meta {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .template-block__original {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      margin: 0;
      padding: 8px;
      background: rgba(15, 23, 42, 0.35);
      border-radius: 6px;
      white-space: pre-wrap;
    }

    .template-block__table {
      margin-top: 10px;
      padding: 10px;
      overflow: auto;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(11, 15, 23, 0.35);
    }

    .excel-like-table {
      font-size: 12px;
      color: var(--text);
      background: transparent;
    }

    .excel-like-table td.label {
      color: #111;
    }

    .demo-error {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(239, 68, 68, 0.35);
      background: rgba(239, 68, 68, 0.08);
      color: #fecaca;
      font-size: 12px;
    }

    @media (max-width: 1100px) {

    }

    .template-line {
      margin: 6px 0;
      font-family: var(--mono);
      font-size: 12px;
    }

    .template-line__label {
      color: var(--accent);
      font-weight: 650;
      margin-right: 8px;
    }

    .template-line__value {
      color: var(--text);
    }

    .param-list {
      margin-left: 20px;
    }

    .param-item {
      margin: 4px 0;
      color: var(--text);
    }

    .param-item__name {
      color: var(--accent);
      font-weight: 650;
    }

    .param-item__type {
      color: var(--muted);
      margin-left: 8px;
    }

    .param-item__desc {
      color: var(--muted);
      font-style: italic;
      margin-left: 8px;
    }

    .original-perform {
      margin-bottom: 12px;
      padding: 10px;
      border-radius: 8px;
      background: rgba(15, 23, 42, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-family: var(--mono);
      font-size: 12px;
      white-space: pre-wrap;
    }

    .original-perform__header {
      font-weight: 650;
      color: var(--text);
      margin-bottom: 6px;
    }

    .original-perform__code {
      color: var(--muted);
    }

    .copy-success {
      color: var(--ok);
      font-size: 12px;
      margin-top: 8px;
      animation: fadeInOut 2s ease-in-out;
    }

    @keyframes fadeInOut {
      0%, 100% { opacity: 0; }
      50% { opacity: 1; }
    }

    .excel-like-table td[data-bind$=".description"] {
      cursor: text;
    }

    .excel-like-table td[data-bind$=".description"]:hover {
      box-shadow: inset 0 0 0 2px rgba(96, 165, 250, 0.55);
    }

    .demo-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: rgba(0, 0, 0, 0.55);
      z-index: 2000;
    }

    .demo-modal__dialog {
      width: min(720px, 96vw);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(15, 23, 42, 0.96);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.40);
      padding: 14px;
    }

    .demo-modal__title {
      font-size: 13px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 10px;
    }

    .demo-modal__textarea {
      width: 100%;
      min-height: 120px;
      resize: vertical;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
    }

    .demo-modal__hint {
      margin-top: 10px;
      color: var(--muted);
      font-size: 12px;
    }

    .demo-modal__actions {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    </style>
  </head>
  <body>
    <header class="app-header">
      <div class="app-header__title">
        <h1>ABAP Flow Analyzer</h1>
        <div class="app-header__subtitle">Offline - No external libraries</div>
      </div>
      <div class="app-header__actions">
        <button id="btnAnalyze" class="btn btn-primary" type="button">Analyze</button>
        <button id="btnLoadSample" class="btn" type="button">Load sample</button>
        <button id="btnClear" class="btn" type="button">Clear</button>
        <button id="btnExportNotes" class="btn" type="button">Export notes</button>
        <button id="btnImportNotes" class="btn" type="button">Import notes</button>
        <input id="notesImportFile" type="file" accept="application/json" style="display:none" />
        <a class="btn" href="template-editor.html" target="_blank" rel="noopener">Template editor</a>
      </div>
    </header>

    <main class="app-main app-main--resizable">
      <section class="panel panel-left">
        <div class="panel__title">ABAP code</div>
        <div class="code-editor">
          <textarea id="abapInput" class="code-input" spellcheck="false" placeholder="Paste ABAP code here..."></textarea>
          <div id="abapTemplateMarkers" class="code-markers" aria-hidden="true"></div>
        </div>
        <div class="panel__footer">
          <div id="statusBar" class="status-bar">Ready.</div>
        </div>
      </section>

      <div id="mainSplitter" class="app-splitter" role="separator" aria-orientation="vertical" tabindex="0"></div>

      <section class="panel panel-right">
        <div class="tabs">
          <button class="tab is-active" data-tab="objects" type="button">Objects</button>
          <button class="tab" data-tab="diagram" type="button">Diagram</button>
          <button class="tab" data-tab="sequence" type="button">Sequence</button>
          <button class="tab" data-tab="trace" type="button">Trace</button>
          <button class="tab" data-tab="templates" type="button">Templates</button>
          <button class="tab" data-tab="config" type="button">Config</button>
          <button class="tab" data-tab="json" type="button">JSON</button>
        </div>

        <div class="tab-panels">
          <section class="tab-panel is-active" id="tab-objects">
            <div class="split">
              <div class="split__left">
                <div class="toolbar">
                  <input id="objectSearch" class="input" type="search" placeholder="Search (FORM, EVENT, name)..." />
                </div>
                <div class="table-wrap">
                  <table class="table" id="objectsTable">
                    <thead>
                      <tr>
                        <th>Kind</th>
                        <th>Name</th>
                        <th>Depth</th>
                        <th>Params</th>
                        <th>DATA</th>
                        <th>CONST</th>
                        <th>Writes</th>
                        <th>Assign</th>
                        <th>Defined</th>
                        <th>Cycle</th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
              </div>
              <div class="split__right">
                <div class="panel__title">Details</div>
                <div id="objectDetails" class="details empty">Analyze to see details.</div>
              </div>
            </div>
          </section>

          <section class="tab-panel" id="tab-diagram">
            <div class="panel__title">Flow diagram</div>
            <div id="diagramHost" class="diagram-host"></div>
            <div class="hint">
              Tip: click a node to open it in <b>Objects</b> and <b>Trace</b>.
            </div>
          </section>

          <section class="tab-panel" id="tab-sequence">
            <div class="panel__title">Sequence diagram (single-thread)</div>

            <div class="form-grid">
              <label>
                View
                <select id="seqRoot" class="input"></select>
              </label>
              <label>
                Max steps
                <input id="seqMaxSteps" class="input" type="number" min="10" max="2000" value="200" />
              </label>
              <div class="form-grid__actions">
                <button id="btnSeqRender" class="btn btn-primary" type="button">Render</button>
              </div>
            </div>

            <div id="sequenceHost" class="sequence-host empty">Analyze to see sequence.</div>
            <div class="hint">Tip: click a parameter to jump to <b>Trace</b>.</div>
          </section>

          <section class="tab-panel" id="tab-trace">
            <div class="panel__title">Data trace</div>

            <div class="form-grid">
              <label>
                Subroutine
                <select id="traceSubroutine" class="input"></select>
              </label>
              <label>
                Variable
                <select id="traceVariable" class="input"></select>
              </label>
              <div class="form-grid__actions">
                <button id="btnTrace" class="btn btn-primary" type="button">Trace origin</button>
              </div>
            </div>

            <div id="traceResults" class="trace-results empty">Select a subroutine + variable and run trace.</div>
          </section>

          <section class="tab-panel" id="tab-templates">
            <div class="panel__title">Template output (flow order)</div>
            <div id="templatesHost" class="trace-results empty">Analyze to see templates.</div>
            <div class="hint">Tip: click a block to highlight the original statement in the editor.</div>
          </section>

          <section class="tab-panel" id="tab-config">
            <div class="split objcfg">
              <div class="split__left">
                <div class="toolbar objcfg-toolbar">
                  <input id="abapObjCfgSearch" class="input" type="search" placeholder="Search (id/label/kind)..." />
                  <button id="abapObjCfgNew" class="btn" type="button">New</button>
                </div>
                <div id="abapObjCfgList" class="objcfg-list"></div>
                <div class="toolbar objcfg-toolbar objcfg-toolbar--bottom">
                  <button id="abapObjCfgExport" class="btn" type="button">Export</button>
                  <button id="abapObjCfgImport" class="btn" type="button">Import</button>
                  <button id="abapObjCfgResetAll" class="btn" type="button">Reset all</button>
                  <input id="abapObjCfgImportFile" type="file" accept="application/json" style="display:none" />
                </div>
              </div>
              <div class="split__right">
                <div class="panel__title">ABAP Objects config (localStorage)</div>
                <div class="objcfg-right">
                  <details id="abapObjCfgGen" class="objcfg-gen">
                    <summary class="objcfg-advanced__summary">Generate from ABAP syntax (beta)</summary>
                    <textarea
                      id="abapObjCfgGenInput"
                      class="objcfg-json objcfg-json--small"
                      spellcheck="false"
                      placeholder="Paste ABAP Doc syntax block here (example: CONCATENATE ... INTO result ...)."
                    ></textarea>
                    <div class="objcfg-gen__row">
                      <input id="abapObjCfgGenId" class="input" type="text" placeholder="Object id (optional)" />
                      <button id="abapObjCfgGenBtn" class="btn btn-primary" type="button">Generate</button>
                    </div>
                    <pre id="abapObjCfgGenOutput" class="objcfg-gen__output"></pre>
                  </details>

                  <div id="abapObjCfgEditor" class="details empty">Select an object on the left.</div>
                </div>
              </div>
            </div>
          </section>

          <section class="tab-panel" id="tab-json">
            <div class="panel__title">Model JSON</div>
            <pre id="jsonOutput" class="json-output empty">Analyze to see JSON.</pre>
          </section>
        </div>
      </section>
    </main>

        <script>
    // js/namespace.js
    (function () {
      "use strict";

      if (!window.AbapFlow) {
        window.AbapFlow = {};
      }

      if (!window.AbapFlow.version) {
        window.AbapFlow.version = "0.1.0";
      }
    })();


    </script>
        <script>
    // abap_objects.config.js
    (function (ns) {
      "use strict";

      // MASTER CONFIG (edit this file to add new ABAP Objects + templates).
      //
      // Design goals:
      // - Add an ABAP Object by declaration (config + optional template file).
      // - Avoid editing multiple JS files when adding new objects.
      //
      // Notes:
      // - This is still a lightweight parser (not a full ABAP compiler).
      // - Regex can be RegExp objects or strings.

      const IDENT = String.raw`[A-Za-z_][A-Za-z0-9_\/]*`;
      const IDENT_PATH = String.raw`${IDENT}(?:(?:[-~]|->|=>)[A-Za-z0-9_\/]+)*`;

      ns.abapObjectsMasterConfig = {
        schema: "abapflow-abap-objects-master-config",
        version: 1,

        // Parser configuration used by `web/js/parser.js`.
        parserConfig: {
          version: 1,

          routineBlocks: [
            // FORM ... ENDFORM.
            {
              kind: "FORM",
              start: /^FORM\b/i,
              end: /^ENDFORM\b/i,
              endRequiresPeriod: true,
              header: {
                name: new RegExp(String.raw`^FORM\s+(${IDENT})\b\s*(.*)$`, "i"),
                clauseOrder: ["TABLES", "USING", "CHANGING", "RAISING"],
                paramIgnoreTokens: ["OPTIONAL", "DEFAULT", "TYPE", "LIKE"],
              },
            },

            // METHOD ... ENDMETHOD.
            {
              kind: "METHOD",
              start: /^METHOD\s+/i,
              end: /^ENDMETHOD\b/i,
              endRequiresPeriod: true,
              header: { name: new RegExp(String.raw`^METHOD\s+(${IDENT})\b`, "i") },
            },

            // FUNCTION ... ENDFUNCTION.
            {
              kind: "FUNCTION",
              start: /^FUNCTION\s+/i,
              end: /^ENDFUNCTION\b/i,
              endRequiresPeriod: true,
              header: { name: new RegExp(String.raw`^FUNCTION\s+(${IDENT})\b`, "i") },
            },

            // MODULE ... ENDMODULE.
            {
              kind: "MODULE",
              start: /^MODULE\s+/i,
              end: /^ENDMODULE\b/i,
              endRequiresPeriod: true,
              header: { name: new RegExp(String.raw`^MODULE\s+(${IDENT})\b`, "i") },
            },
          ],

          events: {
            exact: ["INITIALIZATION", "START-OF-SELECTION", "END-OF-SELECTION", "AT LINE-SELECTION", "AT USER-COMMAND"],
            prefixes: ["AT SELECTION-SCREEN", "TOP-OF-PAGE", "END-OF-PAGE"],
          },

          statements: {
            calls: [
              // PERFORM <subr> [TABLES ...] [USING ...] [CHANGING ...].
              {
                kind: "PERFORM",
                pattern: new RegExp(String.raw`^PERFORM\s+(${IDENT})\b\s*(.*)$`, "i"),
                calleeKind: "FORM",
                clauseOrder: ["TABLES", "USING", "CHANGING"],
              },

              // CALL FUNCTION 'Z_FOO'. (creates a call edge but does not parse EXPORTING/CHANGING mappings)
              {
                kind: "CALL_FUNCTION",
                pattern: /^CALL FUNCTION\s+'([^']+)'/i,
                calleeKind: "FUNCTION",
              },
            ],

            declarations: {
              globalKinds: ["DATA", "CONSTANTS", "PARAMETERS"],
              localKinds: ["DATA", "CONSTANTS"],
              ignorePatterns: {
                DATA: [/^DATA\(/i, /\bBEGIN\s+OF\b/i, /\bEND\s+OF\b/i],
                CONSTANTS: [/\bBEGIN\s+OF\b/i, /\bEND\s+OF\b/i],
              },
            },

            writes: {
              rules: [
                { regex: new RegExp(String.raw`^(${IDENT_PATH})\s*=\s*`) },
                { regex: new RegExp(String.raw`^CLEAR\s+(${IDENT_PATH})\b`, "i") },
                { whenStartsWith: "APPEND", regex: new RegExp(String.raw`\bTO\b\s+(${IDENT_PATH})\b`, "i") },
                { whenStartsWith: "CONCATENATE", regex: new RegExp(String.raw`\bINTO\b\s+(${IDENT_PATH})\b`, "i") },
              ],
            },

            // Legacy: still used for Data Trace. ABAP Objects parsing is handled by `abap_objects/loader.js`.
            assignments: {
              rules: [{ regex: new RegExp(String.raw`^(${IDENT_PATH})\s*=\s*(.+)$`) }],
            },

            // Legacy: still used for indentation heuristics. ABAP Objects parsing is handled by `abap_objects/loader.js`.
            conditionals: {
              rules: [
                { kind: "IF", regex: /^IF\s+(.+)$/i },
                { kind: "ELSEIF", regex: /^ELSEIF\s+(.+)$/i },
              ],
            },
          },
        },

        // ABAP Objects that can be parsed + rendered via templates.
        objects: [
          {
            id: "performCall",
            kind: "callEdge",
            label: "PERFORM",
            match: { toKeyPrefix: "FORM:" },
            builder: { kind: "performCall" },
            templates: [
              {
                id: "perform.excel-like-table",
                label: "PERFORM Excel-like table",
                auto: true,
                file: "js/abap_objects/templates/perform.excel-like-table.js",
              },
            ],
          },

          {
            id: "assignment",
            kind: "statement",
            label: "Assignments (lhs = rhs)",
            parse: { kind: "assignment", continueAfterMatch: true },
            builder: { kind: "assignment" },
            templates: [
              {
                id: "assignment.excel-like-table",
                label: "Assignments Excel-like table",
                auto: true,
                file: "js/abap_objects/templates/assignment.excel-like-table.js",
              },
            ],
          },

          {
            id: "if",
            kind: "statement",
            label: "IF / ELSEIF",
            parse: { kind: "conditional" },
            builder: { kind: "if" },
            templates: [
              {
                id: "if.excel-like-table",
                label: "IF / ELSEIF Excel-like table",
                auto: true,
                file: "js/abap_objects/templates/if.excel-like-table.js",
              },
            ],
          },

          {
            id: "message",
            kind: "statement",
            label: "MESSAGE",
            parse: { kind: "message" },
            builder: { kind: "message" },
            templates: [
              {
                id: "message.excel-like-table",
                label: "MESSAGE Excel-like table",
                auto: true,
                file: "js/abap_objects/templates/message.excel-like-table.js",
              },
            ],
          },

          {
            id: "itabOp",
            kind: "statement",
            label: "READ/COLLECT/MODIFY/DELETE ITAB",
            parse: { kind: "itabOp" },
            builder: { kind: "itabOp" },
            templates: [
              {
                id: "itabRead.excel-like-table",
                label: "READ TABLE Excel-like table",
                auto: true,
                when: { path: "itabOp.kind", equals: "READ" },
                file: "js/abap_objects/templates/itabRead.excel-like-table.js",
              },
              {
                id: "itabCollect.excel-like-table",
                label: "COLLECT Excel-like table",
                auto: true,
                when: { path: "itabOp.kind", equals: "COLLECT" },
                file: "js/abap_objects/templates/itabCollect.excel-like-table.js",
              },
              {
                id: "itabModify.excel-like-table",
                label: "MODIFY ITAB Excel-like table",
                auto: true,
                when: { path: "itabOp.kind", equals: "MODIFY" },
                file: "js/abap_objects/templates/itabModify.excel-like-table.js",
              },
              {
                id: "itabDelete.excel-like-table",
                label: "DELETE ITAB Excel-like table",
                auto: true,
                when: { path: "itabOp.kind", equals: "DELETE" },
                file: "js/abap_objects/templates/itabDelete.excel-like-table.js",
              },
            ],
          },

          {
            id: "append",
            kind: "statement",
            label: "APPEND",
            parse: {
              kind: "regex",
              regex: /^APPEND\s+(.+?)\s+TO\s+(.+?)(?=\s+SORTED\s+BY\b|\s+(?:ASSIGNING|REFERENCE|INTO)\b|$)(?:\s+SORTED\s+BY\s+(.+?)(?=\s+(?:ASSIGNING|REFERENCE|INTO)\b|$))?(?:\s+(.*))?$/i,
              fields: { line: 1, itab: 2, sortedBy: 3, result: 4 },
            },
            builder: { kind: "append" },
            templates: [
              {
                id: "append.excel-like-table",
                label: "APPEND Excel-like table",
                auto: true,
                file: "js/abap_objects/templates/append.excel-like-table.js",
              },
            ],
          },
        ],
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/utils.js
    (function (ns) {
      "use strict";

      const utils = {};

      utils.normalizeNewlines = function (text) {
        if (text == null) return "";
        return String(text).replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      };

      utils.splitLines = function (text) {
        return utils.normalizeNewlines(text).split("\n");
      };

      utils.computeLineStartOffsets = function (text) {
        const normalized = utils.normalizeNewlines(text);
        const offsets = [0];
        for (let i = 0; i < normalized.length; i++) {
          if (normalized[i] === "\n") offsets.push(i + 1);
        }
        offsets.push(normalized.length);
        return offsets;
      };

      utils.isFullLineComment = function (line) {
        const t = String(line || "").trimStart();
        return t.startsWith("*");
      };

      utils.splitInlineComment = function (line) {
        const s = String(line || "");
        let out = "";
        let comment = "";
        let inString = false;

        for (let i = 0; i < s.length; i++) {
          const ch = s[i];
          if (ch === "'") {
            out += ch;
            if (inString) {
              if (i + 1 < s.length && s[i + 1] === "'") {
                out += s[i + 1];
                i++;
              } else {
                inString = false;
              }
            } else {
              inString = true;
            }
            continue;
          }

          if (!inString && ch === '"') {
            comment = s.slice(i + 1);
            break;
          }
          out += ch;
        }

        return { code: out, comment };
      };

      utils.stripInlineComment = function (line) {
        return utils.splitInlineComment(line).code;
      };

      utils.normalizeSpaces = function (s) {
        return String(s || "")
          .replace(/\s+/g, " ")
          .trim();
      };

      utils.stripTrailingPeriod = function (s) {
        return String(s || "").replace(/\.\s*$/, "");
      };

      utils.cleanIdentifierToken = function (token) {
        return String(token || "")
          .trim()
          .replace(/^[\(\[\{]+/, "")
          .replace(/[\)\]\}\.,;]+$/, "")
          .trim();
      };

      utils.unwrapValueToken = function (token) {
        const t = String(token || "").trim();
        const m = /^VALUE\((.+)\)$/i.exec(t);
        return m ? m[1].trim() : t;
      };

      utils.isIdentifier = function (token) {
        const t = utils.cleanIdentifierToken(token);
        return /^[A-Za-z_][A-Za-z0-9_\/]*(?:[-~][A-Za-z0-9_\/]+)*$/.test(t);
      };

      utils.splitByCommaOutsideQuotes = function (s) {
        const out = [];
        let buf = "";
        let inString = false;

        for (let i = 0; i < s.length; i++) {
          const ch = s[i];
          if (ch === "'") {
            buf += ch;
            if (inString) {
              if (i + 1 < s.length && s[i + 1] === "'") {
                buf += s[i + 1];
                i++;
              } else {
                inString = false;
              }
            } else {
              inString = true;
            }
            continue;
          }

          if (!inString && ch === ",") {
            out.push(buf);
            buf = "";
            continue;
          }
          buf += ch;
        }

        out.push(buf);
        return out;
      };

      utils.collectStatements = function (lines, startLine, endLine) {
        const statements = [];
        let current = "";
        let stmtStart = null;

        const from = Math.max(1, startLine || 1);
        const to = Math.min(lines.length, endLine || lines.length);

        for (let ln = from; ln <= to; ln++) {
          const rawLine = lines[ln - 1] || "";
          if (utils.isFullLineComment(rawLine)) continue;

          const codeLine = utils.stripInlineComment(rawLine);
          if (!codeLine.trim()) continue;

          if (stmtStart == null) stmtStart = ln;

          let inString = false;
          for (let i = 0; i < codeLine.length; i++) {
            const ch = codeLine[i];
            current += ch;

            if (ch === "'") {
              if (inString) {
                if (i + 1 < codeLine.length && codeLine[i + 1] === "'") {
                  current += codeLine[i + 1];
                  i++;
                } else {
                  inString = false;
                }
              } else {
                inString = true;
              }
              continue;
            }

            if (!inString && ch === ".") {
              statements.push({ startLine: stmtStart, endLine: ln, text: current });
              current = "";
              stmtStart = null;
            }
          }

          if (stmtStart != null) current += "\n";
        }

        return statements;
      };

      utils.escapeHtml = function (s) {
        return String(s ?? "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      };

      utils.nowIso = function nowIso() {
        return new Date().toISOString();
      };

      utils.safeJsonParse = function safeJsonParse(text) {
        try {
          return { ok: true, value: JSON.parse(text) };
        } catch (err) {
          return { ok: false, error: String(err?.message || err) };
        }
      };

      utils.extractSource = function extractSource(model, sourceRef) {
        if (!model || !Array.isArray(model.lines) || !sourceRef) return "";
        const start = Math.max(1, Math.floor(Number(sourceRef.startLine || 1)));
        const end = Math.min(model.lines.length, Math.floor(Number(sourceRef.endLine || start)));
        return model.lines.slice(start - 1, end).join("\n").trim();
      };

      ns.utils = utils;
    })(window.AbapFlow);

    </script>
        <script>
    // js/template_defs_store.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      const STORAGE_KEY = "abapflow-template-defs";
      const SCHEMA = "abapflow-template-defs";
      const VERSION = 1;

      function nowIso() {
        if (utils && typeof utils.nowIso === "function") return utils.nowIso();
        return new Date().toISOString();
      }

      function safeParse(jsonText) {
        if (utils && typeof utils.safeJsonParse === "function") return utils.safeJsonParse(jsonText);
        try {
          return { ok: true, value: JSON.parse(String(jsonText || "")) };
        } catch (e) {
          return { ok: false, error: String(e?.message || e) };
        }
      }

      function asNonEmptyString(x) {
        const s = String(x ?? "").trim();
        return s ? s : "";
      }

      function isPlainObject(x) {
        return Boolean(x) && typeof x === "object" && !Array.isArray(x);
      }

      function normalizeWhen(when) {
        if (!isPlainObject(when)) return null;
        const path = asNonEmptyString(when.path);
        const equals = asNonEmptyString(when.equals);
        if (!path || !equals) return null;
        return { path, equals };
      }

      function normalizeTemplateMeta(meta) {
        if (!isPlainObject(meta)) return {};
        const label = asNonEmptyString(meta.label);
        const source = asNonEmptyString(meta.source);
        const auto = meta.auto != null ? Boolean(meta.auto) : true;
        const custom = Boolean(meta.custom);
        const when = normalizeWhen(meta.when);
        return {
          ...(label ? { label } : {}),
          ...(source ? { source } : {}),
          auto,
          custom,
          ...(when ? { when } : {}),
        };
      }

      function normalizeStore(value) {
        const out = {
          schema: SCHEMA,
          version: VERSION,
          updatedAt: nowIso(),
          templates: {},
          preferredBySource: {},
        };

        if (!isPlainObject(value)) return out;

        const schema = asNonEmptyString(value.schema);
        const version = Number(value.version);
        if (schema !== SCHEMA || !Number.isFinite(version) || version <= 0) return out;

        const templates = isPlainObject(value.templates) ? value.templates : {};
        for (const [idRaw, entry] of Object.entries(templates)) {
          const id = asNonEmptyString(idRaw);
          if (!id) continue;
          if (!isPlainObject(entry)) continue;
          const config = entry.config;
          if (!isPlainObject(config)) continue;
          const meta = normalizeTemplateMeta(entry.meta);
          out.templates[id] = { updatedAt: asNonEmptyString(entry.updatedAt) || nowIso(), config, meta };
        }

        const pref = isPlainObject(value.preferredBySource) ? value.preferredBySource : {};
        for (const [srcRaw, tidRaw] of Object.entries(pref)) {
          const src = asNonEmptyString(srcRaw);
          const tid = asNonEmptyString(tidRaw);
          if (!src || !tid) continue;
          out.preferredBySource[src] = tid;
        }

        out.updatedAt = asNonEmptyString(value.updatedAt) || out.updatedAt;
        return out;
      }

      function loadStore() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return normalizeStore(null);
          const parsed = safeParse(raw);
          if (!parsed.ok) return normalizeStore(null);
          return normalizeStore(parsed.value);
        } catch (_) {
          return normalizeStore(null);
        }
      }

      function saveStore(store) {
        const normalized = normalizeStore(store);
        normalized.updatedAt = nowIso();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(normalized));
        return normalized;
      }

      function getTemplateConfig(templateId) {
        const id = asNonEmptyString(templateId);
        if (!id) return null;
        const store = loadStore();
        return store.templates?.[id]?.config || null;
      }

      function upsertTemplate(templateId, config, meta) {
        const id = asNonEmptyString(templateId);
        if (!id) return { ok: false, error: "Template id is required." };
        if (!isPlainObject(config)) return { ok: false, error: "Template config must be an object." };

        const store = loadStore();
        const nextMeta = normalizeTemplateMeta(meta);
        const existing = store.templates?.[id];

        store.templates[id] = {
          updatedAt: nowIso(),
          config,
          meta: { ...(existing?.meta || {}), ...nextMeta },
        };

        const saved = saveStore(store);
        return { ok: true, store: saved };
      }

      function deleteTemplate(templateId) {
        const id = asNonEmptyString(templateId);
        if (!id) return { ok: false, error: "Template id is required." };

        const store = loadStore();
        const existed = Boolean(store.templates?.[id]);
        if (existed) delete store.templates[id];

        for (const [src, tid] of Object.entries(store.preferredBySource || {})) {
          if (String(tid || "") === id) delete store.preferredBySource[src];
        }

        const saved = saveStore(store);
        return { ok: true, existed, store: saved };
      }

      function listCustomTemplateEntries() {
        const store = loadStore();
        const out = [];

        for (const [id, entry] of Object.entries(store.templates || {})) {
          if (!entry || typeof entry !== "object") continue;
          const meta = entry.meta || {};
          if (!meta.custom) continue;
          const source = asNonEmptyString(meta.source);
          if (!source) continue;
          const label = asNonEmptyString(meta.label) || id;
          out.push({
            id,
            label,
            source,
            objectId: source,
            auto: meta.auto !== false,
            when: meta.when || null,
            config: entry.config,
          });
        }

        out.sort((a, b) => a.id.localeCompare(b.id));
        return out;
      }

      function getPreferredTemplateId(sourceId) {
        const src = asNonEmptyString(sourceId);
        if (!src) return "";
        const store = loadStore();
        return asNonEmptyString(store.preferredBySource?.[src]);
      }

      function setPreferredTemplateId(sourceId, templateId) {
        const src = asNonEmptyString(sourceId);
        const tid = asNonEmptyString(templateId);
        if (!src) return { ok: false, error: "Source id is required." };

        const store = loadStore();
        if (tid) store.preferredBySource[src] = tid;
        else delete store.preferredBySource[src];

        const saved = saveStore(store);
        return { ok: true, store: saved };
      }

      ns.templateDefs = {
        STORAGE_KEY,
        loadStore,
        saveStore,
        getTemplateConfig,
        upsertTemplate,
        deleteTemplate,
        listCustomTemplateEntries,
        getPreferredTemplateId,
        setPreferredTemplateId,
      };
    })(window.AbapFlow);


    </script>
        <script>
    // js/abap_objects/custom_store.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      const STORAGE_KEY = "abapflow-abap-objects-custom";
      const SCHEMA = "abapflow-abap-objects-custom";
      const VERSION = 1;

      function nowIso() {
        if (utils && typeof utils.nowIso === "function") return utils.nowIso();
        return new Date().toISOString();
      }

      function safeParse(jsonText) {
        if (utils && typeof utils.safeJsonParse === "function") return utils.safeJsonParse(jsonText);
        try {
          return { ok: true, value: JSON.parse(String(jsonText || "")) };
        } catch (e) {
          return { ok: false, error: String(e?.message || e) };
        }
      }

      function asNonEmptyString(x) {
        const s = String(x ?? "").trim();
        return s ? s : "";
      }

      function isPlainObject(x) {
        return Boolean(x) && typeof x === "object" && !Array.isArray(x);
      }

      function deepClone(value) {
        if (value == null) return value;

        if (value instanceof RegExp) {
          return new RegExp(value.source, value.flags);
        }

        if (Array.isArray(value)) return value.map((x) => deepClone(x));

        if (typeof value === "object") {
          const out = {};
          for (const [k, v] of Object.entries(value)) out[k] = deepClone(v);
          return out;
        }

        return value;
      }

      function normalizeStore(value) {
        const out = {
          schema: SCHEMA,
          version: VERSION,
          updatedAt: nowIso(),
          objects: {},
          disabled: {},
        };

        if (!isPlainObject(value)) return out;
        if (asNonEmptyString(value.schema) !== SCHEMA) return out;
        const v = Number(value.version);
        if (!Number.isFinite(v) || v <= 0) return out;

        const objects = isPlainObject(value.objects) ? value.objects : {};
        for (const [keyRaw, obj] of Object.entries(objects)) {
          if (!isPlainObject(obj)) continue;
          const id = asNonEmptyString(obj.id) || asNonEmptyString(keyRaw);
          if (!id) continue;
          out.objects[id] = { ...obj, id };
        }

        const disabled = isPlainObject(value.disabled) ? value.disabled : {};
        for (const [keyRaw, flag] of Object.entries(disabled)) {
          const id = asNonEmptyString(keyRaw);
          if (!id) continue;
          if (flag) out.disabled[id] = true;
        }

        out.updatedAt = asNonEmptyString(value.updatedAt) || out.updatedAt;
        return out;
      }

      function loadStore() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return normalizeStore(null);
          const parsed = safeParse(raw);
          if (!parsed.ok) return normalizeStore(null);
          return normalizeStore(parsed.value);
        } catch (_) {
          return normalizeStore(null);
        }
      }

      function saveStore(store) {
        const normalized = normalizeStore(store);
        normalized.updatedAt = nowIso();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(normalized));
        return normalized;
      }

      function clearStore() {
        try {
          localStorage.removeItem(STORAGE_KEY);
        } catch (_) {}
      }

      function upsertObjectDef(objectDef) {
        const obj = isPlainObject(objectDef) ? objectDef : null;
        const id = asNonEmptyString(obj?.id);
        if (!id) return { ok: false, error: "Object id is required." };

        const store = loadStore();
        store.objects[id] = deepClone({ ...obj, id });
        const saved = saveStore(store);
        return { ok: true, store: saved };
      }

      function deleteObjectDef(objectId) {
        const id = asNonEmptyString(objectId);
        if (!id) return { ok: false, error: "Object id is required." };

        const store = loadStore();
        const existed = Boolean(store.objects?.[id]);
        if (existed) delete store.objects[id];
        const saved = saveStore(store);
        return { ok: true, existed, store: saved };
      }

      function setObjectDisabled(objectId, disabled) {
        const id = asNonEmptyString(objectId);
        if (!id) return { ok: false, error: "Object id is required." };

        const store = loadStore();
        if (disabled) store.disabled[id] = true;
        else delete store.disabled[id];
        const saved = saveStore(store);
        return { ok: true, store: saved };
      }

      function exportJson() {
        return JSON.stringify(loadStore(), null, 2);
      }

      function importJson(jsonText, options) {
        const mode = asNonEmptyString(options?.mode).toLowerCase() || "merge";
        const parsed = safeParse(jsonText);
        if (!parsed.ok) return { ok: false, error: parsed.error || "Invalid JSON." };
        const incoming = normalizeStore(parsed.value);

        if (mode === "replace") {
          const saved = saveStore(incoming);
          return { ok: true, store: saved };
        }

        const store = loadStore();
        for (const [id, obj] of Object.entries(incoming.objects || {})) {
          store.objects[id] = deepClone(obj);
        }
        for (const [id, flag] of Object.entries(incoming.disabled || {})) {
          if (flag) store.disabled[id] = true;
        }

        const saved = saveStore(store);
        return { ok: true, store: saved };
      }

      function getEffectiveConfig(masterConfig) {
        const base = isPlainObject(masterConfig) ? masterConfig : {};
        const store = loadStore();

        const out = deepClone(base);
        const baseObjects = Array.isArray(out.objects) ? out.objects : [];

        const byLower = new Map();
        for (let i = 0; i < baseObjects.length; i++) {
          const id = asNonEmptyString(baseObjects[i]?.id);
          if (!id) continue;
          const lower = id.toLowerCase();
          if (!byLower.has(lower)) byLower.set(lower, i);
        }

        const custom = [];
        for (const [id, obj] of Object.entries(store.objects || {})) {
          const oid = asNonEmptyString(obj?.id) || asNonEmptyString(id);
          if (!oid) continue;
          const lower = oid.toLowerCase();
          const cloned = deepClone({ ...(obj || {}), id: oid });
          if (byLower.has(lower)) baseObjects[byLower.get(lower)] = cloned;
          else custom.push(cloned);
        }

        custom.sort((a, b) => asNonEmptyString(a?.id).localeCompare(asNonEmptyString(b?.id)));

        const disabledSet = new Set(
          Object.entries(store.disabled || {})
            .filter(([, flag]) => Boolean(flag))
            .map(([id]) => String(id).trim().toLowerCase())
            .filter(Boolean),
        );

        out.objects = baseObjects
          .concat(custom)
          .filter((obj) => !disabledSet.has(asNonEmptyString(obj?.id).toLowerCase()));

        return { config: out, store };
      }

      ns.abapObjects = ns.abapObjects || {};
      ns.abapObjects.customStore = {
        STORAGE_KEY,
        loadStore,
        saveStore,
        clearStore,
        upsertObjectDef,
        deleteObjectDef,
        setObjectDisabled,
        exportJson,
        importJson,
        getEffectiveConfig,
      };
    })(window.AbapFlow);


    </script>
        <script>
    // js/logic.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      function isWordChar(ch) {
        return /[A-Za-z0-9_\/]/.test(String(ch || ""));
      }

      function matchKeywordAt(s, i, keywordUpper) {
        const kw = String(keywordUpper || "").toUpperCase();
        if (!kw) return false;
        const end = i + kw.length;
        if (end > s.length) return false;
        if (s.slice(i, end).toUpperCase() !== kw) return false;

        const prev = i > 0 ? s[i - 1] : "";
        const next = end < s.length ? s[end] : "";
        if (prev && isWordChar(prev)) return false;
        if (next && isWordChar(next)) return false;
        return true;
      }

      function stripOuterParens(text) {
        let s = String(text || "").trim();
        if (!s.startsWith("(") || !s.endsWith(")")) return s;

        function hasWrappingParens(input) {
          const t = String(input || "").trim();
          if (!t.startsWith("(") || !t.endsWith(")")) return false;

          let depth = 0;
          let inString = false;
          let inTemplate = false;

          for (let i = 0; i < t.length; i++) {
            const ch = t[i];

            if (ch === "'" && !inTemplate) {
              if (inString) {
                if (i + 1 < t.length && t[i + 1] === "'") {
                  i++;
                } else {
                  inString = false;
                }
              } else {
                inString = true;
              }
              continue;
            }

            if (!inString && ch === "|") {
              inTemplate = !inTemplate;
              continue;
            }

            if (inString || inTemplate) continue;

            if (ch === "(") depth++;
            else if (ch === ")") depth--;

            if (depth === 0 && i < t.length - 1) return false;
          }

          return depth === 0;
        }

        while (hasWrappingParens(s)) {
          s = s.slice(1, -1).trim();
        }

        return s;
      }

      function splitLogicalExpression(expr) {
        const s = String(expr || "").trim();
        const parts = [];
        const ops = [];

        let buf = "";
        let depth = 0;
        let inString = false;
        let inTemplate = false;

        for (let i = 0; i < s.length; i++) {
          const ch = s[i];

          if (ch === "'" && !inTemplate) {
            buf += ch;
            if (inString) {
              if (i + 1 < s.length && s[i + 1] === "'") {
                buf += s[i + 1];
                i++;
              } else {
                inString = false;
              }
            } else {
              inString = true;
            }
            continue;
          }

          if (!inString && ch === "|") {
            buf += ch;
            inTemplate = !inTemplate;
            continue;
          }

          if (!inString && !inTemplate) {
            if (ch === "(") {
              depth++;
              buf += ch;
              continue;
            }
            if (ch === ")") {
              depth = Math.max(0, depth - 1);
              buf += ch;
              continue;
            }
          }

          if (!inString && !inTemplate && depth === 0) {
            if (matchKeywordAt(s, i, "AND")) {
              const t = buf.trim();
              if (t) parts.push(t);
              ops.push("AND");
              buf = "";
              i += 2;
              continue;
            }
            if (matchKeywordAt(s, i, "OR")) {
              const t = buf.trim();
              if (t) parts.push(t);
              ops.push("OR");
              buf = "";
              i += 1;
              continue;
            }
          }

          buf += ch;
        }

        const last = buf.trim();
        if (last) parts.push(last);
        if (ops.length >= parts.length) ops.length = Math.max(0, parts.length - 1);

        return { parts, ops };
      }

      function parseSimpleCondition(rawTerm) {
        const term = utils.normalizeSpaces(stripOuterParens(rawTerm));
        if (!term) return { item1: "", operator: "", item2: "", raw: "" };

        let m = /^(.+?)\s+IS\s+NOT\s+INITIAL$/i.exec(term);
        if (m) return { item1: m[1].trim(), operator: "IS NOT INITIAL", item2: "", raw: term };

        m = /^(.+?)\s+IS\s+INITIAL$/i.exec(term);
        if (m) return { item1: m[1].trim(), operator: "IS INITIAL", item2: "", raw: term };

        m = /^(.+?)\s*(<=|>=|<>|=|<|>)\s*(.+)$/i.exec(term);
        if (m) return { item1: m[1].trim(), operator: m[2].toUpperCase(), item2: m[3].trim(), raw: term };

        m = /^(.+?)\s+\b(EQ|NE|GT|LT|GE|LE)\b\s+(.+)$/i.exec(term);
        if (m) return { item1: m[1].trim(), operator: m[2].toUpperCase(), item2: m[3].trim(), raw: term };

        m = /^(.+?)\s+\bIN\b\s+(.+)$/i.exec(term);
        if (m) return { item1: m[1].trim(), operator: "IN", item2: m[2].trim(), raw: term };

        return { item1: term, operator: "", item2: "", raw: term };
      }

      function parseIfExpression(expr) {
        const { parts, ops } = splitLogicalExpression(expr);
        const out = [];

        for (let i = 0; i < parts.length; i++) {
          const parsed = parseSimpleCondition(parts[i]);
          out.push({ ...parsed, association: String(ops[i] || "").toUpperCase() });
        }

        return out;
      }

      ns.logic = { splitLogicalExpression, parseSimpleCondition, parseIfExpression };
    })(window.AbapFlow);


    </script>
        <script>
    // js/notes.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      const STORAGE_KEY = "abapFlow.notes.v1";
      const SCHEMA = "abapflow-notes";
      const VERSION = 1;

      const nowIso = typeof utils?.nowIso === "function" ? utils.nowIso : () => new Date().toISOString();
      const safeJsonParse =
        typeof utils?.safeJsonParse === "function"
          ? utils.safeJsonParse
          : (text) => {
              try {
                return { ok: true, value: JSON.parse(text) };
              } catch (err) {
                return { ok: false, error: String(err?.message || err) };
              }
            };

      function normalizeProgramId(id) {
        const s = String(id || "")
          .trim()
          .toLowerCase();
        return s || "default";
      }

      function normalizeParamName(name) {
        return String(name || "")
          .trim()
          .toLowerCase();
      }

      function makeParamKey(routineKey, paramName) {
        const rk = String(routineKey || "").trim();
        const pn = normalizeParamName(paramName);
        if (!rk || !pn) return "";
        return `PARAM:${rk}:${pn}`;
      }

      function normalizeDeclKind(kind) {
        return String(kind || "").trim().toUpperCase();
      }

      function makeDeclKey(scopeKey, declKind, variableName) {
        const sk = String(scopeKey || "").trim();
        const dk = normalizeDeclKind(declKind);
        const vn = normalizeParamName(variableName);
        if (!sk || !dk || !vn) return "";
        return `DECL:${sk}:${dk}:${vn}`;
      }

      function makeTypeFieldKey(typeScopeKey, typeName, fieldPath) {
        const sk = String(typeScopeKey || "").trim();
        const tn = normalizeParamName(typeName);
        const fp = normalizeParamName(fieldPath);
        if (!sk || !tn || !fp) return "";
        return `TYPEFIELD:${sk}:${tn}:${fp}`;
      }

      function getProgramIdFromText(text) {
        const lines = String(text || "").split(/\r?\n/);
        for (const rawLine of lines) {
          if (utils.isFullLineComment(rawLine)) continue;
          const code = utils.stripInlineComment(rawLine).trim();
          if (!code) continue;
          const m = /^(REPORT|PROGRAM)\s+([A-Za-z_][A-Za-z0-9_\/]*)\s*\./i.exec(code);
          if (m) return normalizeProgramId(m[2]);
        }
        return "default";
      }

      function normalizeEntry(entry) {
        const desc = String(entry?.description || "").trim();
        const note = String(entry?.note || "").trim();
        const out = { description: desc, note };
        if (entry?.updatedAt) out.updatedAt = String(entry.updatedAt);
        return out;
      }

      function normalizeStore(raw) {
        const store = {
          schema: SCHEMA,
          version: VERSION,
          updatedAt: nowIso(),
          programs: {},
        };

        if (!raw || typeof raw !== "object") return store;

        // Backward compatibility: { routines: { ... } }
        if (raw.routines && typeof raw.routines === "object") {
          const pId = "default";
          store.programs[pId] = { updatedAt: nowIso(), routines: {} };
          for (const [key, entry] of Object.entries(raw.routines)) {
            store.programs[pId].routines[String(key)] = normalizeEntry(entry);
          }
          return store;
        }

        if (raw.programs && typeof raw.programs === "object") {
          for (const [pidRaw, p] of Object.entries(raw.programs)) {
            const pid = normalizeProgramId(pidRaw);
            const routines = {};
            const rawRoutines = p?.routines && typeof p.routines === "object" ? p.routines : {};
            for (const [key, entry] of Object.entries(rawRoutines)) {
              routines[String(key)] = normalizeEntry(entry);
            }
            store.programs[pid] = { updatedAt: String(p?.updatedAt || nowIso()), routines };
          }
        }

        if (raw.updatedAt) store.updatedAt = String(raw.updatedAt);
        return store;
      }

      function loadStore() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return normalizeStore(null);
          const parsed = safeJsonParse(raw);
          if (!parsed.ok) return normalizeStore(null);
          return normalizeStore(parsed.value);
        } catch (_) {
          return normalizeStore(null);
        }
      }

      function saveStore(store) {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(store, null, 2));
        } catch (_) {
          // ignore (storage may be unavailable); keep in-memory store
        }
      }

      let store = loadStore();
      let activeProgramId = "default";

      function ensureActiveProgram() {
        const pid = normalizeProgramId(activeProgramId);
        if (!store.programs[pid]) {
          store.programs[pid] = { updatedAt: nowIso(), routines: {} };
        }
        return store.programs[pid];
      }

      function setActiveProgramFromText(text) {
        activeProgramId = getProgramIdFromText(text);
        ensureActiveProgram();
      }

      function getActiveProgramId() {
        return normalizeProgramId(activeProgramId);
      }

      function getEntry(routineKey) {
        const pid = getActiveProgramId();
        const p = store.programs[pid];
        if (!p || !p.routines) return null;
        return p.routines[String(routineKey)] || null;
      }

      function setEntry(routineKey, patch) {
        const pid = getActiveProgramId();
        const p = ensureActiveProgram();
        const key = String(routineKey);
        const cur = p.routines[key] || { description: "", note: "" };
        const next = {
          description: String(patch?.description ?? cur.description ?? "").trim(),
          note: String(patch?.note ?? cur.note ?? "").trim(),
          updatedAt: nowIso(),
        };

        if (!next.description && !next.note) {
          delete p.routines[key];
        } else {
          p.routines[key] = next;
        }

        p.updatedAt = nowIso();
        store.updatedAt = nowIso();
        saveStore(store);
        return next;
      }

      function applyToModel(model) {
        const pid = getActiveProgramId();
        const p = store.programs[pid];
        if (!model || !model.nodes) return;

        const programEntry = p?.routines?.PROGRAM || null;
        if (programEntry) {
          model.userDescription = String(programEntry.description || "");
          model.userNote = String(programEntry.note || "");
        } else {
          delete model.userDescription;
          delete model.userNote;
        }

        for (const node of model.nodes.values()) {
          const entry = p?.routines?.[node.key] || null;
          if (entry) {
            node.userDescription = String(entry.description || "");
            node.userNote = String(entry.note || "");
          } else {
            delete node.userDescription;
            delete node.userNote;
          }

          if (node.params && node.params.length) {
            for (const param of node.params) {
              const key = makeParamKey(node.key, param.name);
              const pe = key ? p?.routines?.[key] || null : null;
              if (pe) {
                param.userDescription = String(pe.description || "");
                param.userNote = String(pe.note || "");
              } else {
                delete param.userDescription;
                delete param.userNote;
              }
            }
          }

          if (node.localData && node.localData.length) {
            for (const decl of node.localData) {
              const key = makeDeclKey(node.key, decl.declKind, decl.variableName);
              const de = key ? p?.routines?.[key] || null : null;
              if (de) {
                decl.userDescription = String(de.description || "");
                decl.userNote = String(de.note || "");
              } else {
                delete decl.userDescription;
                delete decl.userNote;
              }
            }
          }

          if (node.localConstants && node.localConstants.length) {
            for (const decl of node.localConstants) {
              const key = makeDeclKey(node.key, decl.declKind, decl.variableName);
              const de = key ? p?.routines?.[key] || null : null;
              if (de) {
                decl.userDescription = String(de.description || "");
                decl.userNote = String(de.note || "");
              } else {
                delete decl.userDescription;
                delete decl.userNote;
              }
            }
          }
        }

        if (model.globalData && model.globalData.length) {
          for (const decl of model.globalData) {
            const key = makeDeclKey("PROGRAM", decl.declKind, decl.variableName);
            const de = key ? p?.routines?.[key] || null : null;
            if (de) {
              decl.userDescription = String(de.description || "");
              decl.userNote = String(de.note || "");
            } else {
              delete decl.userDescription;
              delete decl.userNote;
            }
          }
        }

        if (model.globalConstants && model.globalConstants.length) {
          for (const decl of model.globalConstants) {
            const key = makeDeclKey("PROGRAM", decl.declKind, decl.variableName);
            const de = key ? p?.routines?.[key] || null : null;
            if (de) {
              decl.userDescription = String(de.description || "");
              decl.userNote = String(de.note || "");
            } else {
              delete decl.userDescription;
              delete decl.userNote;
            }
          }
        }

        function makeTypeDefKey(scopeKey, typeName) {
          const sk = String(scopeKey || "").trim();
          const tn = String(typeName || "")
            .trim()
            .toLowerCase();
          if (!sk || !tn) return "";
          return `${sk}|${tn}`;
        }

        if (model.typeDefs && typeof model.typeDefs.values === "function") {
          for (const t of model.typeDefs.values()) {
            const scopeKey = String(t?.scopeKey || "").trim() || "PROGRAM";
            const typeName = String(t?.name || "").trim();
            if (!typeName) continue;
            const fields = t?.fields && typeof t.fields.values === "function" ? t.fields : null;
            if (!fields) continue;

            for (const field of fields.values()) {
              const path = String(field?.variableName || "").trim();
              if (!path) continue;
              const key = makeTypeFieldKey(scopeKey, typeName, path);
              const entry = key ? p?.routines?.[key] || null : null;
              if (entry) {
                field.userDescription = String(entry.description || "");
                field.userNote = String(entry.note || "");
              } else {
                delete field.userDescription;
                delete field.userNote;
              }
            }
          }
        }

        function syncVirtualDeclFromTypeField(decl) {
          if (!decl || !decl.isVirtual) return;
          const origin = decl?.virtualOrigin && typeof decl.virtualOrigin === "object" ? decl.virtualOrigin : null;
          if (!origin || origin.kind !== "typeField") return;

          const typeScopeKey = String(origin.typeScopeKey || "").trim() || "PROGRAM";
          const typeName = String(origin.typeName || "").trim();
          const fieldPath = String(origin.fieldPath || "").trim();
          if (!typeName || !fieldPath) return;

          const typeDef = model.typeDefs.get(makeTypeDefKey(typeScopeKey, typeName)) || null;
          const field = typeDef?.fields?.get ? typeDef.fields.get(fieldPath.toLowerCase()) : null;
          if (!field) return;

          decl.description = String(field.description || "");
          if (field.userDescription) decl.userDescription = String(field.userDescription || "");
          else delete decl.userDescription;
          if (field.userNote) decl.userNote = String(field.userNote || "");
          else delete decl.userNote;
        }

        for (const decl of model.globalData || []) syncVirtualDeclFromTypeField(decl);
        for (const decl of model.globalConstants || []) syncVirtualDeclFromTypeField(decl);
        for (const node of model.nodes.values()) {
          for (const decl of node?.localData || []) syncVirtualDeclFromTypeField(decl);
          for (const decl of node?.localConstants || []) syncVirtualDeclFromTypeField(decl);
        }
      }

      function exportJson() {
        return JSON.stringify(store, null, 2);
      }

      function importJson(text, options) {
        const mode = options?.mode === "replace" ? "replace" : "merge";
        const parsed = safeJsonParse(text);
        if (!parsed.ok) return { ok: false, error: `Invalid JSON: ${parsed.error}` };

        const incoming = normalizeStore(parsed.value);
        if (incoming.schema !== SCHEMA || incoming.version !== VERSION) {
          // Accept anyway as long as it has programs/routines we can normalize.
        }

        if (mode === "replace") {
          store = incoming;
          saveStore(store);
          ensureActiveProgram();
          return { ok: true, mode, programs: Object.keys(store.programs).length };
        }

        // merge
        let merged = 0;
        for (const [pid, p] of Object.entries(incoming.programs)) {
          if (!store.programs[pid]) store.programs[pid] = { updatedAt: nowIso(), routines: {} };
          const target = store.programs[pid];
          for (const [key, entry] of Object.entries(p.routines || {})) {
            target.routines[key] = normalizeEntry(entry);
            merged++;
          }
          target.updatedAt = nowIso();
        }
        store.updatedAt = nowIso();
        saveStore(store);
        ensureActiveProgram();
        return { ok: true, mode, merged };
      }

      ns.notes = {
        STORAGE_KEY,
        getProgramIdFromText,
        setActiveProgramFromText,
        getActiveProgramId,
        makeParamKey,
        makeDeclKey,
        makeTypeFieldKey,
        getEntry,
        setEntry,
        applyToModel,
        exportJson,
        importJson,
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/model.js
    (function (ns) {
      "use strict";

      class SourceRef {
        constructor(startLine, endLine) {
          this.startLine = startLine;
          this.endLine = endLine;
        }
      }

      class AbapParameter {
        constructor(kind, name, dataType, description, sourceRef) {
          this.kind = kind;
          this.name = name;
          this.dataType = dataType || "";
          this.description = description || "";
          this.sourceRef = sourceRef || null;
        }
      }

      class AbapDataDeclaration {
        constructor(declKind, variableName, dataType, value, description, sourceRef) {
          this.declKind = declKind;
          this.variableName = variableName;
          this.dataType = dataType || "";
          this.value = value || "";
          this.description = description || "";
          this.sourceRef = sourceRef || null;
        }
      }

      class AbapWrite {
        constructor(variableName, statement, sourceRef) {
          this.variableName = variableName;
          this.statement = statement;
          this.sourceRef = sourceRef || null;
        }
      }

      class AbapAssignment {
        constructor(lhs, rhs, statement, sourceRef) {
          this.lhs = lhs;
          this.rhs = rhs;
          this.statement = statement || "";
          this.sourceRef = sourceRef || null;
        }
      }

      class AbapIfStatement {
        constructor(kind, condition, sourceRef) {
          this.kind = String(kind || "").trim().toUpperCase() || "IF";
          this.condition = String(condition || "").trim();
          this.sourceRef = sourceRef || null;
        }
      }

      class AbapMessageStatement {
        constructor(options) {
          this.kind = "MESSAGE";
          this.msgType = String(options?.msgType || "").trim();
          this.msgClass = String(options?.msgClass || "").trim();
          this.msgNo = String(options?.msgNo || "").trim();
          this.text = String(options?.text || "").trim();
          this.displayLike = String(options?.displayLike || "").trim();
          this.with = Array.isArray(options?.with) ? options.with.map((x) => String(x ?? "").trim()).filter(Boolean) : [];
          this.into = String(options?.into || "").trim();
          this.raising = String(options?.raising || "").trim();
          this.statement = String(options?.statement || "").trim();
          this.sourceRef = options?.sourceRef || null;
        }
      }

      class AbapItabOperation {
        constructor(kind, options, sourceRef) {
          this.kind = String(kind || "").trim().toUpperCase();
          this.table = String(options?.table || "").trim();
          this.target = String(options?.target || "").trim();
          this.conditionText = String(options?.conditionText || "").trim();
          this.conditionKind = String(options?.conditionKind || "").trim().toLowerCase(); // key|where|index|from|free
          this.binarySearch = Boolean(options?.binarySearch);
          this.statement = String(options?.statement || "").trim();
          this.sourceRef = sourceRef || null;
        }
      }

      class AbapCallEdge {
        constructor(fromKey, toKey, targetName, args, sourceRef) {
          this.fromKey = fromKey;
          this.toKey = toKey;
          this.targetName = targetName;
          this.args = args || { tables: [], using: [], changing: [] };
          this.sourceRef = sourceRef || null;
          this.isInCycle = false;
        }
      }

      class AbapRoutine {
        constructor(key, kind, name) {
          this.key = key;
          this.kind = kind;
          this.name = name;
          this.description = "";
          this.isDefined = false;
          this.sourceRef = null;

          this.params = [];
          this.localData = [];
          this.localConstants = [];
          this.assignments = [];
          this.writes = [];
          this.ifStatements = [];
          this.messages = [];
          this.itabOps = [];
          this.statementItems = [];

          this.calls = [];
          this.calledBy = [];

          this.depth = null;
          this.isInCycle = false;
        }

        get paramsCount() {
          return this.params.length;
        }

        get localDataCount() {
          return this.localData.length;
        }

        get localConstCount() {
          return this.localConstants.length;
        }

        get writesCount() {
          return this.writes.length;
        }

        get assignmentsCount() {
          return this.assignments.length;
        }
      }

      class ProgramModel {
        constructor(text, lines, lineStartOffsets) {
          this.text = text || "";
          this.lines = lines || [];
          this.lineStartOffsets = lineStartOffsets || [];

          this.nodes = new Map();
          this.edges = [];
          this.warnings = [];

          this.globalData = [];
          this.globalConstants = [];
          this.typeDefs = new Map();
        }

        static formKey(name) {
          return ProgramModel.routineKey("FORM", name);
        }

        static eventKey(name) {
          const n = String(name || "").replace(/\s+/g, " ").trim().toUpperCase();
          return `EVENT:${n}`;
        }

        static normalizeRoutineKind(kind) {
          return String(kind || "").trim().toUpperCase() || "FORM";
        }

        static routineKey(kind, name) {
          const k = ProgramModel.normalizeRoutineKind(kind);
          if (k === "EVENT") return ProgramModel.eventKey(name);
          return `${k}:${String(name || "").trim().toLowerCase()}`;
        }

        ensureRoutine(kind, name) {
          const k = ProgramModel.normalizeRoutineKind(kind);
          if (k === "EVENT") return this.ensureEvent(name);

          const key = ProgramModel.routineKey(k, name);
          let node = this.nodes.get(key);
          if (!node) {
            node = new AbapRoutine(key, k, String(name || "").trim());
            this.nodes.set(key, node);
          } else {
            node.kind = k;
            node.name = node.name || String(name || "").trim();
          }
          return node;
        }

        defineRoutine(kind, name, sourceRef, description, params) {
          const node = this.ensureRoutine(kind, name);
          node.kind = ProgramModel.normalizeRoutineKind(kind);
          node.name = String(name || "").trim();
          node.isDefined = true;
          node.sourceRef = sourceRef || node.sourceRef;
          node.description = description || node.description;
          node.params = params || node.params;
          return node;
        }

        ensureForm(name) {
          return this.ensureRoutine("FORM", name);
        }

        defineForm(name, sourceRef, description, params) {
          return this.defineRoutine("FORM", name, sourceRef, description, params);
        }

        ensureEvent(name, sourceRef) {
          const key = ProgramModel.eventKey(name);
          let node = this.nodes.get(key);
          if (!node) {
            node = new AbapRoutine(key, "EVENT", String(name || "").trim());
            node.isDefined = true;
            node.sourceRef = sourceRef || null;
            this.nodes.set(key, node);
          } else {
            node.kind = "EVENT";
            node.name = String(name || "").trim();
            node.isDefined = true;
            if (sourceRef && !node.sourceRef) node.sourceRef = sourceRef;
          }
          return node;
        }

        addEdge(edge) {
          this.edges.push(edge);
        }

        serialize() {
          const nodes = Array.from(this.nodes.values()).map((n) => ({
            key: n.key,
            kind: n.kind,
            name: n.name,
            description: n.description,
            isDefined: n.isDefined,
            depth: n.depth,
            isInCycle: n.isInCycle,
            sourceRef: n.sourceRef,
            params: n.params,
            localData: n.localData,
            localConstants: n.localConstants,
            assignments: n.assignments,
            writes: n.writes,
            ifStatements: n.ifStatements,
            messages: n.messages,
            itabOps: n.itabOps,
            statementItems: n.statementItems,
            calls: n.calls.map((e) => ({ toKey: e.toKey, sourceRef: e.sourceRef, args: e.args, isInCycle: e.isInCycle })),
            calledBy: n.calledBy.map((e) => ({ fromKey: e.fromKey, sourceRef: e.sourceRef, args: e.args, isInCycle: e.isInCycle })),
          }));

          const types = Array.from(this.typeDefs?.values?.() || []).map((t) => ({
            scopeKey: t.scopeKey,
            name: t.name,
            description: t.description,
            sourceRef: t.sourceRef,
            fields: Array.from(t.fields?.values?.() || []).map((f) => f),
          }));

          return {
            version: ns.version,
            globals: { data: this.globalData, constants: this.globalConstants },
            types,
            nodes,
            edges: this.edges,
            warnings: this.warnings,
          };
        }
      }

      ns.model = {
        SourceRef,
        AbapRoutine,
        AbapParameter,
        AbapDataDeclaration,
        AbapWrite,
        AbapAssignment,
        AbapIfStatement,
        AbapMessageStatement,
        AbapItabOperation,
        AbapCallEdge,
        ProgramModel,
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/abap_objects/schema.js
    (function (ns) {
      "use strict";

      function isPlainObject(x) {
        return Boolean(x) && typeof x === "object" && !Array.isArray(x);
      }

      function asNonEmptyString(x) {
        const s = String(x ?? "").trim();
        return s ? s : "";
      }

      function pushErr(errors, path, message) {
        errors.push({ path: String(path || ""), message: String(message || "Invalid value") });
      }

      function validateTemplateEntry(tpl, path, errors) {
        if (!isPlainObject(tpl)) {
          pushErr(errors, path, "Template must be an object.");
          return;
        }
        const id = asNonEmptyString(tpl.id);
        if (!id) pushErr(errors, `${path}.id`, "Template id is required.");

        const label = asNonEmptyString(tpl.label);
        if (!label) pushErr(errors, `${path}.label`, "Template label is required.");

        if (tpl.file != null && typeof tpl.file !== "string") {
          pushErr(errors, `${path}.file`, "Template file path must be a string.");
        }

        if (tpl.auto != null && typeof tpl.auto !== "boolean") {
          pushErr(errors, `${path}.auto`, "Template auto must be boolean.");
        }
      }

      function validateObjectDef(obj, index, errors) {
        const path = `objects[${index}]`;
        if (!isPlainObject(obj)) {
          pushErr(errors, path, "Object must be an object.");
          return;
        }

        const id = asNonEmptyString(obj.id);
        if (!id) pushErr(errors, `${path}.id`, "Object id is required.");

        const kind = asNonEmptyString(obj.kind).toLowerCase();
        if (!kind || !["statement", "calledge"].includes(kind)) {
          pushErr(errors, `${path}.kind`, "Object kind must be 'statement' or 'callEdge'.");
        }

        const builderKind = asNonEmptyString(obj?.builder?.kind);
        if (!builderKind) pushErr(errors, `${path}.builder.kind`, "Builder kind is required.");

        if (kind === "statement") {
          const parseKind = asNonEmptyString(obj?.parse?.kind).toLowerCase();
          if (!parseKind) pushErr(errors, `${path}.parse.kind`, "Parse kind is required for statement objects.");

          if (parseKind === "regex") {
            const rx = obj?.parse?.regex;
            const isRe = rx instanceof RegExp;
            const isStr = typeof rx === "string" && asNonEmptyString(rx);
            if (!isRe && !isStr) {
              pushErr(errors, `${path}.parse.regex`, "parse.regex must be a RegExp or a non-empty pattern string.");
            }

            if (obj?.parse?.flags != null && typeof obj.parse.flags !== "string") {
              pushErr(errors, `${path}.parse.flags`, "parse.flags must be a string.");
            }

            if (obj?.parse?.fields != null && !isPlainObject(obj.parse.fields)) {
              pushErr(errors, `${path}.parse.fields`, "parse.fields must be an object.");
            } else if (isPlainObject(obj?.parse?.fields)) {
              for (const [k, v] of Object.entries(obj.parse.fields)) {
                const n = Number(v);
                if (!asNonEmptyString(k)) continue;
                if (!Number.isFinite(n) || n < 0) pushErr(errors, `${path}.parse.fields.${k}`, "Field index must be a number >= 0.");
              }
            }
          }
        }

        if (kind === "calledge") {
          const toKeyPrefix = asNonEmptyString(obj?.match?.toKeyPrefix);
          if (!toKeyPrefix) pushErr(errors, `${path}.match.toKeyPrefix`, "match.toKeyPrefix is required for callEdge objects.");
        }

        if (obj.templates != null) {
          if (!Array.isArray(obj.templates)) {
            pushErr(errors, `${path}.templates`, "templates must be an array.");
          } else {
            for (let i = 0; i < obj.templates.length; i++) {
              validateTemplateEntry(obj.templates[i], `${path}.templates[${i}]`, errors);
            }
          }
        }
      }

      function validateMasterConfig(config) {
        const errors = [];

        if (!isPlainObject(config)) {
          pushErr(errors, "", "Config must be an object.");
          return { ok: false, errors };
        }

        const schema = asNonEmptyString(config.schema);
        if (!schema) pushErr(errors, "schema", "schema is required.");

        const version = Number(config.version);
        if (!Number.isFinite(version) || version <= 0) pushErr(errors, "version", "version must be a positive number.");

        if (config.parserConfig != null && !isPlainObject(config.parserConfig)) {
          pushErr(errors, "parserConfig", "parserConfig must be an object.");
        }

        if (!Array.isArray(config.objects)) {
          pushErr(errors, "objects", "objects must be an array.");
        } else {
          const seen = new Set();
          for (let i = 0; i < config.objects.length; i++) {
            const id = asNonEmptyString(config.objects?.[i]?.id);
            if (id) {
              const lower = id.toLowerCase();
              if (seen.has(lower)) pushErr(errors, `objects[${i}].id`, `Duplicate object id: ${id}`);
              else seen.add(lower);
            }
            validateObjectDef(config.objects[i], i, errors);
          }
        }

        return { ok: errors.length === 0, errors };
      }

      ns.abapObjects = ns.abapObjects || {};
      ns.abapObjects.schema = {
        validateMasterConfig,
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/abap_objects/parsers.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;
      const { AbapAssignment, AbapIfStatement, AbapMessageStatement, AbapItabOperation } = ns.model || {};

      function asRegex(value, flags) {
        if (!value) return null;
        if (value instanceof RegExp) return value;
        if (typeof value === "string") return new RegExp(value, flags || "i");
        return null;
      }

      function regexExec(re, text) {
        if (!re) return null;
        re.lastIndex = 0;
        return re.exec(text);
      }

      function splitTokensOutsideStrings(text) {
        const s = String(text ?? "");
        const tokens = [];
        let buf = "";
        let inString = false;
        let inTemplate = false;

        for (let i = 0; i < s.length; i++) {
          const ch = s[i];

          if (ch === "'" && !inTemplate) {
            buf += ch;
            if (inString) {
              if (i + 1 < s.length && s[i + 1] === "'") {
                buf += s[i + 1];
                i++;
              } else {
                inString = false;
              }
            } else {
              inString = true;
            }
            continue;
          }

          if (!inString && ch === "|") {
            buf += ch;
            inTemplate = !inTemplate;
            continue;
          }

          if (!inString && !inTemplate && /\s/.test(ch)) {
            const t = buf.trim();
            if (t) tokens.push(t);
            buf = "";
            continue;
          }

          buf += ch;
        }

        const last = buf.trim();
        if (last) tokens.push(last);
        return tokens;
      }

      function normalizeStatement(stmtText) {
        return utils.normalizeSpaces(utils.stripTrailingPeriod(String(stmtText ?? "")));
      }

      function parseAssignmentStatement(stmtText, sourceRef, cfg) {
        if (!AbapAssignment) return null;
        const statement = normalizeStatement(stmtText);
        if (!statement) return null;

        const rules = Array.isArray(cfg?.statements?.assignments?.rules) ? cfg.statements.assignments.rules : [];
        for (const rule of rules) {
          const re = asRegex(rule?.regex, rule?.flags);
          const m = regexExec(re, statement);
          if (!m) continue;
          const lhs = String(m[1] || "").trim();
          const rhs = String(m[2] || "").trim();
          if (!lhs || !rhs) continue;
          return new AbapAssignment(lhs, rhs, statement, sourceRef);
        }
        return null;
      }

      function parseConditionalStatement(stmtText, sourceRef, cfg) {
        if (!AbapIfStatement) return null;
        const statement = normalizeStatement(stmtText);
        if (!statement) return null;

        const rules = Array.isArray(cfg?.statements?.conditionals?.rules) ? cfg.statements.conditionals.rules : [];
        for (const rule of rules) {
          const re = asRegex(rule?.regex, rule?.flags);
          const m = regexExec(re, statement);
          if (!m) continue;
          const kind = String(rule?.kind || "").trim().toUpperCase() || "IF";
          const condition = String(m[1] || "").trim();
          if (!condition) continue;
          return new AbapIfStatement(kind, condition, sourceRef);
        }
        return null;
      }

      function parseMessageStatement(stmtText, sourceRef, cfg) {
        if (!AbapMessageStatement) return null;
        const statement = normalizeStatement(stmtText);
        const tokens = splitTokensOutsideStrings(statement);
        if (tokens.length < 2) return null;
        if (String(tokens[0] || "").toUpperCase() !== "MESSAGE") return null;

        const opts = cfg?.statements?.messages;
        if (opts && opts.enabled === false) return null;

        let idx = 1;
        let msgType = "";
        let msgClass = "";
        let msgNo = "";
        let text = "";

        const t1 = String(tokens[idx] || "").trim();
        const t1u = t1.toUpperCase();

        if (t1u === "ID") {
          msgClass = String(tokens[idx + 1] || "").trim();
          idx += 2;

          while (idx < tokens.length) {
            const u = String(tokens[idx] || "").toUpperCase();
            if (u === "WITH" || u === "DISPLAY" || u === "RAISING" || u === "INTO") break;
            if (u === "TYPE" && idx + 1 < tokens.length) {
              msgType = String(tokens[idx + 1] || "").trim();
              idx += 2;
              continue;
            }
            if (u === "NUMBER" && idx + 1 < tokens.length) {
              msgNo = String(tokens[idx + 1] || "").trim();
              idx += 2;
              continue;
            }
            idx++;
          }
        } else {
          const m = /^([A-Za-z])(\d+)\(([^)]+)\)$/.exec(t1);
          if (m) {
            msgType = String(m[1] || "").trim();
            msgNo = String(m[2] || "").trim();
            msgClass = String(m[3] || "").trim();
            idx += 1;
          } else {
            const parts = [];
            while (idx < tokens.length) {
              const u = String(tokens[idx] || "").toUpperCase();
              if (u === "WITH" || u === "DISPLAY" || u === "RAISING" || u === "INTO") break;
              parts.push(tokens[idx]);
              idx++;
            }
            text = parts.join(" ").trim();
          }
        }

        let displayLike = "";
        let into = "";
        let raising = "";
        const withArgs = [];

        while (idx < tokens.length) {
          const u = String(tokens[idx] || "").toUpperCase();

          if (u === "DISPLAY" && String(tokens[idx + 1] || "").toUpperCase() === "LIKE") {
            displayLike = String(tokens[idx + 2] || "").trim();
            idx += 3;
            continue;
          }

          if (u === "WITH") {
            idx += 1;
            while (idx < tokens.length && withArgs.length < 4) {
              const peek = String(tokens[idx] || "").toUpperCase();
              if (peek === "DISPLAY" || peek === "RAISING" || peek === "INTO") break;
              withArgs.push(String(tokens[idx] || "").trim());
              idx++;
            }
            continue;
          }

          if (u === "INTO") {
            into = String(tokens[idx + 1] || "").trim();
            idx += 2;
            continue;
          }

          if (u === "RAISING") {
            raising = String(tokens[idx + 1] || "").trim();
            idx += 2;
            continue;
          }

          idx += 1;
        }

        return new AbapMessageStatement({
          msgType,
          msgClass,
          msgNo,
          text,
          displayLike,
          with: withArgs,
          into,
          raising,
          statement,
          sourceRef,
        });
      }

      function parseItabOperation(stmtText, sourceRef, cfg) {
        if (!AbapItabOperation) return null;
        const statement = normalizeStatement(stmtText);
        const tokens = splitTokensOutsideStrings(statement);
        if (tokens.length < 2) return null;

        const opts = cfg?.statements?.itabOps;
        if (opts && opts.enabled === false) return null;

        const head = String(tokens[0] || "").toUpperCase();

        function joinFrom(startIndex, stopSet) {
          const parts = [];
          let i = startIndex;
          for (; i < tokens.length; i++) {
            const u = String(tokens[i] || "").toUpperCase();
            if (stopSet.has(u)) break;
            parts.push(tokens[i]);
          }
          return { text: parts.join(" ").trim(), next: i };
        }

        if (head === "READ" && String(tokens[1] || "").toUpperCase() === "TABLE") {
          const table = String(tokens[2] || "").trim();
          if (!table) return null;

          let target = "";
          let conditionText = "";
          let conditionKind = "";
          let binarySearch = false;

          for (let i = 3; i < tokens.length; i++) {
            const u = String(tokens[i] || "").toUpperCase();

            if (u === "BINARY" && String(tokens[i + 1] || "").toUpperCase() === "SEARCH") {
              binarySearch = true;
              i += 1;
              continue;
            }

            if (u === "INTO" && !target) {
              target = String(tokens[i + 1] || "").trim();
              continue;
            }

            if (u === "ASSIGNING" && !target) {
              target = String(tokens[i + 1] || "").trim();
              continue;
            }

            if (u === "REFERENCE" && String(tokens[i + 1] || "").toUpperCase() === "INTO" && !target) {
              target = String(tokens[i + 2] || "").trim();
              continue;
            }

            if (u === "INDEX" && !conditionText) {
              conditionKind = "index";
              conditionText = String(tokens[i + 1] || "").trim();
              continue;
            }

            if (u === "WITH" && !conditionText) {
              const next = String(tokens[i + 1] || "").toUpperCase();
              const next2 = String(tokens[i + 2] || "").toUpperCase();
              let start = -1;
              if (next === "KEY") start = i + 2;
              else if (next === "TABLE" && next2 === "KEY") start = i + 3;

              if (start >= 0) {
                const stop = new Set(["BINARY", "INTO", "ASSIGNING", "TRANSPORTING", "REFERENCE", "COMPARING"]);
                const collected = joinFrom(start, stop);
                conditionKind = "key";
                conditionText = collected.text;
              }
              continue;
            }

            if (u === "FROM" && !conditionText) {
              conditionKind = "from";
              conditionText = String(tokens[i + 1] || "").trim();
              continue;
            }
          }

          return new AbapItabOperation("READ", { table, target, conditionText, conditionKind, binarySearch, statement }, sourceRef);
        }

        if (head === "COLLECT") {
          const intoIdx = tokens.findIndex((t) => String(t || "").toUpperCase() === "INTO");
          if (intoIdx < 0 || intoIdx + 1 >= tokens.length) return null;

          const target = tokens.slice(1, intoIdx).join(" ").trim();
          const table = String(tokens[intoIdx + 1] || "").trim();
          if (!table) return null;

          return new AbapItabOperation("COLLECT", { table, target, conditionText: "", conditionKind: "", binarySearch: false, statement }, sourceRef);
        }

        if (head === "MODIFY") {
          let idx = 1;
          if (String(tokens[idx] || "").toUpperCase() === "TABLE") idx++;
          const table = String(tokens[idx] || "").trim();
          if (!table) return null;

          let target = "";
          let conditionText = "";
          let conditionKind = "";

          for (let i = idx + 1; i < tokens.length; i++) {
            const u = String(tokens[i] || "").toUpperCase();
            if (u === "FROM" && !target) {
              const stop = new Set(["TRANSPORTING", "WHERE", "INDEX"]);
              target = joinFrom(i + 1, stop).text;
              continue;
            }
            if (u === "WHERE" && !conditionText) {
              conditionKind = "where";
              conditionText = tokens.slice(i + 1).join(" ").trim();
              break;
            }
            if (u === "INDEX" && !conditionText) {
              conditionKind = "index";
              conditionText = String(tokens[i + 1] || "").trim();
              continue;
            }
          }

          return new AbapItabOperation("MODIFY", { table, target, conditionText, conditionKind, binarySearch: false, statement }, sourceRef);
        }

        if (head === "DELETE") {
          let idx = 1;
          if (String(tokens[idx] || "").toUpperCase() === "TABLE") idx++;
          if (String(tokens[idx] || "").toUpperCase() === "ADJACENT") return null;
          const table = String(tokens[idx] || "").trim();
          if (!table) return null;

          let target = "";
          let conditionText = "";
          let conditionKind = "";

          for (let i = idx + 1; i < tokens.length; i++) {
            const u = String(tokens[i] || "").toUpperCase();
            if (u === "FROM" && !target) {
              const stop = new Set(["WHERE", "INDEX", "USING", "KEY"]);
              target = joinFrom(i + 1, stop).text;
              continue;
            }
            if (u === "WHERE" && !conditionText) {
              conditionKind = "where";
              conditionText = tokens.slice(i + 1).join(" ").trim();
              break;
            }
            if (u === "INDEX" && !conditionText) {
              conditionKind = "index";
              conditionText = String(tokens[i + 1] || "").trim();
              continue;
            }
            if (u === "WITH" && !conditionText) {
              const next = String(tokens[i + 1] || "").toUpperCase();
              const next2 = String(tokens[i + 2] || "").toUpperCase();
              let start = -1;
              if (next === "KEY") start = i + 2;
              else if (next === "TABLE" && next2 === "KEY") start = i + 3;
              if (start >= 0) {
                conditionKind = "key";
                conditionText = tokens.slice(start).join(" ").trim();
                break;
              }
            }
          }

          return new AbapItabOperation("DELETE", { table, target, conditionText, conditionKind, binarySearch: false, statement }, sourceRef);
        }

        return null;
      }

      function parseRegexStatement(stmtText, sourceRef, parseSpec) {
        const statement = normalizeStatement(stmtText);
        if (!statement) return null;

        const re = asRegex(parseSpec?.regex, parseSpec?.flags);
        const m = regexExec(re, statement);
        if (!m) return null;

        const fields = parseSpec?.fields && typeof parseSpec.fields === "object" ? parseSpec.fields : null;
        const out = { statement, sourceRef };
        if (!fields) return out;

        for (const [key, idx] of Object.entries(fields)) {
          const n = Number(idx);
          if (!Number.isFinite(n) || n < 0) continue;
          out[String(key)] = String(m[n] ?? "").trim();
        }
        return out;
      }

      ns.abapObjects = ns.abapObjects || {};
      ns.abapObjects.parsers = {
        splitTokensOutsideStrings,
        normalizeStatement,
        parseAssignmentStatement,
        parseConditionalStatement,
        parseMessageStatement,
        parseItabOperation,
        parseRegexStatement,
      };
    })(window.AbapFlow);


    </script>
        <script>
    // js/abap_objects/loader.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      ns.abapObjects = ns.abapObjects || {};
      const schema = ns.abapObjects.schema;
      const parsers = ns.abapObjects.parsers;

      const state = {
        readyPromise: null,
        config: null,
        templatesById: new Map(),
        registry: null,
      };

      function asNonEmptyString(x) {
        const s = String(x ?? "").trim();
        return s ? s : "";
      }

      function deepCloneJson(value) {
        return deepClone(value);
      }

      function deepClone(value) {
        if (value == null) return value;

        if (value instanceof RegExp) {
          return new RegExp(value.source, value.flags);
        }

        if (Array.isArray(value)) {
          return value.map((x) => deepClone(x));
        }

        if (typeof value === "object") {
          const out = {};
          for (const [k, v] of Object.entries(value)) out[k] = deepClone(v);
          return out;
        }

        return value;
      }

      function formatSchemaErrors(errors) {
        const list = Array.isArray(errors) ? errors : [];
        if (!list.length) return "Invalid config.";
        return list.map((e) => `${e.path || "(root)"}: ${e.message || "Invalid value"}`).join("\n");
      }

      function defaultLoadScript(url) {
        return new Promise((resolve, reject) => {
          if (typeof document === "undefined") {
            reject(new Error("No DOM available to load scripts."));
            return;
          }
          const src = String(url || "").trim();
          if (!src) {
            reject(new Error("Empty script url."));
            return;
          }

          const el = document.createElement("script");
          el.src = src;
          el.async = false;
          el.onload = () => resolve(true);
          el.onerror = () => reject(new Error(`Failed to load script: ${src}`));
          document.head.appendChild(el);
        });
      }

      function defineTemplate(id, config) {
        const tid = asNonEmptyString(id);
        if (!tid) return;
        state.templatesById.set(tid, config || {});
      }

      function getTemplateConfig(id) {
        const tid = asNonEmptyString(id);
        return tid ? state.templatesById.get(tid) || null : null;
      }

      function compileObjectDefs(config) {
        const objects = Array.isArray(config?.objects) ? config.objects : [];

        const objectsById = new Map();
        const statementObjects = [];
        const callEdgeObjects = [];
        const templates = [];

        for (const obj of objects) {
          const id = asNonEmptyString(obj?.id);
          if (!id) continue;
          const kind = asNonEmptyString(obj?.kind).toLowerCase();
          const label = asNonEmptyString(obj?.label) || id;

          const def = {
            id,
            kind,
            label,
            parse: obj?.parse || null,
            match: obj?.match || null,
            builder: obj?.builder || null,
            templates: Array.isArray(obj?.templates) ? obj.templates : [],
          };
          objectsById.set(id, def);

          if (kind === "statement") statementObjects.push(def);
          if (kind === "calledge") callEdgeObjects.push(def);

          for (const t of def.templates) {
            const tid = asNonEmptyString(t?.id);
            if (!tid) continue;
            templates.push({
              id: tid,
              label: asNonEmptyString(t?.label) || tid,
              objectId: id,
              source: id,
              auto: t?.auto !== false,
              when: t?.when || null,
              file: asNonEmptyString(t?.file),
            });
          }
        }

        return { objectsById, statementObjects, callEdgeObjects, templates };
      }

      function parseStatementByObject(def, stmtText, sourceRef, cfg) {
        const kind = asNonEmptyString(def?.parse?.kind).toLowerCase();
        if (!kind) return null;

        if (kind === "assignment") return parsers.parseAssignmentStatement(stmtText, sourceRef, cfg);
        if (kind === "conditional") return parsers.parseConditionalStatement(stmtText, sourceRef, cfg);
        if (kind === "message") return parsers.parseMessageStatement(stmtText, sourceRef, cfg);
        if (kind === "itabop") return parsers.parseItabOperation(stmtText, sourceRef, cfg);
        if (kind === "regex") return parsers.parseRegexStatement(stmtText, sourceRef, def.parse);

        return null;
      }

      function buildContext(def, model, routine, payload, options) {
        const kind = asNonEmptyString(def?.builder?.kind).toLowerCase();
        const tc = ns.templateConverter;
        if (!tc) return null;

        if (kind === "performcall") return tc.buildPerformContext(model, payload, options);
        if (kind === "assignment") return tc.buildAssignmentContext(model, routine, payload, options);
        if (kind === "if") return tc.buildIfContext(model, routine, payload, options);
        if (kind === "message") return tc.buildMessageContext(model, routine, payload, options);
        if (kind === "itabop") return tc.buildItabOpContext(model, routine, payload, options);
        if (kind === "append") return tc.buildAppendContext(model, routine, payload, options);

        if (kind === "mapping") return buildContextByMapping(model, routine, payload, def, options);
        return null;
      }

      function describeExprWithOrigin(model, routineKey, exprText, options) {
        const text = String(exprText ?? "").trim();
        if (!text) return { text: "", originKey: "" };
        if (ns.desc?.describeExpressionWithOrigin) return ns.desc.describeExpressionWithOrigin(model, routineKey, text, options);
        return { text, originKey: "" };
      }

      function buildExprNode(model, routineKey, exprText, options) {
        const text = String(exprText ?? "").trim();
        if (!text) return { text: "", description: "", originKey: "" };
        const described = describeExprWithOrigin(model, routineKey, text, options);
        return {
          text,
          description: String(described.text || "").trim() || text,
          originKey: String(described.originKey || ""),
        };
      }

      function buildContextByMapping(model, routine, payload, def, options) {
        const routineKey = String(routine?.key || "");
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;
        const mapping = def?.builder?.fields && typeof def.builder.fields === "object" ? def.builder.fields : {};

        function splitExprList(text) {
          const s = String(text ?? "").trim();
          if (!s) return [];
          const tokenize =
            parsers && typeof parsers.splitTokensOutsideStrings === "function"
              ? parsers.splitTokensOutsideStrings
              : (x) => String(x || "").split(/\s+/).filter(Boolean);

          const tokens = tokenize(s);
          const out = [];
          for (let i = 0; i < tokens.length; i++) {
            const t = String(tokens[i] || "");
            const tUpper = t.toUpperCase();
            const n1 = tokens[i + 1];
            const n2 = tokens[i + 2];

            if (tUpper === "LINES" && String(n1 || "").toUpperCase() === "OF" && n2 != null) {
              out.push(`LINES OF ${String(n2)}`.trim());
              i += 2;
              continue;
            }

            out.push(t);
          }
          return out.filter(Boolean);
        }

        const ctx = {
          routine: { key: routineKey, kind: String(routine?.kind || ""), name: String(routine?.name || "") },
          object: { id: String(def?.id || ""), label: String(def?.label || ""), statement: String(payload?.statement || payload?.raw || "") },
        };

        for (const [outKey, spec] of Object.entries(mapping)) {
          const t = String(spec?.type || "expr").trim().toLowerCase();
          const from = String(spec?.from || "").trim();
          const raw = from && payload && typeof payload === "object" ? payload[from] : "";

          if (t === "text") {
            ctx[outKey] = String(raw ?? "");
            continue;
          }

          if (t === "exprlist") {
            const list = Array.isArray(raw) ? raw : splitExprList(raw);
            ctx[outKey] = list.map((x) => buildExprNode(model, routineKey, x, { callPath }));
            continue;
          }

          ctx[outKey] = buildExprNode(model, routineKey, raw, { callPath });
        }

        const pairs = [];
        for (const [outKey, spec] of Object.entries(mapping)) {
          const t = String(spec?.type || "expr").trim().toLowerCase();
          const keyword = asNonEmptyString(spec?.label) || asNonEmptyString(outKey);
          if (!keyword) continue;

          if (t === "exprlist") {
            const list = Array.isArray(ctx[outKey]) ? ctx[outKey] : [];
            for (let i = 0; i < list.length; i++) {
              const node = list[i];
              const text = asNonEmptyString(node?.text) || asNonEmptyString(node?.description);
              if (!text) continue;
              pairs.push({ keyword: i === 0 ? keyword : "", value: node });
            }
            continue;
          }

          if (t === "text") {
            const raw = asNonEmptyString(ctx[outKey]);
            if (!raw) continue;
            if (spec?.presentOnly) {
              pairs.push({ keyword, value: { text: "", description: "", originKey: "" } });
            } else {
              pairs.push({ keyword, value: { text: raw, description: raw, originKey: "" } });
            }
            continue;
          }

          const node = ctx[outKey];
          const text = asNonEmptyString(node?.text) || asNonEmptyString(node?.description);
          if (!text) continue;
          pairs.push({ keyword, value: node });
        }

        ctx.pairs = pairs;
        return ctx;
      }

      function installTemplateRegistry(templates) {
        ns.templateRegistry = ns.templateRegistry || { templates: {}, order: [] };
        ns.templateRegistry.templates = ns.templateRegistry.templates || {};
        ns.templateRegistry.order = Array.isArray(ns.templateRegistry.order) ? ns.templateRegistry.order : [];

        ns.templateRegistry.templates = {};
        ns.templateRegistry.order = [];

        for (const t of templates) {
          const cfg = getTemplateConfig(t.id);
          if (!cfg) continue;
          ns.templateRegistry.templates[t.id] = {
            id: t.id,
            label: t.label,
            source: t.source,
            auto: t.auto !== false,
            objectId: t.objectId,
            when: t.when || null,
            config: cfg,
          };
          ns.templateRegistry.order.push(t.id);
        }
      }

      function init(options) {
        if (state.readyPromise) return state.readyPromise;

        state.readyPromise = (async () => {
          if (!schema?.validateMasterConfig) throw new Error("ABAP Objects schema module not loaded.");
          if (!parsers) throw new Error("ABAP Objects parsers module not loaded.");

          let config = options?.config || ns.abapObjectsMasterConfig;
          if (!options?.config) {
            const customStore = ns.abapObjects?.customStore || null;
            if (customStore && typeof customStore.getEffectiveConfig === "function") {
              config = customStore.getEffectiveConfig(config)?.config || config;
            }
          }
          const validation = schema.validateMasterConfig(config);
          if (!validation.ok) {
            throw new Error(formatSchemaErrors(validation.errors));
          }

          state.config = config;

          if (config?.parserConfig && typeof config.parserConfig === "object") {
            ns.parserConfig = deepCloneJson(config.parserConfig);
          }

          const compiled = compileObjectDefs(config);
          state.registry = {
            ...compiled,
            parseStatementItems(model, routine, statementText, sourceRef, cfg) {
              const out = [];
              for (const objDef of compiled.statementObjects) {
                const parsed = parseStatementByObject(objDef, statementText, sourceRef, cfg);
                if (!parsed) continue;
                out.push({
                  objectId: objDef.id,
                  kind: "statement",
                  payload: parsed,
                  sourceRef: parsed?.sourceRef || sourceRef || null,
                  continueAfterMatch: Boolean(objDef?.parse?.continueAfterMatch),
                });
                if (!objDef?.parse?.continueAfterMatch) break;
              }
              return out;
            },
            matchCallEdge(edge) {
              const toKey = String(edge?.toKey || "");
              for (const objDef of compiled.callEdgeObjects) {
                const prefix = asNonEmptyString(objDef?.match?.toKeyPrefix);
                if (prefix && toKey.toUpperCase().startsWith(prefix.toUpperCase())) return objDef;
              }
              return null;
            },
            buildContext,
          };

          const loadScript = typeof options?.loadScript === "function" ? options.loadScript : defaultLoadScript;

          const filesToLoad = compiled.templates.map((t) => t.file).filter(Boolean);
          const uniqueFiles = Array.from(new Set(filesToLoad));
          for (const file of uniqueFiles) await loadScript(file);

          const templateDefs = ns.templateDefs || null;
          if (templateDefs && typeof templateDefs.getTemplateConfig === "function") {
            for (const t of compiled.templates) {
              const override = templateDefs.getTemplateConfig(t.id);
              if (override) defineTemplate(t.id, override);
            }
          }

          for (const t of compiled.templates) {
            if (!getTemplateConfig(t.id)) throw new Error(`Template not registered: ${t.id} (${t.file})`);
          }

          let templatesForRegistry = compiled.templates;

          if (templateDefs && typeof templateDefs.listCustomTemplateEntries === "function") {
            const custom = templateDefs.listCustomTemplateEntries();
            const seen = new Set(compiled.templates.map((t) => String(t?.id || "").trim().toLowerCase()).filter(Boolean));

            const merged = [];
            for (const t of custom) {
              const id = asNonEmptyString(t?.id).toLowerCase();
              if (!id || seen.has(id)) continue;
              if (t?.config) defineTemplate(t.id, t.config);
              merged.push({
                id: asNonEmptyString(t.id),
                label: asNonEmptyString(t.label) || asNonEmptyString(t.id),
                objectId: asNonEmptyString(t.objectId) || asNonEmptyString(t.source),
                source: asNonEmptyString(t.source),
                auto: t.auto !== false,
                when: t.when || null,
                file: "",
              });
            }

            templatesForRegistry = merged.concat(compiled.templates);
          }

          installTemplateRegistry(templatesForRegistry);
          return state.registry;
        })();

        return state.readyPromise;
      }

      function whenReady() {
        return init();
      }

      function reset() {
        state.readyPromise = null;
        state.config = null;
        state.registry = null;
        state.templatesById.clear();
      }

      ns.abapObjects.defineTemplate = defineTemplate;
      ns.abapObjects.getTemplateConfig = getTemplateConfig;
      ns.abapObjects.init = init;
      ns.abapObjects.whenReady = whenReady;
      ns.abapObjects.getRegistry = () => state.registry;
      ns.abapObjects.getConfig = () => state.config;
      ns.abapObjects.reset = reset;
    })(window.AbapFlow);

    </script>
        <script>
    // js/abap_objects/syntax_generator.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      function asNonEmptyString(x) {
        const s = String(x ?? "").trim();
        return s ? s : "";
      }

      function normalizeSpaces(s) {
        if (utils && typeof utils.normalizeSpaces === "function") return utils.normalizeSpaces(s);
        return String(s ?? "")
          .replace(/\s+/g, " ")
          .trim();
      }

      function splitLines(text) {
        if (utils && typeof utils.splitLines === "function") return utils.splitLines(text);
        return String(text ?? "").replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n");
      }

      function isSectionHeader(line) {
        const t = asNonEmptyString(line).toLowerCase();
        if (!t) return false;
        return t === "syntax" || t.startsWith("additions") || t.startsWith("addition") || t.startsWith("effect") || t.startsWith("example");
      }

      function extractFirstSyntaxStatement(text) {
        const lines = splitLines(text);

        let start = -1;
        for (let i = 0; i < lines.length; i++) {
          const raw = String(lines[i] ?? "");
          const t = raw.trim();
          if (!t) continue;
          if (isSectionHeader(t)) continue;
          if (/^[A-Z][A-Z0-9_-]*\b/.test(t)) {
            start = i;
            break;
          }
        }

        if (start < 0) return "";

        const parts = [];
        for (let i = start; i < lines.length; i++) {
          const raw = String(lines[i] ?? "");
          const t = raw.trim();
          if (!t) break;
          if (isSectionHeader(t)) break;
          parts.push(t);
        }

        return normalizeSpaces(parts.join(" ")).replace(/\.\s*$/, "");
      }

      function createDefaultKeyValueExcelLikeTableTemplate(listName) {
        const list = /^[A-Za-z_][A-Za-z0-9_]*$/.test(String(listName || "")) ? String(listName) : "pairs";

        return {
          type: "excel-like-table",
          compact: { removeEmptyRows: true },
          grid: {
            rows: 1,
            cols: 14, // A..N
            colWidths: {
              A: 420, // merged A..G (keyword)
              H: 700, // merged H..N (value)
            },
            defaultRowHeight: 30,
          },
          css: {
            kw: "background:#9dc3e6;font-weight:700;color:#111;",
            cell: "border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;",
            wrap: "white-space:normal;line-height:1.25;",
          },
          merges: [
            { start: "A1", rowspan: 1, colspan: 7 },
            { start: "H1", rowspan: 1, colspan: 7 },
          ],
          cells: [
            { addr: "A1", text: `{${list}[0].keyword}`, class: ["cell", "kw", "wrap"] },
            { addr: "H1", text: `{${list}[0].value.description}`, class: ["cell", "wrap"] },
          ],
        };
      }

      function generateConcatenateObject() {
        const regex =
          "^CONCATENATE\\s+(.+?)\\s+INTO\\s+(.+?)(?=\\s+IN\\s+(?:CHARACTER|BYTE)\\s+MODE\\b|\\s+SEPARATED\\s+BY\\b|\\s+RESPECTING\\s+BLANKS\\b|$)" +
          "(?:\\s+IN\\s+(CHARACTER|BYTE)\\s+MODE)?" +
          "(?:\\s+SEPARATED\\s+BY\\s+(.+?)(?=\\s+RESPECTING\\s+BLANKS\\b|$))?" +
          "(?:\\s+(RESPECTING\\s+BLANKS))?$";

        return {
          id: "concatenate",
          kind: "statement",
          label: "CONCATENATE",
          parse: {
            kind: "regex",
            regex,
            flags: "i",
            fields: {
              sources: 1,
              result: 2,
              mode: 3,
              sep: 4,
              respectingBlanks: 5,
            },
          },
          builder: {
            kind: "mapping",
            fields: {
              items: { type: "exprlist", from: "sources", label: "CONCATENATE" },
              result: { type: "expr", from: "result", label: "INTO" },
              mode: { type: "text", from: "mode", label: "IN ... MODE" },
              sep: { type: "expr", from: "sep", label: "SEPARATED BY" },
              respectingBlanks: { type: "text", from: "respectingBlanks", label: "RESPECTING BLANKS", presentOnly: true },
            },
          },
          templates: [],
        };
      }

      function generateObjectDefFromSyntaxText(text) {
        const syntax = extractFirstSyntaxStatement(text);
        if (!syntax) return { ok: false, error: "No ABAP syntax statement found." };

        const m = /^([A-Z][A-Z0-9_-]*)\b/.exec(syntax);
        const keyword = String(m?.[1] || "").toUpperCase();
        if (!keyword) return { ok: false, error: "Could not detect ABAP keyword from syntax." };

        if (keyword === "CONCATENATE") {
          return { ok: true, keyword, syntax, objectDef: generateConcatenateObject(), warnings: [] };
        }

        return { ok: false, error: `Unsupported keyword: ${keyword}. (Currently supports: CONCATENATE)` };
      }

      ns.abapObjects = ns.abapObjects || {};
      ns.abapObjects.syntaxGenerator = {
        extractFirstSyntaxStatement,
        createDefaultKeyValueExcelLikeTableTemplate,
        generateObjectDefFromSyntaxText,
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/doc.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      function looksLikeSeparator(s) {
        return /^[\-\*\&\s_]+$/.test(String(s || "").trim());
      }

      function extractLeadingComment(lines, beforeLine) {
        const startIdx = Math.max(0, (beforeLine || 1) - 2);
        const block = [];

        for (let i = startIdx; i >= 0; i--) {
          const raw = String(lines[i] || "");
          const trimmed = raw.trim();
          if (!trimmed) {
            if (block.length > 0) break;
            continue;
          }

          if (trimmed.startsWith("*")) {
            block.push(trimmed);
            continue;
          }

          break;
        }

        block.reverse();

        const paramDescriptions = {};
        const descriptionLines = [];

        for (const line of block) {
          let content = line.replace(/^\*\s?/, "");
          content = content.replace(/\*+\s*$/, "").trim();
          content = content.replace(/^\&+/, "").trim();
          if (!content) continue;
          if (looksLikeSeparator(content)) continue;

          const m = /^(-->|<--|<>)\s*([A-Za-z_][A-Za-z0-9_\/]*(?:[-~][A-Za-z0-9_\/]+)*)\s*(.*)$/.exec(content);
          if (m) {
            const name = m[2].toLowerCase();
            const desc = (m[3] || "").trim();
            if (name && desc) paramDescriptions[name] = desc;
            continue;
          }

          if (/^Forms?\b/i.test(content)) continue;
          descriptionLines.push(content);
        }

        return {
          description: descriptionLines.join("\n").trim(),
          paramDescriptions,
          rawLines: block,
        };
      }

      function extractInlineCommentFromStatement(lines, startLine, endLine) {
        const comments = [];
        const from = Math.max(1, startLine || 1);
        const to = Math.min(lines.length, endLine || from);
        for (let ln = from; ln <= to; ln++) {
          const raw = String(lines[ln - 1] || "");
          if (!raw) continue;
          const parts = utils.splitInlineComment(raw);
          const c = String(parts.comment || "").trim();
          if (c) comments.push(c);
        }
        return comments.join(" ").trim();
      }

      function extractInlineCommentsByLine(lines, startLine, endLine) {
        const out = {};
        const from = Math.max(1, startLine || 1);
        const to = Math.min(lines.length, endLine || from);

        for (let ln = from; ln <= to; ln++) {
          const raw = String(lines[ln - 1] || "");
          if (!raw) continue;
          const parts = utils.splitInlineComment(raw);
          const c = String(parts.comment || "").trim();
          if (!c) continue;
          out[ln] = c;
        }

        return out;
      }

      ns.doc = {
        extractLeadingComment,
        extractInlineCommentFromStatement,
        extractInlineCommentsByLine,
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/graph.js
    (function (ns) {
      "use strict";

      function build(model) {
        for (const node of model.nodes.values()) {
          node.calls = [];
          node.calledBy = [];
          node.depth = null;
          node.isInCycle = false;
        }

        for (const edge of model.edges) {
          const from = model.nodes.get(edge.fromKey);
          const to = model.nodes.get(edge.toKey);
          if (!from || !to) continue;
          from.calls.push(edge);
          to.calledBy.push(edge);
          edge.isInCycle = false;
        }

        detectCycles(model);
        computeDepths(model);
      }

      function detectCycles(model) {
        let index = 0;
        const stack = [];
        const indices = new Map();
        const lowlinks = new Map();
        const onStack = new Set();
        const sccId = new Map();
        const sccs = [];

        function strongconnect(vKey) {
          indices.set(vKey, index);
          lowlinks.set(vKey, index);
          index++;
          stack.push(vKey);
          onStack.add(vKey);

          const v = model.nodes.get(vKey);
          for (const edge of v.calls) {
            const wKey = edge.toKey;
            if (!indices.has(wKey)) {
              strongconnect(wKey);
              lowlinks.set(vKey, Math.min(lowlinks.get(vKey), lowlinks.get(wKey)));
            } else if (onStack.has(wKey)) {
              lowlinks.set(vKey, Math.min(lowlinks.get(vKey), indices.get(wKey)));
            }
          }

          if (lowlinks.get(vKey) === indices.get(vKey)) {
            const comp = [];
            let w;
            do {
              w = stack.pop();
              onStack.delete(w);
              comp.push(w);
            } while (w !== vKey);
            const id = sccs.length;
            for (const k of comp) sccId.set(k, id);
            sccs.push(comp);
          }
        }

        for (const key of model.nodes.keys()) {
          if (!indices.has(key)) strongconnect(key);
        }

        for (let i = 0; i < sccs.length; i++) {
          const comp = sccs[i];
          if (comp.length > 1) {
            for (const key of comp) model.nodes.get(key).isInCycle = true;
            continue;
          }

          const key = comp[0];
          const node = model.nodes.get(key);
          const hasSelfLoop = node.calls.some((e) => e.toKey === key);
          if (hasSelfLoop) node.isInCycle = true;
        }

        for (const edge of model.edges) {
          const fromId = sccId.get(edge.fromKey);
          const toId = sccId.get(edge.toKey);
          if (fromId != null && toId != null && fromId === toId) {
            const comp = sccs[fromId] || [];
            if (comp.length > 1 || edge.fromKey === edge.toKey) edge.isInCycle = true;
          }
        }
      }

      function computeDepths(model) {
        const nodes = Array.from(model.nodes.values());
        const roots = nodes.filter((n) => n.kind === "EVENT" || n.calledBy.length === 0);
        const queue = [];

        for (const r of roots) {
          if (r.depth == null) r.depth = 0;
          queue.push(r);
        }

        while (queue.length > 0) {
          const cur = queue.shift();
          const nextDepth = (cur.depth ?? 0) + 1;
          for (const edge of cur.calls) {
            const callee = model.nodes.get(edge.toKey);
            if (!callee) continue;
            if (callee.depth == null || nextDepth < callee.depth) {
              callee.depth = nextDepth;
              queue.push(callee);
            }
          }
        }

        for (const n of nodes) {
          if (n.depth == null) n.depth = 0;
        }
      }

      ns.graph = { build, computeDepths };
    })(window.AbapFlow);


    </script>
        <script>
    // js/lineage.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;
      const IDENT_RE = /[A-Za-z_][A-Za-z0-9_\/]*(?:[-~][A-Za-z0-9_\/]+)*/g;

      function buildGlobalIndex(model) {
        const set = new Set();
        for (const d of model.globalData) set.add(String(d.variableName || "").toLowerCase());
        for (const c of model.globalConstants) set.add(String(c.variableName || "").toLowerCase());
        return set;
      }

      function buildGlobalDeclMap(model) {
        const map = new Map();
        for (const d of model.globalData || []) {
          const name = String(d.variableName || "").toLowerCase();
          if (name) map.set(name, { scope: "GLOBAL:DATA", decl: d });
        }
        for (const c of model.globalConstants || []) {
          const name = String(c.variableName || "").toLowerCase();
          if (name) map.set(name, { scope: "GLOBAL:CONSTANTS", decl: c });
        }
        return map;
      }

      function stripStrings(s) {
        // ABAP strings: '...'; escaped by doubling: ''
        return String(s || "").replace(/'(?:[^']|'')*'/g, " ");
      }

      function collectUsedGlobalNames(model, fromLine, toLine, globalDeclMap, stopAtNameLower) {
        const used = new Set();
        const lines = model?.lines || [];
        const from = Math.max(1, Number(fromLine || 1));
        const to = Math.min(lines.length, Number(toLine || from));
        const stop = String(stopAtNameLower || "").toLowerCase();

        for (let ln = from; ln <= to; ln++) {
          const raw = String(lines[ln - 1] || "");
          if (utils.isFullLineComment(raw)) continue;

          const code = utils.stripInlineComment(raw);
          if (!code.trim()) continue;

          const sanitized = stripStrings(code);
          IDENT_RE.lastIndex = 0;
          let m = null;
          while ((m = IDENT_RE.exec(sanitized))) {
            const token = String(m[0] || "").trim();
            if (!token) continue;
            const root = token.toLowerCase().split(/[-~]/)[0];
            if (!root) continue;
            if (!globalDeclMap.has(root)) continue;
            used.add(root);
            if (stop && root === stop) return used;
          }
        }

        return used;
      }

      function resolveSymbol(model, routineKey, varName) {
        const nameLower = String(varName || "").toLowerCase();
        const routine = model.nodes.get(routineKey);
        if (!routine) return { scope: "unknown" };

        for (const p of routine.params) {
          if (String(p.name || "").toLowerCase() === nameLower) return { scope: "parameter", decl: p };
        }

        for (const d of routine.localData) {
          if (String(d.variableName || "").toLowerCase() === nameLower) return { scope: "local", decl: d };
        }
        for (const c of routine.localConstants) {
          if (String(c.variableName || "").toLowerCase() === nameLower) return { scope: "local", decl: c };
        }

        for (const d of model.globalData) {
          if (String(d.variableName || "").toLowerCase() === nameLower) return { scope: "global", decl: d };
        }
        for (const c of model.globalConstants) {
          if (String(c.variableName || "").toLowerCase() === nameLower) return { scope: "global", decl: c };
        }

        return { scope: "unknown" };
      }

      function matchesVariableName(writtenName, tracedName) {
        const w = String(writtenName || "").toLowerCase();
        const t = String(tracedName || "").toLowerCase();
        return w === t || w.startsWith(`${t}-`) || w.startsWith(`${t}~`);
      }

      function formalParamsByKind(routine, kind) {
        return routine.params.filter((p) => String(p.kind).toUpperCase() === kind);
      }

      function mapThroughEdge(model, edge, callerVarName) {
        const callerToken = utils.cleanIdentifierToken(callerVarName);
        if (!utils.isIdentifier(callerToken)) return null;
        const callerNameLower = String(callerToken || "").toLowerCase();
        const callee = model.nodes.get(edge.toKey);
        if (!callee) return null;

        const rules = [
          { edgeKey: "changing", paramKind: "CHANGING" },
          { edgeKey: "tables", paramKind: "TABLES" },
          { edgeKey: "using", paramKind: "USING" },
        ];

        for (const rule of rules) {
          const actualArgs = (edge.args && edge.args[rule.edgeKey]) || [];
          const formalParams = formalParamsByKind(callee, rule.paramKind);
          const max = Math.min(actualArgs.length, formalParams.length);
          for (let i = 0; i < max; i++) {
            const actual = utils.cleanIdentifierToken(actualArgs[i]);
            if (!actual) continue;
            if (String(actual).toLowerCase() === callerNameLower) {
              return { mappedVarName: formalParams[i].name, kind: rule.paramKind };
            }
          }
        }

        return null;
      }

      function mapBackThroughEdge(model, edge, calleeVarName) {
        const calleeNameLower = String(calleeVarName || "").toLowerCase();
        const callee = model.nodes.get(edge.toKey);
        if (!callee) return null;

        const decl = callee.params.find((p) => String(p.name || "").toLowerCase() === calleeNameLower) || null;
        const kind = String(decl?.kind || "").toUpperCase();

        const rule = kind === "USING" ? { edgeKey: "using", paramKind: "USING" } : kind === "CHANGING" ? { edgeKey: "changing", paramKind: "CHANGING" } : kind === "TABLES" ? { edgeKey: "tables", paramKind: "TABLES" } : null;

        if (!rule) return null;

        const formalParams = formalParamsByKind(callee, rule.paramKind);
        const idx = formalParams.findIndex((p) => String(p.name || "").toLowerCase() === calleeNameLower);
        if (idx < 0) return null;

        const actualArgs = (edge.args && edge.args[rule.edgeKey]) || [];
        if (idx >= actualArgs.length) return null;

        const actual = utils.cleanIdentifierToken(actualArgs[idx]);
        if (!actual) return null;

        return { mappedVarName: actual, kind: rule.paramKind };
      }

      function traceVariable(model, startKey, varName, options) {
        const maxNodes = Math.max(50, Number(options?.maxNodes || 250));
        const globalIndex = buildGlobalIndex(model);
        const globalDeclMap = buildGlobalDeclMap(model);
        const usesGlobalCache = new Map();
        const usesGlobalSubtreeCache = new Map();
        const usesGlobalSubtreeVisiting = new Set();

        const startVar = String(varName || "").trim();
        if (!startVar) return { error: "Variable name is empty." };

        const startRoutine = model.nodes.get(startKey);
        if (!startRoutine) return { error: "Subroutine/event not found." };

        const stack = new Set();
        let visitedCount = 0;

        function routineUsesGlobal(routineKey, nameLower) {
          const key = `${String(routineKey || "")}|${String(nameLower || "").toLowerCase()}`;
          if (usesGlobalCache.has(key)) return usesGlobalCache.get(key);
          const routine = model.nodes.get(routineKey);
          if (!routine?.sourceRef) {
            usesGlobalCache.set(key, false);
            return false;
          }

          const used = collectUsedGlobalNames(
            model,
            routine.sourceRef.startLine,
            routine.sourceRef.endLine || routine.sourceRef.startLine,
            globalDeclMap,
            nameLower,
          );
          const out = used.has(String(nameLower || "").toLowerCase());
          usesGlobalCache.set(key, out);
          return out;
        }

        function routineUsesGlobalInSubtree(routineKey, nameLower) {
          const key = `${String(routineKey || "")}|${String(nameLower || "").toLowerCase()}`;
          if (usesGlobalSubtreeCache.has(key)) return usesGlobalSubtreeCache.get(key);
          if (usesGlobalSubtreeVisiting.has(key)) return false;
          usesGlobalSubtreeVisiting.add(key);

          let out = routineUsesGlobal(routineKey, nameLower);
          if (!out) {
            const routine = model.nodes.get(routineKey);
            for (const edge of routine?.calls || []) {
              if (routineUsesGlobalInSubtree(edge.toKey, nameLower)) {
                out = true;
                break;
              }
            }
          }

          usesGlobalSubtreeVisiting.delete(key);
          usesGlobalSubtreeCache.set(key, out);
          return out;
        }

        function walk(routineKey, currentVarName) {
          visitedCount++;
          const routine = model.nodes.get(routineKey);
          if (!routine) return null;

          const visitKey = `${routineKey}|${String(currentVarName || "").toLowerCase()}`;
          if (stack.has(visitKey)) {
            return {
              routineKey,
              routineName: routine.name,
              routineKind: routine.kind,
              varName: currentVarName,
              resolution: resolveSymbol(model, routineKey, currentVarName),
              sourceRef: routine.sourceRef,
              cycle: true,
              writes: [],
              calls: [],
            };
          }

          if (visitedCount > maxNodes) {
            return {
              routineKey,
              routineName: routine.name,
              routineKind: routine.kind,
              varName: currentVarName,
              resolution: resolveSymbol(model, routineKey, currentVarName),
              sourceRef: routine.sourceRef,
              truncated: true,
              writes: [],
              calls: [],
            };
          }

          stack.add(visitKey);

          const resolution = resolveSymbol(model, routineKey, currentVarName);
          const nameLower = String(currentVarName || "").toLowerCase();
          const isGlobal = resolution.scope === "global" && globalIndex.has(nameLower);

          const writes = routine.writes.filter((w) => matchesVariableName(w.variableName, currentVarName));
          const decl = resolution.decl;
          if (
            decl &&
            (resolution.scope === "local" || resolution.scope === "global") &&
            decl.declKind &&
            decl.variableName &&
            decl.value &&
            matchesVariableName(decl.variableName, currentVarName)
          ) {
            const dt = decl.dataType ? ` TYPE ${decl.dataType}` : "";
            const declUpper = String(decl.declKind || "").toUpperCase();
            const valueKeyword = declUpper === "PARAMETERS" ? "DEFAULT" : "VALUE";
            writes.unshift({
              variableName: decl.variableName,
              statement: `${decl.declKind} ${decl.variableName}${dt} ${valueKeyword} ${decl.value}`,
              sourceRef: decl.sourceRef || null,
            });
          }

          const calls = [];

          if (resolution.scope === "parameter") {
            const incoming = (routine.calledBy || []).slice().sort((a, b) => {
              const la = a.sourceRef?.startLine ?? 1e9;
              const lb = b.sourceRef?.startLine ?? 1e9;
              return la - lb;
            });

            for (const edge of incoming) {
              const mapping = mapBackThroughEdge(model, edge, currentVarName);
              if (!mapping) continue;
              const child = walk(edge.fromKey, mapping.mappedVarName);
              if (!child) continue;
              calls.push({
                direction: "fromCaller",
                edge,
                fromVar: mapping.mappedVarName,
                toVar: currentVarName,
                mappingKind: mapping.kind,
                child,
              });
            }
          }

          for (const edge of routine.calls) {
            const paramMapping = mapThroughEdge(model, edge, currentVarName);
            if (paramMapping) {
              const child = walk(edge.toKey, paramMapping.mappedVarName);
              if (!child) continue;
              calls.push({
                direction: "toCallee",
                edge,
                fromVar: currentVarName,
                toVar: paramMapping.mappedVarName,
                mappingKind: paramMapping.kind,
                child,
              });
              continue;
            }

            if (!isGlobal) continue;
            if (!routineUsesGlobalInSubtree(edge.toKey, nameLower)) continue;

            const child = walk(edge.toKey, currentVarName);
            if (!child) continue;
            calls.push({
              direction: "toCallee",
              edge,
              fromVar: currentVarName,
              toVar: currentVarName,
              mappingKind: "GLOBAL",
              child,
            });
          }

          stack.delete(visitKey);

          return {
            routineKey,
            routineName: routine.name,
            routineKind: routine.kind,
            varName: currentVarName,
            resolution,
            sourceRef: routine.sourceRef,
            writes,
            calls,
          };
        }

        const root = walk(startKey, startVar);
        return { startKey, varName: startVar, root };
      }

      function getVariablesForRoutine(model, routineKey, options) {
        const routine = model.nodes.get(routineKey);
        if (!routine) return [];

        const vars = [];
        for (const p of routine.params) vars.push({ name: p.name, scope: `PARAM:${p.kind}`, dataType: p.dataType, description: p.description });
        for (const d of routine.localData) vars.push({ name: d.variableName, scope: "LOCAL:DATA", dataType: d.dataType, description: d.description });
        for (const c of routine.localConstants)
          vars.push({ name: c.variableName, scope: "LOCAL:CONSTANTS", dataType: c.dataType, description: c.description });

        const globalMode = String(options?.globalMode || "all").toLowerCase();
        if (globalMode === "all") {
          for (const d of model.globalData) vars.push({ name: d.variableName, scope: "GLOBAL:DATA", dataType: d.dataType, description: d.description });
          for (const c of model.globalConstants) vars.push({ name: c.variableName, scope: "GLOBAL:CONSTANTS", dataType: c.dataType, description: c.description });
        } else if (globalMode === "used") {
          const globalDeclMap = buildGlobalDeclMap(model);
          const used = collectUsedGlobalNames(
            model,
            routine.sourceRef?.startLine,
            routine.sourceRef?.endLine || routine.sourceRef?.startLine,
            globalDeclMap,
          );

          const items = Array.from(used)
            .map((nameLower) => globalDeclMap.get(nameLower))
            .filter(Boolean)
            .map((entry) => ({
              name: entry.decl.variableName,
              scope: entry.scope,
              dataType: entry.decl.dataType,
              description: entry.decl.description,
            }))
            .sort((a, b) => String(a.name || "").localeCompare(String(b.name || "")));

          vars.push(...items);
        }

        return vars;
      }

      function getGlobalVariables(model) {
        const out = [];
        for (const d of model?.globalData || []) out.push({ name: d.variableName, scope: "GLOBAL:DATA", dataType: d.dataType, description: d.description });
        for (const c of model?.globalConstants || [])
          out.push({ name: c.variableName, scope: "GLOBAL:CONSTANTS", dataType: c.dataType, description: c.description });
        out.sort((a, b) => String(a.name || "").localeCompare(String(b.name || "")));
        return out;
      }

      function getProgramEntrypoints(model) {
        const nodes = Array.from(model?.nodes?.values?.() || []);
        const events = nodes
          .filter((n) => n.kind === "EVENT")
          .sort((a, b) => (a.sourceRef?.startLine ?? 1e9) - (b.sourceRef?.startLine ?? 1e9))
          .map((n) => n.key);

        if (events.length > 0) return events;

        const forms = nodes
          .filter((n) => n.kind === "FORM" && n.isDefined && (n.calledBy?.length || 0) === 0)
          .sort((a, b) => (a.sourceRef?.startLine ?? 1e9) - (b.sourceRef?.startLine ?? 1e9))
          .map((n) => n.key);

        return forms;
      }

      function traceGlobalVariable(model, varName, options) {
        const startVar = String(varName || "").trim();
        if (!startVar) return { error: "Variable name is empty." };

        const globalDeclMap = buildGlobalDeclMap(model);
        const startLower = startVar.toLowerCase();
        const globalEntry = globalDeclMap.get(startLower) || null;
        const decl = globalEntry?.decl || null;

        const entrypoints = getProgramEntrypoints(model);
        const calls = [];

        for (const key of entrypoints) {
          const routine = model.nodes.get(key);
          if (!routine?.sourceRef) continue;
          const childResult = traceVariable(model, key, startVar, options);
          if (!childResult?.root) continue;

          const root = childResult.root;
          const hasChildCalls = (root.calls || []).length > 0;
          const hasOwnWrites = (root.writes || []).some((w) => {
            const ln = w?.sourceRef?.startLine ?? null;
            if (!ln) return false;
            const from = root.sourceRef?.startLine ?? null;
            if (!from) return false;
            const to = root.sourceRef?.endLine ?? from;
            return ln >= from && ln <= to;
          });

          if (!hasChildCalls && !hasOwnWrites) continue;

          calls.push({
            direction: "toCallee",
            edge: { sourceRef: routine.sourceRef || null },
            fromVar: startVar,
            toVar: startVar,
            mappingKind: "ENTRYPOINT",
            label: `Entrypoint ${childResult.root.routineKind} ${childResult.root.routineName}: ${startVar}`,
            child: childResult.root,
          });
        }

        const resolution = decl ? { scope: "global", decl } : { scope: "unknown" };

        return {
          startKey: "PROGRAM",
          varName: startVar,
          root: {
            routineKey: "PROGRAM",
            routineName: "PROGRAM (Globals)",
            routineKind: "PROGRAM",
            varName: startVar,
            resolution,
            sourceRef: decl?.sourceRef || null,
            writes: [],
            calls,
          },
        };
      }

      ns.lineage = { traceVariable, traceGlobalVariable, getVariablesForRoutine, getGlobalVariables, resolveSymbol };
    })(window.AbapFlow);

    </script>
        <script>
    // js/desc_resolver.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      // Identifier paths like:
      // - lv_a
      // - ls_s-field
      // - lo_ref->attr
      // - zif_intf=>const
      const IDENT_PATH_RE = /[A-Za-z_][A-Za-z0-9_\/]*(?:(?:->|=>|[-~])[A-Za-z0-9_\/]+)*/g;

      class ObjAbap {
        constructor(options) {
          this.kind = String(options?.kind || "UNKNOWN").toUpperCase();
          this.key = String(options?.key || "");
          this.name = String(options?.name || "");
          this.scope = String(options?.scope || "unknown").toLowerCase();
          this.routineKey = String(options?.routineKey || "");
          this.entity = options?.entity || null;
        }

        get description() {
          return pickDescription(this.entity, this.name);
        }
      }

      class ObjAbapParam extends ObjAbap {
        constructor(options) {
          super({ ...options, kind: "PARAM" });
        }
      }

      class ObjAbapDecl extends ObjAbap {
        constructor(options) {
          super({ ...options, kind: "DECL" });
        }
      }

      class ObjAbapTypeField extends ObjAbap {
        constructor(options) {
          super({ ...options, kind: "TYPEFIELD" });
        }
      }

      class ObjAbapUnknown extends ObjAbap {
        constructor(options) {
          super({ ...options, kind: "UNKNOWN" });
        }
      }

      function pickDescription(entity, fallbackName) {
        const user = String(entity?.userDescription || "").trim();
        if (user) return user;
        const code = String(entity?.description || "").trim();
        if (code) return code;

        if (fallbackName != null) return String(fallbackName || "").trim();
        const name = entity?.variableName ?? entity?.name ?? "";
        return String(name || "").trim();
      }

      function maskMatchesWithSpaces(text, re) {
        return String(text || "").replace(re, (m) => " ".repeat(m.length));
      }

      function maskStringsAndTemplates(text) {
        let s = String(text || "");
        // ABAP strings: '...'; escaped by doubling: ''
        s = maskMatchesWithSpaces(s, /'(?:[^']|'')*'/g);
        // ABAP string templates: |...|  (best-effort)
        s = maskMatchesWithSpaces(s, /\|[^|]*\|/g);
        return s;
      }

      function rootFromPath(path) {
        const s = String(path || "").trim();
        if (!s) return "";
        const root = s.split(/(?:->|=>|[-~])/)[0] || "";
        const m = /^[A-Za-z_][A-Za-z0-9_\/]*/.exec(root.trim());
        return m ? m[0] : "";
      }

      function isRootIdentifier(name) {
        return /^[A-Za-z_][A-Za-z0-9_\/]*$/.test(String(name || "").trim());
      }

      function isSimpleStructPath(token) {
        const s = String(token || "");
        if (!s.includes("-")) return false;
        if (s.includes("->") || s.includes("=>") || s.includes("~")) return false;
        return true;
      }

      function splitStructPath(token) {
        const s = String(token || "").trim();
        if (!isSimpleStructPath(s)) return null;
        const parts = s.split("-").filter(Boolean);
        if (parts.length < 2) return null;
        const root = parts[0];
        if (!isRootIdentifier(root)) return null;
        const fields = parts.slice(1);
        if (fields.some((x) => !/^[A-Za-z0-9_\/]+$/.test(String(x || "")))) return null;
        return { root, fields };
      }

      function makeTypeDefKey(scopeKey, typeName) {
        const sk = String(scopeKey || "").trim();
        const tn = String(typeName || "")
          .trim()
          .toLowerCase();
        if (!sk || !tn) return "";
        return `${sk}|${tn}`;
      }

      function resolveTypeFieldFromVirtualDecl(model, decl) {
        const origin = decl?.virtualOrigin && typeof decl.virtualOrigin === "object" ? decl.virtualOrigin : null;
        if (!origin || origin.kind !== "typeField") return null;

        const typeScopeKey = String(origin.typeScopeKey || "").trim() || "PROGRAM";
        const typeName = String(origin.typeName || "").trim();
        const fieldPath = String(origin.fieldPath || "").trim();
        if (!typeName || !fieldPath) return null;

        const key = makeTypeDefKey(typeScopeKey, typeName);
        const typeDef = model?.typeDefs?.get ? model.typeDefs.get(key) : null;
        const field = typeDef?.fields?.get ? typeDef.fields.get(fieldPath.toLowerCase()) : null;

        return { typeScopeKey, typeName, fieldPath, field, typeDef };
      }

      function incomingEdgeForRoutine(callPath, routineKey) {
        const rk = String(routineKey || "");
        if (!rk) return null;
        const path = Array.isArray(callPath) ? callPath : [];
        for (let i = path.length - 1; i >= 0; i--) {
          const e = path[i];
          if (String(e?.toKey || "") === rk) return { edge: e, index: i };
        }
        return null;
      }

      function mapParamToActualExpression(model, edge, paramName) {
        const calleeKey = String(edge?.toKey || "");
        const callee = model?.nodes?.get ? model.nodes.get(calleeKey) : null;
        if (!callee) return "";

        const targetLower = String(paramName || "").trim().toLowerCase();
        if (!targetLower) return "";

        const p = (callee.params || []).find((x) => String(x?.name || "").toLowerCase() === targetLower) || null;
        if (!p) return "";

        const kind = String(p.kind || "").toUpperCase();
        const rule =
          kind === "USING"
            ? { edgeKey: "using", kind: "USING" }
            : kind === "CHANGING"
              ? { edgeKey: "changing", kind: "CHANGING" }
              : kind === "TABLES"
                ? { edgeKey: "tables", kind: "TABLES" }
                : null;
        if (!rule) return "";

        const formals = (callee.params || []).filter((x) => String(x?.kind || "").toUpperCase() === rule.kind);
        const idx = formals.findIndex((x) => String(x?.name || "").toLowerCase() === targetLower);
        if (idx < 0) return "";

        const actuals = edge?.args?.[rule.edgeKey] || [];
        if (!Array.isArray(actuals) || idx >= actuals.length) return "";

        return String(actuals[idx] ?? "").trim();
      }

      function appendSuffixIfAppropriate(actualExpr, suffix) {
        const sfx = String(suffix || "");
        const a = String(actualExpr || "").trim();
        if (!sfx || !a) return a;
        if (!isRootIdentifier(a)) return a;
        return `${a}${sfx}`;
      }

      function makeOriginKeyFromResolution(resolution, routineKey, symbolName) {
        if (!ns.notes) return "";

        const scope = String(resolution?.scope || "").toLowerCase();
        const decl = resolution?.decl || null;

        if (scope === "parameter") {
          if (!ns.notes.makeParamKey) return "";
          return ns.notes.makeParamKey(routineKey, symbolName);
        }

        if ((scope === "local" || scope === "global") && decl?.declKind && decl?.variableName && ns.notes.makeDeclKey) {
          const scopeKey = scope === "global" ? "PROGRAM" : routineKey;
          return ns.notes.makeDeclKey(scopeKey, decl.declKind, decl.variableName);
        }

        return "";
      }

      function describeExpression(model, routineKey, expression, options) {
        const expr = String(expression ?? "");
        const rk = String(routineKey || "").trim();
        if (!expr) return { text: "", primary: null };
        if (!rk || !model || !model.nodes) return { text: expr, primary: null };

        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;
        const maxDepth = Math.max(0, Math.floor(Number(options?.maxDepth ?? 12)));
        const overrideByKey = options?.overrideByKey;

        const masked = maskStringsAndTemplates(expr);

        let primary = null;
        let originChain = null;
        const origins = [];
        const originByKey = new Map();
        let out = "";
        let last = 0;
        IDENT_PATH_RE.lastIndex = 0;

        function addOrigin(obj) {
          if (!obj || !obj.key) return;
          const k = String(obj.key || "").trim();
          if (!k) return;
          if (originByKey.has(k)) return;
          originByKey.set(k, obj);
          origins.push(obj);
        }

        function lookupOverride(originKey) {
          const k = String(originKey || "").trim();
          if (!k || !overrideByKey) return "";

          let v = undefined;
          if (overrideByKey instanceof Map) v = overrideByKey.get(k);
          else if (typeof overrideByKey === "object") v = overrideByKey[k];

          return String(v ?? "").trim();
        }

        function describeToken(currentRoutineKey, token, currentCallPath, depth) {
          const structPath = splitStructPath(token);
          const root = structPath ? structPath.root : rootFromPath(token);
          if (!root) return { text: token, primary: null };

          const suffix = token.slice(root.length);
          const resolution =
            typeof ns.lineage?.resolveSymbol === "function"
              ? ns.lineage.resolveSymbol(model, currentRoutineKey, root)
              : { scope: "unknown" };
          const scope = String(resolution?.scope || "unknown").toLowerCase();

          if (scope === "parameter" && depth < maxDepth) {
            let incoming = incomingEdgeForRoutine(currentCallPath, currentRoutineKey);
            let edge = incoming?.edge || null;
            let edgeIndex = Number.isFinite(incoming?.index) ? incoming.index : -1;

            if (!edge) {
              const routine = model.nodes.get(currentRoutineKey);
              const incomingEdges = (routine?.calledBy || [])
                .slice()
                .sort((a, b) => (a?.sourceRef?.startLine ?? 1e9) - (b?.sourceRef?.startLine ?? 1e9));
              for (const e of incomingEdges) {
                if (mapParamToActualExpression(model, e, root)) {
                  edge = e;
                  break;
                }
              }
            }

            const actualExprRaw = edge ? mapParamToActualExpression(model, edge, root) : "";
            const fallback = pickDescription(resolution?.decl, root) || root;

            if (edge && actualExprRaw) {
              const callerKey = String(edge?.fromKey || "").trim();
              if (callerKey) {
                const mappedExpr = appendSuffixIfAppropriate(actualExprRaw, suffix);
                const nextCallPath =
                  currentCallPath && edgeIndex >= 0
                    ? currentCallPath.slice(0, edgeIndex)
                    : currentCallPath && currentCallPath.length
                      ? currentCallPath.slice(0, -1)
                      : null;

                const nested = describeExpression(model, callerKey, mappedExpr, {
                  callPath: nextCallPath,
                  maxDepth: maxDepth - 1,
                  overrideByKey,
                });
                return {
                  text: nested.text || mappedExpr || `${fallback}${suffix}`,
                  primary: nested.primary || null,
                  chain: Array.isArray(nested.origins) && nested.origins.length ? nested.origins : null,
                };
              }
            }

            const key = makeOriginKeyFromResolution(resolution, currentRoutineKey, root);
            const override = lookupOverride(key);
            const desc = override || fallback;
            const p = key
              ? new ObjAbapParam({ key, scope: "parameter", routineKey: currentRoutineKey, name: root, entity: resolution?.decl || null })
              : null;
            return { text: `${desc}${suffix}`, primary: p, chain: p ? [p] : null };
          }

          if (scope === "local" || scope === "global") {
            if (structPath) {
              const parts = [];
              const chain = [];
              let lastPrimary = null;

              const rootKey = makeOriginKeyFromResolution(resolution, currentRoutineKey, root);
              const rootOverride = lookupOverride(rootKey);
              const rootDesc = rootOverride || pickDescription(resolution?.decl, root) || root;
              parts.push(rootDesc);
              if (rootKey) chain.push(new ObjAbapDecl({ key: rootKey, scope, routineKey: currentRoutineKey, name: root, entity: resolution?.decl || null }));

              let currentFull = root;
              for (const segName of structPath.fields) {
                currentFull = `${currentFull}-${segName}`;
                const segRes =
                  typeof ns.lineage?.resolveSymbol === "function"
                    ? ns.lineage.resolveSymbol(model, currentRoutineKey, currentFull)
                    : { scope: "unknown" };

                let segText = segName;
                let segPrimary = null;

                if ((segRes.scope === "local" || segRes.scope === "global") && segRes.decl) {
                  const decl = segRes.decl;
                  const virtualType = resolveTypeFieldFromVirtualDecl(model, decl);
                  if (virtualType && virtualType.field) {
                    const segKey = ns.notes?.makeTypeFieldKey
                      ? ns.notes.makeTypeFieldKey(virtualType.typeScopeKey, virtualType.typeName, virtualType.fieldPath)
                      : "";
                    const segOverride = lookupOverride(segKey);
                    segText = segOverride || pickDescription(virtualType.field, segName) || segName;
                    if (segKey) {
                      segPrimary = new ObjAbapTypeField({
                        key: segKey,
                        scope: "type",
                        routineKey: virtualType.typeScopeKey,
                        name: segName,
                        entity: virtualType.field,
                      });
                    }
                  } else {
                    const segKey = makeOriginKeyFromResolution(segRes, currentRoutineKey, currentFull);
                    const segOverride = lookupOverride(segKey);
                    segText = segOverride || pickDescription(decl, segName) || segName;
                    if (segKey) segPrimary = new ObjAbapDecl({ key: segKey, scope: segRes.scope, routineKey: currentRoutineKey, name: segName, entity: decl });
                  }
                }

                parts.push(segText);
                if (segPrimary) {
                  chain.push(segPrimary);
                  lastPrimary = segPrimary;
                }
              }

              return { text: parts.join("-"), primary: lastPrimary || null, chain };
            }

            const key = makeOriginKeyFromResolution(resolution, currentRoutineKey, root);
            const override = lookupOverride(key);
            const desc = override || pickDescription(resolution?.decl, root) || root;
            return {
              text: `${desc}${suffix}`,
              primary: key ? new ObjAbapDecl({ key, scope, routineKey: currentRoutineKey, name: root, entity: resolution?.decl || null }) : null,
              chain: key ? [new ObjAbapDecl({ key, scope, routineKey: currentRoutineKey, name: root, entity: resolution?.decl || null })] : null,
            };
          }

          return { text: token, primary: null };
        }

        let m = null;
        while ((m = IDENT_PATH_RE.exec(masked))) {
          const token = String(m[0] || "");
          const idx = Number(m.index || 0);
          if (idx < last) continue;

          out += expr.slice(last, idx);

          const rawToken = expr.slice(idx, idx + token.length);
          const r = describeToken(rk, rawToken, callPath, 0);
          out += r.text;

          if (!primary && r.primary?.key) primary = r.primary;
          if (!originChain && Array.isArray(r.chain) && r.chain.length) originChain = r.chain;
          if (Array.isArray(r.chain) && r.chain.length) {
            for (const o of r.chain) addOrigin(o);
          } else if (r.primary?.key) {
            addOrigin(r.primary);
          }
          last = idx + token.length;
        }

        out += expr.slice(last);
        return { text: out, primary, originChain, origins };
      }

      function describeExpressionWithOrigin(model, routineKey, expression, options) {
        const res = describeExpression(model, routineKey, expression, options);
        return {
          text: res.text,
          originKey: String(res.primary?.key || ""),
          primary: res.primary || null,
          originChain: Array.isArray(res.originChain) ? res.originChain : null,
          origins: Array.isArray(res.origins) ? res.origins : null,
        };
      }

      ns.desc = {
        IDENT_PATH_RE,
        ObjAbap,
        ObjAbapParam,
        ObjAbapDecl,
        ObjAbapTypeField,
        ObjAbapUnknown,
        pickDescription,
        maskStringsAndTemplates,
        rootFromPath,
        describeExpression,
        describeExpressionWithOrigin,
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/diagram.js
    (function (ns) {
      "use strict";

      const SVG_NS = "http://www.w3.org/2000/svg";

      function el(name, attrs) {
        const node = document.createElementNS(SVG_NS, name);
        for (const [k, v] of Object.entries(attrs || {})) node.setAttribute(k, String(v));
        return node;
      }

      function render(model, host, options) {
        const onNodeClick = options?.onNodeClick || null;
        host.innerHTML = "";

        const nodes = Array.from(model.nodes.values()).sort((a, b) => {
          if (a.depth !== b.depth) return a.depth - b.depth;
          const ka = a.kind === "EVENT" ? 0 : a.kind === "FORM" ? 1 : 2;
          const kb = b.kind === "EVENT" ? 0 : b.kind === "FORM" ? 1 : 2;
          if (ka !== kb) return ka - kb;
          return a.name.localeCompare(b.name);
        });

        const maxDepth = Math.max(0, ...nodes.map((n) => n.depth ?? 0));
        const cols = Array.from({ length: maxDepth + 1 }, () => []);
        for (const n of nodes) cols[n.depth ?? 0].push(n);

        const margin = 18;
        const nodeW = 230;
        const nodeH = 72;
        const colGap = 80;
        const rowGap = 18;

        const positions = new Map();

        let totalH = 0;
        for (const col of cols) {
          const h = margin * 2 + col.length * nodeH + Math.max(0, col.length - 1) * rowGap;
          totalH = Math.max(totalH, h);
        }
        const totalW = margin * 2 + cols.length * nodeW + Math.max(0, cols.length - 1) * colGap;

        const svg = el("svg", { width: totalW, height: totalH, viewBox: `0 0 ${totalW} ${totalH}` });

        const defs = el("defs");
        const marker = el("marker", { id: "arrow", markerWidth: 10, markerHeight: 10, refX: 9, refY: 5, orient: "auto" });
        marker.appendChild(el("path", { d: "M0 0 L10 5 L0 10 z", fill: "#64748b" }));
        defs.appendChild(marker);
        svg.appendChild(defs);

        for (let d = 0; d < cols.length; d++) {
          const col = cols[d];
          const x = margin + d * (nodeW + colGap);
          let y = margin;
          for (const n of col) {
            positions.set(n.key, { x, y, w: nodeW, h: nodeH });
            y += nodeH + rowGap;
          }
        }

        const edgesGroup = el("g", {});
        for (const edge of model.edges) {
          const from = positions.get(edge.fromKey);
          const to = positions.get(edge.toKey);
          if (!from || !to) continue;

          const sx = from.x + from.w;
          const sy = from.y + from.h / 2;
          const ex = to.x;
          const ey = to.y + to.h / 2;
          const bend = Math.max(40, Math.min(140, Math.abs(ex - sx) * 0.35));
          const c1x = sx + bend;
          const c1y = sy;
          const c2x = ex - bend;
          const c2y = ey;
          const dAttr = `M ${sx} ${sy} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${ex} ${ey}`;

          edgesGroup.appendChild(
            el("path", {
              d: dAttr,
              fill: "none",
              stroke: edge.isInCycle ? "#ef4444" : "#94a3b8",
              "stroke-width": edge.isInCycle ? 2.2 : 1.6,
              "marker-end": "url(#arrow)",
              opacity: edge.isInCycle ? 0.95 : 0.75,
            }),
          );
        }
        svg.appendChild(edgesGroup);

        const nodesGroup = el("g", {});
        for (const n of nodes) {
          const pos = positions.get(n.key);
          if (!pos) continue;

          const g = el("g", { class: "node", "data-key": n.key });
          const fill = n.isDefined ? "#f8fafc" : "#e5e7eb";
          const stroke = n.isInCycle ? "#ef4444" : n.kind === "EVENT" ? "#60a5fa" : "#64748b";

          const rect = el("rect", {
            x: pos.x,
            y: pos.y,
            width: pos.w,
            height: pos.h,
            rx: 12,
            ry: 12,
            fill,
            stroke,
            "stroke-width": n.isInCycle ? 2.4 : 1.6,
          });
          if (!n.isDefined) rect.setAttribute("stroke-dasharray", "6 4");

          const title = el("text", { x: pos.x + 12, y: pos.y + 24, fill: "#0b1020", "font-size": 13, "font-family": "system-ui, sans-serif" });
          title.textContent = `${n.kind} ${n.name}`;

          const meta = el("text", { x: pos.x + 12, y: pos.y + 46, fill: "#0b1020", "font-size": 11, "font-family": "ui-monospace, monospace" });
          meta.textContent = `P:${n.paramsCount} D:${n.localDataCount} C:${n.localConstCount} W:${n.writesCount}`;

          g.appendChild(rect);
          g.appendChild(title);
          g.appendChild(meta);

          if (onNodeClick) {
            g.style.cursor = "pointer";
            g.addEventListener("click", () => onNodeClick(n.key));
          }

          nodesGroup.appendChild(g);
        }
        svg.appendChild(nodesGroup);

        host.appendChild(svg);

        return { svg, positions };
      }

      ns.diagram = { render };
    })(window.AbapFlow);


    </script>
        <script>
    // js/sequence.js
    (function (ns) {
      "use strict";

      const PROGRAM_ALL_KEY = "SEQUENCE:PROGRAM_ALL";

      function getStartCandidates(model) {
        const nodes = Array.from(model.nodes.values());
        nodes.sort((a, b) => {
          const la = a.sourceRef?.startLine ?? 1e9;
          const lb = b.sourceRef?.startLine ?? 1e9;
          if (la !== lb) return la - lb;
          const ka = a.kind === "EVENT" ? 0 : a.kind === "FORM" ? 1 : 2;
          const kb = b.kind === "EVENT" ? 0 : b.kind === "FORM" ? 1 : 2;
          if (ka !== kb) return ka - kb;
          return a.name.localeCompare(b.name);
        });

        const items = nodes.map((n) => ({
          key: n.key,
          label: `${n.kind} ${n.name}${n.isDefined ? "" : " (external)"}`,
        }));

        items.unshift({ key: PROGRAM_ALL_KEY, label: "PROGRAM (All entrypoints)" });
        return items;
      }

      function getProgramEntrypoints(model) {
        const nodes = Array.from(model.nodes.values());
        const events = nodes
          .filter((n) => n.kind === "EVENT")
          .sort((a, b) => (a.sourceRef?.startLine ?? 1e9) - (b.sourceRef?.startLine ?? 1e9))
          .map((n) => n.key);

        if (events.length > 0) return events;

        const forms = nodes
          .filter((n) => n.kind === "FORM" && n.isDefined && (n.calledBy?.length || 0) === 0)
          .sort((a, b) => (a.sourceRef?.startLine ?? 1e9) - (b.sourceRef?.startLine ?? 1e9))
          .map((n) => n.key);

        return forms;
      }

      function build(model, startKey, options) {
        const maxSteps = Math.max(10, Number(options?.maxSteps || 200));
        const steps = [];

        const rowKeys = [];
        const rowSet = new Set();
        function ensureRow(key) {
          if (!rowSet.has(key)) {
            rowSet.add(key);
            rowKeys.push(key);
          }
        }

        let truncated = false;

        function walk(routineKey, depth, stack) {
          if (steps.length >= maxSteps) {
            truncated = true;
            return;
          }

          const routine = model.nodes.get(routineKey);
          if (!routine) return;

          stack.add(routineKey);

          const calls = (routine.calls || []).slice().sort((a, b) => {
            const la = a.sourceRef?.startLine ?? 1e9;
            const lb = b.sourceRef?.startLine ?? 1e9;
            return la - lb;
          });

          for (const edge of calls) {
            if (steps.length >= maxSteps) {
              truncated = true;
              break;
            }

            ensureRow(edge.fromKey);
            ensureRow(edge.toKey);

            const isRecursion = stack.has(edge.toKey);
            steps.push({
              kind: "call",
              depth,
              fromKey: edge.fromKey,
              toKey: edge.toKey,
              edge,
              isRecursion,
            });

            if (!isRecursion) walk(edge.toKey, depth + 1, stack);
          }

          stack.delete(routineKey);
        }

        if (startKey === PROGRAM_ALL_KEY) {
          const roots = getProgramEntrypoints(model);
          for (let r = 0; r < roots.length; r++) {
            const rootKey = roots[r];
            const root = model.nodes.get(rootKey);
            ensureRow(rootKey);

            steps.push({
              kind: "separator",
              label: root ? `${root.kind} ${root.name}` : rootKey,
              rootKey,
            });

            const stack = new Set();
            walk(rootKey, 0, stack);
            if (steps.length >= maxSteps) break;
          }
        } else {
          ensureRow(startKey);
          const stack = new Set();
          walk(startKey, 0, stack);
        }

        return { startKey, steps, rowKeys, truncated, maxSteps };
      }

      function render(container, model, sequence, options) {
        const onParamClick = options?.onParamClick || null;
        const onRowClick = options?.onRowClick || null;

        container.innerHTML = "";
        container.classList.remove("empty");

        const scroll = document.createElement("div");
        scroll.className = "seq-scroll";

        const grid = document.createElement("div");
        grid.className = "seq-grid";

        const labels = document.createElement("div");
        labels.className = "seq-labels";

        const canvas = document.createElement("div");
        canvas.className = "seq-canvas";

        const header = document.createElement("div");
        header.className = "seq-header";
        header.textContent = sequence.truncated
          ? `Sequence truncated at ${sequence.maxSteps} steps.`
          : `Steps: ${sequence.steps.length}`;
        labels.appendChild(header);

        function createChip(param, routineKey) {
          const b = document.createElement("button");
          b.type = "button";
          b.className = "chip";
          b.dataset.key = routineKey;
          b.dataset.var = param.name;
          const dt = param.dataType ? ` TYPE ${param.dataType}` : "";
          const descText = String(param.userDescription || param.description || "").trim();
          const desc = descText ? ` - ${descText}` : "";
          b.textContent = `${param.kind} ${param.name}${dt}${desc}`;
          b.title = "Jump to Trace";
          b.addEventListener("click", (ev) => {
            ev.stopPropagation();
            if (onParamClick) onParamClick({ routineKey, varName: param.name });
          });
          return b;
        }

        for (const key of sequence.rowKeys) {
          const routine = model.nodes.get(key);
          if (!routine) continue;

          const row = document.createElement("div");
          row.className = "seq-row-label";
          row.dataset.key = key;

          const title = document.createElement("div");
          title.className = "seq-row-title";
          title.textContent = `${routine.kind} ${routine.name}${routine.isDefined ? "" : " (external)"}`;
          row.appendChild(title);

          const descText = String(routine.userDescription || routine.description || "").trim();
          if (descText) {
            const desc = document.createElement("div");
            desc.className = "seq-row-desc";
            desc.textContent = descText;
            row.appendChild(desc);
          }

          if (routine.params && routine.params.length > 0) {
            const params = document.createElement("div");
            params.className = "seq-row-params";
            for (const p of routine.params) params.appendChild(createChip(p, key));
            row.appendChild(params);
          }

          if (onRowClick) {
            row.style.cursor = "pointer";
            row.addEventListener("click", () => onRowClick({ routineKey: key }));
          }

          labels.appendChild(row);
        }

        grid.appendChild(labels);
        grid.appendChild(canvas);
        scroll.appendChild(grid);
        container.appendChild(scroll);

        const gridRect = grid.getBoundingClientRect();
        const rowEls = Array.from(labels.querySelectorAll(".seq-row-label"));
        const rowCenters = new Map();
        const rowRanges = [];
        const rowElByKey = new Map();
        for (const rowEl of rowEls) {
          const key = rowEl.dataset.key;
          if (!key) continue;
          rowElByKey.set(key, rowEl);

          const anchorEl = rowEl.querySelector(".seq-row-title") || rowEl;
          const rect = anchorEl.getBoundingClientRect();
          const y = Math.round(rect.top - gridRect.top + rect.height / 2);
          rowCenters.set(key, y);

          const rowRect = rowEl.getBoundingClientRect();
          rowRanges.push({
            key,
            top: rowRect.top - gridRect.top,
            bottom: rowRect.bottom - gridRect.top,
          });
        }

        const steps = sequence.steps || [];
        const colW = 140;
        const marginX = 18;
        const marginY = 10;
        const headerH = header.offsetHeight;

        const width = Math.max(720, marginX * 2 + steps.length * colW);
        const height = Math.max(520, labels.scrollHeight);

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.classList.add("seq-svg");
        svg.setAttribute("width", String(width));
        svg.setAttribute("height", String(height));
        svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        function addMarker(id, fill) {
          const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
          marker.setAttribute("id", id);
          marker.setAttribute("markerWidth", "10");
          marker.setAttribute("markerHeight", "10");
          marker.setAttribute("refX", "9");
          marker.setAttribute("refY", "5");
          marker.setAttribute("orient", "auto");
          const mPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
          mPath.setAttribute("d", "M0 0 L10 5 L0 10 z");
          mPath.setAttribute("fill", fill);
          marker.appendChild(mPath);
          defs.appendChild(marker);
        }

        addMarker("seq-arrow", "#64748b");
        addMarker("seq-arrow-danger", "#ef4444");
        svg.appendChild(defs);

        function line(x1, y1, x2, y2, stroke, w, dash) {
          const p = document.createElementNS("http://www.w3.org/2000/svg", "line");
          p.setAttribute("x1", String(x1));
          p.setAttribute("y1", String(y1));
          p.setAttribute("x2", String(x2));
          p.setAttribute("y2", String(y2));
          p.setAttribute("stroke", stroke);
          p.setAttribute("stroke-width", String(w || 1));
          if (dash) p.setAttribute("stroke-dasharray", dash);
          svg.appendChild(p);
        }

        for (let i = 0; i < steps.length; i++) {
          const x = marginX + i * colW + colW / 2;
          line(x, headerH + marginY, x, height, "rgba(255,255,255,0.05)", 1);

          const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
          t.setAttribute("x", String(x - 6));
          t.setAttribute("y", String(headerH - 10));
          t.setAttribute("fill", "rgba(255,255,255,0.45)");
          t.setAttribute("font-size", "11");
          t.setAttribute("font-family", "ui-monospace, monospace");
          t.textContent = String(i + 1);
          svg.appendChild(t);

          const step = steps[i];
          if (step && step.kind === "separator") {
            const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
            label.setAttribute("x", String(x + 10));
            label.setAttribute("y", String(headerH - 28));
            label.setAttribute("fill", "rgba(96,165,250,0.85)");
            label.setAttribute("font-size", "11");
            label.setAttribute("font-family", "system-ui, sans-serif");
            label.textContent = step.label || "Section";
            svg.appendChild(label);

            line(x, headerH + marginY, x, height, "rgba(96,165,250,0.10)", 3, "8 6");
          }
        }

        for (const [key, y] of rowCenters.entries()) {
          line(0, y, width, y, "rgba(255,255,255,0.06)", 1);

          const routine = model.nodes.get(key);
          if (routine && routine.isInCycle) {
            line(0, y + 1, width, y + 1, "rgba(239,68,68,0.18)", 2);
          }
        }

        const hoverLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        hoverLine.classList.add("seq-hover-line");
        hoverLine.setAttribute("x1", "0");
        hoverLine.setAttribute("x2", String(width));
        hoverLine.setAttribute("y1", "0");
        hoverLine.setAttribute("y2", "0");
        hoverLine.style.opacity = "0";
        svg.appendChild(hoverLine);

        const connectorGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        connectorGroup.setAttribute("opacity", "0.85");
        svg.appendChild(connectorGroup);

        function bezierConnector(x1, y1, x2, y2, stroke, width) {
          const dx = Math.max(30, Math.min(70, Math.abs(x2 - x1) * 0.45));
          const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
          p.setAttribute("d", `M ${x1} ${y1} C ${x1 + dx} ${y1}, ${x2 - dx} ${y2}, ${x2} ${y2}`);
          p.setAttribute("fill", "none");
          p.setAttribute("stroke", stroke);
          p.setAttribute("stroke-width", String(width));
          p.setAttribute("stroke-linecap", "round");
          p.setAttribute("stroke-linejoin", "round");
          connectorGroup.appendChild(p);
        }

        const arrowsGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svg.appendChild(arrowsGroup);

        for (let i = 0; i < steps.length; i++) {
          const st = steps[i];
          if (!st || st.kind !== "call") continue;

          const x = marginX + i * colW + colW / 2;
          const y1 = rowCenters.get(st.fromKey) ?? 0;
          const y2 = rowCenters.get(st.toKey) ?? 0;
          const isCycle = st.edge?.isInCycle || st.isRecursion;
          const isExternal = model.nodes.get(st.toKey)?.isDefined === false;

          const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
          p.setAttribute("d", `M ${x} ${y1} L ${x} ${y2}`);
          p.setAttribute("fill", "none");
          p.setAttribute("stroke", isCycle ? "#ef4444" : "#94a3b8");
          p.setAttribute("stroke-width", isCycle ? "2.2" : "1.6");
          p.setAttribute("marker-end", isCycle ? "url(#seq-arrow-danger)" : "url(#seq-arrow)");
          p.setAttribute("opacity", isCycle ? "0.95" : "0.8");
          if (isExternal) p.setAttribute("stroke-dasharray", "6 4");

          const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
          const from = model.nodes.get(st.fromKey);
          const to = model.nodes.get(st.toKey);
          title.textContent = `${from ? from.name : st.fromKey} -> ${to ? to.name : st.toKey}`;
          p.appendChild(title);
          arrowsGroup.appendChild(p);

          const next = steps[i + 1];
          if (!next || next.kind !== "call") continue;
          const x2 = marginX + (i + 1) * colW + colW / 2;
          const yNext = rowCenters.get(next.fromKey);
          if (yNext == null) continue;

          const isCycle2 = isCycle || next.edge?.isInCycle || next.isRecursion;
          bezierConnector(x, y2, x2, yNext, isCycle2 ? "rgba(239,68,68,0.35)" : "rgba(96,165,250,0.35)", 3.4);
        }

        canvas.appendChild(svg);

        let labelHoverKey = null;
        let svgHoverKey = null;
        let activeHoverKey = null;

        function applyHover(key) {
          if (key === activeHoverKey) return;
          if (activeHoverKey) {
            rowElByKey.get(activeHoverKey)?.classList.remove("is-hover");
          }

          activeHoverKey = key || null;
          if (!activeHoverKey) {
            hoverLine.style.opacity = "0";
            return;
          }

          rowElByKey.get(activeHoverKey)?.classList.add("is-hover");

          const y = rowCenters.get(activeHoverKey);
          if (y == null) {
            hoverLine.style.opacity = "0";
            return;
          }

          hoverLine.setAttribute("y1", String(y));
          hoverLine.setAttribute("y2", String(y));
          hoverLine.style.opacity = "1";
        }

        function updateHover() {
          applyHover(labelHoverKey || svgHoverKey);
        }

        for (const rowEl of rowEls) {
          const key = rowEl.dataset.key;
          if (!key) continue;
          rowEl.addEventListener("mouseenter", () => {
            labelHoverKey = key;
            updateHover();
          });
          rowEl.addEventListener("mouseleave", () => {
            if (labelHoverKey === key) {
              labelHoverKey = null;
              updateHover();
            }
          });
        }

        function findRowKeyAtY(y) {
          for (let i = 0; i < rowRanges.length; i++) {
            const r = rowRanges[i];
            if (y >= r.top && y <= r.bottom) return r.key;
          }
          return null;
        }

        svg.addEventListener("mousemove", (ev) => {
          const rect = grid.getBoundingClientRect();
          const y = ev.clientY - rect.top;
          const key = findRowKeyAtY(y);
          if (key !== svgHoverKey) {
            svgHoverKey = key;
            updateHover();
          }
        });

        svg.addEventListener("mouseleave", () => {
          if (svgHoverKey) {
            svgHoverKey = null;
            updateHover();
          }
        });

        const gridW = 360 + width;
        grid.style.width = `${gridW}px`;
      }

      ns.sequence = { PROGRAM_ALL_KEY, getStartCandidates, build, render };
    })(window.AbapFlow);

    </script>
        <script>
    // js/parser.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;
      const doc = ns.doc;
      const {
        ProgramModel,
        SourceRef,
        AbapParameter,
        AbapDataDeclaration,
        AbapWrite,
        AbapAssignment,
        AbapIfStatement,
        AbapMessageStatement,
        AbapItabOperation,
        AbapCallEdge,
      } = ns.model;

      function defaultParserConfig() {
        const IDENT = String.raw`[A-Za-z_][A-Za-z0-9_\/]*`;
        const IDENT_PATH = String.raw`${IDENT}(?:(?:[-~]|->|=>)[A-Za-z0-9_\/]+)*`;

        return {
          version: 1,
          routineBlocks: [
            {
              kind: "FORM",
              start: /^FORM\b/i,
              end: /^ENDFORM\b/i,
              endRequiresPeriod: true,
              header: {
                name: new RegExp(String.raw`^FORM\s+(${IDENT})\b\s*(.*)$`, "i"),
                clauseOrder: ["TABLES", "USING", "CHANGING", "RAISING"],
                paramIgnoreTokens: ["OPTIONAL", "DEFAULT", "TYPE", "LIKE"],
              },
            },
          ],
          events: {
            exact: ["INITIALIZATION", "START-OF-SELECTION", "END-OF-SELECTION", "AT LINE-SELECTION", "AT USER-COMMAND"],
            prefixes: ["AT SELECTION-SCREEN", "TOP-OF-PAGE", "END-OF-PAGE"],
          },
          statements: {
            calls: [
              {
                kind: "PERFORM",
                pattern: new RegExp(String.raw`^PERFORM\s+(${IDENT})\b\s*(.*)$`, "i"),
                calleeKind: "FORM",
                clauseOrder: ["TABLES", "USING", "CHANGING"],
              },
            ],
            declarations: {
              globalKinds: ["DATA", "CONSTANTS", "PARAMETERS"],
              localKinds: ["DATA", "CONSTANTS"],
              ignorePatterns: {
                DATA: [/^DATA\(/i, /\bBEGIN\s+OF\b/i, /\bEND\s+OF\b/i],
                CONSTANTS: [/\bBEGIN\s+OF\b/i, /\bEND\s+OF\b/i],
              },
            },
            writes: {
              rules: [
                { regex: new RegExp(String.raw`^(${IDENT_PATH})\s*=\s*`) },
                { regex: new RegExp(String.raw`^CLEAR\s+(${IDENT_PATH})\b`, "i") },
                { whenStartsWith: "APPEND", regex: new RegExp(String.raw`\bTO\b\s+(${IDENT_PATH})\b`, "i") },
                { whenStartsWith: "CONCATENATE", regex: new RegExp(String.raw`\bINTO\b\s+(${IDENT_PATH})\b`, "i") },
              ],
            },
            assignments: {
              rules: [{ regex: new RegExp(String.raw`^(${IDENT_PATH})\s*=\s*(.+)$`) }],
            },
            conditionals: {
              rules: [
                { kind: "IF", regex: /^IF\s+(.+)$/i },
                { kind: "ELSEIF", regex: /^ELSEIF\s+(.+)$/i },
              ],
            },
            messages: { enabled: true },
            itabOps: { enabled: true },
          },
        };
      }

      function asRegex(value, flags) {
        if (!value) return null;
        if (value instanceof RegExp) return value;
        if (typeof value === "string") return new RegExp(value, flags || "i");
        return null;
      }

      function regexTest(re, text) {
        if (!re) return false;
        re.lastIndex = 0;
        return re.test(text);
      }

      function regexExec(re, text) {
        if (!re) return null;
        re.lastIndex = 0;
        return re.exec(text);
      }

      function getParserConfig() {
        const base = defaultParserConfig();
        const user = ns.parserConfig;
        if (!user || typeof user !== "object") return base;

        const statements = user.statements && typeof user.statements === "object" ? user.statements : {};
        const decls = statements.declarations && typeof statements.declarations === "object" ? statements.declarations : {};
        const writes = statements.writes && typeof statements.writes === "object" ? statements.writes : {};
        const assignments = statements.assignments && typeof statements.assignments === "object" ? statements.assignments : {};
        const conditionals = statements.conditionals && typeof statements.conditionals === "object" ? statements.conditionals : {};

        return {
          ...base,
          ...user,
          routineBlocks: Array.isArray(user.routineBlocks) ? user.routineBlocks : base.routineBlocks,
          events: { ...base.events, ...(user.events || {}) },
          statements: {
            ...base.statements,
            ...statements,
            calls: Array.isArray(statements.calls) ? statements.calls : base.statements.calls,
            declarations: {
              ...base.statements.declarations,
              ...decls,
              ignorePatterns: { ...base.statements.declarations.ignorePatterns, ...(decls.ignorePatterns || {}) },
            },
            writes: {
              ...base.statements.writes,
              ...writes,
              rules: Array.isArray(writes.rules) ? writes.rules : base.statements.writes.rules,
            },
            assignments: {
              ...base.statements.assignments,
              ...assignments,
              rules: Array.isArray(assignments.rules) ? assignments.rules : base.statements.assignments.rules,
            },
            conditionals: {
              ...base.statements.conditionals,
              ...conditionals,
              rules: Array.isArray(conditionals.rules) ? conditionals.rules : base.statements.conditionals.rules,
            },
          },
        };
      }

      function findRoutineBlocks(lines, cfg) {
        const defs = Array.isArray(cfg?.routineBlocks) ? cfg.routineBlocks : [];
        const blocks = [];
        let i = 0;

        while (i < lines.length) {
          const raw = lines[i] || "";
          if (utils.isFullLineComment(raw)) {
            i++;
            continue;
          }

          const code = utils.stripInlineComment(raw).trim();
          if (!code) {
            i++;
            continue;
          }

          let matchedDef = null;
          for (const def of defs) {
            const startRe = asRegex(def?.start);
            if (startRe && regexTest(startRe, code)) {
              matchedDef = def;
              break;
            }
          }

          if (!matchedDef) {
            i++;
            continue;
          }

          const startLine = i + 1;
          const endRe = asRegex(matchedDef.end);
          const endRequiresPeriod = matchedDef.endRequiresPeriod !== false;

          let j = i;
          while (j < lines.length) {
            const raw2 = lines[j] || "";
            if (utils.isFullLineComment(raw2)) {
              j++;
              continue;
            }
            const code2 = utils.stripInlineComment(raw2).trim();
            if (endRe && regexTest(endRe, code2) && (!endRequiresPeriod || code2.includes("."))) break;
            j++;
          }

          const endLine = Math.min(lines.length, j + 1);
          blocks.push({
            kind: String(matchedDef.kind || "ROUTINE").trim().toUpperCase(),
            startLine,
            endLine,
            def: matchedDef,
          });
          i = endLine;
        }

        return blocks;
      }

      function buildLineMask(lines, blocks) {
        const mask = new Array(lines.length).fill(false);
        for (const b of blocks) {
          for (let ln = b.startLine; ln <= b.endLine; ln++) mask[ln - 1] = true;
        }
        return mask;
      }

      function parseRoutineHeader(blockDef, stmtText, paramDescriptions, headerSourceRef) {
        const statement = utils.normalizeSpaces(utils.stripTrailingPeriod(stmtText));
        const header = blockDef?.header || {};
        const nameRe = asRegex(header.name);
        const m = regexExec(nameRe, statement);
        if (!m) return null;

        const name = m[1];
        const rest = m[2] || "";

        const clauseOrder = Array.isArray(header.clauseOrder) ? header.clauseOrder : [];
        if (clauseOrder.length === 0) return { name, params: [] };

        const u = rest.toUpperCase();
        const indices = clauseOrder
          .map((k) => ({ k, idx: u.search(new RegExp(`\\b${k}\\b`)) }))
          .filter((x) => x.idx >= 0)
          .sort((a, b) => a.idx - b.idx);

        const clauses = {};
        for (let i = 0; i < indices.length; i++) {
          const cur = indices[i];
          const next = indices[i + 1];
          const start = cur.idx;
          const end = next ? next.idx : rest.length;
          clauses[cur.k] = rest.slice(start + cur.k.length, end).trim();
          clauses[cur.k] = clauses[cur.k].replace(/\s+/g, " ").trim();
          if (clauses[cur.k].startsWith(cur.k)) clauses[cur.k] = clauses[cur.k].slice(cur.k.length).trim();
        }

        const ignore = new Set((header.paramIgnoreTokens || []).map((t) => String(t || "").trim().toUpperCase()).filter(Boolean));

        function parseParams(kind, text) {
          const out = [];
          if (!text) return out;

          if (kind === "RAISING") {
            const tokens = text.split(/\s+/).map(utils.cleanIdentifierToken).filter(Boolean);
            for (const t of tokens) {
              const desc = paramDescriptions[String(t).toLowerCase()] || "";
              out.push(new AbapParameter(kind, t, "", desc, headerSourceRef));
            }
            return out;
          }

          const tokens = text.split(/\s+/).filter(Boolean);
          let i = 0;
          while (i < tokens.length) {
            const raw0 = String(tokens[i] || "").trim();
            const rawUpper = utils.cleanIdentifierToken(raw0).toUpperCase();
            if (ignore.has(rawUpper)) {
              i++;
              continue;
            }

            const token = utils.cleanIdentifierToken(utils.unwrapValueToken(raw0));
            if (!utils.isIdentifier(token)) {
              i++;
              continue;
            }

            const pName = token;
            let dataType = "";
            if (i + 2 < tokens.length && /^(TYPE|LIKE)$/i.test(tokens[i + 1])) {
              dataType = utils.cleanIdentifierToken(tokens[i + 2]);
              i += 3;
            } else {
              i += 1;
            }

            const desc = paramDescriptions[String(pName).toLowerCase()] || "";
            out.push(new AbapParameter(kind, pName, dataType, desc, headerSourceRef));
          }
          return out;
        }

        const params = [];
        for (const clause of clauseOrder) {
          const k = String(clause || "").toUpperCase();
          params.push(...parseParams(k, clauses[k]));
        }

        return { name, params };
      }

      function extractDeclInlineDescriptionsByVar(lines, startLine, endLine, declKind) {
        const byLine = doc.extractInlineCommentsByLine ? doc.extractInlineCommentsByLine(lines, startLine, endLine) : {};
        const byVar = {};
        const kindUpper = String(declKind || "").trim().toUpperCase();

        const from = Math.max(1, startLine || 1);
        const to = Math.min(lines.length, endLine || from);

        for (let ln = from; ln <= to; ln++) {
          const c = String(byLine?.[ln] || "").trim();
          if (!c) continue;

          const raw = String(lines[ln - 1] || "");
          if (utils.isFullLineComment(raw)) continue;

          let code = utils.stripInlineComment(raw).trim();
          if (!code) continue;

          const dk = String(declKind || "").trim();
          if (dk) {
            const re = new RegExp(`^${dk}\\b`, "i");
            if (re.test(code)) {
              code = code.replace(re, "").trim();
              if (code.startsWith(":")) code = code.slice(1).trim();
            }
          }

          code = code.replace(/^[,]+/, "").trim();
          if (!code) continue;

          let firstToken = "";
          if (kindUpper === "PARAMETERS") {
            const m = /^([A-Za-z_][A-Za-z0-9_\/]*)/.exec(code);
            firstToken = m ? m[1] : "";
          } else {
            firstToken = utils.cleanIdentifierToken(code.split(/\s+/)[0] || "");
          }
          if (!utils.isIdentifier(firstToken)) continue;

          const key = String(firstToken).toLowerCase();
          if (!(key in byVar)) byVar[key] = c;
        }

        return byVar;
      }

      function parseDataOrConstants(stmt, declKind, descriptionsByVar, leadingDescription, sourceRef, options) {
        const s = utils.normalizeSpaces(utils.stripTrailingPeriod(stmt));
        const ignorePatterns = Array.isArray(options?.ignorePatterns) ? options.ignorePatterns : [];
        const kindUpper = String(declKind || "").trim().toUpperCase();
        for (const p of ignorePatterns) {
          const re = asRegex(p);
          if (re && regexTest(re, s)) return [];
        }

        let body = s.replace(new RegExp(`^${declKind}\\b`, "i"), "").trim();
        if (body.startsWith(":")) body = body.slice(1).trim();

        const parts = utils.splitByCommaOutsideQuotes(body).map((p) => p.trim()).filter(Boolean);
        const out = [];

        for (const p of parts) {
          let variableName = "";
          if (kindUpper === "PARAMETERS") {
            const m = /^([A-Za-z_][A-Za-z0-9_\/]*)/.exec(p);
            variableName = m ? m[1] : "";
          } else {
            const firstToken = utils.cleanIdentifierToken(p.split(/\s+/)[0] || "");
            variableName = firstToken;
          }
          if (!utils.isIdentifier(variableName)) continue;

          let dataType = "";
          if (kindUpper === "PARAMETERS") {
            const typeMatch = /\bTYPE\b\s+([^\s]+)/i.exec(p);
            dataType = typeMatch ? utils.cleanIdentifierToken(typeMatch[1]) : "";
            if (!dataType) {
              const likeMatch = /\bLIKE\b\s+([^\s]+)/i.exec(p);
              dataType = likeMatch ? utils.cleanIdentifierToken(likeMatch[1]) : "";
            }

            let len = "";
            const parenLen = new RegExp(`^${variableName}\\((\\d+)\\)`, "i").exec(p);
            if (parenLen && parenLen[1]) len = String(parenLen[1]);
            if (!len) {
              const lengthMatch = /\bLENGTH\b\s+(\d+)\b/i.exec(p);
              if (lengthMatch && lengthMatch[1]) len = String(lengthMatch[1]);
            }

            if (len) {
              if (dataType) dataType = `${dataType} LENGTH ${len}`;
              else dataType = `c LENGTH ${len}`;
            }
          } else {
            const typeMatch = /\bTYPE\b\s+([^\s]+)/i.exec(p);
            dataType = typeMatch ? utils.cleanIdentifierToken(typeMatch[1]) : "";
          }

          let value = "";
          if (kindUpper === "PARAMETERS") {
            const defaultMatch = /\bDEFAULT\b\s+(.+)$/i.exec(p);
            value = defaultMatch ? defaultMatch[1].trim() : "";
          } else {
            const valueMatch = /\bVALUE\b\s+(.+)$/i.exec(p);
            value = valueMatch ? valueMatch[1].trim() : "";
          }

          const inlineDesc = String(descriptionsByVar?.[String(variableName).toLowerCase()] || "").trim();
          const desc = inlineDesc || (out.length === 0 ? String(leadingDescription || "").trim() : "");

          out.push(new AbapDataDeclaration(declKind, variableName, dataType, value, desc, sourceRef));
        }

        return out;
      }

      function parseBeginOfDeclarationsFromStatement(statement, declKind, originalLines) {
        const out = [];
        const stack = [];
        let removedKindPrefix = false;

        const from = Math.max(1, Number(statement?.startLine || 1));
        const to = Math.min(originalLines.length, Number(statement?.endLine || from));

        for (let ln = from; ln <= to; ln++) {
          const raw = String(originalLines[ln - 1] || "");
          if (utils.isFullLineComment(raw)) continue;

          const parts = utils.splitInlineComment(raw);
          const inlineComment = String(parts.comment || "").trim();
          let codeLine = String(parts.code || "").trim();
          if (!codeLine) continue;

          if (!removedKindPrefix) {
            const re = new RegExp(`^${String(declKind || "").trim()}\\b`, "i");
            if (re.test(codeLine)) {
              codeLine = codeLine.replace(re, "").trim();
              if (codeLine.startsWith(":")) codeLine = codeLine.slice(1).trim();
            }
            removedKindPrefix = true;
          }

          const segments = utils.splitByCommaOutsideQuotes(codeLine);
          const parsed = [];

          for (let idx = 0; idx < segments.length; idx++) {
            let seg = String(segments[idx] || "").trim();
            if (!seg) continue;
            seg = seg.replace(/^[,]+/, "").trim();
            seg = seg.replace(/\.\s*$/, "").trim();
            if (!seg) continue;

            const normalized = utils.normalizeSpaces(seg);
            let m = /^BEGIN OF\s+([A-Za-z_][A-Za-z0-9_\/]*)\b/i.exec(normalized);
            if (m) {
              parsed.push({ kind: "begin", name: m[1], normalized, idx });
              continue;
            }

            m = /^END OF\s+([A-Za-z_][A-Za-z0-9_\/]*)\b/i.exec(normalized);
            if (m) {
              parsed.push({ kind: "end", name: m[1], normalized, idx });
              continue;
            }

            if (/^INCLUDE\b/i.test(normalized)) continue;

            const first = utils.cleanIdentifierToken(normalized.split(/\s+/)[0] || "");
            if (!utils.isIdentifier(first)) continue;
            if (/^(BEGIN|END|OF)$/i.test(first)) continue;

            const typeMatch = /\bTYPE\b\s+([^\s]+)/i.exec(normalized);
            let dataType = typeMatch ? utils.cleanIdentifierToken(typeMatch[1]) : "";
            if (!dataType) {
              const likeMatch = /\bLIKE\b\s+([^\s]+)/i.exec(normalized);
              dataType = likeMatch ? utils.cleanIdentifierToken(likeMatch[1]) : "";
            }

            const valueMatch = /\bVALUE\b\s+(.+)$/i.exec(normalized);
            const value = valueMatch ? String(valueMatch[1] || "").trim() : "";

            parsed.push({ kind: "field", name: first, dataType, value, normalized, idx });
          }

          if (inlineComment) {
            for (let i = parsed.length - 1; i >= 0; i--) {
              if (parsed[i].kind === "begin" || parsed[i].kind === "field") {
                parsed[i].inlineDesc = inlineComment;
                break;
              }
            }
          }

          for (const seg of parsed) {
            if (seg.kind === "begin") {
              const parent = stack.length ? stack[stack.length - 1] : null;
              const fullName = parent ? `${parent.fullName}-${seg.name}` : seg.name;
              const leading = !seg.inlineDesc ? doc.extractLeadingComment(originalLines, ln).description : "";
              const desc = String(seg.inlineDesc || leading || "").trim();
              out.push(new AbapDataDeclaration(declKind, fullName, "", "", desc, new SourceRef(ln, ln)));
              stack.push({ name: seg.name, fullName });
              continue;
            }

            if (seg.kind === "end") {
              const target = String(seg.name || "").toLowerCase();
              if (stack.length && String(stack[stack.length - 1].name || "").toLowerCase() === target) {
                stack.pop();
                continue;
              }

              let matchIdx = -1;
              for (let i = stack.length - 1; i >= 0; i--) {
                if (String(stack[i].name || "").toLowerCase() === target) {
                  matchIdx = i;
                  break;
                }
              }
              if (matchIdx >= 0) stack.splice(matchIdx);
              else if (stack.length) stack.pop();
              continue;
            }

            if (seg.kind === "field") {
              const parent = stack.length ? stack[stack.length - 1] : null;
              const fullName = parent ? `${parent.fullName}-${seg.name}` : seg.name;
              const leading = !seg.inlineDesc ? doc.extractLeadingComment(originalLines, ln).description : "";
              const desc = String(seg.inlineDesc || leading || "").trim();
              out.push(new AbapDataDeclaration(declKind, fullName, seg.dataType || "", seg.value || "", desc, new SourceRef(ln, ln)));
            }
          }
        }

        return out;
      }

      function makeTypeDefKey(scopeKey, typeName) {
        const sk = String(scopeKey || "").trim();
        const tn = String(typeName || "")
          .trim()
          .toLowerCase();
        if (!sk || !tn) return "";
        return `${sk}|${tn}`;
      }

      function parseTypesBeginOfFromStatement(statement, scopeKey, originalLines) {
        const stack = [];
        let removedKindPrefix = false;

        const from = Math.max(1, Number(statement?.startLine || 1));
        const to = Math.min(originalLines.length, Number(statement?.endLine || from));

        let typeName = "";
        let typeDesc = "";
        const fields = new Map();

        for (let ln = from; ln <= to; ln++) {
          const raw = String(originalLines[ln - 1] || "");
          if (utils.isFullLineComment(raw)) continue;

          const parts = utils.splitInlineComment(raw);
          const inlineComment = String(parts.comment || "").trim();
          let codeLine = String(parts.code || "").trim();
          if (!codeLine) continue;

          if (!removedKindPrefix) {
            const re = /^TYPES\b/i;
            if (re.test(codeLine)) {
              codeLine = codeLine.replace(re, "").trim();
              if (codeLine.startsWith(":")) codeLine = codeLine.slice(1).trim();
            }
            removedKindPrefix = true;
          }

          const segments = utils.splitByCommaOutsideQuotes(codeLine);
          const parsed = [];

          for (let idx = 0; idx < segments.length; idx++) {
            let seg = String(segments[idx] || "").trim();
            if (!seg) continue;
            seg = seg.replace(/^[,]+/, "").trim();
            seg = seg.replace(/\.\s*$/, "").trim();
            if (!seg) continue;

            const normalized = utils.normalizeSpaces(seg);
            let m = /^BEGIN OF\s+([A-Za-z_][A-Za-z0-9_\/]*)\b/i.exec(normalized);
            if (m) {
              parsed.push({ kind: "begin", name: m[1], normalized, idx });
              continue;
            }

            m = /^END OF\s+([A-Za-z_][A-Za-z0-9_\/]*)\b/i.exec(normalized);
            if (m) {
              parsed.push({ kind: "end", name: m[1], normalized, idx });
              continue;
            }

            if (/^INCLUDE\b/i.test(normalized)) continue;

            const first = utils.cleanIdentifierToken(normalized.split(/\s+/)[0] || "");
            if (!utils.isIdentifier(first)) continue;
            if (/^(BEGIN|END|OF)$/i.test(first)) continue;

            const typeMatch = /\bTYPE\b\s+([^\s]+)/i.exec(normalized);
            let dataType = typeMatch ? utils.cleanIdentifierToken(typeMatch[1]) : "";
            if (!dataType) {
              const likeMatch = /\bLIKE\b\s+([^\s]+)/i.exec(normalized);
              dataType = likeMatch ? utils.cleanIdentifierToken(likeMatch[1]) : "";
            }

            parsed.push({ kind: "field", name: first, dataType, normalized, idx });
          }

          if (inlineComment) {
            for (let i = parsed.length - 1; i >= 0; i--) {
              if (parsed[i].kind === "begin" || parsed[i].kind === "field") {
                parsed[i].inlineDesc = inlineComment;
                break;
              }
            }
          }

          for (const seg of parsed) {
            if (seg.kind === "begin") {
              if (!typeName) {
                typeName = seg.name;
                const leading = !seg.inlineDesc ? doc.extractLeadingComment(originalLines, ln).description : "";
                typeDesc = String(seg.inlineDesc || leading || "").trim();
                stack.push({ name: seg.name, path: "" });
                continue;
              }

              const parent = stack.length ? stack[stack.length - 1] : null;
              const parentPath = parent ? String(parent.path || "") : "";
              const path = parentPath ? `${parentPath}-${seg.name}` : seg.name;
              const leading = !seg.inlineDesc ? doc.extractLeadingComment(originalLines, ln).description : "";
              const desc = String(seg.inlineDesc || leading || "").trim();
              fields.set(path.toLowerCase(), new AbapDataDeclaration("TYPES", path, "", "", desc, new SourceRef(ln, ln)));
              stack.push({ name: seg.name, path });
              continue;
            }

            if (seg.kind === "end") {
              const target = String(seg.name || "").toLowerCase();
              if (stack.length && String(stack[stack.length - 1].name || "").toLowerCase() === target) {
                stack.pop();
                continue;
              }

              let matchIdx = -1;
              for (let i = stack.length - 1; i >= 0; i--) {
                if (String(stack[i].name || "").toLowerCase() === target) {
                  matchIdx = i;
                  break;
                }
              }
              if (matchIdx >= 0) stack.splice(matchIdx);
              else if (stack.length) stack.pop();
              continue;
            }

            if (seg.kind === "field") {
              const parent = stack.length ? stack[stack.length - 1] : null;
              const parentPath = parent ? String(parent.path || "") : "";
              const path = parentPath ? `${parentPath}-${seg.name}` : seg.name;
              const leading = !seg.inlineDesc ? doc.extractLeadingComment(originalLines, ln).description : "";
              const desc = String(seg.inlineDesc || leading || "").trim();
              fields.set(path.toLowerCase(), new AbapDataDeclaration("TYPES", path, seg.dataType || "", "", desc, new SourceRef(ln, ln)));
            }
          }
        }

        if (!typeName) return null;

        return {
          scopeKey: String(scopeKey || "").trim() || "PROGRAM",
          name: typeName,
          description: typeDesc,
          sourceRef: new SourceRef(from, to),
          fields,
        };
      }

      function parseClauseArgs(rest, clauseOrder) {
        const args = { tables: [], using: [], changing: [] };
        const keys = Array.isArray(clauseOrder) ? clauseOrder.map((k) => String(k || "").toUpperCase()) : [];
        if (!rest || keys.length === 0) return args;

        const u = rest.toUpperCase();
        const indices = keys
          .map((k) => ({ k, idx: u.search(new RegExp(`\\b${k}\\b`)) }))
          .filter((x) => x.idx >= 0)
          .sort((a, b) => a.idx - b.idx);

        const clauses = {};
        for (let i = 0; i < indices.length; i++) {
          const cur = indices[i];
          const next = indices[i + 1];
          const start = cur.idx;
          const end = next ? next.idx : rest.length;
          clauses[cur.k] = rest.slice(start + cur.k.length, end).trim();
          clauses[cur.k] = clauses[cur.k].replace(/\s+/g, " ").trim();
          if (clauses[cur.k].startsWith(cur.k)) clauses[cur.k] = clauses[cur.k].slice(cur.k.length).trim();
        }

        function tokensOf(text) {
          if (!text) return [];
          return text
            .split(/\s+/)
            .map((t) => utils.cleanIdentifierToken(t))
            .filter(Boolean);
        }

        if (clauses.TABLES != null) args.tables = tokensOf(clauses.TABLES);
        if (clauses.USING != null) args.using = tokensOf(clauses.USING);
        if (clauses.CHANGING != null) args.changing = tokensOf(clauses.CHANGING);
        return args;
      }

      function parseCallByRule(stmtText, rule) {
        const statement = utils.normalizeSpaces(utils.stripTrailingPeriod(stmtText));
        const pattern = asRegex(rule?.pattern);
        const m = regexExec(pattern, statement);
        if (!m) return null;

        const target = String(m[1] || "").trim();
        if (!target) return null;

        const rest = String(m[2] || "").trim();
        const args = parseClauseArgs(rest, rule?.clauseOrder);
        return { target, args };
      }

      function parseWriteTargets(stmtText, cfg) {
        const s = utils.normalizeSpaces(utils.stripTrailingPeriod(stmtText));
        const u = s.toUpperCase();

        const out = [];
        const rules = cfg?.statements?.writes?.rules || [];

        for (const rule of rules) {
          const when = String(rule?.whenStartsWith || "").trim();
          if (when) {
            const w = when.toUpperCase();
            if (!(u === w || u.startsWith(`${w} `))) continue;
          }

          const re = asRegex(rule?.regex);
          const m = regexExec(re, s);
          if (m && m[1]) out.push(m[1]);
        }

        return out;
      }

      function eventNameFromStatement(stmtText, cfg) {
        const t = utils.normalizeSpaces(utils.stripTrailingPeriod(stmtText));
        const u = t.toUpperCase();

        const exact = Array.isArray(cfg?.events?.exact) ? cfg.events.exact : [];
        for (const e of exact) {
          if (u === String(e || "").trim().toUpperCase()) return t;
        }

        const prefixes = Array.isArray(cfg?.events?.prefixes) ? cfg.events.prefixes : [];
        for (const p of prefixes) {
          const pu = String(p || "").trim().toUpperCase();
          if (pu && u.startsWith(pu)) return t;
        }

        return null;
      }

      function parseRoutineStatement(model, routine, statement, originalLines, cfg) {
        const text = statement.text;
        const normalized = utils.normalizeSpaces(utils.stripTrailingPeriod(text));
        if (!normalized) return;

        const src = new SourceRef(statement.startLine, statement.endLine);

        if (/^TYPES\b/i.test(normalized) && /\bBEGIN\s+OF\b/i.test(normalized)) {
          const scopeKey = routine?.key || "PROGRAM";
          const typeDef = parseTypesBeginOfFromStatement(statement, scopeKey, originalLines);
          if (typeDef && typeDef.name) {
            const key = makeTypeDefKey(typeDef.scopeKey, typeDef.name);
            if (key) model.typeDefs.set(key, typeDef);
          }
          return;
        }

        const callRules = Array.isArray(cfg?.statements?.calls) ? cfg.statements.calls : [];
        for (const rule of callRules) {
          const parsed = parseCallByRule(normalized, rule);
          if (!parsed) continue;

          const calleeKind = String(rule?.calleeKind || "FORM").trim().toUpperCase();
          const callee = model.ensureRoutine(calleeKind, parsed.target);
          const edge = new AbapCallEdge(routine.key, callee.key, parsed.target, parsed.args, src);
          model.addEdge(edge);
          return;
        }

        const declCfg = cfg?.statements?.declarations || {};
        const localKinds = Array.isArray(declCfg.localKinds) ? declCfg.localKinds : [];

        for (const kind of localKinds) {
          const dk = String(kind || "").trim().toUpperCase();
          if (!dk) continue;
          if (!new RegExp(`^${dk}\\b`, "i").test(normalized)) continue;

          if ((dk === "DATA" || dk === "CONSTANTS") && /\bBEGIN\s+OF\b/i.test(normalized)) {
            const decls = parseBeginOfDeclarationsFromStatement(statement, dk, originalLines);
            if (dk === "DATA") routine.localData.push(...decls);
            else if (dk === "CONSTANTS") routine.localConstants.push(...decls);
            return;
          }

          const leadingDoc = doc.extractLeadingComment(originalLines, statement.startLine);
          const inlineDescriptionsByVar = extractDeclInlineDescriptionsByVar(originalLines, statement.startLine, statement.endLine, dk);

          const decls = parseDataOrConstants(normalized, dk, inlineDescriptionsByVar, leadingDoc.description, src, {
            ignorePatterns: declCfg.ignorePatterns?.[dk] || [],
            supportsValue: dk === "CONSTANTS",
          });

          if (dk === "DATA") routine.localData.push(...decls);
          else if (dk === "CONSTANTS") routine.localConstants.push(...decls);
          return;
        }

        const registry = ns.abapObjects?.getRegistry?.() || null;
        if (registry && typeof registry.parseStatementItems === "function") {
          const items = registry.parseStatementItems(model, routine, normalized, src, cfg);
          if (items.length) {
            if (!Array.isArray(routine.statementItems)) routine.statementItems = [];
            for (const it of items) routine.statementItems.push(it);

            for (const it of items) {
              if (it.objectId === "assignment" && it.payload) routine.assignments.push(it.payload);
              if (it.objectId === "if" && it.payload) routine.ifStatements.push(it.payload);
              if (it.objectId === "message" && it.payload) routine.messages.push(it.payload);
              if (it.objectId === "itabOp" && it.payload) routine.itabOps.push(it.payload);
            }

            const shouldContinue = items.some((x) => x && x.continueAfterMatch);
            if (!shouldContinue) return;
          }
        }

        const writes = parseWriteTargets(normalized, cfg);
        for (const v of writes) routine.writes.push(new AbapWrite(v, normalized, src));
      }

      function parseRoutineBlocks(model, lines, blocks, cfg) {
        for (const block of blocks) {
          const statements = utils.collectStatements(lines, block.startLine, block.endLine);
          if (statements.length === 0) continue;

          const header = statements[0];
          const headerRef = new SourceRef(block.startLine, header.endLine);
          const leadingDoc = doc.extractLeadingComment(lines, block.startLine);

          const headerInfo = parseRoutineHeader(block.def, header.text, leadingDoc.paramDescriptions, headerRef);
          if (!headerInfo) continue;

          const routine = model.defineRoutine(block.kind, headerInfo.name, new SourceRef(block.startLine, block.endLine), leadingDoc.description, headerInfo.params);

          for (let i = 1; i < statements.length; i++) {
            const st = statements[i];
            const normalized = utils.normalizeSpaces(utils.stripTrailingPeriod(st.text));
            const endRe = asRegex(block.def?.end);
            if (endRe && regexTest(endRe, normalized)) break;
            parseRoutineStatement(model, routine, st, lines, cfg);
          }
        }
      }

      function parseTopLevel(model, lines, routineMask, cfg) {
        const masked = lines.map((l, idx) => (routineMask[idx] ? "" : l));
        const statements = utils.collectStatements(masked, 1, masked.length);

        let currentEvent = null;
        let lastStmt = null;

        for (const st of statements) {
          lastStmt = st;
          const normalized = utils.normalizeSpaces(utils.stripTrailingPeriod(st.text));
          if (!normalized) continue;

          const ev = eventNameFromStatement(normalized, cfg);
          if (ev) {
            currentEvent = model.ensureEvent(ev, new SourceRef(st.startLine, st.endLine));
            continue;
          }

          if (!currentEvent) {
            const src = new SourceRef(st.startLine, st.endLine);

            if (/^TYPES\b/i.test(normalized) && /\bBEGIN\s+OF\b/i.test(normalized)) {
              const typeDef = parseTypesBeginOfFromStatement(st, "PROGRAM", lines);
              if (typeDef && typeDef.name) {
                const key = makeTypeDefKey(typeDef.scopeKey, typeDef.name);
                if (key) model.typeDefs.set(key, typeDef);
              }
              continue;
            }

            const declCfg = cfg?.statements?.declarations || {};
            const globalKinds = Array.isArray(declCfg.globalKinds) ? declCfg.globalKinds : [];

            for (const kind of globalKinds) {
              const dk = String(kind || "").trim().toUpperCase();
              if (!dk) continue;
              if (!new RegExp(`^${dk}\\b`, "i").test(normalized)) continue;

              if ((dk === "DATA" || dk === "CONSTANTS") && /\bBEGIN\s+OF\b/i.test(normalized)) {
                const decls = parseBeginOfDeclarationsFromStatement(st, dk, lines);
                if (dk === "DATA") model.globalData.push(...decls);
                else if (dk === "CONSTANTS") model.globalConstants.push(...decls);
                break;
              }

              const leadingDoc = doc.extractLeadingComment(lines, st.startLine);
              const inlineDescriptionsByVar = extractDeclInlineDescriptionsByVar(lines, st.startLine, st.endLine, dk);

              const decls = parseDataOrConstants(normalized, dk, inlineDescriptionsByVar, leadingDoc.description, src, {
                ignorePatterns: declCfg.ignorePatterns?.[dk] || [],
                supportsValue: dk === "CONSTANTS",
              });

              if (dk === "DATA") model.globalData.push(...decls);
              else if (dk === "CONSTANTS") model.globalConstants.push(...decls);
              else if (dk === "PARAMETERS") model.globalData.push(...decls);
              break;
            }

            continue;
          }

          parseRoutineStatement(model, currentEvent, st, lines, cfg);
          if (currentEvent.sourceRef) currentEvent.sourceRef.endLine = st.endLine;
        }

        if (currentEvent && currentEvent.sourceRef && lastStmt) {
          currentEvent.sourceRef.endLine = Math.max(currentEvent.sourceRef.endLine || 0, lastStmt.endLine);
        }
      }

      function resolveTypeDef(model, scopeKey, typeName) {
        const sk = String(scopeKey || "").trim() || "PROGRAM";
        const tn = String(typeName || "").trim();
        if (!sk || !tn) return null;

        const localKey = makeTypeDefKey(sk, tn);
        if (localKey && model?.typeDefs?.has?.(localKey)) return model.typeDefs.get(localKey) || null;

        const globalKey = makeTypeDefKey("PROGRAM", tn);
        if (globalKey && model?.typeDefs?.has?.(globalKey)) return model.typeDefs.get(globalKey) || null;

        return null;
      }

      function expandTypedStructDeclsInList(model, declList, scopeKey) {
        const list = Array.isArray(declList) ? declList : [];
        if (!list.length) return;

        const existing = new Set(
          list
            .map((d) => String(d?.variableName || "").toLowerCase())
            .map((s) => s.trim())
            .filter(Boolean),
        );

        const queue = list.slice();
        for (let qi = 0; qi < queue.length; qi++) {
          const decl = queue[qi] || null;
          const typeName = String(decl?.dataType || "").trim();
          if (!typeName) continue;
          if (!/^[A-Za-z_][A-Za-z0-9_\/]*$/.test(typeName)) continue;

          const typeDef = resolveTypeDef(model, scopeKey, typeName);
          if (!typeDef || !typeDef.fields || typeof typeDef.fields.values !== "function") continue;

          for (const field of typeDef.fields.values()) {
            const fieldPath = String(field?.variableName || "").trim();
            if (!fieldPath) continue;

            const baseName = String(decl?.variableName || "").trim();
            if (!baseName) continue;

            const virtualName = `${baseName}-${fieldPath}`;
            const virtualLower = virtualName.toLowerCase();
            if (existing.has(virtualLower)) continue;

            const virtualDecl = new AbapDataDeclaration(
              decl.declKind,
              virtualName,
              String(field?.dataType || "").trim(),
              "",
              String(field?.description || "").trim(),
              field?.sourceRef || null,
            );
            virtualDecl.isVirtual = true;
            virtualDecl.virtualOrigin = {
              kind: "typeField",
              typeScopeKey: String(typeDef.scopeKey || "").trim() || "PROGRAM",
              typeName: String(typeDef.name || "").trim(),
              fieldPath,
            };

            list.push(virtualDecl);
            queue.push(virtualDecl);
            existing.add(virtualLower);
          }
        }
      }

      function expandTypedStructFields(model) {
        if (!model || !model.typeDefs || !model.nodes) return;

        expandTypedStructDeclsInList(model, model.globalData, "PROGRAM");
        expandTypedStructDeclsInList(model, model.globalConstants, "PROGRAM");

        for (const node of model.nodes.values()) {
          const scopeKey = String(node?.key || "").trim();
          if (!scopeKey) continue;
          expandTypedStructDeclsInList(model, node.localData, scopeKey);
          expandTypedStructDeclsInList(model, node.localConstants, scopeKey);
        }
      }

      function parseProgram(text) {
        const normalized = utils.normalizeNewlines(text);
        const lines = utils.splitLines(normalized);
        const offsets = utils.computeLineStartOffsets(normalized);
        const model = new ProgramModel(normalized, lines, offsets);

        const cfg = getParserConfig();
        const routineBlocks = findRoutineBlocks(lines, cfg);
        const routineMask = buildLineMask(lines, routineBlocks);

        parseRoutineBlocks(model, lines, routineBlocks, cfg);
        parseTopLevel(model, lines, routineMask, cfg);
        expandTypedStructFields(model);

        ns.graph.build(model);
        return model;
      }

      ns.parser = { parseProgram };
    })(window.AbapFlow);

    </script>
        <script>
    // js/sample.js
    (function (ns) {
      "use strict";

      // Sample ABAP code for both `index.html` and `demo.html`.
      // Goal: have enough PERFORM patterns to test template conversion:
      // - A call to `main` with 6 USING params
      // - A call to `demo_all` with TABLES/USING/CHANGING + RAISING in signature
      // - Cycles (mutual + self) for diagram/trace testing

      ns.sampleCode = `REPORT zabap_flow_demo.

    DATA gv_count TYPE i.
    DATA gv_text  TYPE string.
    DATA gt_log   TYPE TABLE OF string.

    * Global config (BEGIN OF struct)
    DATA: BEGIN OF gs_conf,
            counter TYPE i, " Counter
            title   TYPE string,
            BEGIN OF meta, " Meta
              user  TYPE syuname, " User
              depth TYPE i,
            END OF meta,
          END OF gs_conf.

    * Typed config (TYPES BEGIN OF struct)
    TYPES: BEGIN OF ty_conf,
             counter TYPE i, " Counter
             title   TYPE string, " Title
             flag    TYPE abap_bool,
             BEGIN OF meta, " Meta
               user  TYPE syuname, " User
               depth TYPE i, " Depth
             END OF meta,
           END OF ty_conf.

    DATA gs_typed TYPE ty_conf. " Typed config

    * Constants struct (BEGIN OF)
    CONSTANTS: BEGIN OF gc_labels,
                 ok     TYPE string VALUE 'OK', " OK label
                 cancel TYPE string VALUE 'CANCEL',
               END OF gc_labels.

    * Selection screen parameters (demo)
    PARAMETERS p_user TYPE syuname DEFAULT sy-uname. " Current user
    PARAMETERS p_text(10) TYPE c. " Text (len via parentheses)
    PARAMETERS p_len LENGTH 5. " Len-only (defaults to c LENGTH 5)

    PARAMETERS: p_a TYPE i DEFAULT 1, " A
                p_b TYPE i. " B

    START-OF-SELECTION.
      gs_conf-meta-user = p_user.
      gs_conf-title = p_text.
      gs_conf-meta-depth = p_a + p_b.
      gs_conf-counter = gs_conf-meta-depth.

      gs_typed-counter = gs_conf-counter.
      gs_typed-title = gs_conf-title.
      gs_typed-flag = abap_true.
      gs_typed-meta-user = gs_conf-meta-user.
      gs_typed-meta-depth = gs_conf-meta-depth.

      PERFORM main USING p_user p_text abap_true abap_true abap_true gs_conf-meta-depth
                  CHANGING gv_count gv_text.

    *&--------------------------------------------------------------------*
    *&    Form  MAIN
    *&--------------------------------------------------------------------*
    *  --> iv_user    User name
    *  --> iv_in      Input string (expects numeric for demo_all)
    *  --> iv_demo    Run demo_all (TABLES/USING/CHANGING/RAISING)
    *  --> iv_cycle   Run mutual recursion test
    *  --> iv_self    Run self recursion test
    *  --> iv_maxd    Max recursion depth
    *  <-- cv_count   Counter
    *  <-- cv_text    Output text
    *&--------------------------------------------------------------------*
    FORM main
      USING
        iv_user  TYPE syuname
        iv_in    TYPE string
        iv_demo  TYPE abap_bool
        iv_cycle TYPE abap_bool
        iv_self  TYPE abap_bool
        iv_maxd  TYPE i
      CHANGING
        cv_count TYPE i
        cv_text  TYPE string.

      DATA lv_a TYPE i VALUE 0.
      DATA lv_b TYPE string.

      TYPES: BEGIN OF ty_local,
               item_1 TYPE i, " Local item 1
               BEGIN OF meta, " Local meta
                 depth TYPE i, " Local depth
               END OF meta,
             END OF ty_local.

      DATA ls_local_typed TYPE ty_local. " Local typed struct

      * Local context struct
      DATA: BEGIN OF ls_ctx,
              item_1 TYPE i, " Item desc 1
              text   TYPE string,
              BEGIN OF meta, " Meta
                user TYPE syuname, " User
              END OF meta,
            END OF ls_ctx.

      *  su
      DATA lv_next_depth TYPE i.
      DATA lv_msg        TYPE string.     " Message

      lv_a = p_a + p_b.
      lv_b = p_text.
      lv_msg = p_len.

      ls_ctx-item_1 = lv_a.
      ls_ctx-text = lv_b.
      ls_ctx-meta-user = iv_user.

      ls_local_typed-item_1 = ls_ctx-item_1.
      ls_local_typed-meta-depth = iv_maxd.

      gs_conf-counter = ls_ctx-item_1.
      gs_conf-title = ls_ctx-text.
      gs_conf-meta-user = ls_ctx-meta-user.
      gs_conf-counter = gs_conf-counter + 1.

      gs_typed-counter = gs_conf-counter.
      gs_typed-title = gs_conf-title.
      gs_typed-flag = iv_demo.
      gs_typed-meta-user = gs_conf-meta-user.
      gs_typed-meta-depth = gs_conf-meta-depth + 1.

      DATA: lv_next_depth2 TYPE i,         "  su
            lv_msg2        TYPE string.    " Message

      IF ls_ctx-item_1 = 0 AND lv_msg IS INITIAL OR gs_conf-meta-user IS INITIAL.
        cv_count = cv_count.
      ENDIF.

      cv_count = cv_count + 1.

      PERFORM step_a USING ls_ctx-item_1 iv_maxd CHANGING cv_count.
      PERFORM step_b USING ls_local_typed-meta-depth CHANGING lv_b.
      PERFORM pass_changing CHANGING lv_b.

      MESSAGE s001(zmsg) WITH gs_conf-meta-user gs_typed-counter INTO lv_msg DISPLAY LIKE 'I'.
      MESSAGE |Hello { iv_user }|.

      CONCATENATE lv_b gc_labels-ok INTO lv_b.

      READ TABLE gt_log WITH KEY table_line = lv_b INTO lv_msg BINARY SEARCH.
      COLLECT lv_b INTO gt_log.
      MODIFY gt_log FROM lv_b INDEX 1.
      DELETE gt_log WHERE table_line = lv_b.

      cv_text = lv_b.

      IF iv_demo = abap_true.
        TRY.
            PERFORM demo_all
              TABLES   gt_log
              USING    iv_in
              CHANGING gv_text.
          CATCH cx_sy_conversion_no_number.
            " ignore for demo
        ENDTRY.
      ENDIF.

      IF iv_cycle = abap_true.
        PERFORM step_cycle_1 USING 1 iv_maxd.
      ENDIF.

      IF iv_self = abap_true.
        PERFORM self_call USING 1 iv_maxd.
      ENDIF.

    ENDFORM.

    *&--------------------------------------------------------------------*
    *&    Form  STEP_A
    *&--------------------------------------------------------------------*
    *  --> iv_in     Input value
    *  --> iv_maxd   Max depth (forwarded to step_c)
    *  <-- cv_count  Counter (CHANGING)
    *&--------------------------------------------------------------------*
    FORM step_a
      USING
        iv_in   TYPE i
        iv_maxd TYPE i
      CHANGING
        cv_count TYPE i.

      cv_count = cv_count + 1.
      PERFORM step_c USING iv_maxd CHANGING cv_count.

    ENDFORM.

    *&--------------------------------------------------------------------*
    *&    Form  STEP_B
    *&--------------------------------------------------------------------*
    *  --> iv_in     Input value
    *  <-- cv_out    Output text (CHANGING)
    *&--------------------------------------------------------------------*
    FORM step_b
      USING
        iv_in TYPE i
      CHANGING
        cv_out TYPE string.

      cv_out = |step_b: { iv_in }|.
      PERFORM log_msg USING cv_out.

    ENDFORM.

    *&--------------------------------------------------------------------*
    *&    Form  STEP_C
    *&--------------------------------------------------------------------*
    *  --> iv_maxd   Max depth
    *  <-- cv_count  Counter
    *&--------------------------------------------------------------------*
    FORM step_c
      USING
        iv_maxd TYPE i
      CHANGING
        cv_count TYPE i.

      cv_count = cv_count + 1.
      PERFORM step_cycle_2 USING 1 iv_maxd.

    ENDFORM.

    *&--------------------------------------------------------------------*
    *&    Form  PASS_CHANGING
    *&--------------------------------------------------------------------*
    *  <-> cv_text  Text passed through multiple levels
    *&--------------------------------------------------------------------*
    FORM pass_changing
      CHANGING
        cv_text TYPE string.

      PERFORM deeper_change CHANGING cv_text.

    ENDFORM.

    *&--------------------------------------------------------------------*
    *&    Form  DEEPER_CHANGE
    *&--------------------------------------------------------------------*
    *  <-> cv_text  Text to be modified
    *&--------------------------------------------------------------------*
    FORM deeper_change
      CHANGING
        cv_text TYPE string.

      CONCATENATE cv_text '->deeper' INTO cv_text.
      PERFORM log_msg USING cv_text.

    ENDFORM.

    *&--------------------------------------------------------------------*
    *&    Form  STEP_CYCLE_1
    *&--------------------------------------------------------------------*
    *  --> iv_depth  Current recursion depth
    *  --> iv_maxd   Max recursion depth
    *&--------------------------------------------------------------------*
    FORM step_cycle_1
      USING
        iv_depth TYPE i
        iv_maxd  TYPE i.

      DATA lv_next_depth TYPE i.
      DATA lv_msg        TYPE string.

      IF iv_depth >= iv_maxd.
        RETURN.
      ENDIF.

      lv_msg = |cycle_1 depth={ iv_depth } max={ iv_maxd }|.
      PERFORM log_msg USING lv_msg.

      lv_next_depth = iv_depth + 1.
      PERFORM step_cycle_2 USING lv_next_depth iv_maxd.

    ENDFORM.

    *&--------------------------------------------------------------------*
    *&    Form  STEP_CYCLE_2
    *&--------------------------------------------------------------------*
    *  --> iv_depth  Current recursion depth
    *  --> iv_maxd   Max recursion depth
    *&--------------------------------------------------------------------*
    FORM step_cycle_2
      USING
        iv_depth TYPE i
        iv_maxd  TYPE i.

      DATA lv_next_depth TYPE i.
      DATA lv_msg        TYPE string.

      IF iv_depth >= iv_maxd.
        RETURN.
      ENDIF.

      lv_msg = |cycle_2 depth={ iv_depth } max={ iv_maxd }|.
      PERFORM log_msg USING lv_msg.

      lv_next_depth = iv_depth + 1.
      PERFORM step_cycle_1 USING lv_next_depth iv_maxd.

    ENDFORM.

    *&--------------------------------------------------------------------*
    *&    Form  SELF_CALL
    *&--------------------------------------------------------------------*
    *  --> iv_depth  Current recursion depth
    *  --> iv_maxd   Max recursion depth
    *&--------------------------------------------------------------------*
    FORM self_call
      USING
        iv_depth TYPE i
        iv_maxd  TYPE i.

      DATA lv_next_depth TYPE i.
      DATA lv_msg        TYPE string.

      IF iv_depth >= iv_maxd.
        RETURN.
      ENDIF.

      lv_msg = |self_call depth={ iv_depth } max={ iv_maxd }|.
      PERFORM log_msg USING lv_msg.

      lv_next_depth = iv_depth + 1.
      PERFORM self_call USING lv_next_depth iv_maxd.

    ENDFORM.

    *&--------------------------------------------------------------------*
    *&    Form  LOG_MSG
    *&--------------------------------------------------------------------*
    *  --> iv_msg   Message to append to global log
    *&--------------------------------------------------------------------*
    FORM log_msg
      USING
        iv_msg TYPE string.

      APPEND iv_msg TO gt_log.

    ENDFORM.

    *&--------------------------------------------------------------------*
    *&    Form  DEMO_ALL
    *&--------------------------------------------------------------------*
    *  --> pt_log   Log table
    *  --> iv_in    Input string (expects numeric)
    *  <-- cv_text  Output text
    *&--------------------------------------------------------------------*
    FORM demo_all
      TABLES
        pt_log TYPE STANDARD TABLE
      USING
        iv_in  TYPE string
      CHANGING
        cv_text TYPE string
      RAISING
        cx_sy_conversion_no_number.

      DATA lv_num TYPE i.
      lv_num = iv_in.

      MESSAGE e001(zmsg) WITH iv_in RAISING cx_sy_conversion_no_number.

      cv_text = |Converted: { lv_num }|.
      APPEND cv_text TO pt_log.
      PERFORM log_msg USING cv_text.

    ENDFORM.
    `;
    })(window.AbapFlow);

    </script>
        <script>
    // js/table_renderer.js
    (function (ns) {
      "use strict";

      function normalizeAddress(addr) {
        const s = String(addr || "").trim().toUpperCase();
        const m = /^([A-Z]+)(\d+)$/.exec(s);
        if (!m) return "";
        return `${m[1]}${Number(m[2])}`;
      }

      function colToIndex(colLetters) {
        const s = String(colLetters || "").trim().toUpperCase();
        if (!/^[A-Z]+$/.test(s)) return 0;
        let n = 0;
        for (let i = 0; i < s.length; i++) {
          n = n * 26 + (s.charCodeAt(i) - 64);
        }
        return n;
      }

      function indexToCol(index1) {
        let n = Number(index1);
        if (!Number.isFinite(n) || n <= 0) return "";
        n = Math.floor(n);
        let s = "";
        while (n > 0) {
          const rem = (n - 1) % 26;
          s = String.fromCharCode(65 + rem) + s;
          n = Math.floor((n - 1) / 26);
        }
        return s;
      }

      function parseAddress(addr) {
        const s = String(addr || "").trim().toUpperCase();
        const m = /^([A-Z]+)(\d+)$/.exec(s);
        if (!m) return null;
        const col = colToIndex(m[1]);
        const row = Number(m[2]);
        if (!Number.isFinite(col) || !Number.isFinite(row) || col <= 0 || row <= 0) return null;
        return { col, row };
      }

      function addrFromRC(col1, row1) {
        return `${indexToCol(col1)}${row1}`;
      }

      function cssTextForClasses(css, classes) {
        if (!css || typeof css !== "object") return "";
        if (!Array.isArray(classes)) return "";
        let out = "";
        for (const cls of classes) {
          const rule = css[String(cls || "").trim()];
          if (!rule) continue;
          const t = String(rule).trim();
          if (!t) continue;
          out += t.endsWith(";") ? t : `${t};`;
        }
        return out;
      }

      function buildColumnWidths(config, cols) {
        const explicit = new Map();
        const colWidths = config?.grid?.colWidths && typeof config.grid.colWidths === "object" ? config.grid.colWidths : {};

        for (const [key, value] of Object.entries(colWidths)) {
          const idx = colToIndex(key);
          const w = Number(value);
          if (!idx || idx > cols || !Number.isFinite(w) || w <= 0) continue;
          explicit.set(idx, w);
        }

        const widths = new Map(explicit);

        const merges = Array.isArray(config?.merges) ? config.merges : [];
        for (const merge of merges) {
          const start = parseAddress(merge?.start);
          if (!start) continue;
          const colspan = Number(merge?.colspan || 1);
          if (!Number.isFinite(colspan) || colspan < 2) continue;

          const startCol = start.col;
          const endCol = Math.min(cols, startCol + colspan - 1);
          const total = explicit.get(startCol);
          if (!Number.isFinite(total)) continue;

          let hasOtherExplicit = false;
          for (let c = startCol + 1; c <= endCol; c++) {
            if (explicit.has(c)) {
              hasOtherExplicit = true;
              break;
            }
          }
          if (hasOtherExplicit) continue;

          const each = total / (endCol - startCol + 1);
          for (let c = startCol; c <= endCol; c++) widths.set(c, each);
        }

        const fallback = Number(config?.grid?.defaultColWidth);
        const defaultColWidth = Number.isFinite(fallback) && fallback > 0 ? fallback : 40;
        for (let c = 1; c <= cols; c++) {
          if (!widths.has(c)) widths.set(c, defaultColWidth);
        }
        return widths;
      }

      function buildRowHeights(config, rows) {
        const rowHeights = config?.grid?.rowHeights && typeof config.grid.rowHeights === "object" ? config.grid.rowHeights : {};
        const heights = new Map();
        for (const [key, value] of Object.entries(rowHeights)) {
          const r = Number(key);
          const h = Number(value);
          if (!Number.isFinite(r) || !Number.isFinite(h) || r <= 0 || h <= 0) continue;
          heights.set(r, h);
        }

        const fallback = Number(config?.grid?.defaultRowHeight);
        const defaultRowHeight = Number.isFinite(fallback) && fallback > 0 ? fallback : 30;
        for (let r = 1; r <= rows; r++) {
          if (!heights.has(r)) heights.set(r, defaultRowHeight);
        }
        return heights;
      }

      function buildMergeMaps(config, rows, cols) {
        const skip = new Set();
        const startMap = new Map();
        const merges = Array.isArray(config?.merges) ? config.merges : [];

        for (const merge of merges) {
          const start = parseAddress(merge?.start);
          if (!start) continue;
          const rowspan = Math.max(1, Math.floor(Number(merge?.rowspan || 1)));
          const colspan = Math.max(1, Math.floor(Number(merge?.colspan || 1)));
          const startRow = start.row;
          const startCol = start.col;
          if (startRow > rows || startCol > cols) continue;

          const endRow = Math.min(rows, startRow + rowspan - 1);
          const endCol = Math.min(cols, startCol + colspan - 1);
          const startAddr = addrFromRC(startCol, startRow);
          startMap.set(startAddr, { rowspan: endRow - startRow + 1, colspan: endCol - startCol + 1 });

          for (let r = startRow; r <= endRow; r++) {
            for (let c = startCol; c <= endCol; c++) {
              if (r === startRow && c === startCol) continue;
              skip.add(addrFromRC(c, r));
            }
          }
        }

        return { skip, startMap };
      }

      function renderExcelLikeTable(config) {
        if (!config || config.type !== "excel-like-table") {
          const el = document.createElement("div");
          el.className = "demo-error";
          el.textContent = "Unsupported template type.";
          return el;
        }

        const rows = Math.max(1, Math.floor(Number(config?.grid?.rows || 1)));
        const cols = Math.max(1, Math.floor(Number(config?.grid?.cols || 1)));

        const table = document.createElement("table");
        table.className = "excel-like-table";
        table.style.borderCollapse = "collapse";
        table.style.tableLayout = "fixed";

        const cellMap = new Map();
        const cells = Array.isArray(config.cells) ? config.cells : [];
        for (const c of cells) {
          const addr = normalizeAddress(c?.addr);
          if (!addr) continue;
          cellMap.set(addr, c);
        }

        const colWidths = buildColumnWidths(config, cols);
        const rowHeights = buildRowHeights(config, rows);
        const { skip, startMap } = buildMergeMaps(config, rows, cols);

        let baseClasses = [];
        if (Array.isArray(config?.defaultCellClass)) {
          baseClasses = config.defaultCellClass.map((x) => String(x || "").trim()).filter(Boolean);
        } else if (typeof config?.defaultCellClass === "string" && config.defaultCellClass.trim()) {
          baseClasses = [config.defaultCellClass.trim()];
        } else if (config?.css?.cell) {
          baseClasses = ["cell"];
        }

        const colgroup = document.createElement("colgroup");
        let totalWidth = 0;
        for (let c = 1; c <= cols; c++) {
          const w = Number(colWidths.get(c));
          const col = document.createElement("col");
          if (Number.isFinite(w) && w > 0) {
            col.style.width = `${w}px`;
            totalWidth += w;
          }
          colgroup.appendChild(col);
        }
        table.appendChild(colgroup);
        if (totalWidth > 0) table.style.width = `${totalWidth}px`;

        for (let r = 1; r <= rows; r++) {
          const tr = document.createElement("tr");
          const h = Number(rowHeights.get(r));
          if (Number.isFinite(h) && h > 0) tr.style.height = `${h}px`;

          for (let c = 1; c <= cols; c++) {
            const addr = addrFromRC(c, r);
            if (skip.has(addr)) continue;

            const td = document.createElement("td");
            td.dataset.addr = addr;

            const cellCfg = cellMap.get(addr);
            if (cellCfg) {
              td.textContent = String(cellCfg.text ?? "");
              const bind = String(cellCfg.bind || "").trim();
              if (bind) {
                td.dataset.bind = bind;
                if (/\.description$/.test(bind)) td.title = "Double-click  sa m t (local/global).";
              }
            }

            const combined = [];
            for (const cls of baseClasses) combined.push(cls);
            if (Array.isArray(cellCfg?.class)) {
              for (const cls of cellCfg.class) combined.push(String(cls || "").trim());
            }

            const seen = new Set();
            const classes = combined.filter((x) => {
              const t = String(x || "").trim();
              if (!t || seen.has(t)) return false;
              seen.add(t);
              return true;
            });

            if (classes.length) {
              td.className = classes.join(" ");
              const styleText = cssTextForClasses(config.css, classes);
              const cellStyle = cellCfg && typeof cellCfg === "object" ? String(cellCfg.style || "").trim() : "";
              const mergedStyle = `${styleText || ""}${cellStyle ? (cellStyle.endsWith(";") ? cellStyle : `${cellStyle};`) : ""}`;
              if (mergedStyle) td.style.cssText = mergedStyle;
            } else if (cellCfg && typeof cellCfg === "object") {
              const cellStyle = String(cellCfg.style || "").trim();
              if (cellStyle) td.style.cssText = cellStyle.endsWith(";") ? cellStyle : `${cellStyle};`;
            }

            const merge = startMap.get(addr);
            if (merge) {
              if (merge.rowspan > 1) td.rowSpan = merge.rowspan;
              if (merge.colspan > 1) td.colSpan = merge.colspan;
            }

            // Keep Excel-like fixed cell size: don't let long text expand rows/cols and hide adjacent cell formatting.
            td.style.boxSizing = "border-box";
            if (!td.style.overflow) td.style.overflow = "hidden";
            if (Number.isFinite(h) && h > 0) {
              td.style.height = `${h}px`;
              td.style.maxHeight = `${h}px`;
            }

            tr.appendChild(td);
          }

          table.appendChild(tr);
        }

        return table;
      }

      ns.tableRenderer = {
        renderExcelLikeTable,
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/template_converter.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;

      const desc = ns.desc || null;
      const IDENT_PATH_RE = desc?.IDENT_PATH_RE ? new RegExp(desc.IDENT_PATH_RE.source, "g") : /[A-Za-z_][A-Za-z0-9_\/]*(?:(?:->|=>|[-~])[A-Za-z0-9_\/]+)*/g;
      const pickDescription =
        typeof desc?.pickDescription === "function"
          ? desc.pickDescription
          : (entity, fallbackName) => {
              if (!entity) return String(fallbackName || "").trim();
              const user = String(entity.userDescription || "").trim();
              if (user) return user;
              const code = String(entity.description || "").trim();
              if (code) return code;
              return String(fallbackName || entity.variableName || entity.name || "").trim();
            };
      const maskStringsAndTemplates =
        typeof desc?.maskStringsAndTemplates === "function"
          ? desc.maskStringsAndTemplates
          : (s) => {
              // ABAP strings: '...'; escaped by doubling: ''
              const noStrings = String(s || "").replace(/'(?:[^']|'')*'/g, " ");
              // ABAP string templates: |...|  (best-effort)
              return noStrings.replace(/\|[^|]*\|/g, " ");
            };
      const rootFromPath =
        typeof desc?.rootFromPath === "function"
          ? desc.rootFromPath
          : (path) => {
              const s = String(path || "").trim();
              if (!s) return "";
              const root = s.split(/(?:->|=>|[-~])/)[0] || "";
              const m = /^[A-Za-z_][A-Za-z0-9_\/]*/.exec(root.trim());
              return m ? m[0] : "";
            };

      const extractSource =
        typeof utils?.extractSource === "function"
          ? utils.extractSource
          : (model, sourceRef) => {
              if (!model || !Array.isArray(model.lines) || !sourceRef) return "";
              const start = Math.max(1, Math.floor(Number(sourceRef.startLine || 1)));
              const end = Math.min(model.lines.length, Math.floor(Number(sourceRef.endLine || start)));
              return model.lines.slice(start - 1, end).join("\n").trim();
            };

      function pickNote(entity) {
        if (!entity) return "";
        const user = String(entity.userNote || "").trim();
        if (user) return user;
        return String(entity.note || "").trim();
      }

      function resolveBestSymbol(model, routineKey, expr) {
        const resolver = ns.lineage?.resolveSymbol;
        const rk = String(routineKey || "").trim();
        if (!resolver || !model || !rk) return { root: "", scope: "unknown", decl: null };

        const sanitized = maskStringsAndTemplates(expr);
        IDENT_PATH_RE.lastIndex = 0;
        const tokens = [];
        let m = null;
        while ((m = IDENT_PATH_RE.exec(sanitized))) {
          const token = String(m[0] || "").trim();
          if (token) tokens.push(token);
        }

        for (const token of tokens) {
          const root = rootFromPath(token);
          if (!root) continue;
          const res = resolver(model, rk, root);
          if (res && String(res.scope || "").toLowerCase() !== "unknown") return { root, scope: res.scope, decl: res.decl || null };
        }

        const fallbackRoot = tokens.length ? rootFromPath(tokens[0]) : "";
        if (!fallbackRoot) return { root: "", scope: "unknown", decl: null };
        const fallback = resolver(model, rk, fallbackRoot);
        return { root: fallbackRoot, scope: fallback?.scope || "unknown", decl: fallback?.decl || null };
      }

      function extractPerformEdges(model) {
        const edges = model && Array.isArray(model.edges) ? model.edges : [];
        return edges.filter((e) => String(e?.toKey || "").toUpperCase().startsWith("FORM:"));
      }

      function extractAssignments(model) {
        const out = [];
        const nodes = Array.from(model?.nodes?.values ? model.nodes.values() : []);
        for (const routine of nodes) {
          const assigns = Array.isArray(routine?.assignments) ? routine.assignments : [];
          for (const a of assigns) {
            if (!a || !a.sourceRef) continue;
            out.push({ routine, assignment: a });
          }
        }

        out.sort((a, b) => Number(a?.assignment?.sourceRef?.startLine || 0) - Number(b?.assignment?.sourceRef?.startLine || 0));
        return out;
      }

      function extractIfStatements(model) {
        const out = [];
        const nodes = Array.from(model?.nodes?.values ? model.nodes.values() : []);
        for (const routine of nodes) {
          const list = Array.isArray(routine?.ifStatements) ? routine.ifStatements : [];
          for (const st of list) {
            if (!st || !st.sourceRef) continue;
            out.push({ routine, ifStatement: st });
          }
        }

        out.sort((a, b) => Number(a?.ifStatement?.sourceRef?.startLine || 0) - Number(b?.ifStatement?.sourceRef?.startLine || 0));
        return out;
      }

      function extractMessages(model) {
        const out = [];
        const nodes = Array.from(model?.nodes?.values ? model.nodes.values() : []);
        for (const routine of nodes) {
          const list = Array.isArray(routine?.messages) ? routine.messages : [];
          for (const msg of list) {
            if (!msg || !msg.sourceRef) continue;
            out.push({ routine, message: msg });
          }
        }

        out.sort((a, b) => Number(a?.message?.sourceRef?.startLine || 0) - Number(b?.message?.sourceRef?.startLine || 0));
        return out;
      }

      function extractItabOperations(model) {
        const out = [];
        const nodes = Array.from(model?.nodes?.values ? model.nodes.values() : []);
        for (const routine of nodes) {
          const list = Array.isArray(routine?.itabOps) ? routine.itabOps : [];
          for (const op of list) {
            if (!op || !op.sourceRef) continue;
            out.push({ routine, itabOp: op });
          }
        }

        out.sort((a, b) => Number(a?.itabOp?.sourceRef?.startLine || 0) - Number(b?.itabOp?.sourceRef?.startLine || 0));
        return out;
      }

      function buildArgMappings(model, callerKey, actuals, formals, options) {
        const a = Array.isArray(actuals) ? actuals : [];
        const f = Array.isArray(formals) ? formals : [];
        const len = a.length;
        if (len === 0) return [];

        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;

        const out = [];
        for (let i = 0; i < len; i++) {
          const formal = f[i] || null;
          const actualText = a[i] != null ? String(a[i]) : "";
          const described = desc?.describeExpressionWithOrigin
            ? desc.describeExpressionWithOrigin(model, callerKey, actualText, { callPath })
            : { text: "", originKey: "" };
          out.push({
            actual: actualText,
            name: formal ? String(formal.name || "") : "",
            dataType: formal ? String(formal.dataType || "") : "",
            description: String(described.text || "").trim() || actualText.trim() || (formal ? String(formal.name || "") : ""),
            originKey: String(described.originKey || ""),
            note: formal ? pickNote(formal) : "",
          });
        }
        return out;
      }

      function buildPerformContext(model, edge, options) {
        const toKey = String(edge?.toKey || "");
        const fromKey = String(edge?.fromKey || "");

        const callee = model?.nodes?.get(toKey) || null;
        const caller = model?.nodes?.get(fromKey) || null;

        const params = Array.isArray(callee?.params) ? callee.params : [];
        const formalTables = params.filter((p) => String(p?.kind || "").toUpperCase() === "TABLES");
        const formalUsing = params.filter((p) => String(p?.kind || "").toUpperCase() === "USING");
        const formalChanging = params.filter((p) => String(p?.kind || "").toUpperCase() === "CHANGING");
        const formalRaising = params.filter((p) => String(p?.kind || "").toUpperCase() === "RAISING");

        const args = edge?.args || {};
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;
        const tables = buildArgMappings(model, fromKey, args.tables, formalTables, { callPath });
        const using = buildArgMappings(model, fromKey, args.using, formalUsing, { callPath });
        const changing = buildArgMappings(model, fromKey, args.changing, formalChanging, { callPath });
        const raising = formalRaising.map((p) => ({
          name: String(p?.name || ""),
          description: pickDescription(p, p?.name),
          originKey: ns.notes?.makeParamKey ? ns.notes.makeParamKey(toKey, String(p?.name || "")) : "",
          note: pickNote(p),
        }));

        const performName = String(edge?.targetName || callee?.name || "").trim();

        const presence = {
          tables: tables.length > 0,
          using: using.length > 0,
          changing: changing.length > 0,
          raising: raising.length > 0,
        };

        return {
          perform: {
            key: toKey,
            name: performName,
            description: pickDescription(callee, performName),
            note: pickNote(callee),
            originKey: toKey,
          },
          caller: {
            key: fromKey,
            name: String(caller?.name || "").trim(),
          },
          presence,
          tables,
          using,
          changing,
          raising,
        };
      }

      function buildAssignmentContext(model, routine, assignment, options) {
        const r = routine || null;
        const a = assignment || null;

        const lhsText = String(a?.lhs || "");
        const rhsText = String(a?.rhs || "");

        const routineKey = String(r?.key || "");
        const lhsResolved = resolveBestSymbol(model, routineKey, lhsText);
        const rhsResolved = resolveBestSymbol(model, routineKey, rhsText);
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;

        const lhsDesc = desc?.describeExpressionWithOrigin
          ? desc.describeExpressionWithOrigin(model, routineKey, lhsText, { callPath })
          : { text: pickDescription(lhsResolved.decl, lhsResolved.root || lhsText), originKey: "" };

        const rhsDesc = desc?.describeExpressionWithOrigin
          ? desc.describeExpressionWithOrigin(model, routineKey, rhsText, { callPath })
          : { text: pickDescription(rhsResolved.decl, rhsResolved.root || rhsText), originKey: "" };

        return {
          routine: {
            key: String(r?.key || ""),
            kind: String(r?.kind || ""),
            name: String(r?.name || ""),
          },
          assignment: {
            lhs: lhsText,
            rhs: rhsText,
            statement: String(a?.statement || ""),
          },
          item: {
            text: lhsText,
            root: lhsResolved.root,
            scope: String(lhsResolved.scope || "unknown"),
            description: String(lhsDesc.text || "").trim() || lhsText.trim() || lhsResolved.root,
            note: pickNote(lhsResolved.decl),
            originKey: String(lhsDesc.originKey || ""),
          },
          value: {
            text: rhsText,
            root: rhsResolved.root,
            scope: String(rhsResolved.scope || "unknown"),
            description: String(rhsDesc.text || "").trim() || rhsText.trim() || rhsResolved.root,
            note: pickNote(rhsResolved.decl),
            originKey: String(rhsDesc.originKey || ""),
          },
        };
      }

      function buildIfContext(model, routine, ifStatement, options) {
        const r = routine || null;
        const st = ifStatement || null;

        const routineKey = String(r?.key || "");
        const kind = String(st?.kind || "IF").trim().toUpperCase() || "IF";
        const condition = String(st?.condition || "").trim();
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;

        const parsed = typeof ns.logic?.parseIfExpression === "function" ? ns.logic.parseIfExpression(condition) : [{ item1: condition, operator: "", item2: "", association: "", raw: condition }];

        const conditions = (parsed || []).map((c) => {
          const item1Text = String(c?.item1 || "").trim();
          const item2Text = String(c?.item2 || "").trim();

          const item1Resolved = resolveBestSymbol(model, routineKey, item1Text);
          const item2Resolved = item2Text ? resolveBestSymbol(model, routineKey, item2Text) : { root: "", scope: "unknown", decl: null };

          const item1Desc = desc?.describeExpressionWithOrigin
            ? desc.describeExpressionWithOrigin(model, routineKey, item1Text, { callPath })
            : { text: pickDescription(item1Resolved.decl, item1Text) || item1Text, originKey: "" };

          const item2Desc =
            item2Text && desc?.describeExpressionWithOrigin
              ? desc.describeExpressionWithOrigin(model, routineKey, item2Text, { callPath })
              : { text: pickDescription(item2Resolved.decl, item2Text) || item2Text, originKey: "" };

          return {
            item1: {
              text: item1Text,
              root: item1Resolved.root,
              scope: String(item1Resolved.scope || "unknown"),
              description: String(item1Desc.text || "").trim() || item1Text,
              note: pickNote(item1Resolved.decl),
              originKey: String(item1Desc.originKey || ""),
            },
            operator: String(c?.operator || "").trim(),
            item2: {
              text: item2Text,
              root: item2Resolved.root,
              scope: String(item2Resolved.scope || "unknown"),
              description: String(item2Desc.text || "").trim() || item2Text,
              note: pickNote(item2Resolved.decl),
              originKey: String(item2Desc.originKey || ""),
            },
            association: String(c?.association || "").trim().toUpperCase(),
            raw: String(c?.raw || "").trim(),
          };
        });

        return {
          routine: {
            key: routineKey,
            kind: String(r?.kind || ""),
            name: String(r?.name || ""),
          },
          if: { kind, condition },
          conditions,
        };
      }

      function describeExprWithOrigin(model, routineKey, exprText, options) {
        const text = String(exprText ?? "").trim();
        if (!text) return { text: "", originKey: "" };
        if (desc?.describeExpressionWithOrigin) return desc.describeExpressionWithOrigin(model, routineKey, text, options);
        return { text, originKey: "" };
      }

      function buildExprNode(model, routineKey, exprText, options) {
        const text = String(exprText ?? "").trim();
        if (!text) return { text: "", description: "", originKey: "" };
        const described = describeExprWithOrigin(model, routineKey, text, options);
        return {
          text,
          description: String(described.text || "").trim() || text,
          originKey: String(described.originKey || ""),
        };
      }

      const KEY_COND_START_RE =
        /[A-Za-z_][A-Za-z0-9_\/]*(?:(?:->|=>|[-~])[A-Za-z0-9_\/]+)*\s*(?:<=|>=|<>|=|<|>|EQ|NE|GT|LT|GE|LE)\b/gi;

      function splitKeyConditionTerms(text) {
        const raw = String(text || "").trim();
        if (!raw) return [];

        const masked = desc?.maskStringsAndTemplates ? desc.maskStringsAndTemplates(raw) : raw;

        KEY_COND_START_RE.lastIndex = 0;
        const starts = [];
        let m = null;
        while ((m = KEY_COND_START_RE.exec(masked))) starts.push(Number(m.index || 0));
        if (starts.length <= 1) return [raw];

        const out = [];
        for (let i = 0; i < starts.length; i++) {
          const start = starts[i];
          const end = i + 1 < starts.length ? starts[i + 1] : raw.length;
          const term = raw.slice(start, end).trim();
          if (term) out.push(term);
        }
        return out;
      }

      function buildConditionOperand(model, routineKey, exprText, options) {
        const text = String(exprText ?? "").trim();
        if (!text) return { text: "", root: "", scope: "unknown", description: "", note: "", originKey: "" };

        const resolved = resolveBestSymbol(model, routineKey, text);
        const described = describeExprWithOrigin(model, routineKey, text, options);

        return {
          text,
          root: resolved.root,
          scope: String(resolved.scope || "unknown"),
          description: String(described.text || "").trim() || text,
          note: pickNote(resolved.decl),
          originKey: String(described.originKey || ""),
        };
      }

      function buildMessageContext(model, routine, message, options) {
        const r = routine || null;
        const msg = message || null;
        const routineKey = String(r?.key || "");
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;

        const msgClass = buildExprNode(model, routineKey, msg?.msgClass || "", { callPath });
        const msgNo = buildExprNode(model, routineKey, msg?.msgNo || "", { callPath });
        const displayLike = buildExprNode(model, routineKey, msg?.displayLike || "", { callPath });
        const into = buildExprNode(model, routineKey, msg?.into || "", { callPath });
        const raising = buildExprNode(model, routineKey, msg?.raising || "", { callPath });
        const messageText = buildExprNode(model, routineKey, msg?.text || "", { callPath });

        const withArgs = Array.isArray(msg?.with) ? msg.with : [];
        const withNodes = withArgs.map((x) => buildExprNode(model, routineKey, x, { callPath }));

        return {
          routine: {
            key: routineKey,
            kind: String(r?.kind || ""),
            name: String(r?.name || ""),
          },
          message: {
            msgType: String(msg?.msgType || "").trim(),
            statement: String(msg?.statement || "").trim(),
          },
          msgClass,
          msgNo,
          displayLike,
          with: withNodes,
          into,
          raising,
          messageText,
          labels: {
            msgClass: msgClass.text ? "Message class" : "",
            msgNo: msgNo.text ? "Message No." : "",
            with1: withNodes.length >= 1 ? "Message variable &1" : "",
            with2: withNodes.length >= 2 ? "Message variable &2" : "",
            with3: withNodes.length >= 3 ? "Message variable &3" : "",
            with4: withNodes.length >= 4 ? "Message variable &4" : "",
            into: into.text ? "ch lu" : "",
            raising: raising.text ? "Raising" : "",
            displayLike: displayLike.text ? "Display like" : "",
            messageText: messageText.text ? "Message text" : "",
          },
        };
      }

      function buildItabOpContext(model, routine, itabOp, options) {
        const r = routine || null;
        const op = itabOp || null;
        const routineKey = String(r?.key || "");
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;

        const kind = String(op?.kind || "").trim().toUpperCase();
        const table = buildExprNode(model, routineKey, op?.table || "", { callPath });
        const target = buildExprNode(model, routineKey, op?.target || "", { callPath });

        const condText = String(op?.conditionText || "").trim();
        const condKind = String(op?.conditionKind || "").trim().toLowerCase();

        let parsed = [];
        if (condText) {
          if (condKind === "where" && typeof ns.logic?.parseIfExpression === "function") {
            parsed = ns.logic.parseIfExpression(condText);
          } else if (condKind === "key" && typeof ns.logic?.parseSimpleCondition === "function") {
            const terms = splitKeyConditionTerms(condText);
            for (let i = 0; i < terms.length; i++) {
              const p = ns.logic.parseSimpleCondition(terms[i]);
              parsed.push({ ...p, association: i < terms.length - 1 ? "AND" : "" });
            }
          } else if (condKind === "index") {
            parsed = [{ item1: "INDEX", operator: "=", item2: condText, association: "", raw: `INDEX = ${condText}` }];
          } else if (condKind === "from") {
            parsed = [{ item1: condText, operator: "FROM", item2: "", association: "", raw: `FROM ${condText}` }];
          } else if (typeof ns.logic?.parseIfExpression === "function") {
            parsed = ns.logic.parseIfExpression(condText);
          } else {
            parsed = [{ item1: condText, operator: "", item2: "", association: "", raw: condText }];
          }
        }

        const conditions = (parsed || []).map((c) => {
          const item1Text = String(c?.item1 || "").trim();
          const item2Text = String(c?.item2 || "").trim();

          return {
            item1: buildConditionOperand(model, routineKey, item1Text, { callPath }),
            operator: String(c?.operator || "").trim(),
            item2: buildConditionOperand(model, routineKey, item2Text, { callPath }),
            association: String(c?.association || "").trim().toUpperCase(),
            raw: String(c?.raw || "").trim(),
          };
        });

        const binarySearch = Boolean(op?.binarySearch);

        const targetLabelByKind =
          kind === "READ" ? "ch lu" : kind === "COLLECT" ? "Ngun" : kind === "MODIFY" ? "Ngun" : kind === "DELETE" ? "Ngun" : "Target";

        return {
          routine: {
            key: routineKey,
            kind: String(r?.kind || ""),
            name: String(r?.name || ""),
          },
          itabOp: {
            kind,
            statement: String(op?.statement || "").trim(),
            binarySearch,
            conditionKind: condKind,
            conditionText: condText,
          },
          table,
          target,
          conditions,
          labels: {
            target: target.text ? targetLabelByKind : "",
            conditions: conditions.length ? "iu kin" : "",
            condItem1: conditions.length ? "Item 1" : "",
            condOperator: conditions.length ? "Operator" : "",
            condItem2: conditions.length ? "Item 2" : "",
            condAssoc: conditions.length ? "Associations" : "",
            binarySearch: binarySearch ? "* Binarysearch" : "",
          },
        };
      }

      function buildAppendContext(model, routine, append, options) {
        const r = routine || null;
        const a = append || null;

        const routineKey = String(r?.key || "");
        const callPath = Array.isArray(options?.callPath) ? options.callPath : null;

        const line = buildExprNode(model, routineKey, a?.line || "", { callPath });
        const itab = buildExprNode(model, routineKey, a?.itab || "", { callPath });
        const sortedBy = buildExprNode(model, routineKey, a?.sortedBy || "", { callPath });
        const result = buildExprNode(model, routineKey, a?.result || "", { callPath });

        return {
          routine: {
            key: routineKey,
            kind: String(r?.kind || ""),
            name: String(r?.name || ""),
          },
          append: {
            statement: String(a?.statement || "").trim(),
          },
          line,
          itab,
          sortedBy,
          result,
          labels: {
            sortedBy: sortedBy.text ? "Sorted By" : "",
          },
        };
      }

      function resolvePath(obj, path) {
        const raw = String(path || "").trim();
        if (!raw) return undefined;

        let cur = obj;
        const parts = raw.split(".").map((p) => p.trim()).filter(Boolean);

        for (const part of parts) {
          if (cur == null) return undefined;
          const m = /^([A-Za-z0-9_$]+)(.*)$/.exec(part);
          if (!m) return undefined;
          const prop = m[1];
          let rest = m[2] || "";
          cur = cur[prop];

          while (rest) {
            const m2 = /^\[(\d+)\](.*)$/.exec(rest);
            if (!m2) return undefined;
            const idx = Number(m2[1]);
            if (!Number.isFinite(idx)) return undefined;
            cur = cur == null ? undefined : cur[idx];
            rest = m2[2] || "";
          }
        }

        return cur;
      }

      function fillText(text, context, options) {
        const s = String(text ?? "");
        const preserveUnresolved = Boolean(options?.preserveUnresolved);
        return s.replace(/\{([^}]+)\}/g, (m, expr) => {
          const value = resolvePath(context, expr);
          if (value == null) return preserveUnresolved ? m : "";
          if (typeof value === "string") return value;
          if (typeof value === "number" || typeof value === "boolean") return String(value);
          return preserveUnresolved ? m : "";
        });
      }

      function replaceListIndexInText(text, listName, fromIndex, toIndex) {
        const s = String(text ?? "");
        const from = Number(fromIndex);
        const to = Number(toIndex);
        if (!Number.isFinite(from) || !Number.isFinite(to)) return s;
        const re = new RegExp(`\\{${listName}\\[${from}\\]`, "g");
        return s.replace(re, `{${listName}[${to}]`);
      }

      function fillTemplateConfig(templateConfig, context, options) {
        const cfg = JSON.parse(JSON.stringify(templateConfig || {}));
        if (!cfg || typeof cfg !== "object") return cfg;

        const sectionLabels =
          templateConfig?.sectionLabels && typeof templateConfig.sectionLabels === "object" ? templateConfig.sectionLabels : {};
        const presence = context?.presence && typeof context.presence === "object" ? context.presence : {};
        const labels = {
          ...(context?.labels && typeof context.labels === "object" ? context.labels : {}),
          tables: presence.tables ? String(sectionLabels.tables ?? "Table") : "",
          using: presence.using ? String(sectionLabels.using ?? "Using") : "",
          changing: presence.changing ? String(sectionLabels.changing ?? "Changing") : "",
          raising: presence.raising ? String(sectionLabels.raising ?? "Raising") : "",
        };
        const ctx = { ...(context || {}), labels };

        if (Array.isArray(cfg.cells)) {
          for (const cell of cfg.cells) {
            if (!cell || typeof cell !== "object") continue;
            if (cell.text == null) continue;

            const rawText = String(cell.text ?? "");
            const bindMatch = /^\{([^}]+)\}$/.exec(rawText.trim());
            if (bindMatch) cell.bind = String(bindMatch[1] || "").trim();

            cell.text = fillText(rawText, ctx, options);
          }
        }

        return cfg;
      }

      function parseCellAddr(addr) {
        const s = String(addr || "").trim().toUpperCase();
        const m = /^([A-Z]+)(\d+)$/.exec(s);
        if (!m) return null;
        return { col: m[1], row: Number(m[2]) };
      }

      function shiftAddrRow(addr, afterRow, delta) {
        const parsed = parseCellAddr(addr);
        if (!parsed) return addr;
        if (parsed.row > afterRow) return `${parsed.col}${parsed.row + delta}`;
        return `${parsed.col}${parsed.row}`;
      }

      function shiftRowHeights(rowHeights, afterRow, delta) {
        const src = rowHeights && typeof rowHeights === "object" ? rowHeights : {};
        const out = {};
        for (const [k, v] of Object.entries(src)) {
          const r = Number(k);
          if (!Number.isFinite(r) || r <= 0) continue;
          const nr = r > afterRow ? r + delta : r;
          out[String(nr)] = v;
        }
        return out;
      }

      function scanRepeatSections(cells) {
        const info = new Map();
        const re = /\{([A-Za-z_][A-Za-z0-9_]*)\[(\d+)\]\.[^}]*\}/g;

        for (const cell of cells) {
          const a = parseCellAddr(cell?.addr);
          if (!a) continue;
          const text = String(cell?.text ?? "");
          re.lastIndex = 0;
          let m;
          while ((m = re.exec(text))) {
            const list = m[1];
            const idx = Number(m[2]);
            if (!Number.isFinite(idx) || idx < 0) continue;

            if (!info.has(list)) {
              info.set(list, { maxIndex: -1, rowForIndex: new Map(), rowsUsed: new Set() });
            }
            const cur = info.get(list);
            cur.maxIndex = Math.max(cur.maxIndex, idx);
            cur.rowsUsed.add(a.row);
            if (!cur.rowForIndex.has(idx)) cur.rowForIndex.set(idx, a.row);
          }
        }

        return info;
      }

      function expandExcelLikeTableTemplate(templateConfig, context) {
        const cfg = JSON.parse(JSON.stringify(templateConfig || {}));
        if (!cfg || typeof cfg !== "object") return cfg;
        if (cfg.type !== "excel-like-table") return cfg;
        if (!cfg.grid || typeof cfg.grid !== "object") return cfg;
        if (!Array.isArray(cfg.cells)) return cfg;

        const merges = Array.isArray(cfg.merges) ? cfg.merges : [];
        cfg.merges = merges;

        const info = scanRepeatSections(cfg.cells);
        const sections = [];

        for (const [list, data] of info.entries()) {
          const maxIndex = Number(data?.maxIndex);
          if (!Number.isFinite(maxIndex) || maxIndex < 0) continue;

          const rows = Array.from(data.rowsUsed || []).filter((r) => Number.isFinite(r) && r > 0).sort((a, b) => a - b);
          if (!rows.length) continue;

          sections.push({
            list,
            baseCount: maxIndex + 1,
            baseIndex: maxIndex,
            startRow: rows[0],
            endRow: rows[rows.length - 1],
            templateRow: data.rowForIndex?.get(maxIndex) || rows[rows.length - 1],
          });
        }

        sections.sort((a, b) => b.startRow - a.startRow);

        function insertRowsAfter(afterRow, count, section) {
          if (count <= 0) return;

          cfg.cells = cfg.cells.map((cell) => {
            const addr = shiftAddrRow(cell?.addr, afterRow, count);
            return { ...cell, addr };
          });

          cfg.merges = cfg.merges.map((m) => {
            const start = shiftAddrRow(m?.start, afterRow, count);
            return { ...m, start };
          });

          cfg.grid.rowHeights = shiftRowHeights(cfg.grid.rowHeights, afterRow, count);
          cfg.grid.rows = Math.max(1, Math.floor(Number(cfg.grid.rows || 1)) + count);

          const rowCells = cfg.cells
            .filter((cell) => parseCellAddr(cell?.addr)?.row === section.templateRow)
            .map((cell) => ({ ...cell }));
          const rowMerges = cfg.merges
            .filter((m) => parseCellAddr(m?.start)?.row === section.templateRow)
            .map((m) => ({ ...m }));
          const baseHeight =
            cfg.grid.rowHeights?.[String(section.templateRow)] ?? cfg.grid.rowHeights?.[Number(section.templateRow)] ?? null;

          for (let i = 1; i <= count; i++) {
            const newRow = afterRow + i;
            const newIndex = section.baseIndex + i;

            for (const baseCell of rowCells) {
              const parsed = parseCellAddr(baseCell?.addr);
              if (!parsed) continue;
              const newAddr = `${parsed.col}${newRow}`;
              const text = replaceListIndexInText(baseCell?.text, section.list, section.baseIndex, newIndex);
              let nextText = text;
              if (parsed.col === "A" && /\{labels\./.test(nextText)) nextText = "";
              cfg.cells.push({ ...baseCell, addr: newAddr, text: nextText });
            }

            for (const baseMerge of rowMerges) {
              const parsed = parseCellAddr(baseMerge?.start);
              if (!parsed) continue;
              cfg.merges.push({ ...baseMerge, start: `${parsed.col}${newRow}` });
            }

            if (baseHeight != null) cfg.grid.rowHeights[String(newRow)] = baseHeight;
          }
        }

        for (const section of sections) {
          const want = Array.isArray(context?.[section.list]) ? context[section.list].length : 0;
          const baseCount = section.baseCount;
          if (want <= baseCount) continue;
          insertRowsAfter(section.endRow, want - baseCount, section);
        }

        return cfg;
      }

      function compactExcelLikeTableConfig(cfg) {
        if (!cfg || cfg.type !== "excel-like-table") return cfg;
        if (!cfg.grid || typeof cfg.grid !== "object") return cfg;
        if (!cfg.compact?.removeEmptyRows) return cfg;
        if (!Array.isArray(cfg.cells)) return cfg;

        const totalRows = Math.max(1, Math.floor(Number(cfg.grid.rows || 1)));
        const rowsWithText = new Set([1]);

        for (const cell of cfg.cells) {
          const parsed = parseCellAddr(cell?.addr);
          if (!parsed) continue;
          if (parsed.row < 1 || parsed.row > totalRows) continue;
          const text = String(cell?.text ?? "").trim();
          if (text) rowsWithText.add(parsed.row);
        }

        const keepRows = Array.from(rowsWithText).filter((r) => r >= 1 && r <= totalRows).sort((a, b) => a - b);
        if (keepRows.length === totalRows) return cfg;

        const rowMap = new Map();
        for (let i = 0; i < keepRows.length; i++) rowMap.set(keepRows[i], i + 1);

        cfg.cells = cfg.cells
          .map((cell) => {
            const parsed = parseCellAddr(cell?.addr);
            if (!parsed) return null;
            const newRow = rowMap.get(parsed.row);
            if (!newRow) return null;
            return { ...cell, addr: `${parsed.col}${newRow}` };
          })
          .filter(Boolean);

        if (Array.isArray(cfg.merges)) {
          cfg.merges = cfg.merges
            .map((merge) => {
              const parsed = parseCellAddr(merge?.start);
              if (!parsed) return null;
              const newRow = rowMap.get(parsed.row);
              if (!newRow) return null;
              return { ...merge, start: `${parsed.col}${newRow}` };
            })
            .filter(Boolean);
        }

        const oldHeights = cfg.grid.rowHeights && typeof cfg.grid.rowHeights === "object" ? cfg.grid.rowHeights : {};
        const newHeights = {};
        for (const oldRow of keepRows) {
          const newRow = rowMap.get(oldRow);
          const h = oldHeights[oldRow] ?? oldHeights[String(oldRow)];
          if (newRow && h != null) newHeights[String(newRow)] = h;
        }
        cfg.grid.rowHeights = newHeights;
        cfg.grid.rows = keepRows.length;
        return cfg;
      }

      function convertPerforms(model, templateConfig) {
        const edges = extractPerformEdges(model)
          .slice()
          .sort((a, b) => Number(a?.sourceRef?.startLine || 0) - Number(b?.sourceRef?.startLine || 0));
        return edges.map((edge) => {
          const context = buildPerformContext(model, edge);
          const expandedTemplate = expandExcelLikeTableTemplate(templateConfig, context);
          const filledConfig = compactExcelLikeTableConfig(fillTemplateConfig(expandedTemplate, context));
          const original = extractSource(model, edge.sourceRef) || `PERFORM ${context.perform.name}`;
          return { edge, context, filledConfig, original };
        });
      }

      function convertAssignments(model, templateConfig) {
        const items = extractAssignments(model);
        return items.map(({ routine, assignment }) => {
          const context = buildAssignmentContext(model, routine, assignment);
          const filledConfig = compactExcelLikeTableConfig(fillTemplateConfig(templateConfig, context));
          const original = extractSource(model, assignment.sourceRef) || `${context.assignment.lhs} = ${context.assignment.rhs}`;
          return {
            routineKey: String(routine?.key || ""),
            routineName: String(routine?.name || ""),
            routineKind: String(routine?.kind || ""),
            assignment,
            context,
            filledConfig,
            original,
            sourceRef: assignment?.sourceRef || null,
          };
        });
      }

      function convertIfStatements(model, templateConfig) {
        const items = extractIfStatements(model);
        return items.map(({ routine, ifStatement }) => {
          const context = buildIfContext(model, routine, ifStatement);
          const expanded = expandExcelLikeTableTemplate(templateConfig, context);
          const filledConfig = compactExcelLikeTableConfig(fillTemplateConfig(expanded, context));
          const original = extractSource(model, ifStatement.sourceRef) || `${context.if?.kind || "IF"} ${context.if?.condition || ""}`;
          return {
            routineKey: String(routine?.key || ""),
            routineName: String(routine?.name || ""),
            routineKind: String(routine?.kind || ""),
            ifStatement,
            context,
            filledConfig,
            original,
            sourceRef: ifStatement?.sourceRef || null,
          };
        });
      }

      ns.templateConverter = {
        extractPerformEdges,
        extractAssignments,
        extractIfStatements,
        extractMessages,
        extractItabOperations,
        buildPerformContext,
        buildAssignmentContext,
        buildIfContext,
        buildMessageContext,
        buildItabOpContext,
        buildAppendContext,
        fillTemplateConfig,
        expandExcelLikeTableTemplate,
        compactExcelLikeTableConfig,
        convertPerforms,
        convertAssignments,
        convertIfStatements,
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/template_excel_export.js
    (function (ns) {
      "use strict";

      function escapeHtml(text) {
        return String(text ?? "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function setCellHtmlFromText(cellEl, text) {
        const normalized = String(text ?? "")
          .replace(/\r\n/g, "\n")
          .replace(/\r/g, "\n")
          .replace(/\u00a0/g, " ");
        cellEl.innerHTML = escapeHtml(normalized).replace(/\n/g, "<br>");
      }

      function normalizeColorToHex(colorRaw) {
        const raw = String(colorRaw || "").trim();
        if (!raw) return "";
        if (/^(transparent|none)$/i.test(raw)) return "";

        const hex = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.exec(raw);
        if (hex) {
          const h = hex[1].toLowerCase();
          if (h.length === 3) return `#${h[0]}${h[0]}${h[1]}${h[1]}${h[2]}${h[2]}`;
          return `#${h}`;
        }

        const rgb = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*([\d.]+)\s*)?\)$/i.exec(raw);
        if (rgb) {
          const alpha = rgb[4] != null ? Number(rgb[4]) : 1;
          if (!Number.isFinite(alpha) || alpha <= 0) return "";
          const r = Math.max(0, Math.min(255, Number(rgb[1])));
          const g = Math.max(0, Math.min(255, Number(rgb[2])));
          const b = Math.max(0, Math.min(255, Number(rgb[3])));
          const toHex = (n) => n.toString(16).padStart(2, "0");
          return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        return raw;
      }

      function parseCssBorder(cssBorder) {
        const raw = String(cssBorder || "").trim();
        if (!raw) return null;
        if (/^0(?:px|pt)?\s+/i.test(raw)) return null;

        const m = /^(\d+(?:\.\d+)?)(px|pt)?\s+([a-z]+)\s+(.+)$/i.exec(raw);
        if (!m) return null;

        const width = Number(m[1]);
        if (!Number.isFinite(width) || width <= 0) return null;

        const unit = String(m[2] || "px").toLowerCase();
        const style = String(m[3] || "").toLowerCase();
        const color = normalizeColorToHex(m[4]);

        if (!style || style === "none" || style === "hidden") return null;
        if (!color) return null;

        let pt = width;
        if (unit === "px") pt = (width * 72) / 96;
        pt = Math.max(0.25, pt);
        const ptText = `${Math.round(pt * 100) / 100}pt`;

        return { style, color, ptText };
      }

      function borderToExcelCss(cssBorder) {
        const parts = parseCssBorder(cssBorder);
        if (!parts) return { css: "", msoAlt: "" };
        return {
          css: `${parts.ptText} ${parts.style} ${parts.color}`,
          msoAlt: `${parts.style} ${parts.color} ${parts.ptText}`,
        };
      }

      function inlineComputedCellStyles(dstCell, srcCell) {
        if (!dstCell || !srcCell || typeof window === "undefined" || typeof window.getComputedStyle !== "function") return;

        let cs = null;
        try {
          cs = window.getComputedStyle(srcCell);
        } catch (_) {
          cs = null;
        }
        if (!cs) return;

        const top = borderToExcelCss(cs.borderTop);
        const right = borderToExcelCss(cs.borderRight);
        const bottom = borderToExcelCss(cs.borderBottom);
        const left = borderToExcelCss(cs.borderLeft);

        dstCell.style.border = "none";
        if (top.css) dstCell.style.borderTop = top.css;
        if (right.css) dstCell.style.borderRight = right.css;
        if (bottom.css) dstCell.style.borderBottom = bottom.css;
        if (left.css) dstCell.style.borderLeft = left.css;

        if (top.msoAlt) dstCell.style.setProperty("mso-border-top-alt", top.msoAlt);
        if (right.msoAlt) dstCell.style.setProperty("mso-border-right-alt", right.msoAlt);
        if (bottom.msoAlt) dstCell.style.setProperty("mso-border-bottom-alt", bottom.msoAlt);
        if (left.msoAlt) dstCell.style.setProperty("mso-border-left-alt", left.msoAlt);

        if (top.msoAlt && top.msoAlt === right.msoAlt && top.msoAlt === bottom.msoAlt && top.msoAlt === left.msoAlt) {
          dstCell.style.setProperty("mso-border-alt", top.msoAlt);
        }

        if (cs.backgroundColor && cs.backgroundColor !== "rgba(0, 0, 0, 0)" && cs.backgroundColor !== "transparent") {
          dstCell.style.backgroundColor = cs.backgroundColor;
        }
        if (cs.color) dstCell.style.color = cs.color;

        if (cs.fontWeight) dstCell.style.fontWeight = cs.fontWeight;
        if (cs.fontStyle) dstCell.style.fontStyle = cs.fontStyle;
        if (cs.fontSize) dstCell.style.fontSize = cs.fontSize;
        if (cs.fontFamily) dstCell.style.fontFamily = cs.fontFamily;
        if (cs.lineHeight) dstCell.style.lineHeight = cs.lineHeight;

        if (cs.textAlign) dstCell.style.textAlign = cs.textAlign;
        if (cs.verticalAlign) dstCell.style.verticalAlign = cs.verticalAlign;
        if (cs.whiteSpace) dstCell.style.whiteSpace = cs.whiteSpace;

        if (cs.paddingTop) dstCell.style.paddingTop = cs.paddingTop;
        if (cs.paddingRight) dstCell.style.paddingRight = cs.paddingRight;
        if (cs.paddingBottom) dstCell.style.paddingBottom = cs.paddingBottom;
        if (cs.paddingLeft) dstCell.style.paddingLeft = cs.paddingLeft;

        const styleAttr = String(dstCell.getAttribute("style") || "").trim();
        if (!/mso-number-format\s*:/i.test(styleAttr)) {
          const suffix = 'mso-number-format:"\\@";';
          dstCell.setAttribute("style", (styleAttr ? (styleAttr.endsWith(";") ? styleAttr : `${styleAttr};`) : "") + suffix);
        }
      }

      function cleanCloneOfTable(table) {
        const clone = table.cloneNode(true);

        clone.setAttribute("cellpadding", "0");
        clone.setAttribute("cellspacing", "0");
        clone.setAttribute("border", "1");
        clone.style.borderCollapse = "collapse";
        clone.style.borderSpacing = "0";
        clone.style.setProperty("mso-table-lspace", "0pt");
        clone.style.setProperty("mso-table-rspace", "0pt");

        const srcCells = table.querySelectorAll("td,th");
        const dstCells = clone.querySelectorAll("td,th");
        let tableBorderAlt = "";
        for (let i = 0; i < dstCells.length; i++) {
          const td = dstCells[i];
          const src = srcCells[i] || null;
          td.classList.remove("is-selected", "is-editing");
          td.removeAttribute("data-addr");
          td.removeAttribute("data-bind");
          td.removeAttribute("title");

          const editor = td.querySelector("textarea.cell-editor");
          const text = editor ? String(editor.value ?? editor.textContent ?? "") : String(td.textContent ?? "");
          setCellHtmlFromText(td, text);

          td.querySelectorAll("textarea.cell-editor").forEach((ta) => ta.remove());
          inlineComputedCellStyles(td, src);

          if (!tableBorderAlt) {
            const s = String(td.getAttribute("style") || "");
            const m = /mso-border-alt\s*:\s*([^;]+);?/i.exec(s);
            if (m) tableBorderAlt = String(m[1] || "").trim();
          }
        }

        if (tableBorderAlt) {
          clone.style.setProperty("mso-border-alt", tableBorderAlt);
          clone.style.setProperty("mso-border-insideh", tableBorderAlt);
          clone.style.setProperty("mso-border-insidev", tableBorderAlt);
        }

        return clone;
      }

      function wrapExcelHtmlFragment(fragmentHtml) {
        const frag = String(fragmentHtml || "");
        return (
          '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">' +
          "<head><meta charset=\"utf-8\"></head>" +
          "<body><!--StartFragment-->" +
          frag +
          "<!--EndFragment--></body></html>"
        );
      }

      function tableToHtml(table) {
        const clone = cleanCloneOfTable(table);
        return clone.outerHTML;
      }

      function tableToTsv(table) {
        const rows = Array.from(table?.rows || []);
        const occupied = [];
        const grid = [];
        let maxCols = 0;

        for (let r = 0; r < rows.length; r++) {
          const tr = rows[r];
          if (!occupied[r]) occupied[r] = [];
          const row = [];
          let col = 0;

          const cells = Array.from(tr?.cells || []);
          for (const cell of cells) {
            while (occupied[r][col]) col++;

            const rowspan = Math.max(1, Math.floor(Number(cell?.rowSpan || 1)));
            const colspan = Math.max(1, Math.floor(Number(cell?.colSpan || 1)));
            const text = String(cell?.innerText ?? cell?.textContent ?? "")
              .replace(/\r\n/g, "\n")
              .replace(/\r/g, "\n")
              .replace(/\u00a0/g, " ")
              .trimEnd();

            row[col] = text;

            for (let rr = 0; rr < rowspan; rr++) {
              const rowIdx = r + rr;
              if (!occupied[rowIdx]) occupied[rowIdx] = [];
              for (let cc = 0; cc < colspan; cc++) {
                occupied[rowIdx][col + cc] = true;
              }
            }

            col += colspan;
            maxCols = Math.max(maxCols, col);
          }

          grid[r] = row;
        }

        const lines = [];
        for (let r = 0; r < grid.length; r++) {
          const row = grid[r] || [];
          const out = [];
          for (let c = 0; c < maxCols; c++) out.push(String(row[c] ?? ""));
          lines.push(out.join("\t"));
        }
        return lines.join("\n");
      }

      async function copyHtmlToClipboard(html, plainText) {
        const h = String(html || "");
        const t = String(plainText || "");

        if (document?.execCommand) {
          const host = document.createElement("div");
          host.contentEditable = "true";
          host.style.position = "fixed";
          host.style.left = "-10000px";
          host.style.top = "0";
          host.style.width = "1px";
          host.style.height = "1px";
          host.style.opacity = "0";
          host.innerHTML = h;

          document.body.appendChild(host);
          try {
            host.focus();
          } catch (_) {}

          const range = document.createRange();
          range.selectNodeContents(host);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);

          let ok = false;
          try {
            ok = Boolean(document.execCommand("copy"));
          } catch (_) {
            ok = false;
          }

          sel.removeAllRanges();
          host.remove();

          if (ok) return { ok: true, method: "execCommand" };
        }

        if (navigator?.clipboard?.write && typeof ClipboardItem !== "undefined") {
          const wrapped = wrapExcelHtmlFragment(h);
          const item = new ClipboardItem({
            "text/html": new Blob([wrapped], { type: "text/html" }),
            ...(t ? { "text/plain": new Blob([t], { type: "text/plain" }) } : {}),
          });
          await navigator.clipboard.write([item]);
          return { ok: true, method: "clipboard.write" };
        }

        if (navigator?.clipboard?.writeText) {
          await navigator.clipboard.writeText(t || "");
          return { ok: true, method: "writeText" };
        }

        return { ok: false, error: "Clipboard API not available." };
      }

      async function copyExcelLikeTableToClipboard(tableEl) {
        if (!tableEl) return { ok: false, error: "No table to copy." };
        const html = tableToHtml(tableEl);
        const tsv = tableToTsv(tableEl);
        return await copyHtmlToClipboard(html, tsv);
      }

      ns.templateExcelExport = {
        copyExcelLikeTableToClipboard,
        toExcelHtml: (tableEl) => (tableEl ? wrapExcelHtmlFragment(tableToHtml(tableEl)) : ""),
        toHtml: (tableEl) => (tableEl ? tableToHtml(tableEl) : ""),
        toTsv: (tableEl) => (tableEl ? tableToTsv(tableEl) : ""),
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/ui_core.js
    (function (ns) {
      "use strict";

      ns.ui = ns.ui || {};
      const ui = ns.ui;

      ui.state = ui.state || {
        model: null,
        selectedKey: null,
      };

      ui.constants = ui.constants || {};
      if (!ui.constants.TRACE_ALL_GLOBALS_KEY) ui.constants.TRACE_ALL_GLOBALS_KEY = "TRACE:ALL_GLOBALS";

      ui.$ =
        ui.$ ||
        function $(id) {
          return document.getElementById(id);
        };

      ui.setStatus =
        ui.setStatus ||
        function setStatus(message, isError) {
          const el = ui.$("statusBar");
          if (!el) return;
          el.textContent = message;
          el.style.color = isError ? "#fecaca" : "";
        };

      ui.setActiveTab =
        ui.setActiveTab ||
        function setActiveTab(name) {
          const tabs = document.querySelectorAll(".tab");
          const panels = document.querySelectorAll(".tab-panel");
          for (const t of tabs) t.classList.toggle("is-active", t.dataset.tab === name);
          for (const p of panels) p.classList.toggle("is-active", p.id === `tab-${name}`);
        };

      ui.highlightSource =
        ui.highlightSource ||
        function highlightSource(startLine, endLine) {
          const model = ui.state.model;
          if (!model) return;
          const ta = ui.$("abapInput");
          if (!ta) return;

          const startIdx = Math.max(1, Number(startLine || 1));
          const endIdx = Math.max(startIdx, Number(endLine || startIdx));

          const offsets = model.lineStartOffsets;
          const start = offsets[startIdx - 1] ?? 0;
          const end = offsets[endIdx] ?? ta.value.length;

          ta.focus();
          try {
            ta.setSelectionRange(start, end);
          } catch (_) {
            // ignore
          }

          const approxLineHeight = 16;
          ta.scrollTop = Math.max(0, (startIdx - 3) * approxLineHeight);
        };

      ui.downloadTextFile =
        ui.downloadTextFile ||
        function downloadTextFile(filename, text, mimeType) {
          const blob = new Blob([String(text || "")], { type: mimeType || "text/plain" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          window.setTimeout(() => URL.revokeObjectURL(url), 1000);
        };
    })(window.AbapFlow);


    </script>
        <script>
    // js/ui_abap_markers.js
    (function (ns) {
      "use strict";

      ns.ui = ns.ui || {};
      const ui = ns.ui;

      let currentMarkers = [];
      let rafPending = false;

      function getTextArea() {
        const ta = ui.$ ? ui.$("abapInput") : document.getElementById("abapInput");
        return ta instanceof HTMLTextAreaElement ? ta : null;
      }

      function getHost() {
        const host = ui.$ ? ui.$("abapTemplateMarkers") : document.getElementById("abapTemplateMarkers");
        return host instanceof HTMLElement ? host : null;
      }

      function schedulePositionUpdate() {
        if (rafPending) return;
        rafPending = true;
        requestAnimationFrame(() => {
          rafPending = false;
          updatePositions();
        });
      }

      function readLayoutMetrics(ta) {
        const style = window.getComputedStyle(ta);
        const lineHeight = Number.parseFloat(style.lineHeight) || 16;
        const paddingTop = Number.parseFloat(style.paddingTop) || 0;
        return { lineHeight, paddingTop };
      }

      function normalizeMarkers(markers) {
        const out = [];
        const seenLine = new Set();
        for (const m of Array.isArray(markers) ? markers : []) {
          const resultId = String(m?.resultId || "").trim();
          if (!resultId) continue;
          const startLine = Math.max(1, Math.floor(Number(m?.startLine || 0)));
          if (!Number.isFinite(startLine) || startLine <= 0) continue;
          const key = String(startLine);
          if (seenLine.has(key)) continue;
          seenLine.add(key);
          out.push({
            resultId,
            templateId: String(m?.templateId || "").trim(),
            objectId: String(m?.objectId || "").trim(),
            startLine,
            endLine: Math.max(startLine, Math.floor(Number(m?.endLine || startLine))),
          });
        }
        out.sort((a, b) => a.startLine - b.startLine);
        return out;
      }

      function clearMarkersUi() {
        currentMarkers = [];
        const host = getHost();
        if (!host) return;
        host.replaceChildren();
        host.classList.add("is-hidden");
      }

      function ensureWired() {
        const ta = getTextArea();
        if (!ta) return;
        if (ta.dataset.templateMarkersWired === "1") return;
        ta.dataset.templateMarkersWired = "1";

        ta.addEventListener("scroll", schedulePositionUpdate);
        window.addEventListener("resize", schedulePositionUpdate);

        ta.addEventListener("input", () => {
          // Avoid stale markers after code edits.
          clearMarkersUi();
        });
      }

      function renderMarkersUi(markers) {
        const ta = getTextArea();
        const host = getHost();
        if (!ta || !host) return;

        host.replaceChildren();

        currentMarkers = normalizeMarkers(markers);
        if (currentMarkers.length === 0) {
          host.classList.add("is-hidden");
          return;
        }

        host.classList.remove("is-hidden");

        for (const m of currentMarkers) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "code-marker";
          btn.textContent = "T";
          btn.dataset.resultId = m.resultId;
          btn.dataset.startLine = String(m.startLine);
          btn.dataset.endLine = String(m.endLine);

          const label = m.objectId ? `${m.objectId}${m.templateId ? ` (${m.templateId})` : ""}` : m.templateId || "template";
          btn.title = `Go to template output - ${label} (L${m.startLine})`;

          btn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (typeof ui.scrollToTemplateResultId === "function") {
              ui.scrollToTemplateResultId(m.resultId);
              return;
            }
            if (typeof ui.setActiveTab === "function") ui.setActiveTab("templates");
          });

          host.appendChild(btn);
        }

        schedulePositionUpdate();
      }

      function updatePositions() {
        const ta = getTextArea();
        const host = getHost();
        if (!ta || !host) return;
        if (host.classList.contains("is-hidden")) return;

        const { lineHeight, paddingTop } = readLayoutMetrics(ta);
        const scrollTop = ta.scrollTop;
        const markerSize = 14;
        const visibleTop = -lineHeight;
        const visibleBottom = ta.clientHeight + lineHeight;

        for (const btn of Array.from(host.querySelectorAll("button.code-marker"))) {
          const line = Math.max(1, Math.floor(Number(btn.dataset.startLine || 1)));
          const y = paddingTop + (line - 1) * lineHeight - scrollTop + Math.max(0, (lineHeight - markerSize) / 2);
          btn.style.top = `${Math.round(y)}px`;
          btn.style.display = y < visibleTop || y > visibleBottom ? "none" : "inline-flex";
        }
      }

      ui.renderAbapTemplateMarkers = function renderAbapTemplateMarkers(markers) {
        ensureWired();
        renderMarkersUi(markers);
      };

      ui.clearAbapTemplateMarkers = function clearAbapTemplateMarkers() {
        clearMarkersUi();
      };
    })(window.AbapFlow);

    </script>
        <script>
    // js/ui_anno.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;
      const ui = ns.ui;

      function sourceLink(label, sourceRef) {
        if (!sourceRef || !sourceRef.startLine) return utils.escapeHtml(label);
        const start = Number(sourceRef.startLine || 0);
        const end = Number(sourceRef.endLine || sourceRef.startLine || 0);
        return `<a href="#" class="source-link" data-start="${start}" data-end="${end}">${utils.escapeHtml(label)}</a>`;
      }

      function renderAnnoSummaryHtml(options) {
        const codeDesc = String(options?.codeDesc || "").trim();
        const userDesc = String(options?.userDesc || "").trim();
        const userNote = String(options?.userNote || "").trim();

        const lines = [];
        if (userDesc) lines.push(`<div><span class="anno-summary__k">Desc:</span> ${utils.escapeHtml(userDesc)}</div>`);
        if (codeDesc && (!userDesc || codeDesc !== userDesc)) {
          const label = userDesc ? "Desc (code)" : "Desc";
          lines.push(`<div><span class="anno-summary__k">${label}:</span> ${utils.escapeHtml(codeDesc)}</div>`);
        }
        if (userNote) {
          lines.push(`<div><span class="anno-summary__k">Note:</span> ${utils.escapeHtml(userNote)}</div>`);
        }

        if (!lines.length) return "";
        return `<div class="anno-summary">${lines.join("")}</div>`;
      }

      function renderInlineAnnoEditorHtml(options) {
        const annoKey = String(options?.annoKey || "").trim();
        if (!annoKey) return "";

        const titleText = String(options?.title || "Edit notes");
        const codeDesc = String(options?.codeDesc || "").trim();
        const userDesc = String(options?.userDesc || "").trim();
        const userNote = String(options?.userNote || "").trim();
        const annoType = String(options?.annoType || "").trim();
        const style = String(options?.style || "").trim();

        const attrs = options?.attrs && typeof options.attrs === "object" ? options.attrs : {};

        function toDataAttrs(field) {
          const parts = [];
          parts.push(`data-anno-type="${utils.escapeHtml(annoType)}"`);
          parts.push(`data-anno-key="${utils.escapeHtml(annoKey)}"`);
          parts.push(`data-anno-field="${utils.escapeHtml(field)}"`);

          for (const [nameRaw, valueRaw] of Object.entries(attrs)) {
            const name = String(nameRaw || "").trim();
            if (!name) continue;
            if (!name.startsWith("data-")) continue;
            if (!/^data-[a-z0-9-]+$/.test(name)) continue;
            parts.push(`${name}="${utils.escapeHtml(String(valueRaw ?? ""))}"`);
          }

          return parts.join(" ");
        }

        const styleAttr = style ? ` style="${utils.escapeHtml(style)}"` : "";

        return `<details class="param-notes"${styleAttr}>
            <summary class="param-notes__summary">${utils.escapeHtml(titleText)}</summary>
            <div class="param-notes__body">
              <div class="anno-grid">
                <div class="anno-label">Description (from code)</div>
                <div class="anno-code${codeDesc ? "" : " anno-code--empty"}">${utils.escapeHtml(codeDesc || "(none)")}</div>

                <div class="anno-label">Your description</div>
                <textarea class="textarea param-notes__input" rows="2" ${toDataAttrs("description")} placeholder="Add your description (stored locally)...">${utils.escapeHtml(
                  userDesc,
                )}</textarea>

                <div class="anno-label">Your note</div>
                <textarea class="textarea param-notes__input" rows="3" ${toDataAttrs("note")} placeholder="Add notes (stored locally)...">${utils.escapeHtml(
                  userNote,
                )}</textarea>
              </div>
            </div>
          </details>`;
      }

      function wireInlineAnnoEditors(rootEl) {
        const model = ui.state.model;
        if (!model || !ns.notes) return;
        const root = rootEl || ui.$("objectDetails");
        if (!root) return;
        const inputs = Array.from(root.querySelectorAll("textarea.param-notes__input[data-anno-key][data-anno-field]"));
        if (inputs.length === 0) return;

        for (const el of inputs) {
          let saveTimer = null;

          function saveNow() {
            if (saveTimer) {
              clearTimeout(saveTimer);
              saveTimer = null;
            }
            const key = String(el.dataset.annoKey || "");
            const field = String(el.dataset.annoField || "");
            const annoType = String(el.dataset.annoType || "");
            const routineKey = String(el.dataset.routineKey || "");
            const paramName = String(el.dataset.paramName || "");
            const scopeKey = String(el.dataset.scopeKey || "");
            const declKind = String(el.dataset.declKind || "");
            const varName = String(el.dataset.varName || "");
            const typeScopeKey = String(el.dataset.typeScopeKey || "");
            const typeName = String(el.dataset.typeName || "");
            const fieldPath = String(el.dataset.fieldPath || "");
            const value = String(el.value || "").trim();
            if (!key) return;

            if (field === "note") ns.notes.setEntry(key, { note: value });
            else ns.notes.setEntry(key, { description: value });

            function applyUserFields(target) {
              if (!target) return;
              if (field === "note") {
                if (value) target.userNote = value;
                else delete target.userNote;
              } else {
                if (value) target.userDescription = value;
                else delete target.userDescription;
              }
            }

            if (annoType === "param") {
              const routine = model.nodes.get(routineKey);
              const p =
                routine?.params?.find((x) => String(x.name || "").toLowerCase() === String(paramName || "").toLowerCase()) || null;
              applyUserFields(p);
            } else if (annoType === "decl") {
              const dk = String(declKind || "").toUpperCase();
              const vnLower = String(varName || "").toLowerCase();
              if (scopeKey === "PROGRAM") {
                const list = dk === "CONSTANTS" ? model.globalConstants : model.globalData;
                const d = list?.find((x) => String(x.variableName || "").toLowerCase() === vnLower) || null;
                applyUserFields(d);
              } else {
                const routine = model.nodes.get(scopeKey);
                const list = dk === "CONSTANTS" ? routine?.localConstants : routine?.localData;
                const d = list?.find((x) => String(x.variableName || "").toLowerCase() === vnLower) || null;
                applyUserFields(d);
              }
            } else if (annoType === "routine") {
              const rk = routineKey || key;
              if (rk === "PROGRAM") applyUserFields(model);
              else applyUserFields(model.nodes.get(rk));
            } else if (annoType === "typefield") {
              const sk = typeScopeKey || "PROGRAM";
              const tn = String(typeName || "").trim();
              const fp = String(fieldPath || "").trim();
              if (tn && fp && model.typeDefs && typeof model.typeDefs.get === "function") {
                const typeKey = `${sk}|${tn.toLowerCase()}`;
                const typeDef = model.typeDefs.get(typeKey) || null;
                const typeField = typeDef?.fields?.get ? typeDef.fields.get(fp.toLowerCase()) : null;
                applyUserFields(typeField);

                function syncVirtualDecls(list) {
                  const arr = Array.isArray(list) ? list : [];
                  for (const d of arr) {
                    if (!d || !d.isVirtual) continue;
                    const origin = d.virtualOrigin && typeof d.virtualOrigin === "object" ? d.virtualOrigin : null;
                    if (!origin || origin.kind !== "typeField") continue;
                    if (String(origin.typeScopeKey || "PROGRAM") !== sk) continue;
                    if (String(origin.typeName || "").trim().toLowerCase() !== tn.toLowerCase()) continue;
                    if (String(origin.fieldPath || "").trim().toLowerCase() !== fp.toLowerCase()) continue;
                    applyUserFields(d);
                  }
                }

                syncVirtualDecls(model.globalData);
                syncVirtualDecls(model.globalConstants);
                for (const node of model.nodes.values()) {
                  syncVirtualDecls(node?.localData);
                  syncVirtualDecls(node?.localConstants);
                }
              }
            }

            if (document.getElementById("tab-sequence").classList.contains("is-active") && typeof ui.renderSequence === "function") {
              ui.renderSequence();
            }
            if (document.getElementById("tab-templates")?.classList.contains("is-active") && typeof ui.renderTemplates === "function") {
              ui.renderTemplates();
            }
          }

          function scheduleSave() {
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = window.setTimeout(saveNow, 350);
          }

          el.addEventListener("input", scheduleSave);
          el.addEventListener("blur", saveNow);
        }
      }

      function wireNotesEditorForKey(objectKey, applyLocal, options) {
        if (!objectKey || !ns.notes) return;
        const descEl = ui.$("annoDesc");
        const noteEl = ui.$("annoNote");
        const clearBtn = ui.$("btnAnnoClear");
        const statusEl = ui.$("annoSaveState");
        if (!descEl || !noteEl || !statusEl) return;

        let saveTimer = null;

        function saveNow() {
          if (saveTimer) {
            clearTimeout(saveTimer);
            saveTimer = null;
          }
          const description = String(descEl.value || "").trim();
          const note = String(noteEl.value || "").trim();
          ns.notes.setEntry(objectKey, { description, note });
          if (applyLocal) applyLocal(description, note);

          statusEl.textContent = "Saved.";
          window.setTimeout(() => {
            if (statusEl.textContent === "Saved.") statusEl.textContent = "";
          }, 1200);

          if (options?.rerenderSequence && document.getElementById("tab-sequence").classList.contains("is-active") && typeof ui.renderSequence === "function") {
            ui.renderSequence();
          }
          if (document.getElementById("tab-templates")?.classList.contains("is-active") && typeof ui.renderTemplates === "function") {
            ui.renderTemplates();
          }
        }

        function scheduleSave() {
          statusEl.textContent = "Saving...";
          if (saveTimer) clearTimeout(saveTimer);
          saveTimer = window.setTimeout(saveNow, 350);
        }

        descEl.addEventListener("input", scheduleSave);
        noteEl.addEventListener("input", scheduleSave);
        descEl.addEventListener("blur", saveNow);
        noteEl.addEventListener("blur", saveNow);

        if (clearBtn) {
          clearBtn.addEventListener("click", () => {
            descEl.value = "";
            noteEl.value = "";
            saveNow();
            if (typeof ui.renderDetails === "function") ui.renderDetails();
          });
        }
      }

      ui.sourceLink = sourceLink;
      ui.renderAnnoSummaryHtml = renderAnnoSummaryHtml;
      ui.renderInlineAnnoEditorHtml = renderInlineAnnoEditorHtml;
      ui.wireInlineAnnoEditors = wireInlineAnnoEditors;
      ui.wireNotesEditorForKey = wireNotesEditorForKey;
    })(window.AbapFlow);

    </script>
        <script>
    // js/ui_objects_list.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;
      const ui = ns.ui;
      const state = ui.state;

      function getDisplayObjects(model) {
        const out = [];
        out.push({
          key: "PROGRAM",
          kind: "PROGRAM",
          name: "(Globals)",
          depth: "",
          isDefined: true,
          isInCycle: false,
          paramsCount: 0,
          localDataCount: model.globalData.length,
          localConstCount: model.globalConstants.length,
          writesCount: 0,
          assignmentsCount: 0,
        });

        const nodes = Array.from(model.nodes.values()).sort((a, b) => {
          if (a.depth !== b.depth) return a.depth - b.depth;
          const ka = a.kind === "EVENT" ? 0 : a.kind === "FORM" ? 1 : 2;
          const kb = b.kind === "EVENT" ? 0 : b.kind === "FORM" ? 1 : 2;
          if (ka !== kb) return ka - kb;
          return a.name.localeCompare(b.name);
        });

        for (const n of nodes) out.push(n);
        return out;
      }

      function selectObject(key, syncTrace) {
        state.selectedKey = key;
        if (typeof ui.renderObjectsTable === "function") ui.renderObjectsTable();
        if (typeof ui.renderDetails === "function") ui.renderDetails();

        if (syncTrace && state.model && key !== "PROGRAM") {
          const sel = ui.$("traceSubroutine");
          if (sel) sel.value = key;
          if (typeof ui.updateTraceVariables === "function") ui.updateTraceVariables();
        }
      }

      function renderObjectsTable() {
        const model = state.model;
        const table = ui.$("objectsTable");
        const tbody = table ? table.querySelector("tbody") : null;
        if (!tbody) return;
        tbody.innerHTML = "";
        if (!model) return;

        const filter = String(ui.$("objectSearch")?.value || "").trim().toLowerCase();
        const objects = getDisplayObjects(model);
        const filtered = filter
          ? objects.filter((o) => `${o.kind} ${o.name}`.toLowerCase().includes(filter) || String(o.key).toLowerCase().includes(filter))
          : objects;

        for (const obj of filtered) {
          const tr = document.createElement("tr");
          tr.dataset.key = obj.key;
          if (obj.key === state.selectedKey) tr.classList.add("is-selected");

          const isDefined = obj.isDefined !== false;
          const cycle = obj.isInCycle === true;
          const definedBadge = isDefined ? '<span class="badge badge-ok">Yes</span>' : '<span class="badge">No</span>';
          const cycleBadge = cycle ? '<span class="badge badge-danger">Yes</span>' : '<span class="badge">No</span>';

          tr.innerHTML = `
            <td>${utils.escapeHtml(obj.kind)}</td>
            <td>${utils.escapeHtml(obj.name)}</td>
            <td>${utils.escapeHtml(String(obj.depth ?? ""))}</td>
            <td>${utils.escapeHtml(String(obj.paramsCount ?? obj.params?.length ?? 0))}</td>
            <td>${utils.escapeHtml(String(obj.localDataCount ?? obj.localData?.length ?? 0))}</td>
            <td>${utils.escapeHtml(String(obj.localConstCount ?? obj.localConstants?.length ?? 0))}</td>
            <td>${utils.escapeHtml(String(obj.writesCount ?? obj.writes?.length ?? 0))}</td>
            <td>${utils.escapeHtml(String(obj.assignmentsCount ?? obj.assignments?.length ?? 0))}</td>
            <td>${definedBadge}</td>
            <td>${cycleBadge}</td>
          `;

          tr.addEventListener("click", () => selectObject(obj.key, true));
          tbody.appendChild(tr);
        }
      }

      ui.selectObject = selectObject;
      ui.renderObjectsTable = renderObjectsTable;
    })(window.AbapFlow);


    </script>
        <script>
    // js/ui_objects_details.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;
      const ui = ns.ui;
      const state = ui.state;

      const sourceLink = ui.sourceLink;
      const renderAnnoSummaryHtml = ui.renderAnnoSummaryHtml;
      const renderInlineAnnoEditorHtml = ui.renderInlineAnnoEditorHtml;

      function isSimpleStructFieldName(name) {
        const s = String(name || "");
        if (!s.includes("-")) return false;
        if (s.includes("->") || s.includes("=>") || s.includes("~")) return false;
        return true;
      }

      function resolveTypeFieldForVirtualDecl(model, decl) {
        const origin = decl?.virtualOrigin && typeof decl.virtualOrigin === "object" ? decl.virtualOrigin : null;
        if (!origin || origin.kind !== "typeField") return null;

        const typeScopeKey = String(origin.typeScopeKey || "").trim() || "PROGRAM";
        const typeName = String(origin.typeName || "").trim();
        const fieldPath = String(origin.fieldPath || "").trim();
        if (!typeName || !fieldPath) return null;

        const typeKey = `${typeScopeKey}|${typeName.toLowerCase()}`;
        const typeDef = model?.typeDefs?.get ? model.typeDefs.get(typeKey) : null;
        const field = typeDef?.fields?.get ? typeDef.fields.get(fieldPath.toLowerCase()) : null;
        if (!field) return null;

        return { typeScopeKey, typeName, fieldPath, field };
      }

      function renderDeclInner(model, decl, scopeKey, options) {
        const name = String(decl?.variableName || "").trim();
        const declKind = String(decl?.declKind || "").trim();
        const upperKind = declKind.toUpperCase();

        const isVirtualTypeField = Boolean(decl?.isVirtual && decl?.virtualOrigin?.kind === "typeField");
        const typeField = isVirtualTypeField ? resolveTypeFieldForVirtualDecl(model, decl) : null;

        const codeDesc = String((typeField?.field?.description ?? decl?.description) || "").trim();
        const userDesc = String((typeField?.field?.userDescription ?? decl?.userDescription) || "").trim();
        const userNote = String((typeField?.field?.userNote ?? decl?.userNote) || "").trim();
        const shownDesc = userDesc || codeDesc;

        const dt = decl?.dataType ? ` TYPE ${decl.dataType}` : options?.showUnknownType ? " TYPE ?" : "";
        const valueKeyword = upperKind === "PARAMETERS" ? "DEFAULT" : "VALUE";
        const valuePart = decl?.value ? ` ${valueKeyword} ${decl.value}` : "";
        const desc = shownDesc ? ` - ${shownDesc}` : "";

        const summary = renderAnnoSummaryHtml({ codeDesc, userDesc, userNote });

        let edit = "";
        if (typeField && ns.notes?.makeTypeFieldKey) {
          const key = ns.notes.makeTypeFieldKey(typeField.typeScopeKey, typeField.typeName, typeField.fieldPath);
          edit = key
            ? renderInlineAnnoEditorHtml({
                title: `Edit type field notes  ${typeField.typeName}-${typeField.fieldPath}`,
                codeDesc,
                userDesc,
                userNote,
                annoType: "typefield",
                annoKey: key,
                attrs: {
                  "data-type-scope-key": typeField.typeScopeKey,
                  "data-type-name": typeField.typeName,
                  "data-field-path": typeField.fieldPath,
                },
              })
            : "";
        } else if (ns.notes?.makeDeclKey) {
          const key = ns.notes.makeDeclKey(scopeKey, declKind, name);
          edit = key
            ? renderInlineAnnoEditorHtml({
                title: "Edit notes",
                codeDesc,
                userDesc,
                userNote,
                annoType: "decl",
                annoKey: key,
                attrs: {
                  "data-scope-key": scopeKey,
                  "data-decl-kind": declKind,
                  "data-var-name": name,
                },
              })
            : "";
        }

        const labelName = String(options?.labelName || name);
        return `${sourceLink(`${labelName}${dt}${valuePart}${desc}`, decl?.sourceRef)}${summary}${edit}`;
      }

      function renderDeclListGrouped(model, decls, scopeKey, options) {
        const list = Array.isArray(decls) ? decls : [];
        if (!list.length) return "";

        const fieldsByRoot = new Map();
        for (const d of list) {
          const name = String(d?.variableName || "").trim();
          if (!isSimpleStructFieldName(name)) continue;
          const root = name.split("-")[0] || "";
          const rootLower = root.toLowerCase();
          if (!rootLower) continue;
          if (!fieldsByRoot.has(rootLower)) fieldsByRoot.set(rootLower, []);
          fieldsByRoot.get(rootLower).push(d);
        }

        const rendered = new Set();
        const out = [];

        function renderSingle(decl, extra) {
          return `<li class="param-item">${renderDeclInner(model, decl, scopeKey, { ...options, ...(extra || {}) })}</li>`;
        }

        function renderGroup(rootDecl, rootName, fields) {
          const rootLower = String(rootName || "").toLowerCase();
          if (rendered.has(rootLower)) return;
          rendered.add(rootLower);

          const sorted = (fields || [])
            .slice()
            .sort((a, b) => String(a?.variableName || "").localeCompare(String(b?.variableName || "")));

          const headerInner = rootDecl
            ? renderDeclInner(model, rootDecl, scopeKey, options)
            : `<span>${utils.escapeHtml(rootName || "")}</span>`;

          const fieldItems = sorted
            .map((d) => {
              const full = String(d?.variableName || "").trim();
              const rel = full.toLowerCase().startsWith(`${rootLower}-`) ? full.slice(rootLower.length + 1) : full;
              const depth = rel.split("-").filter(Boolean).length;
              const pad = Math.max(0, depth - 1) * 14;
              return `<li class="param-item decl-group__field" style="padding-left:${pad}px">${renderDeclInner(model, d, scopeKey, {
                ...options,
                showUnknownType: false,
                labelName: rel,
              })}</li>`;
            })
            .join("");

          out.push(`<li class="decl-group">
            <div class="decl-group__header param-item">
              <button type="button" class="decl-group__toggle" aria-expanded="true" title="Collapse/expand"></button>
              <div class="decl-group__header-content">${headerInner}</div>
            </div>
            <ul class="list decl-group__fields">${fieldItems || "<li>(none)</li>"}</ul>
          </li>`);
        }

        for (const d of list) {
          const name = String(d?.variableName || "").trim();
          if (isSimpleStructFieldName(name)) {
            const rootLower = String(name.split("-")[0] || "").toLowerCase();
            if (fieldsByRoot.has(rootLower)) continue;
          }

          const rootLower = name.toLowerCase();
          const fields = fieldsByRoot.get(rootLower) || null;
          if (fields) {
            renderGroup(d, name, fields);
          } else {
            out.push(renderSingle(d));
          }
        }

        for (const [rootLower, fields] of fieldsByRoot.entries()) {
          if (rendered.has(rootLower)) continue;
          renderGroup(null, rootLower, fields);
        }

        return out.join("");
      }

      function renderProgramDetails(model) {
        const globalsData = renderDeclListGrouped(model, model.globalData || [], "PROGRAM", { showUnknownType: true });
        const globalsConst = renderDeclListGrouped(model, model.globalConstants || [], "PROGRAM", { showUnknownType: true });

        const userDesc = String(model.userDescription || "").trim();
        const userNote = String(model.userNote || "").trim();
        const notesSection = `
          <div class="section">
            <div class="section__title">Notes</div>
            <div class="anno-grid">
              <div class="anno-label">Your description</div>
              <textarea id="annoDesc" class="textarea" rows="2" placeholder="Add your description (stored locally)...">${utils.escapeHtml(
                userDesc,
              )}</textarea>

              <div class="anno-label">Your note</div>
              <textarea id="annoNote" class="textarea" rows="4" placeholder="Add notes (stored locally)...">${utils.escapeHtml(
                userNote,
              )}</textarea>

              <div class="anno-actions">
                <button id="btnAnnoClear" class="btn" type="button">Clear</button>
                <span id="annoSaveState" class="anno-status"></span>
              </div>
            </div>
          </div>
        `;

        return `
          <h3>PROGRAM (Globals)</h3>
          ${notesSection}
          <div class="meta">Global DATA: ${model.globalData.length} ? Global CONSTANTS: ${model.globalConstants.length}</div>
          <div class="section">
            <div class="section__title">Global DATA</div>
            <ul class="list">${globalsData || "<li>(none)</li>"}</ul>
          </div>
          <div class="section">
            <div class="section__title">Global CONSTANTS</div>
            <ul class="list">${globalsConst || "<li>(none)</li>"}</ul>
          </div>
        `;
      }

      function renderRoutineDetails(r) {
        const model = state.model;
        const lineInfo = r.sourceRef?.startLine ? `Lines ${r.sourceRef.startLine}-${r.sourceRef.endLine || r.sourceRef.startLine}` : "Lines ?";

        const params = r.params
          .map((p) => {
            const dt = p.dataType ? ` TYPE ${p.dataType}` : "";
            const key = ns.notes?.makeParamKey ? ns.notes.makeParamKey(r.key, p.name) : "";
            const codeDesc = String(p.description || "").trim();
            const userDesc = String(p.userDescription || "").trim();
            const userNote = String(p.userNote || "").trim();
            const shownDesc = userDesc || codeDesc;
            const desc = shownDesc ? ` - ${shownDesc}` : "";
            const summary = renderAnnoSummaryHtml({ codeDesc, userDesc, userNote });

            const edit = key
              ? renderInlineAnnoEditorHtml({
                  title: "Edit notes",
                  codeDesc,
                  userDesc,
                  userNote,
                  annoType: "param",
                  annoKey: key,
                  attrs: {
                    "data-routine-key": r.key,
                    "data-param-name": String(p.name || ""),
                  },
                })
              : "";

            return `<li class="param-item">${sourceLink(`${p.kind} ${p.name}${dt}${desc}`, p.sourceRef || r.sourceRef)}${summary}${edit}</li>`;
          })
          .join("");

        const localsData = renderDeclListGrouped(model, r.localData || [], r.key, { showUnknownType: false });

        const localsConst = renderDeclListGrouped(model, r.localConstants || [], r.key, { showUnknownType: false });

        const calls = r.calls
          .map((e) => {
            const callee = model.nodes.get(e.toKey);
            const name = callee ? `${callee.kind} ${callee.name}` : e.targetName;
            const codeDesc = String(callee?.description || "").trim();
            const userDesc = String(callee?.userDescription || "").trim();
            const userNote = String(callee?.userNote || "").trim();
            const summary = renderAnnoSummaryHtml({ codeDesc, userDesc, userNote });
            const key = String(e.toKey || "");

            const edit = key
              ? renderInlineAnnoEditorHtml({
                  title: "Edit notes",
                  codeDesc,
                  userDesc,
                  userNote,
                  annoType: "routine",
                  annoKey: key,
                  attrs: { "data-routine-key": key },
                })
              : "";

            return `<li class="param-item">${sourceLink(`PERFORM ${name}`, e.sourceRef)}${e.isInCycle ? ' <span class="badge badge-danger">cycle</span>' : ""}${summary}${edit}</li>`;
          })
          .join("");

        const calledBy = r.calledBy
          .map((e) => {
            const caller = model.nodes.get(e.fromKey);
            const name = caller ? `${caller.kind} ${caller.name}` : e.fromKey;
            const codeDesc = String(caller?.description || "").trim();
            const userDesc = String(caller?.userDescription || "").trim();
            const userNote = String(caller?.userNote || "").trim();
            const summary = renderAnnoSummaryHtml({ codeDesc, userDesc, userNote });
            const key = String(e.fromKey || "");

            const edit = key
              ? renderInlineAnnoEditorHtml({
                  title: "Edit notes",
                  codeDesc,
                  userDesc,
                  userNote,
                  annoType: "routine",
                  annoKey: key,
                  attrs: { "data-routine-key": key },
                })
              : "";

            return `<li class="param-item">${sourceLink(`Called by ${name}`, e.sourceRef)}${summary}${edit}</li>`;
          })
          .join("");

        const writes = r.writes.map((w) => `<li>${sourceLink(`${w.variableName}  ?  ${w.statement}`, w.sourceRef)}</li>`).join("");

        const statementSections = (() => {
          const registry = ns.abapObjects?.getRegistry?.() || null;
          const defs = Array.isArray(registry?.statementObjects) ? registry.statementObjects : [];
          const items = Array.isArray(r.statementItems) ? r.statementItems : [];
          if (!defs.length || !items.length) return "";

          const byObjectId = new Map();
          for (const it of items) {
            const objectId = String(it?.objectId || "").trim();
            if (!objectId) continue;
            if (!byObjectId.has(objectId)) byObjectId.set(objectId, []);
            byObjectId.get(objectId).push(it);
          }

          function labelForItem(objectId, payload) {
            if (objectId === "assignment") {
              const lhs = String(payload?.lhs || "").trim();
              const rhs = String(payload?.rhs || "").trim();
              if (lhs && rhs) return `${lhs} = ${rhs}`;
            }

            if (objectId === "if") {
              const kind = String(payload?.kind || "IF").trim().toUpperCase() || "IF";
              const cond = String(payload?.condition || "").trim();
              return cond ? `${kind} ${cond}` : kind;
            }

            const stmt = String(payload?.statement || payload?.raw || "").trim();
            if (stmt) return stmt;

            const kind = String(payload?.kind || "").trim();
            return kind || String(objectId || "Statement");
          }

          const sections = [];
          for (const def of defs) {
            const objectId = String(def?.id || "").trim();
            if (!objectId) continue;
            const list = byObjectId.get(objectId) || [];
            if (!list.length) continue;

            const rows = list
              .map((it) => {
                const payload = it?.payload || null;
                const src = it?.sourceRef || payload?.sourceRef || null;
                return `<li>${sourceLink(labelForItem(objectId, payload), src)}</li>`;
              })
              .join("");

            sections.push(`
              <div class="section">
                <div class="section__title">${utils.escapeHtml(String(def?.label || objectId))}</div>
                <ul class="list">${rows || "<li>(none)</li>"}</ul>
              </div>
            `);
          }

          return sections.join("");
        })();

        const codeDesc = String(r.description || "").trim();
        const userDesc = String(r.userDescription || "").trim();
        const userNote = String(r.userNote || "").trim();

        const notesSection = `
          <div class="section">
            <div class="section__title">Notes</div>
            <div class="anno-grid">
              <div class="anno-label">Description (from code)</div>
              <div class="anno-code${codeDesc ? "" : " anno-code--empty"}">${utils.escapeHtml(codeDesc || "(none)")}</div>

              <div class="anno-label">Your description</div>
              <textarea id="annoDesc" class="textarea" rows="2" placeholder="Add your description (stored locally)...">${utils.escapeHtml(
                userDesc,
              )}</textarea>

              <div class="anno-label">Your note</div>
              <textarea id="annoNote" class="textarea" rows="4" placeholder="Add notes (stored locally)...">${utils.escapeHtml(
                userNote,
              )}</textarea>

              <div class="anno-actions">
                <button id="btnAnnoClear" class="btn" type="button">Clear</button>
                <span id="annoSaveState" class="anno-status"></span>
              </div>
            </div>
          </div>
        `;

        return `
          <h3>${utils.escapeHtml(r.kind)} ${utils.escapeHtml(r.name)}</h3>
          <div class="meta">${utils.escapeHtml(lineInfo)} ? Defined: ${r.isDefined ? "Yes" : "No"} ? Cycle: ${r.isInCycle ? "Yes" : "No"} ? Depth: ${r.depth}</div>
          ${notesSection}
          <div class="section">
            <div class="section__title">Parameters</div>
            <ul class="list">${params || "<li>(none)</li>"}</ul>
          </div>
          <div class="section">
            <div class="section__title">Local DATA</div>
            <ul class="list">${localsData || "<li>(none)</li>"}</ul>
          </div>
          <div class="section">
            <div class="section__title">Local CONSTANTS</div>
            <ul class="list">${localsConst || "<li>(none)</li>"}</ul>
          </div>
          <div class="section">
            <div class="section__title">Writes</div>
            <ul class="list">${writes || "<li>(none)</li>"}</ul>
          </div>
          ${statementSections}
          <div class="section">
            <div class="section__title">Calls (PERFORM)</div>
            <ul class="list">${calls || "<li>(none)</li>"}</ul>
          </div>
          <div class="section">
            <div class="section__title">Called by</div>
            <ul class="list">${calledBy || "<li>(none)</li>"}</ul>
          </div>
        `;
      }

      function renderDetails() {
        const model = state.model;
        const el = ui.$("objectDetails");
        if (!el) return;

        if (!model) {
          el.textContent = "Analyze to see details.";
          el.classList.add("empty");
          return;
        }

        if (!state.selectedKey) {
          el.textContent = "Select an object to see details.";
          el.classList.add("empty");
          return;
        }

        el.classList.remove("empty");

        if (!el.dataset.declGroupsBound) {
          el.dataset.declGroupsBound = "1";
          el.addEventListener("click", (ev) => {
            const t = ev.target;
            if (!(t instanceof HTMLElement)) return;
            const btn = t.closest("button.decl-group__toggle");
            if (!btn) return;
            const group = btn.closest(".decl-group");
            if (!group) return;
            ev.preventDefault();
            ev.stopPropagation();
            const collapsed = group.classList.toggle("is-collapsed");
            btn.setAttribute("aria-expanded", String(!collapsed));
          });
        }

        if (state.selectedKey === "PROGRAM") {
          el.innerHTML = renderProgramDetails(model);
          ui.wireNotesEditorForKey(
            "PROGRAM",
            (description, note) => {
              if (description) model.userDescription = description;
              else delete model.userDescription;
              if (note) model.userNote = note;
              else delete model.userNote;
            },
            { rerenderSequence: false },
          );
          ui.wireInlineAnnoEditors();
          return;
        }

        const r = model.nodes.get(state.selectedKey);
        if (!r) {
          el.textContent = "Object not found.";
          return;
        }

        el.innerHTML = renderRoutineDetails(r);
        ui.wireNotesEditorForKey(
          r.key,
          (description, note) => {
            if (description) r.userDescription = description;
            else delete r.userDescription;
            if (note) r.userNote = note;
            else delete r.userNote;
          },
          { rerenderSequence: true },
        );
        ui.wireInlineAnnoEditors();
      }

      ui.renderDetails = renderDetails;
    })(window.AbapFlow);

    </script>
        <script>
    // js/ui_abap_objects_config.js
    (function (ns) {
      "use strict";

      const ui = ns.ui;
      const utils = ns.utils;

      const state = {
        selectedId: "",
        lastListHash: "",
        lastTplHash: "",
      };

      function $(id) {
        return ui.$(id);
      }

      function asNonEmptyString(x) {
        const s = String(x ?? "").trim();
        return s ? s : "";
      }

      function isPlainObject(x) {
        return Boolean(x) && typeof x === "object" && !Array.isArray(x);
      }

      function safeJsonParse(text) {
        if (utils && typeof utils.safeJsonParse === "function") return utils.safeJsonParse(text);
        try {
          return { ok: true, value: JSON.parse(String(text || "")) };
        } catch (e) {
          return { ok: false, error: String(e?.message || e) };
        }
      }

      function deepClone(value) {
        if (value == null) return value;
        if (value instanceof RegExp) return new RegExp(value.source, value.flags);
        if (Array.isArray(value)) return value.map((x) => deepClone(x));
        if (typeof value === "object") {
          const out = {};
          for (const [k, v] of Object.entries(value)) out[k] = deepClone(v);
          return out;
        }
        return value;
      }

      function normalizeRegexForEditor(obj) {
        if (!isPlainObject(obj)) return obj;
        const parse = isPlainObject(obj.parse) ? obj.parse : null;
        const kind = asNonEmptyString(parse?.kind).toLowerCase();
        if (kind !== "regex") return obj;

        const rx = parse?.regex;
        if (rx instanceof RegExp) {
          parse.regex = rx.source;
          if (rx.flags) parse.flags = rx.flags;
        } else if (isPlainObject(rx)) {
          const source = asNonEmptyString(rx.source);
          const flags = asNonEmptyString(rx.flags);
          if (source) {
            parse.regex = source;
            if (flags) parse.flags = flags;
          }
        }

        return obj;
      }

      function stringifyForEditor(obj) {
        const clone = deepClone(obj);
        normalizeRegexForEditor(clone);
        return JSON.stringify(clone, null, 2);
      }

      function getCustomStore() {
        return ns.abapObjects?.customStore || null;
      }

      function getBaseConfig() {
        return ns.abapObjectsMasterConfig || null;
      }

      function getBaseObjects() {
        const base = getBaseConfig();
        return Array.isArray(base?.objects) ? base.objects : [];
      }

      function getBaseIndexByIdLower() {
        const map = new Map();
        const base = getBaseObjects();
        for (let i = 0; i < base.length; i++) {
          const id = asNonEmptyString(base[i]?.id);
          if (!id) continue;
          const lower = id.toLowerCase();
          if (!map.has(lower)) map.set(lower, i);
        }
        return map;
      }

      function buildEntries() {
        const base = getBaseObjects();
        const byLower = getBaseIndexByIdLower();
        const storeApi = getCustomStore();
        const store = storeApi ? storeApi.loadStore() : { objects: {}, disabled: {} };

        const disabledSet = new Set(
          Object.entries(store.disabled || {})
            .filter(([, flag]) => Boolean(flag))
            .map(([id]) => String(id).trim().toLowerCase())
            .filter(Boolean),
        );

        const storeByLower = new Map();
        for (const [id, obj] of Object.entries(store.objects || {})) {
          const oid = asNonEmptyString(obj?.id) || asNonEmptyString(id);
          if (!oid) continue;
          storeByLower.set(oid.toLowerCase(), { ...(obj || {}), id: oid });
        }

        const entries = [];

        for (const baseObj of base) {
          const id = asNonEmptyString(baseObj?.id);
          if (!id) continue;
          const lower = id.toLowerCase();
          const override = storeByLower.get(lower) || null;
          entries.push({
            id,
            idLower: lower,
            kind: asNonEmptyString((override || baseObj)?.kind),
            label: asNonEmptyString((override || baseObj)?.label) || id,
            isBase: true,
            isCustom: false,
            isOverride: Boolean(override),
            disabled: disabledSet.has(lower),
            baseDef: baseObj,
            def: override || baseObj,
          });
        }

        const custom = [];
        for (const obj of storeByLower.values()) {
          const id = asNonEmptyString(obj?.id);
          if (!id) continue;
          const lower = id.toLowerCase();
          if (byLower.has(lower)) continue;
          custom.push({
            id,
            idLower: lower,
            kind: asNonEmptyString(obj?.kind),
            label: asNonEmptyString(obj?.label) || id,
            isBase: false,
            isCustom: true,
            isOverride: false,
            disabled: disabledSet.has(lower),
            baseDef: null,
            def: obj,
          });
        }

        custom.sort((a, b) => a.id.localeCompare(b.id));
        return entries.concat(custom);
      }

      function computeListHash(entries, query) {
        const q = asNonEmptyString(query).toLowerCase();
        return `${q}::${entries
          .map((e) => `${e.idLower}:${e.isOverride ? 1 : 0}:${e.isCustom ? 1 : 0}:${e.disabled ? 1 : 0}`)
          .join("|")}`;
      }

      function listMatchesQuery(entry, query) {
        const q = asNonEmptyString(query).toLowerCase();
        if (!q) return true;
        const id = entry.idLower;
        const label = String(entry.label || "").toLowerCase();
        return id.includes(q) || label.includes(q) || String(entry.kind || "").toLowerCase().includes(q);
      }

      function renderList() {
        const host = $("abapObjCfgList");
        if (!host) return;

        const entries = buildEntries();
        const q = $("abapObjCfgSearch")?.value || "";
        const hash = computeListHash(entries, q);
        if (hash === state.lastListHash) return;
        state.lastListHash = hash;

        host.replaceChildren();

        const filtered = entries.filter((e) => listMatchesQuery(e, q));
        for (const e of filtered) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "objcfg-item";
          if (e.idLower === String(state.selectedId || "").toLowerCase()) btn.classList.add("is-active");
          if (e.disabled) btn.classList.add("is-disabled");
          if (e.isCustom) btn.classList.add("is-custom");
          if (e.isOverride) btn.classList.add("is-override");

          const title = document.createElement("div");
          title.className = "objcfg-item__title";
          title.textContent = e.id;

          const meta = document.createElement("div");
          meta.className = "objcfg-item__meta";
          const origin = e.isCustom ? "custom" : e.isOverride ? "override" : "built-in";
          meta.textContent = `${origin}  ${asNonEmptyString(e.kind) || "?"}`;

          btn.appendChild(title);
          btn.appendChild(meta);
          btn.addEventListener("click", () => selectObject(e.id));
          host.appendChild(btn);
        }
      }

      function escapeHtml(s) {
        if (utils && typeof utils.escapeHtml === "function") return utils.escapeHtml(s);
        return String(s ?? "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function buildTemplateCatalog() {
        const byIdLower = new Map();

        for (const obj of getBaseObjects()) {
          for (const t of Array.isArray(obj?.templates) ? obj.templates : []) {
            const id = asNonEmptyString(t?.id);
            if (!id) continue;
            const lower = id.toLowerCase();
            if (byIdLower.has(lower)) continue;
            byIdLower.set(lower, {
              id,
              label: asNonEmptyString(t?.label) || id,
              file: typeof t?.file === "string" ? t.file : "",
              origin: "built-in",
            });
          }
        }

        const defs = ns.templateDefs?.loadStore ? ns.templateDefs.loadStore() : null;
        const defsMap = isPlainObject(defs?.templates) ? defs.templates : {};
        for (const [idRaw, entry] of Object.entries(defsMap)) {
          const id = asNonEmptyString(idRaw);
          if (!id) continue;
          const lower = id.toLowerCase();
          if (byIdLower.has(lower)) continue;
          const meta = entry?.meta || {};
          byIdLower.set(lower, {
            id,
            label: asNonEmptyString(meta.label) || id,
            file: "",
            origin: meta.custom ? "custom" : "local",
          });
        }

        const out = Array.from(byIdLower.values());
        out.sort((a, b) => a.id.localeCompare(b.id));
        return out;
      }

      function computeTplHash(list) {
        return list.map((t) => `${t.id.toLowerCase()}:${t.origin}`).join("|");
      }

      function renderEditor() {
        const host = $("abapObjCfgEditor");
        if (!host) return;

        const selectedLower = String(state.selectedId || "").trim().toLowerCase();
        if (!selectedLower) {
          host.textContent = "Select an object on the left.";
          host.classList.add("empty");
          return;
        }

        const entries = buildEntries();
        const entry = entries.find((e) => e.idLower === selectedLower) || null;
        if (!entry) {
          host.textContent = "Object not found.";
          host.classList.add("empty");
          return;
        }

        host.classList.remove("empty");

        const origin = entry.isCustom ? "custom" : entry.isOverride ? "override" : "built-in";
        const disabledBadge = entry.disabled ? `<span class="badge badge-danger">disabled</span>` : "";

        host.innerHTML = `
          <div class="objcfg-editor__head">
            <div class="objcfg-editor__title">Object: <code>${escapeHtml(entry.id)}</code></div>
            <div class="objcfg-editor__badges">
              <span class="badge">${escapeHtml(origin)}</span>
              ${disabledBadge}
            </div>
          </div>

          <div class="objcfg-editor__actions">
            <button id="abapObjCfgBtnSave" class="btn btn-primary" type="button">Save</button>
            <button id="abapObjCfgBtnSaveNew" class="btn" type="button">Save new</button>
            <button id="abapObjCfgBtnReset" class="btn" type="button">Reset override</button>
            <button id="abapObjCfgBtnDelete" class="btn" type="button">Delete</button>
            <button id="abapObjCfgBtnToggleDisable" class="btn" type="button">${entry.disabled ? "Enable" : "Disable"}</button>
            <button id="abapObjCfgBtnApply" class="btn" type="button">Apply</button>
          </div>

          <div class="objcfg-quick">
            <div class="objcfg-label__text">Quick editor</div>
            <div id="abapObjCfgQuick" class="objcfg-quick__host"></div>
          </div>

          <details class="objcfg-advanced" open>
            <summary class="objcfg-advanced__summary">Advanced JSON</summary>
            <textarea id="abapObjCfgJson" class="objcfg-json" spellcheck="false"></textarea>
          </details>

          <div class="objcfg-templates">
            <div class="objcfg-label__text">Template mappings</div>
            <div class="objcfg-templates__row">
              <select id="abapObjCfgTplSelect" class="input"></select>
              <button id="abapObjCfgTplAdd" class="btn" type="button">Add mapping</button>
            </div>
            <div id="abapObjCfgTplList" class="objcfg-templates__list"></div>
          </div>

          <div class="hint">Saved in localStorage key: <code>${escapeHtml(getCustomStore()?.STORAGE_KEY || "")}</code></div>
        `;

        const jsonEl = $("abapObjCfgJson");
        if (jsonEl) {
          jsonEl.value = stringifyForEditor(entry.def);
        }

        const btnReset = $("abapObjCfgBtnReset");
        if (btnReset) btnReset.disabled = !(entry.isBase && entry.isOverride);

        const btnDelete = $("abapObjCfgBtnDelete");
        if (btnDelete) btnDelete.disabled = !entry.isCustom;

        renderTemplateSelect();
        renderTemplateMappingsList();
        renderQuickEditorFromJson();
        $("abapObjCfgBtnSave")?.addEventListener("click", () => onSave({ mode: "save" }));
        $("abapObjCfgBtnSaveNew")?.addEventListener("click", () => onSave({ mode: "saveNew" }));
        $("abapObjCfgBtnReset")?.addEventListener("click", () => onResetOverride(entry));
        $("abapObjCfgBtnDelete")?.addEventListener("click", () => onDeleteCustom(entry));
        $("abapObjCfgBtnToggleDisable")?.addEventListener("click", () => onToggleDisable(entry));
        $("abapObjCfgBtnApply")?.addEventListener("click", onApply);
        $("abapObjCfgTplAdd")?.addEventListener("click", onAddTemplateMapping);
      }

      function renderTemplateSelect() {
        const sel = $("abapObjCfgTplSelect");
        if (!sel) return;
        const list = buildTemplateCatalog();
        const hash = computeTplHash(list);
        if (hash === state.lastTplHash) return;
        state.lastTplHash = hash;

        sel.replaceChildren();

        const optEmpty = document.createElement("option");
        optEmpty.value = "";
        optEmpty.textContent = "Select a template...";
        sel.appendChild(optEmpty);

        for (const t of list) {
          const opt = document.createElement("option");
          opt.value = t.id;
          const origin = t.origin === "built-in" ? "built-in" : "local";
          opt.textContent = `${t.id} (${origin})`;
          sel.appendChild(opt);
        }
      }

      function getJsonObject() {
        const el = $("abapObjCfgJson");
        if (!el) return { ok: false, error: "Editor not ready." };
        const parsed = safeJsonParse(el.value);
        if (!parsed.ok) return { ok: false, error: parsed.error || "Invalid JSON." };
        if (!isPlainObject(parsed.value)) return { ok: false, error: "Object JSON must be an object." };
        return { ok: true, value: parsed.value };
      }

      function setJsonObject(obj) {
        const el = $("abapObjCfgJson");
        if (!el) return;
        el.value = stringifyForEditor(obj);
      }

      function validateObjectDef(obj) {
        const schema = ns.abapObjects?.schema || null;
        if (!schema?.validateMasterConfig) return { ok: true, errors: [] };

        const master = {
          schema: "abapflow-abap-objects-master-config",
          version: 1,
          parserConfig: { version: 1 },
          objects: [obj],
        };
        const res = schema.validateMasterConfig(master);
        return res.ok ? { ok: true, errors: [] } : res;
      }

      function updateJsonObject(mutator, options) {
        const res = getJsonObject();
        if (!res.ok) {
          ui.setStatus(res.error || "Invalid JSON.", true);
          return { ok: false, error: res.error || "Invalid JSON." };
        }
        const obj = res.value;
        try {
          mutator(obj);
        } catch (e) {
          const msg = String(e?.message || e);
          ui.setStatus(msg, true);
          return { ok: false, error: msg };
        }
        setJsonObject(obj);
        if (options?.rerender) renderEditor();
        else if (options?.rerenderTemplatesList) renderTemplateMappingsList();
        else if (options?.rerenderQuick) renderQuickEditorFromJson();
        return { ok: true, value: obj };
      }

      function renderQuickEditorFromJson() {
        const host = $("abapObjCfgQuick");
        if (!host) return;
        const parsed = getJsonObject();
        if (!parsed.ok) {
          host.innerHTML = `<div class="objcfg-quick__error">Fix JSON to use the quick editor.</div>`;
          return;
        }
        const obj = parsed.value || {};
        const kind = asNonEmptyString(obj.kind).toLowerCase();
        const builderKind = asNonEmptyString(obj?.builder?.kind);
        const parseKind = asNonEmptyString(obj?.parse?.kind);
        const isStatement = kind === "statement";
        const isRegex = isStatement && parseKind.toLowerCase() === "regex";
        const isMappingBuilder = builderKind.toLowerCase() === "mapping";
        host.innerHTML = `
          <div class="objcfg-form">
            <label class="objcfg-field">
              <span class="objcfg-field__label">Label</span>
              <input id="abapObjCfgFieldLabel" class="input" type="text" value="${escapeHtml(asNonEmptyString(obj.label))}" />
            </label>

            <label class="objcfg-field">
              <span class="objcfg-field__label">Kind</span>
              <select id="abapObjCfgFieldKind" class="input">
                <option value="statement">statement</option>
                <option value="callEdge">callEdge</option>
              </select>
            </label>

            <label class="objcfg-field">
              <span class="objcfg-field__label">Builder kind</span>
              <input id="abapObjCfgFieldBuilderKind" class="input" list="abapObjCfgBuilderKinds" value="${escapeHtml(builderKind)}" />
              <datalist id="abapObjCfgBuilderKinds">
                <option value="performCall"></option>
                <option value="assignment"></option>
                <option value="if"></option>
                <option value="message"></option>
                <option value="itabOp"></option>
                <option value="append"></option>
                <option value="mapping"></option>
              </datalist>
            </label>

            ${
              isStatement
                ? `
              <label class="objcfg-field">
                <span class="objcfg-field__label">Parse kind</span>
                <input id="abapObjCfgFieldParseKind" class="input" list="abapObjCfgParseKinds" value="${escapeHtml(parseKind)}" />
                <datalist id="abapObjCfgParseKinds">
                  <option value="regex"></option>
                  <option value="assignment"></option>
                  <option value="conditional"></option>
                  <option value="message"></option>
                  <option value="itabOp"></option>
                </datalist>
              </label>

              <label class="objcfg-field objcfg-field--checkbox">
                <span class="objcfg-field__label">continueAfterMatch</span>
                <input id="abapObjCfgFieldContinue" type="checkbox" ${obj?.parse?.continueAfterMatch ? "checked" : ""} />
              </label>
            `
                : `
              <label class="objcfg-field">
                <span class="objcfg-field__label">match.toKeyPrefix</span>
                <input id="abapObjCfgFieldToKeyPrefix" class="input" type="text" value="${escapeHtml(asNonEmptyString(obj?.match?.toKeyPrefix))}" />
              </label>
            `
            }
          </div>

          ${
            isRegex
              ? `
            <div class="objcfg-sub">
              <div class="objcfg-sub__title">Regex</div>
              <div class="objcfg-sub__grid">
                <label class="objcfg-field objcfg-field--wide">
                  <span class="objcfg-field__label">parse.regex (pattern)</span>
                  <textarea id="abapObjCfgFieldRegex" class="objcfg-json objcfg-json--small" spellcheck="false">${escapeHtml(
                    asNonEmptyString(obj?.parse?.regex),
                  )}</textarea>
                </label>
                <label class="objcfg-field">
                  <span class="objcfg-field__label">parse.flags</span>
                  <input id="abapObjCfgFieldFlags" class="input" type="text" value="${escapeHtml(asNonEmptyString(obj?.parse?.flags) || "i")}" />
                </label>
              </div>

              <div class="objcfg-sub__title">Regex fields</div>
              <div class="objcfg-mini-table">
                <div class="objcfg-mini-table__head">
                  <div>Field</div>
                  <div>Group</div>
                  <div></div>
                </div>
                <div id="abapObjCfgRegexFields"></div>
              </div>
              <button id="abapObjCfgRegexAddField" class="btn" type="button">Add regex field</button>
            </div>
          `
              : ""
          }

          ${
            isMappingBuilder
              ? `
            <div class="objcfg-sub">
              <div class="objcfg-sub__title">Builder mapping fields</div>
              <div class="objcfg-mini-table">
                <div class="objcfg-mini-table__head objcfg-mini-table__head--4">
                  <div>Out key</div>
                  <div>Type</div>
                  <div>From</div>
                  <div></div>
                </div>
                <div id="abapObjCfgMappingFields"></div>
              </div>
              <button id="abapObjCfgMapAddField" class="btn" type="button">Add mapping field</button>
            </div>
          `
              : ""
          }
        `;

        const kindSel = $("abapObjCfgFieldKind");
        if (kindSel) kindSel.value = isStatement ? "statement" : "callEdge";

        $("abapObjCfgFieldLabel")?.addEventListener("input", (ev) => {
          const v = String(ev?.target?.value ?? "");
          updateJsonObject((o) => {
            o.label = v;
          });
        });

        kindSel?.addEventListener("change", (ev) => {
          const next = asNonEmptyString(ev?.target?.value).toLowerCase();
          updateJsonObject(
            (o) => {
              o.kind = next === "calledge" || next === "callEdge" ? "callEdge" : "statement";

              if (o.kind.toLowerCase() === "statement") {
                if (!isPlainObject(o.parse)) o.parse = { kind: "regex" };
              } else {
                if (!isPlainObject(o.match)) o.match = { toKeyPrefix: "" };
              }

              if (!isPlainObject(o.builder)) o.builder = {};
              if (!asNonEmptyString(o.builder.kind)) {
                o.builder.kind = o.kind.toLowerCase() === "statement" ? "mapping" : "performCall";
              }
            },
            { rerender: true },
          );
        });

        $("abapObjCfgFieldBuilderKind")?.addEventListener("change", (ev) => {
          const v = asNonEmptyString(ev?.target?.value);
          updateJsonObject(
            (o) => {
              if (!isPlainObject(o.builder)) o.builder = {};
              o.builder.kind = v;
              if (v.toLowerCase() === "mapping") {
                if (!isPlainObject(o.builder.fields)) o.builder.fields = {};
              }
            },
            { rerender: true },
          );
        });

        if (isStatement) {
          $("abapObjCfgFieldParseKind")?.addEventListener("change", (ev) => {
            const v = asNonEmptyString(ev?.target?.value);
            updateJsonObject(
              (o) => {
                if (!isPlainObject(o.parse)) o.parse = {};
                o.parse.kind = v;
                if (v.toLowerCase() === "regex") {
                  if (!asNonEmptyString(o.parse.regex)) o.parse.regex = "^$";
                  if (o.parse.flags == null) o.parse.flags = "i";
                  if (!isPlainObject(o.parse.fields)) o.parse.fields = {};
                }
              },
              { rerender: true },
            );
          });

          $("abapObjCfgFieldContinue")?.addEventListener("change", (ev) => {
            const checked = Boolean(ev?.target?.checked);
            updateJsonObject((o) => {
              if (!isPlainObject(o.parse)) o.parse = {};
              if (checked) o.parse.continueAfterMatch = true;
              else delete o.parse.continueAfterMatch;
            });
          });
        } else {
          $("abapObjCfgFieldToKeyPrefix")?.addEventListener("input", (ev) => {
            const v = String(ev?.target?.value ?? "");
            updateJsonObject((o) => {
              if (!isPlainObject(o.match)) o.match = {};
              o.match.toKeyPrefix = v;
            });
          });
        }

        if (isRegex) {
          $("abapObjCfgFieldRegex")?.addEventListener("input", (ev) => {
            const v = String(ev?.target?.value ?? "");
            updateJsonObject((o) => {
              if (!isPlainObject(o.parse)) o.parse = {};
              o.parse.regex = v;
            });
          });
          $("abapObjCfgFieldFlags")?.addEventListener("input", (ev) => {
            const v = asNonEmptyString(ev?.target?.value);
            updateJsonObject((o) => {
              if (!isPlainObject(o.parse)) o.parse = {};
              if (v) o.parse.flags = v;
              else delete o.parse.flags;
            });
          });

          renderRegexFieldsTable(obj);
          $("abapObjCfgRegexAddField")?.addEventListener("click", addRegexField);
        }

        if (isMappingBuilder) {
          renderMappingFieldsTable(obj);
          $("abapObjCfgMapAddField")?.addEventListener("click", addMappingField);
        }
      }

      function getRegexFieldsFromJsonObject(obj) {
        const fields = isPlainObject(obj?.parse?.fields) ? obj.parse.fields : {};
        const out = [];
        for (const [k, v] of Object.entries(fields)) {
          const key = asNonEmptyString(k);
          const n = Number(v);
          if (!key) continue;
          if (!Number.isFinite(n)) continue;
          out.push({ key, index: n });
        }
        out.sort((a, b) => a.index - b.index || a.key.localeCompare(b.key));
        return out;
      }

      function renderRegexFieldsTable(obj) {
        const host = $("abapObjCfgRegexFields");
        if (!host) return;
        host.replaceChildren();

        const list = getRegexFieldsFromJsonObject(obj);
        if (list.length === 0) {
          const empty = document.createElement("div");
          empty.className = "objcfg-mini-table__empty";
          empty.textContent = "(no fields)";
          host.appendChild(empty);
          return;
        }

        for (const row of list) {
          const wrap = document.createElement("div");
          wrap.className = "objcfg-mini-table__row";
          wrap.dataset.key = row.key;

          const inKey = document.createElement("input");
          inKey.className = "input objcfg-mini-table__input";
          inKey.value = row.key;

          const inIdx = document.createElement("input");
          inIdx.className = "input objcfg-mini-table__input";
          inIdx.type = "number";
          inIdx.min = "0";
          inIdx.value = String(row.index);

          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "btn";
          btn.textContent = "Remove";
          btn.addEventListener("click", () => {
            updateJsonObject(
              (o) => {
                if (!isPlainObject(o.parse)) return;
                if (!isPlainObject(o.parse.fields)) return;
                delete o.parse.fields[row.key];
              },
              { rerender: true },
            );
          });

          const applyFromInputs = () => {
            const nextKey = asNonEmptyString(inKey.value);
            const n = Number(inIdx.value);
            if (!nextKey || !Number.isFinite(n)) return;
            updateJsonObject(
              (o) => {
                if (!isPlainObject(o.parse)) o.parse = {};
                if (!isPlainObject(o.parse.fields)) o.parse.fields = {};
                const oldKey = row.key;
                if (oldKey !== nextKey) delete o.parse.fields[oldKey];
                o.parse.fields[nextKey] = n;
              },
              { rerender: true },
            );
          };

          inKey.addEventListener("change", applyFromInputs);
          inIdx.addEventListener("change", applyFromInputs);

          wrap.appendChild(inKey);
          wrap.appendChild(inIdx);
          wrap.appendChild(btn);
          host.appendChild(wrap);
        }
      }

      function addRegexField() {
        const key = asNonEmptyString(window.prompt("Field name:", ""));
        if (!key) return;
        const idx = Number(window.prompt("Group index (number):", "1"));
        if (!Number.isFinite(idx)) return;
        updateJsonObject(
          (o) => {
            if (!isPlainObject(o.parse)) o.parse = {};
            if (!isPlainObject(o.parse.fields)) o.parse.fields = {};
            o.parse.fields[key] = idx;
          },
          { rerender: true },
        );
      }

      function getMappingFieldsFromJsonObject(obj) {
        const fields = isPlainObject(obj?.builder?.fields) ? obj.builder.fields : {};
        const out = [];
        for (const [outKeyRaw, spec] of Object.entries(fields)) {
          const outKey = asNonEmptyString(outKeyRaw);
          if (!outKey) continue;
          const s = isPlainObject(spec) ? spec : {};
          out.push({
            outKey,
            type: asNonEmptyString(s.type) || "expr",
            from: asNonEmptyString(s.from),
          });
        }
        out.sort((a, b) => a.outKey.localeCompare(b.outKey));
        return out;
      }

      function renderMappingFieldsTable(obj) {
        const host = $("abapObjCfgMappingFields");
        if (!host) return;
        host.replaceChildren();

        const list = getMappingFieldsFromJsonObject(obj);
        if (list.length === 0) {
          const empty = document.createElement("div");
          empty.className = "objcfg-mini-table__empty";
          empty.textContent = "(no fields)";
          host.appendChild(empty);
          return;
        }

        for (const row of list) {
          const wrap = document.createElement("div");
          wrap.className = "objcfg-mini-table__row objcfg-mini-table__row--4";
          wrap.dataset.key = row.outKey;

          const inKey = document.createElement("input");
          inKey.className = "input objcfg-mini-table__input";
          inKey.value = row.outKey;

          const selType = document.createElement("select");
          selType.className = "input objcfg-mini-table__input";
          for (const t of ["expr", "exprlist", "text"]) {
            const opt = document.createElement("option");
            opt.value = t;
            opt.textContent = t;
            selType.appendChild(opt);
          }
          selType.value = row.type;

          const inFrom = document.createElement("input");
          inFrom.className = "input objcfg-mini-table__input";
          inFrom.value = row.from;

          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "btn";
          btn.textContent = "Remove";
          btn.addEventListener("click", () => {
            updateJsonObject(
              (o) => {
                if (!isPlainObject(o.builder)) return;
                if (!isPlainObject(o.builder.fields)) return;
                delete o.builder.fields[row.outKey];
              },
              { rerender: true },
            );
          });

          const applyFromInputs = () => {
            const nextKey = asNonEmptyString(inKey.value);
            const type = asNonEmptyString(selType.value) || "expr";
            const from = asNonEmptyString(inFrom.value);
            if (!nextKey) return;
            updateJsonObject(
              (o) => {
                if (!isPlainObject(o.builder)) o.builder = { kind: "mapping" };
                if (!isPlainObject(o.builder.fields)) o.builder.fields = {};
                const oldKey = row.outKey;
                if (oldKey !== nextKey) delete o.builder.fields[oldKey];
                o.builder.fields[nextKey] = { type, from };
              },
              { rerender: true },
            );
          };

          inKey.addEventListener("change", applyFromInputs);
          selType.addEventListener("change", applyFromInputs);
          inFrom.addEventListener("change", applyFromInputs);

          wrap.appendChild(inKey);
          wrap.appendChild(selType);
          wrap.appendChild(inFrom);
          wrap.appendChild(btn);
          host.appendChild(wrap);
        }
      }

      function addMappingField() {
        const outKey = asNonEmptyString(window.prompt("Out key:", ""));
        if (!outKey) return;
        const from = asNonEmptyString(window.prompt("From (payload field name):", ""));
        const type = asNonEmptyString(window.prompt("Type (expr|exprlist|text):", "expr")) || "expr";
        updateJsonObject(
          (o) => {
            if (!isPlainObject(o.builder)) o.builder = { kind: "mapping" };
            if (!isPlainObject(o.builder.fields)) o.builder.fields = {};
            o.builder.fields[outKey] = { type, from };
          },
          { rerender: true },
        );
      }

      function onSave(options) {
        const storeApi = getCustomStore();
        if (!storeApi) {
          ui.setStatus("ABAP Objects custom store module not loaded.", true);
          return;
        }

        const res = getJsonObject();
        if (!res.ok) {
          ui.setStatus(res.error || "Invalid JSON.", true);
          return;
        }

        const obj = res.value;
        const id = asNonEmptyString(obj?.id);
        if (!id) {
          ui.setStatus("Object id is required.", true);
          return;
        }

        const validation = validateObjectDef(obj);
        if (!validation.ok) {
          const msg = (validation.errors || [])
            .map((e) => `${e.path || "(root)"}: ${e.message || "Invalid value"}`)
            .join("\n");
          ui.setStatus(msg || "Invalid object config.", true);
          return;
        }

        const mode = asNonEmptyString(options?.mode);
        if (mode === "saveNew") {
          const suggested = `${id}_copy`;
          const nextId = asNonEmptyString(window.prompt("New object id:", suggested));
          if (!nextId) return;
          const cloned = deepClone({ ...obj, id: nextId });
          const saved = storeApi.upsertObjectDef(cloned);
          if (!saved.ok) {
            ui.setStatus(saved.error || "Save failed.", true);
            return;
          }
          state.selectedId = nextId;
          state.lastListHash = "";
          ui.setStatus(`Saved new object: ${nextId}.`, false);
          renderList();
          renderEditor();
          return;
        }

        const saved = storeApi.upsertObjectDef(obj);
        if (!saved.ok) {
          ui.setStatus(saved.error || "Save failed.", true);
          return;
        }

        state.selectedId = id;
        state.lastListHash = "";
        ui.setStatus(`Saved: ${id}.`, false);
        renderList();
        renderEditor();
      }

      function onResetOverride(entry) {
        const storeApi = getCustomStore();
        if (!storeApi) return;
        if (!entry?.isBase || !entry?.isOverride) return;
        const ok = window.confirm(`Reset override for "${entry.id}"?`);
        if (!ok) return;
        storeApi.deleteObjectDef(entry.id);
        state.lastListHash = "";
        ui.setStatus(`Reset override: ${entry.id}.`, false);
        renderList();
        renderEditor();
      }

      function onDeleteCustom(entry) {
        const storeApi = getCustomStore();
        if (!storeApi) return;
        if (!entry?.isCustom) return;
        const ok = window.confirm(`Delete custom object "${entry.id}"?`);
        if (!ok) return;
        storeApi.deleteObjectDef(entry.id);
        state.selectedId = "";
        state.lastListHash = "";
        ui.setStatus(`Deleted: ${entry.id}.`, false);
        renderList();
        renderEditor();
      }

      function onToggleDisable(entry) {
        const storeApi = getCustomStore();
        if (!storeApi) return;
        storeApi.setObjectDisabled(entry.id, !entry.disabled);
        state.lastListHash = "";
        ui.setStatus(`${entry.disabled ? "Enabled" : "Disabled"}: ${entry.id}.`, false);
        renderList();
        renderEditor();
      }

      function onApply() {
        if (ns.abapObjects?.reset) ns.abapObjects.reset();
        ui.setStatus("Applied ABAP Objects config. Re-analyze to reload.", false);
        const input = $("abapInput")?.value || "";
        if (String(input).trim()) $("btnAnalyze")?.click();
      }

      function normalizeTemplatesList(value) {
        if (!Array.isArray(value)) return [];
        const out = [];
        for (const t of value) {
          if (!isPlainObject(t)) continue;
          const id = asNonEmptyString(t.id);
          if (!id) continue;
          out.push({
            id,
            label: asNonEmptyString(t.label) || id,
            auto: t.auto !== false,
            file: typeof t.file === "string" ? t.file : "",
            when: isPlainObject(t.when) ? t.when : null,
          });
        }
        return out;
      }

      function renderTemplateMappingsList() {
        const host = $("abapObjCfgTplList");
        if (!host) return;

        const res = getJsonObject();
        host.replaceChildren();
        if (!res.ok) return;

        const list = normalizeTemplatesList(res.value.templates);
        if (list.length === 0) {
          const empty = document.createElement("div");
          empty.className = "objcfg-templates__empty";
          empty.textContent = "(no mappings)";
          host.appendChild(empty);
          return;
        }

        for (const t of list) {
          const row = document.createElement("div");
          row.className = "objcfg-templates__item";

          const left = document.createElement("div");
          left.className = "objcfg-templates__item-text";
          left.textContent = `${t.id}`;

          const right = document.createElement("button");
          right.type = "button";
          right.className = "btn objcfg-templates__remove";
          right.textContent = "Remove";
          right.addEventListener("click", () => removeTemplateMapping(t.id));

          row.appendChild(left);
          row.appendChild(right);
          host.appendChild(row);
        }
      }

      function onAddTemplateMapping() {
        const sel = $("abapObjCfgTplSelect");
        const tid = asNonEmptyString(sel?.value);
        if (!tid) return;

        const res = getJsonObject();
        if (!res.ok) {
          ui.setStatus(res.error || "Invalid JSON.", true);
          return;
        }

        const obj = res.value;
        if (!Array.isArray(obj.templates)) obj.templates = [];

        const existing = normalizeTemplatesList(obj.templates);
        const exists = existing.some((t) => String(t.id || "").trim().toLowerCase() === tid.toLowerCase());
        if (exists) {
          ui.setStatus(`Template already mapped: ${tid}.`, true);
          return;
        }

        const catalog = buildTemplateCatalog();
        const found = catalog.find((t) => t.id.toLowerCase() === tid.toLowerCase()) || null;

        obj.templates.push({
          id: tid,
          label: found?.label || tid,
          auto: true,
          file: found?.file || "",
        });

        setJsonObject(obj);
        renderTemplateMappingsList();
      }

      function removeTemplateMapping(templateId) {
        const tid = asNonEmptyString(templateId);
        if (!tid) return;

        const res = getJsonObject();
        if (!res.ok) return;

        const obj = res.value;
        const list = Array.isArray(obj.templates) ? obj.templates : [];
        const next = list.filter((t) => String(t?.id || "").trim().toLowerCase() !== tid.toLowerCase());
        obj.templates = next;

        setJsonObject(obj);
        renderTemplateMappingsList();
      }

      function selectObject(objectId) {
        state.selectedId = asNonEmptyString(objectId);
        state.lastListHash = "";
        ui.setActiveTab("config");
        renderList();
        renderEditor();
      }

      function createNewObject() {
        const storeApi = getCustomStore();
        if (!storeApi) {
          ui.setStatus("ABAP Objects custom store module not loaded.", true);
          return;
        }

        const suggested = "newObject";
        const id = asNonEmptyString(window.prompt("New object id:", suggested));
        if (!id) return;

        const exists = buildEntries().some((e) => e.idLower === id.toLowerCase());
        if (exists) {
          const ok = window.confirm(`"${id}" already exists. Overwrite/override it?`);
          if (!ok) return;
        }

        const obj = {
          id,
          kind: "statement",
          label: "New object",
          parse: { kind: "regex", regex: "^$" },
          builder: { kind: "mapping", fields: {} },
          templates: [],
        };
        storeApi.upsertObjectDef(obj);

        state.selectedId = id;
        state.lastListHash = "";
        ui.setStatus(`Created: ${id}.`, false);
        renderList();
        renderEditor();
      }

      function exportStore() {
        const storeApi = getCustomStore();
        if (!storeApi) return;
        const stamp = new Date().toISOString().replace(/[:]/g, "-").slice(0, 19);
        ui.downloadTextFile(`abapflow-abap-objects-custom-${stamp}.json`, storeApi.exportJson(), "application/json");
        ui.setStatus("ABAP Objects config exported.", false);
      }

      async function importStoreFromFile(file) {
        const storeApi = getCustomStore();
        if (!storeApi) return;
        if (!file) return;

        const text = await file.text();
        const res = storeApi.importJson(text, { mode: "merge" });
        if (!res.ok) {
          ui.setStatus(res.error || "Import failed.", true);
          return;
        }
        state.selectedId = "";
        state.lastListHash = "";
        ui.setStatus("ABAP Objects config imported (merge).", false);
        renderList();
        renderEditor();
      }

      function resetAll() {
        const storeApi = getCustomStore();
        if (!storeApi) return;
        const ok = window.confirm("Reset ALL custom ABAP Objects config in localStorage?");
        if (!ok) return;
        storeApi.clearStore();
        state.selectedId = "";
        state.lastListHash = "";
        ui.setStatus("ABAP Objects config reset.", false);
        renderList();
        renderEditor();
      }

      function bindOnce() {
        const tab = $("tab-config");
        if (!tab || tab.dataset.bound) return;
        tab.dataset.bound = "1";

        $("abapObjCfgSearch")?.addEventListener("input", () => {
          state.lastListHash = "";
          renderList();
        });
        $("abapObjCfgNew")?.addEventListener("click", createNewObject);
        $("abapObjCfgExport")?.addEventListener("click", exportStore);
        $("abapObjCfgImport")?.addEventListener("click", () => $("abapObjCfgImportFile")?.click());
        $("abapObjCfgResetAll")?.addEventListener("click", resetAll);
        $("abapObjCfgImportFile")?.addEventListener("change", async (ev) => {
          const input = ev.target;
          const file = input?.files?.[0] || null;
          await importStoreFromFile(file);
          if (input) input.value = "";
        });
      }

      ui.renderAbapObjectsConfig = function renderAbapObjectsConfig() {
        bindOnce();
        state.lastListHash = "";
        state.lastTplHash = "";
        renderList();
        renderEditor();
      };

      ui.selectAbapObjectConfig = selectObject;
    })(window.AbapFlow);

    </script>
        <script>
    // js/ui_abap_objects_syntax_generator.js
    (function (ns) {
      "use strict";

      const ui = ns.ui;
      const utils = ns.utils;

      function asNonEmptyString(x) {
        const s = String(x ?? "").trim();
        return s ? s : "";
      }

      function safeJsonStringify(value) {
        try {
          return JSON.stringify(value, null, 2);
        } catch (e) {
          return String(e?.message || e);
        }
      }

      function bindOnce() {
        const btn = ui?.$("abapObjCfgGenBtn");
        if (!btn || btn.dataset.bound) return;
        btn.dataset.bound = "1";

        btn.addEventListener("click", () => {
          const gen = ns.abapObjects?.syntaxGenerator;
          const store = ns.abapObjects?.customStore;
          if (!gen?.generateObjectDefFromSyntaxText) {
            ui.setStatus("Syntax generator module not loaded.", true);
            return;
          }
          if (!store?.upsertObjectDef) {
            ui.setStatus("ABAP Objects custom store module not loaded.", true);
            return;
          }

          const input = ui.$("abapObjCfgGenInput")?.value || "";
          const res = gen.generateObjectDefFromSyntaxText(input);
          const out = ui.$("abapObjCfgGenOutput");

          if (!res?.ok) {
            if (out) out.textContent = String(res?.error || "Generate failed.");
            ui.setStatus(String(res?.error || "Generate failed."), true);
            return;
          }

          const idOverride = asNonEmptyString(ui.$("abapObjCfgGenId")?.value);
          const objectDef = res.objectDef || {};
          const id = asNonEmptyString(idOverride) || asNonEmptyString(objectDef.id) || asNonEmptyString(res.keyword)?.toLowerCase();
          if (!id) {
            ui.setStatus("Object id is required.", true);
            return;
          }

          objectDef.id = id;
          if (!asNonEmptyString(objectDef.label)) objectDef.label = asNonEmptyString(res.keyword) || id;
          if (!asNonEmptyString(objectDef.kind)) objectDef.kind = "statement";

          const effective = store.getEffectiveConfig ? store.getEffectiveConfig(ns.abapObjectsMasterConfig)?.config : null;
          const existingObj = Array.isArray(effective?.objects)
            ? effective.objects.find((o) => String(o?.id || "").trim().toLowerCase() === id.toLowerCase()) || null
            : null;
          const existing = Boolean(existingObj);
          if (existing) {
            const ok = window.confirm(`"${id}" already exists. Override it with generated config?`);
            if (!ok) return;
          }

          if (existingObj && Array.isArray(existingObj.templates) && existingObj.templates.length && (!Array.isArray(objectDef.templates) || objectDef.templates.length === 0)) {
            objectDef.templates = JSON.parse(JSON.stringify(existingObj.templates));
          }

          if (!Array.isArray(objectDef.templates)) objectDef.templates = [];
          if (objectDef.templates.length === 0) {
            const genTpl = ns.abapObjects?.syntaxGenerator;
            const defs = ns.templateDefs;
            if (genTpl?.createDefaultKeyValueExcelLikeTableTemplate && defs?.upsertTemplate) {
              const templateId = `${id}.default.excel-like-table`;

              objectDef.templates.push({ id: templateId, label: "Default (key/value)", auto: true });

              if (!defs.getTemplateConfig || !defs.getTemplateConfig(templateId)) {
                const cfg = genTpl.createDefaultKeyValueExcelLikeTableTemplate("pairs");
                defs.upsertTemplate(templateId, cfg, { label: "Default (key/value)", source: id, auto: true });
              }
            }
          }

          const saved = store.upsertObjectDef(objectDef);
          if (!saved.ok) {
            const msg = saved.error || "Save failed.";
            if (out) out.textContent = msg;
            ui.setStatus(msg, true);
            return;
          }

          if (out) out.textContent = safeJsonStringify(objectDef);
          ui.setStatus(`Generated object: ${id}.`, false);

          if (ns.abapObjects?.reset) ns.abapObjects.reset();

          if (ui.selectAbapObjectConfig) {
            ui.selectAbapObjectConfig(id);
          } else {
            ui.setActiveTab?.("config");
          }

          const code = ui.$("abapInput")?.value || "";
          if (String(code).trim()) ui.$("btnAnalyze")?.click();
        });

        const input = ui.$("abapObjCfgGenInput");
        if (input) {
          input.addEventListener("input", () => {
            const gen = ns.abapObjects?.syntaxGenerator;
            const out = ui.$("abapObjCfgGenOutput");
            if (!gen?.extractFirstSyntaxStatement || !out) return;
            const stmt = gen.extractFirstSyntaxStatement(input.value);
            if (!stmt) {
              out.textContent = "";
              return;
            }
            const m = /^([A-Z][A-Z0-9_-]*)\\b/.exec(stmt);
            const keyword = asNonEmptyString(m?.[1]);
            if (keyword) {
              const idEl = ui.$("abapObjCfgGenId");
              if (idEl && !asNonEmptyString(idEl.value)) idEl.value = keyword.toLowerCase();
            }
          });
        }
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", bindOnce);
      } else {
        bindOnce();
      }

      ns.ui = ns.ui || {};
      ns.ui.initAbapObjectsSyntaxGenerator = bindOnce;
    })(window.AbapFlow);

    </script>
        <script>
    // js/ui_templates_store.js
    (function (ns) {
      "use strict";

      const ui = ns.ui;
      ui.templates = ui.templates || {};
      const tpl = ui.templates;
      const utils = ns.utils;

      const TEMPLATE_OVERRIDES_STORAGE_KEY = "abapFlow.templateLocalOverrides.v1";
      const TEMPLATE_OVERRIDES_SCHEMA = "abapflow-template-local-overrides";
      const TEMPLATE_OVERRIDES_VERSION = 1;

      let templateLocalOverrides = loadTemplateLocalOverrides();

      const nowIso = typeof utils?.nowIso === "function" ? utils.nowIso : () => new Date().toISOString();
      const safeJsonParse =
        typeof utils?.safeJsonParse === "function"
          ? utils.safeJsonParse
          : (text) => {
              try {
                return { ok: true, value: JSON.parse(text) };
              } catch (err) {
                return { ok: false, error: String(err?.message || err) };
              }
            };

      function getActiveProgramId() {
        if (ns.notes?.getActiveProgramId) return ns.notes.getActiveProgramId();
        return "default";
      }

      function loadTemplateLocalOverrides() {
        try {
          const raw = localStorage.getItem(TEMPLATE_OVERRIDES_STORAGE_KEY);
          if (!raw) return new Map();
          const parsed = safeJsonParse(raw);
          if (!parsed.ok) return new Map();
          const obj = parsed.value;
          if (obj?.schema !== TEMPLATE_OVERRIDES_SCHEMA || obj?.version !== TEMPLATE_OVERRIDES_VERSION) return new Map();

          const out = new Map();
          const overrides = obj?.overrides && typeof obj.overrides === "object" ? obj.overrides : {};
          for (const [key, binds] of Object.entries(overrides)) {
            if (!binds || typeof binds !== "object") continue;
            const bindMap = new Map();
            for (const [bind, value] of Object.entries(binds)) {
              const b = String(bind || "").trim();
              if (!b) continue;

              if (typeof value === "string") {
                const v = String(value ?? "");
                if (!v.trim()) continue;
                bindMap.set(b, v);
                continue;
              }

              if (!value || typeof value !== "object" || Array.isArray(value)) continue;

              const rawByKey = value.byKey && typeof value.byKey === "object" && !Array.isArray(value.byKey) ? value.byKey : value;
              const byKey = new Map();
              for (const [originKeyRaw, ov] of Object.entries(rawByKey)) {
                const originKey = String(originKeyRaw || "").trim();
                if (!originKey) continue;
                const v = String(ov ?? "");
                if (!v.trim()) continue;
                byKey.set(originKey, v);
              }
              if (byKey.size) bindMap.set(b, byKey);
            }
            if (bindMap.size) out.set(String(key), bindMap);
          }
          return out;
        } catch (_) {
          return new Map();
        }
      }

      function saveTemplateLocalOverrides() {
        try {
          const obj = {
            schema: TEMPLATE_OVERRIDES_SCHEMA,
            version: TEMPLATE_OVERRIDES_VERSION,
            updatedAt: nowIso(),
            overrides: {},
          };

          for (const [key, bindMap] of templateLocalOverrides.entries()) {
            const bucket = {};
            for (const [bind, value] of bindMap.entries()) {
              const b = String(bind || "").trim();
              if (!b) continue;

              if (typeof value === "string") {
                const v = String(value ?? "");
                if (!v.trim()) continue;
                bucket[b] = v;
                continue;
              }

              if (value instanceof Map) {
                const byKey = {};
                for (const [originKey, ov] of value.entries()) {
                  const ok = String(originKey || "").trim();
                  if (!ok) continue;
                  const v = String(ov ?? "");
                  if (!v.trim()) continue;
                  byKey[ok] = v;
                }
                if (Object.keys(byKey).length) bucket[b] = { byKey };
              }
            }
            if (Object.keys(bucket).length) obj.overrides[String(key)] = bucket;
          }

          localStorage.setItem(TEMPLATE_OVERRIDES_STORAGE_KEY, JSON.stringify(obj, null, 2));
        } catch (_) {
          // ignore
        }
      }

      function templateBucketKey(templateId, resultId) {
        const pid = String(getActiveProgramId() || "default");
        const tid = String(templateId || "").trim() || "default";
        const rid = String(resultId || "").trim();
        return `${pid}::${tid}::${rid}`;
      }

      function getLocalTemplateOverrides(templateId, resultId) {
        const key = templateBucketKey(templateId, resultId);
        return templateLocalOverrides.get(key) || null;
      }

      function setLocalTemplateOverride(templateId, resultId, bind, value) {
        const key = templateBucketKey(templateId, resultId);
        const b = String(bind || "").trim();
        if (!b) return;

        const v = String(value ?? "");
        const hasValue = Boolean(v.trim());

        let bucket = templateLocalOverrides.get(key);
        if (!bucket && hasValue) {
          bucket = new Map();
          templateLocalOverrides.set(key, bucket);
        }
        if (!bucket) return;

        bucket.set(b, v);
        if (!hasValue) bucket.delete(b);

        if (bucket.size === 0) templateLocalOverrides.delete(key);
        saveTemplateLocalOverrides();
      }

      function setLocalTemplateOverrideByOriginKey(templateId, resultId, bind, originKey, value, baseOriginKey) {
        const key = templateBucketKey(templateId, resultId);
        const b = String(bind || "").trim();
        const ok = String(originKey || "").trim();
        if (!b || !ok) return;

        const v = String(value ?? "");
        const hasValue = Boolean(v.trim());

        let bucket = templateLocalOverrides.get(key);
        if (!bucket && hasValue) {
          bucket = new Map();
          templateLocalOverrides.set(key, bucket);
        }
        if (!bucket) return;

        const baseKey = String(baseOriginKey || "").trim();

        const cur = bucket.get(b);
        let map = null;

        if (cur instanceof Map) {
          map = cur;
        } else if (typeof cur === "string") {
          map = new Map();
          const legacy = String(cur ?? "");
          if (legacy.trim()) {
            map.set(baseKey || ok, legacy);
          }
        } else {
          map = new Map();
        }

        if (hasValue) map.set(ok, v);
        else map.delete(ok);

        if (map.size) bucket.set(b, map);
        else bucket.delete(b);

        if (bucket.size === 0) templateLocalOverrides.delete(key);
        saveTemplateLocalOverrides();
      }

      function resolveBindPath(obj, path) {
        const raw = String(path || "").trim();
        if (!raw) return undefined;

        let cur = obj;
        const parts = raw
          .split(".")
          .map((p) => p.trim())
          .filter(Boolean);

        for (const part of parts) {
          if (cur == null) return undefined;
          const m = /^([A-Za-z0-9_$]+)(.*)$/.exec(part);
          if (!m) return undefined;
          const prop = m[1];
          let rest = m[2] || "";
          cur = cur[prop];

          while (rest) {
            const m2 = /^\[(\d+)\](.*)$/.exec(rest);
            if (!m2) return undefined;
            const idx = Number(m2[1]);
            if (!Number.isFinite(idx)) return undefined;
            cur = cur == null ? undefined : cur[idx];
            rest = m2[2] || "";
          }
        }

        return cur;
      }

      function applyOverridesToConfig(config, overridesMap, meta) {
        if (!config || !Array.isArray(config.cells) || !overridesMap) return;

        const model = meta?.model || null;
        const context = meta?.context || null;
        const callPath = Array.isArray(meta?.callPath) ? meta.callPath : null;

        const desc = ns.desc;

        for (const cell of config.cells) {
          const bind = String(cell?.bind || "").trim();
          if (!bind) continue;
          if (!overridesMap.has(bind)) continue;

          const overrideEntry = overridesMap.get(bind);
          const overrideValue = typeof overrideEntry === "string" ? String(overrideEntry ?? "") : "";

          if (
            model &&
            context &&
            desc &&
            typeof desc.describeExpression === "function" &&
            bind.endsWith(".description") &&
            bind.length > ".description".length
          ) {
            const basePath = bind.slice(0, -".description".length);
            const base = resolveBindPath(context, basePath);
            const originKey = String(base?.originKey || "").trim();
            const exprText = String((typeof base?.text === "string" && base.text.trim()) || (typeof base?.actual === "string" && base.actual.trim()) || "");

            const callerKey = String(context?.caller?.key || "").trim();
            const routineKey = String(context?.routine?.key || "").trim();
            const evalRoutineKey = callerKey && typeof base?.actual === "string" ? callerKey : routineKey || callerKey;

            if (exprText && evalRoutineKey) {
              let overrideByKey = null;
              if (overrideEntry instanceof Map) {
                overrideByKey = overrideEntry;
              } else if (originKey && overrideValue.trim()) {
                overrideByKey = new Map([[originKey, overrideValue]]);
              }

              if (overrideByKey && overrideByKey.size) {
                const resolved = desc.describeExpression(model, evalRoutineKey, exprText, { callPath, overrideByKey });
                const nextText = String(resolved?.text ?? "").trim();
                if (nextText) {
                  cell.text = nextText;
                  continue;
                }
              }
            }
          }

          if (typeof overrideEntry === "string") cell.text = overrideValue;
        }
      }

      tpl.getLocalTemplateOverrides = getLocalTemplateOverrides;
      tpl.setLocalTemplateOverride = setLocalTemplateOverride;
      tpl.setLocalTemplateOverrideByOriginKey = setLocalTemplateOverrideByOriginKey;
      tpl.resolveBindPath = resolveBindPath;
      tpl.applyOverridesToConfig = applyOverridesToConfig;
    })(window.AbapFlow);

    </script>
        <script>
    // js/ui_templates_flow.js
    (function (ns) {
      "use strict";

      const ui = ns.ui;
      const tpl = ui.templates;
      const utils = ns.utils;
      const extractSource =
        typeof utils?.extractSource === "function"
          ? utils.extractSource
          : (model, sourceRef) => {
              if (!model || !Array.isArray(model.lines) || !sourceRef) return "";
              const start = Math.max(1, Math.floor(Number(sourceRef.startLine || 1)));
              const end = Math.min(model.lines.length, Math.floor(Number(sourceRef.endLine || start)));
              return model.lines.slice(start - 1, end).join("\n").trim();
            };

      function computeIfIndentByLine(model, routine) {
        const out = new Map();
        if (!utils?.collectStatements || !utils?.normalizeSpaces || !utils?.stripTrailingPeriod) return out;

        const lines = model?.lines;
        const src = routine?.sourceRef;
        if (!Array.isArray(lines) || !src?.startLine || !src?.endLine) return out;

        const statements = utils.collectStatements(lines, src.startLine, src.endLine);

        let level = 0;
        for (const st of statements) {
          const normalized = utils.normalizeSpaces(utils.stripTrailingPeriod(st.text));
          if (!normalized) continue;

          const u = normalized.toUpperCase();

          if (u === "ENDIF" || u === "END IF") {
            level = Math.max(0, level - 1);
            out.set(st.startLine, level);
            continue;
          }

          if (u.startsWith("ELSEIF ")) {
            level = Math.max(0, level - 1);
            out.set(st.startLine, level);
            level += 1;
            continue;
          }

          if (u === "ELSE") {
            level = Math.max(0, level - 1);
            out.set(st.startLine, level);
            level += 1;
            continue;
          }

          if (u.startsWith("IF ")) {
            out.set(st.startLine, level);
            level += 1;
            continue;
          }

          out.set(st.startLine, level);
        }

        return out;
      }

      function listTemplateEntries() {
        const templates =
          ns.templateRegistry?.templates && typeof ns.templateRegistry.templates === "object" ? ns.templateRegistry.templates : {};
        const order = Array.isArray(ns.templateRegistry?.order)
          ? ns.templateRegistry.order
          : Object.keys(templates).sort((a, b) => a.localeCompare(b));

        const out = [];
        for (const id of order) {
          const t = templates[id];
          if (!t || typeof t !== "object") continue;
          const entry = { ...t, id: String(t.id || id) };
          out.push(entry);
        }

        return out;
      }

      function pickAutoTemplatesBySource(entries) {
        const out = new Map();
        for (const e of entries || []) {
          if (!e || typeof e !== "object") continue;
          if (e.auto === false) continue;
          const source = String(e.source || "").trim();
          if (!source) continue;
          if (!out.has(source)) out.set(source, []);
          out.get(source).push(e);
        }
        return out;
      }

      function resolvePath(obj, path) {
        const raw = String(path || "").trim();
        if (!raw) return undefined;

        let cur = obj;
        const parts = raw
          .split(".")
          .map((p) => p.trim())
          .filter(Boolean);

        for (const part of parts) {
          if (cur == null) return undefined;
          const m = /^([A-Za-z0-9_$]+)(.*)$/.exec(part);
          if (!m) return undefined;
          const prop = m[1];
          let rest = m[2] || "";
          cur = cur[prop];

          while (rest) {
            const m2 = /^\[(\d+)\](.*)$/.exec(rest);
            if (!m2) return undefined;
            const idx = Number(m2[1]);
            if (!Number.isFinite(idx)) return undefined;
            cur = cur == null ? undefined : cur[idx];
            rest = m2[2] || "";
          }
        }

        return cur;
      }

      function templateWhenMatches(entry, context) {
        const when = entry?.when;
        if (!when) return true;
        if (typeof when !== "object") return true;

        const path = String(when.path || "").trim();
        if (!path) return true;

        const actual = resolvePath(context, path);
        const expected = when.equals;
        if (expected == null) return Boolean(actual);

        return String(actual ?? "")
          .trim()
          .toUpperCase() === String(expected ?? "")
          .trim()
          .toUpperCase();
      }

      function pickTemplateEntry(entries, context, sourceId) {
        const list = Array.isArray(entries) ? entries : [];
        if (!list.length) return null;

        const preferredId =
          ns.templateDefs && typeof ns.templateDefs.getPreferredTemplateId === "function" ? ns.templateDefs.getPreferredTemplateId(sourceId) : "";
        if (preferredId) {
          const preferred = list.find((e) => String(e?.id || "").trim() === preferredId) || null;
          if (preferred && templateWhenMatches(preferred, context)) return preferred;
        }

        for (const e of list) {
          if (templateWhenMatches(e, context)) return e;
        }
        return list[0] || null;
      }

      function getProgramEntrypoints(model) {
        const nodes = Array.from(model?.nodes?.values ? model.nodes.values() : []);
        const byLine = (a, b) => (a?.sourceRef?.startLine ?? 1e9) - (b?.sourceRef?.startLine ?? 1e9);

        const events = nodes
          .filter((n) => n && n.kind === "EVENT")
          .slice()
          .sort(byLine)
          .map((n) => n.key);
        if (events.length) return events;

        const roots = nodes
          .filter((n) => n && n.kind === "FORM" && n.isDefined && (n.calledBy?.length || 0) === 0)
          .slice()
          .sort(byLine)
          .map((n) => n.key);
        if (roots.length) return roots;

        return nodes
          .filter((n) => n && n.kind === "FORM" && n.isDefined)
          .slice()
          .sort(byLine)
          .map((n) => n.key);
      }

      function edgeIdFrom(edge) {
        const fromKey = String(edge?.fromKey || "");
        const toKey = String(edge?.toKey || "");
        const start = Math.max(0, Math.floor(Number(edge?.sourceRef?.startLine || 0)));
        const end = Math.max(start, Math.floor(Number(edge?.sourceRef?.endLine || start)));
        return `${fromKey}->${toKey}@${start}-${end}`;
      }

      function statementIdFrom(objectId, routineKey, sourceRef) {
        const ok = String(objectId || "").trim() || "ST";
        const rk = String(routineKey || "").trim() || "ROUTINE";
        const start = Math.max(0, Math.floor(Number(sourceRef?.startLine || 0)));
        const end = Math.max(start, Math.floor(Number(sourceRef?.endLine || start)));

        if (ok === "assignment") return `${rk}@${start}-${end}`;
        if (ok === "if") return `IF:${rk}@${start}-${end}`;
        if (ok === "message") return `MSG:${rk}@${start}-${end}`;
        if (ok === "itabOp") return `ITAB:${rk}@${start}-${end}`;

        return `ST:${ok}:${rk}@${start}-${end}`;
      }

      function routineTemplateSteps(model, routineKey, templatesBySource) {
        const routine = model?.nodes?.get ? model.nodes.get(routineKey) : null;
        if (!routine) return [];

        const steps = [];

        if (Array.isArray(routine.statementItems)) {
          for (const item of routine.statementItems) {
            const objectId = String(item?.objectId || "").trim();
            if (!objectId) continue;
            if (!templatesBySource.has(objectId)) continue;
            const src = item?.sourceRef || null;
            if (!src) continue;
            steps.push({ kind: "statement", objectId, sourceRef: src, routineKey, routine, item });
          }
        }

        const registry = ns.abapObjects?.getRegistry?.() || null;
        if (registry && Array.isArray(routine.calls)) {
          for (const edge of routine.calls) {
            if (!edge?.sourceRef) continue;
            const objDef = registry.matchCallEdge?.(edge) || null;
            const objectId = String(objDef?.id || "").trim();
            if (!objectId) continue;
            if (!templatesBySource.has(objectId)) continue;
            steps.push({ kind: "callEdge", objectId, sourceRef: edge.sourceRef, routineKey, routine, edge, objDef });
          }
        }

        steps.sort((a, b) => Number(a?.sourceRef?.startLine || 0) - Number(b?.sourceRef?.startLine || 0));
        return steps;
      }

      function buildTemplatesFlow(model, templatesBySource, options) {
        const maxSteps = Math.max(50, Number(options?.maxSteps || 900));
        const items = [];
        let truncated = false;

        const converter = ns.templateConverter;
        if (!converter) return { items: [], truncated: false };
        const registry = ns.abapObjects?.getRegistry?.() || null;
        if (!registry) return { items: [], truncated: false };

        function convertCallEdge(step, callPath) {
          const objEntries = templatesBySource.get(step.objectId);
          if (!Array.isArray(objEntries) || objEntries.length === 0) return null;

          const ctx = registry.buildContext(step.objDef, model, step.routine, step.edge, { callPath });
          if (!ctx) return null;

          const entry = pickTemplateEntry(objEntries, ctx, step.objectId);
          if (!entry?.config) return null;

          const expanded = converter.expandExcelLikeTableTemplate(entry.config, ctx);
          const filled = converter.compactExcelLikeTableConfig(converter.fillTemplateConfig(expanded, ctx));
          const resultId = edgeIdFrom(step.edge);
          tpl.applyOverridesToConfig(filled, tpl.getLocalTemplateOverrides(entry.id, resultId), { model, context: ctx, callPath });

          return {
            kind: String(step.objectId || "callEdge"),
            objectId: String(step.objectId || ""),
            templateId: String(entry.id || ""),
            resultId,
            routineKey: String(step.routineKey || ""),
            callPath: Array.isArray(callPath) ? callPath : null,
            edge: step.edge,
            context: ctx,
            sourceRef: step.edge?.sourceRef || null,
            original: extractSource(model, step.edge?.sourceRef) || `CALL ${String(step.edge?.targetName || "").trim()}`,
            filledConfig: filled,
          };
        }

        function convertStatement(step, callPath) {
          const objEntries = templatesBySource.get(step.objectId);
          if (!Array.isArray(objEntries) || objEntries.length === 0) return null;

          const objDef = registry.objectsById?.get ? registry.objectsById.get(step.objectId) : null;
          if (!objDef) return null;

          const ctx = registry.buildContext(objDef, model, step.routine, step.item?.payload || null, { callPath });
          if (!ctx) return null;

          const entry = pickTemplateEntry(objEntries, ctx, step.objectId);
          if (!entry?.config) return null;

          const expanded = converter.expandExcelLikeTableTemplate(entry.config, ctx);
          const filled = converter.compactExcelLikeTableConfig(converter.fillTemplateConfig(expanded, ctx));
          const resultId = statementIdFrom(step.objectId, step.routineKey, step.item?.sourceRef);
          tpl.applyOverridesToConfig(filled, tpl.getLocalTemplateOverrides(entry.id, resultId), { model, context: ctx, callPath });

          const fallback = String(step.item?.payload?.statement || "").trim() || String(objDef.label || step.objectId);

          return {
            kind: String(step.objectId || "statement"),
            objectId: String(step.objectId || ""),
            templateId: String(entry.id || ""),
            resultId,
            routineKey: String(step.routineKey || ""),
            callPath: Array.isArray(callPath) ? callPath : null,
            item: step.item,
            context: ctx,
            sourceRef: step.item?.sourceRef || null,
            original: extractSource(model, step.item?.sourceRef) || fallback,
            filledConfig: filled,
          };
        }

        function walk(routineKey, depth, stack, callPath) {
          const routine = model?.nodes?.get ? model.nodes.get(routineKey) : null;
          if (!routine) return;

          const ifIndentByLine = computeIfIndentByLine(model, routine);

          if (items.length >= maxSteps) {
            truncated = true;
            return;
          }

          stack.add(routineKey);

          const steps = routineTemplateSteps(model, routineKey, templatesBySource);
          for (const step of steps) {
            if (items.length >= maxSteps) {
              truncated = true;
              break;
            }

            const indentWithinIf = Number(ifIndentByLine.get(step?.sourceRef?.startLine) || 0);
            const stepDepth = depth + Math.max(0, indentWithinIf);

            if (step.kind === "statement") {
              const r = convertStatement(step, callPath);
              if (r) items.push({ kind: "template", depth: stepDepth, isRecursion: false, result: r });
              continue;
            }

            if (step.kind === "callEdge") {
              const isRecursion = stack.has(step.edge?.toKey);
              const r = convertCallEdge(step, callPath);
              if (r) items.push({ kind: "template", depth: stepDepth, isRecursion, result: r });
              if (!isRecursion && step.edge?.toKey) {
                walk(step.edge.toKey, stepDepth + 1, stack, (callPath || []).concat([step.edge]));
              }
            }
          }

          stack.delete(routineKey);
        }

        const roots = getProgramEntrypoints(model);
        for (const rootKey of roots) {
          const root = model.nodes.get(rootKey);
          items.push({ kind: "separator", label: root ? `${root.kind} ${root.name}` : rootKey, rootKey });
          walk(rootKey, 0, new Set(), []);
          if (truncated) break;
        }

        if (truncated) {
          items.push({ kind: "note", text: `Truncated at ${maxSteps} steps.` });
        }

        return { items, truncated, maxSteps };
      }

      tpl.listTemplateEntries = listTemplateEntries;
      tpl.pickAutoTemplatesBySource = pickAutoTemplatesBySource;
      tpl.buildTemplatesFlow = buildTemplatesFlow;
    })(window.AbapFlow);

    </script>
        <script>
    // js/ui_clipboard.js
    (function (ns) {
      "use strict";

      const ui = ns.ui;
      ui.clipboard = ui.clipboard || {};

      function copyHtmlViaExecCommand(html) {
        const el = document.createElement("div");
        el.contentEditable = "true";
        el.style.position = "fixed";
        el.style.left = "-10000px";
        el.style.top = "0";
        el.style.width = "1px";
        el.style.height = "1px";
        el.style.overflow = "hidden";
        el.innerHTML = String(html || "");
        document.body.appendChild(el);

        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(el);
        selection.removeAllRanges();
        selection.addRange(range);

        let ok = false;
        try {
          ok = document.execCommand("copy");
        } catch (_) {
          ok = false;
        }

        selection.removeAllRanges();
        el.remove();
        return ok;
      }

      async function copyHtmlToClipboard(html, plainText) {
        const htmlText = String(html ?? "");
        const textText = String(plainText ?? "");

        if (navigator.clipboard && navigator.clipboard.write && window.ClipboardItem) {
          try {
            const item = new ClipboardItem({
              "text/html": new Blob([htmlText], { type: "text/html" }),
              "text/plain": new Blob([textText], { type: "text/plain" }),
            });
            await navigator.clipboard.write([item]);
            return true;
          } catch (_) {
            // fallback below
          }
        }

        if (htmlText.trim()) return copyHtmlViaExecCommand(htmlText);

        if (navigator.clipboard && navigator.clipboard.writeText) {
          try {
            await navigator.clipboard.writeText(textText);
            return true;
          } catch (_) {
            // ignore
          }
        }

        const ta = document.createElement("textarea");
        ta.value = textText;
        ta.style.position = "fixed";
        ta.style.left = "-10000px";
        ta.style.top = "0";
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        let ok = false;
        try {
          ok = document.execCommand("copy");
        } catch (_) {
          ok = false;
        }
        ta.remove();
        return ok;
      }

      ui.clipboard.copyHtml = copyHtmlToClipboard;
    })(window.AbapFlow);


    </script>
        <script>
    // js/ui_templates_render.js
    (function (ns) {
      "use strict";

      const ui = ns.ui;
      const tpl = ui.templates;
      const state = ui.state;

      let templateResultById = new Map();
      let selectedTemplateCard = null;
      let selectedTemplateResultIds = new Set();
      let collapsedTemplateResultIds = new Set();
      let tableByResultId = new Map();
      let lastRenderOrder = [];
      let lastToolbarUpdate = null;

      function scrollToTemplateResultId(resultId) {
        const id = String(resultId || "").trim();
        if (!id) return;
        if (!state.model) return;

        if (typeof ui.setActiveTab === "function") ui.setActiveTab("templates");

        requestAnimationFrame(() => {
          renderTemplates({ autoSelectResultId: id });
        });
      }

      function isEditableDescriptionBind(bind) {
        const b = String(bind || "").trim();
        if (!b) return false;
        if (b === "perform.description") return true;
        if (b === "item.description" || b === "value.description") return true;
        if (b === "table.description" || b === "target.description") return true;
        if (/^(?:msgClass|msgNo|displayLike|messageText|into|raising)\.description$/.test(b)) return true;
        if (/^with\[\d+\]\.description$/.test(b)) return true;
        if (/^conditions\[\d+\]\.(?:item1|item2)\.description$/.test(b)) return true;
        return /^(tables|using|changing|raising)\[\d+\]\.description$/.test(b);
      }

      function labelForDescriptionBind(result, bind) {
        const b = String(bind || "").trim();
        const ctx = result?.context;
        const performName = String(ctx?.perform?.name || "").trim();

        if (b === "item.description") {
          const item = String(ctx?.assignment?.lhs || "").trim();
          return item ? `Desc Item: ${item}` : "Desc Item";
        }

        if (b === "value.description") {
          const value = String(ctx?.assignment?.rhs || "").trim();
          return value ? `Desc Value: ${value}` : "Desc Value";
        }

        if (b === "table.description") {
          const text = String(ctx?.table?.text || "").trim();
          return text ? `Desc Internal table: ${text}` : "Desc Internal table";
        }

        if (b === "target.description") {
          const text = String(ctx?.target?.text || "").trim();
          return text ? `Desc Target: ${text}` : "Desc Target";
        }

        const msgMatch = /^(msgClass|msgNo|displayLike|messageText|into|raising)\.description$/.exec(b);
        if (msgMatch) {
          const prop = String(msgMatch[1] || "");
          const node = ctx?.[prop] || null;
          const text = String(node?.text || "").trim();
          const label =
            prop === "msgClass"
              ? "Message class"
              : prop === "msgNo"
                ? "Message No."
                : prop === "displayLike"
                  ? "Display like"
                  : prop === "messageText"
                    ? "Message text"
                    : prop === "into"
                      ? "Destination"
                      : prop === "raising"
                        ? "Raising"
                        : prop;
          return text ? `Desc ${label}: ${text}` : `Desc ${label}`;
        }

        const withMatch = /^with\[(\d+)\]\.description$/.exec(b);
        if (withMatch) {
          const idx = Number(withMatch[1]);
          const node = ctx?.with?.[idx] || null;
          const text = String(node?.text || "").trim();
          const label = `Message &${idx + 1}`;
          return text ? `Desc ${label}: ${text}` : `Desc ${label}`;
        }

        const condMatch = /^conditions\[(\d+)\]\.(item1|item2)\.description$/.exec(b);
        if (condMatch) {
          const idx = Number(condMatch[1]);
          const side = String(condMatch[2] || "").trim();
          const cond = ctx?.conditions?.[idx] || null;
          const itemText = side === "item2" ? String(cond?.item2?.text || "").trim() : String(cond?.item1?.text || "").trim();
          const op = String(cond?.operator || "").trim();
          const label = side === "item2" ? "Item 2" : "Item 1";
          const tail = itemText ? `${itemText}${op ? ` (${op})` : ""}` : `#${idx + 1}`;
          return `Desc ${label}: ${tail}`;
        }
        if (!b) return "M t";

        if (b === "perform.description") return performName ? `M t FORM ${performName}` : "M t FORM";

        const m = /^(tables|using|changing|raising)\[(\d+)\]\.description$/.exec(b);
        if (!m) return "M t";

        const list = m[1];
        const idx = Number(m[2]);
        const item = ctx?.[list]?.[idx] || null;
        const kind = String(list || "").toUpperCase();
        const actual = String(item?.actual || "").trim();
        const formal = String(item?.name || "").trim();

        if (actual && formal) return `M t ${kind}: ${actual}  ${formal}`;
        if (formal) return `M t ${kind}: ${formal}`;
        if (actual) return `M t ${kind}: ${actual}`;
        return `M t ${kind}`;
      }

      function resolveGlobalDescriptionKey(result, bind) {
        const b = String(bind || "").trim();
        const ctx = result?.context;
        if (!ctx) return null;

        function keyFromExprNode(node) {
          const originKey = String(node?.originKey || "").trim();
          if (originKey) return { key: originKey };

          if (!ns.notes?.makeDeclKey || !ns.lineage?.resolveSymbol) return null;

          const model = state.model;
          const routineKey = String(result?.routineKey || ctx.routine?.key || "").trim();
          const exprText = String(node?.text || "").trim();
          if (!model || !routineKey || !exprText) return null;

          const root =
            typeof ns.desc?.rootFromPath === "function"
              ? ns.desc.rootFromPath(exprText)
              : (/^[A-Za-z_][A-Za-z0-9_\/]*/.exec(exprText) || [])[0] || "";
          if (!root) return null;

          const resolution = ns.lineage.resolveSymbol(model, routineKey, root);
          if (!resolution || resolution.scope === "unknown") return null;

          if (resolution.scope === "parameter") {
            const key = ns.notes.makeParamKey?.(routineKey, root);
            return key ? { key } : null;
          }

          if (resolution.scope === "local" || resolution.scope === "global") {
            const declKind = String(resolution.decl?.declKind || "").trim();
            if (!declKind) return null;
            const scopeKey = resolution.scope === "global" ? "PROGRAM" : routineKey;
            const key = ns.notes.makeDeclKey(scopeKey, declKind, root);
            return key ? { key } : null;
          }

          return null;
        }

        if (b === "table.description") return keyFromExprNode(ctx?.table);
        if (b === "target.description") return keyFromExprNode(ctx?.target);

        const msgMatch = /^(msgClass|msgNo|displayLike|messageText|into|raising)\.description$/.exec(b);
        if (msgMatch) return keyFromExprNode(ctx?.[msgMatch[1]]);

        const withMatch = /^with\[(\d+)\]\.description$/.exec(b);
        if (withMatch) return keyFromExprNode(ctx?.with?.[Number(withMatch[1])]);

        if (b === "perform.description") {
          const key = String(ctx.perform?.originKey || ctx.perform?.key || "").trim();
          return key ? { key } : null;
        }

        const condMatch = /^conditions\[(\d+)\]\.(item1|item2)\.description$/.exec(b);
        if (condMatch) {
          const idx = Number(condMatch[1]);
          const side = String(condMatch[2] || "").trim();
          const k = String(ctx?.conditions?.[idx]?.[side]?.originKey || "").trim();
          if (k) return { key: k };

          if (!ns.notes?.makeDeclKey || !ns.lineage?.resolveSymbol) return null;

          const model = state.model;
          const routineKey = String(result?.routineKey || ctx.routine?.key || "").trim();
          const cond = ctx?.conditions?.[idx] || null;
          const root = side === "item2" ? String(cond?.item2?.root || "").trim() : String(cond?.item1?.root || "").trim();
          if (!model || !routineKey || !root) return null;

          const resolution = ns.lineage.resolveSymbol(model, routineKey, root);
          if (!resolution || resolution.scope === "unknown") return null;

          if (resolution.scope === "parameter") {
            const key = ns.notes.makeParamKey(routineKey, root);
            return key ? { key } : null;
          }

          if (resolution.scope === "local" || resolution.scope === "global") {
            const declKind = String(resolution.decl?.declKind || "").trim();
            if (!declKind) return null;
            const scopeKey = resolution.scope === "global" ? "PROGRAM" : routineKey;
            const key = ns.notes.makeDeclKey(scopeKey, declKind, root);
            return key ? { key } : null;
          }

          return null;
        }

        if (b === "item.description" || b === "value.description") {
          const key =
            b === "item.description"
              ? String(ctx?.item?.originKey || "").trim()
              : String(ctx?.value?.originKey || "").trim();
          if (key) return { key };

          if (!ns.notes?.makeDeclKey || !ns.lineage?.resolveSymbol) return null;

          const model = state.model;
          const routineKey = String(result?.routineKey || ctx.routine?.key || "").trim();
          const root = b === "item.description" ? String(ctx?.item?.root || "").trim() : String(ctx?.value?.root || "").trim();
          if (!model || !routineKey || !root) return null;

          const resolution = ns.lineage.resolveSymbol(model, routineKey, root);
          if (!resolution || resolution.scope === "unknown") return null;

          if (resolution.scope === "parameter") {
            const key = ns.notes.makeParamKey(routineKey, root);
            return key ? { key } : null;
          }

          if (resolution.scope === "local" || resolution.scope === "global") {
            const declKind = String(resolution.decl?.declKind || "").trim();
            if (!declKind) return null;
            const scopeKey = resolution.scope === "global" ? "PROGRAM" : routineKey;
            const key = ns.notes.makeDeclKey(scopeKey, declKind, root);
            return key ? { key } : null;
          }

          return null;
        }

        const m = /^(tables|using|changing|raising)\[(\d+)\]\.description$/.exec(b);
        if (!m) return null;

        const list = m[1];
        const idx = Number(m[2]);
        const item = ctx?.[list]?.[idx] || null;
        const originKey = String(item?.originKey || "").trim();
        if (originKey) return { key: originKey };

        const formalName = String(item?.name || "").trim();
        const routineKey = String(ctx.perform?.key || "").trim();
        if (!ns.notes?.makeParamKey || !routineKey || !formalName) return null;

        const key = ns.notes.makeParamKey(routineKey, formalName);
        return key ? { key } : null;
      }

      // Config-driven templates support:
      // - Allow editing any `*.description` cell (local override or global notes).
      // - Resolve the "global" target using `originKey` when available, otherwise fall back to symbol resolution.
      function isEditableDescriptionBind(bind) {
        const b = String(bind || "").trim();
        return b.endsWith(".description") && b.length > ".description".length;
      }

      function labelForDescriptionBind(result, bind) {
        const b = String(bind || "").trim();
        if (!b || !isEditableDescriptionBind(b)) return "Edit description";

        const ctx = result?.context || null;
        const basePath = b.slice(0, -".description".length);
        const node = typeof tpl.resolveBindPath === "function" ? tpl.resolveBindPath(ctx, basePath) : null;

        if (basePath === "perform") {
          const performName = String(ctx?.perform?.name || "").trim();
          return performName ? `Description FORM ${performName}` : "Description FORM";
        }

        const text = String(node?.text ?? node?.actual ?? node?.name ?? "").trim();
        if (text) return `Description: ${text}`;
        return `Description: ${basePath}`;
      }

      function resolveGlobalDescriptionKey(result, bind) {
        const b = String(bind || "").trim();
        if (!b || !isEditableDescriptionBind(b)) return null;

        const ctx = result?.context || null;
        if (!ctx) return null;

        const basePath = b.slice(0, -".description".length);
        const node = typeof tpl.resolveBindPath === "function" ? tpl.resolveBindPath(ctx, basePath) : null;
        if (!node || typeof node !== "object") return null;

        const originKey = String(node?.originKey || "").trim();
        if (originKey) return { key: originKey };

        const calleeKey = String(ctx?.perform?.key || "").trim();
        const formalName = String(node?.name || "").trim();
        if (calleeKey && formalName && typeof ns.notes?.makeParamKey === "function") {
          const key = ns.notes.makeParamKey(calleeKey, formalName);
          if (key) return { key };
        }

        if (!ns.notes?.makeDeclKey || !ns.lineage?.resolveSymbol) return null;

        const model = state.model;
        if (!model) return null;

        const exprText = String(
          (typeof node?.text === "string" && node.text.trim()) || (typeof node?.actual === "string" && node.actual.trim()) || "",
        ).trim();
        if (!exprText) return null;

        const callerKey = String(ctx?.caller?.key || "").trim();
        const routineKey = String(result?.routineKey || ctx?.routine?.key || "").trim();
        const evalRoutineKey = callerKey && typeof node?.actual === "string" ? callerKey : routineKey || callerKey;
        if (!evalRoutineKey) return null;

        const root =
          typeof ns.desc?.rootFromPath === "function"
            ? ns.desc.rootFromPath(exprText)
            : (/^[A-Za-z_][A-Za-z0-9_\/]*/.exec(exprText) || [])[0] || "";
        if (!root) return null;

        const resolution = ns.lineage.resolveSymbol(model, evalRoutineKey, root);
        if (!resolution || resolution.scope === "unknown") return null;

        if (resolution.scope === "parameter") {
          const key = ns.notes.makeParamKey?.(evalRoutineKey, root);
          return key ? { key } : null;
        }

        if (resolution.scope === "local" || resolution.scope === "global") {
          const declKind = String(resolution.decl?.declKind || "").trim();
          if (!declKind) return null;
          const scopeKey = resolution.scope === "global" ? "PROGRAM" : evalRoutineKey;
          const key = ns.notes.makeDeclKey(scopeKey, declKind, root);
          return key ? { key } : null;
        }

        return null;
      }

      function openDescriptionEditorDialog(options) {
        const titleText = String(options?.title || "Edit description");
        const initialValue = String(options?.value ?? "");

        return new Promise((resolve) => {
          const overlay = document.createElement("div");
          overlay.className = "demo-modal";

          const dialog = document.createElement("div");
          dialog.className = "demo-modal__dialog";
          overlay.appendChild(dialog);

          const title = document.createElement("div");
          title.className = "demo-modal__title";
          title.textContent = titleText;
          dialog.appendChild(title);

          const textarea = document.createElement("textarea");
          textarea.className = "input demo-modal__textarea";
          textarea.value = initialValue;
          textarea.placeholder = "Nhp m t...";
          dialog.appendChild(textarea);

          const hint = document.createElement("div");
          hint.className = "demo-modal__hint";
          hint.textContent = "Chn phm vi cp nht:";
          dialog.appendChild(hint);

          const actions = document.createElement("div");
          actions.className = "demo-modal__actions";
          dialog.appendChild(actions);

          const btnCancel = document.createElement("button");
          btnCancel.type = "button";
          btnCancel.className = "btn";
          btnCancel.textContent = "Hy";

          const btnClear = document.createElement("button");
          btnClear.type = "button";
          btnClear.className = "btn";
          btnClear.textContent = "Xa m t";

          const btnLocal = document.createElement("button");
          btnLocal.type = "button";
          btnLocal.className = "btn";
          btnLocal.textContent = "Ch template hin ti";

          const btnGlobal = document.createElement("button");
          btnGlobal.type = "button";
          btnGlobal.className = "btn btn-primary";
          btnGlobal.textContent = "Ton b template";

          actions.appendChild(btnCancel);
          actions.appendChild(btnClear);
          actions.appendChild(btnLocal);
          actions.appendChild(btnGlobal);

          function cleanup() {
            window.removeEventListener("keydown", onKeyDown);
            overlay.remove();
          }

          function close(action) {
            const value = textarea.value;
            cleanup();
            resolve({ action, value });
          }

          function onKeyDown(e) {
            if (e.key === "Escape") {
              e.preventDefault();
              close("cancel");
            }
          }

          overlay.addEventListener("click", (e) => {
            if (e.target === overlay) close("cancel");
          });
          btnCancel.addEventListener("click", () => close("cancel"));
          btnClear.addEventListener("click", () => close("clear"));
          btnLocal.addEventListener("click", () => close("local"));
          btnGlobal.addEventListener("click", () => close("global"));
          window.addEventListener("keydown", onKeyDown);

          document.body.appendChild(overlay);
          textarea.focus();
          textarea.select();
        });
      }

      function originLabel(origin) {
        const kind = String(origin?.kind || "").trim().toUpperCase();
        const key = String(origin?.key || "").trim();

        if (kind === "DECL") {
          const vn = String(origin?.entity?.variableName || "").trim();
          if (vn) return vn;
          return String(origin?.name || "").trim();
        }

        if (kind === "PARAM") {
          const pn = String(origin?.entity?.name || "").trim();
          if (pn) return pn;
          return String(origin?.name || "").trim();
        }

        if (kind === "TYPEFIELD") {
          const m = /^TYPEFIELD:[^:]*:([^:]+):(.+)$/.exec(key);
          if (m) return `${m[1]}-${m[2]}`;
          return String(origin?.name || "").trim();
        }

        return String(origin?.name || "").trim() || key;
      }

      function openDescriptionEditorDialogForTargets(options) {
        const titleText = String(options?.title || "Edit description");
        const targets = Array.isArray(options?.targets) ? options.targets : [];
        const initialByKey = options?.initialByKey && typeof options.initialByKey === "object" ? options.initialByKey : {};
        const initialKey = String(options?.initialKey || (targets[0] ? targets[0].key : "") || "").trim();

        return new Promise((resolve) => {
          const overlay = document.createElement("div");
          overlay.className = "demo-modal";

          const dialog = document.createElement("div");
          dialog.className = "demo-modal__dialog";
          overlay.appendChild(dialog);

          const title = document.createElement("div");
          title.className = "demo-modal__title";
          title.textContent = titleText;
          dialog.appendChild(title);

          let selectedKey = initialKey;
          const draftByKey = new Map();

          function getInitialForKey(key) {
            return String(initialByKey[String(key || "")] ?? "");
          }

          for (const t of targets) {
            const k = String(t?.key || "").trim();
            if (!k) continue;
            draftByKey.set(k, getInitialForKey(k));
          }

          let select = null;
          if (targets.length > 1) {
            const row = document.createElement("div");
            row.style.display = "flex";
            row.style.gap = "8px";
            row.style.alignItems = "center";
            row.style.marginBottom = "8px";

            const label = document.createElement("div");
            label.textContent = "Object:";
            label.style.minWidth = "64px";
            row.appendChild(label);

            select = document.createElement("select");
            select.className = "input";
            select.style.flex = "1";
            for (const t of targets) {
              const key = String(t?.key || "").trim();
              const labelText = String(t?.label || "").trim() || key;
              if (!key) continue;
              const opt = document.createElement("option");
              opt.value = key;
              opt.textContent = labelText;
              select.appendChild(opt);
            }
            if (selectedKey) select.value = selectedKey;
            row.appendChild(select);

            dialog.appendChild(row);
          }

          const textarea = document.createElement("textarea");
          textarea.className = "input demo-modal__textarea";
          textarea.value = selectedKey ? draftByKey.get(selectedKey) || "" : "";
          textarea.placeholder = "Nhp m t...";
          dialog.appendChild(textarea);

          const hint = document.createElement("div");
          hint.className = "demo-modal__hint";
          hint.textContent = "Chn phm vi cp nht:";
          dialog.appendChild(hint);

          const actions = document.createElement("div");
          actions.className = "demo-modal__actions";
          dialog.appendChild(actions);

          const btnCancel = document.createElement("button");
          btnCancel.type = "button";
          btnCancel.className = "btn";
          btnCancel.textContent = "Hy";

          const btnClear = document.createElement("button");
          btnClear.type = "button";
          btnClear.className = "btn";
          btnClear.textContent = "Xa m t";

          const btnLocal = document.createElement("button");
          btnLocal.type = "button";
          btnLocal.className = "btn";
          btnLocal.textContent = "Ch template hin ti";

          const btnGlobal = document.createElement("button");
          btnGlobal.type = "button";
          btnGlobal.className = "btn btn-primary";
          btnGlobal.textContent = "Ton b template";

          actions.appendChild(btnCancel);
          actions.appendChild(btnClear);
          actions.appendChild(btnLocal);
          actions.appendChild(btnGlobal);

          function cleanup() {
            window.removeEventListener("keydown", onKeyDown);
            overlay.remove();
          }

          function close(action) {
            if (selectedKey) draftByKey.set(selectedKey, textarea.value);
            const value = selectedKey ? draftByKey.get(selectedKey) || "" : textarea.value;
            cleanup();
            resolve({ action, value, targetKey: selectedKey });
          }

          function onKeyDown(e) {
            if (e.key === "Escape") {
              e.preventDefault();
              close("cancel");
            }
          }

          if (select) {
            select.addEventListener("change", () => {
              if (selectedKey) draftByKey.set(selectedKey, textarea.value);
              selectedKey = String(select.value || "").trim();
              textarea.value = selectedKey ? draftByKey.get(selectedKey) || "" : "";
              textarea.focus();
              textarea.select();
            });
          }

          overlay.addEventListener("click", (e) => {
            if (e.target === overlay) close("cancel");
          });
          btnCancel.addEventListener("click", () => close("cancel"));
          btnClear.addEventListener("click", () => close("clear"));
          btnLocal.addEventListener("click", () => close("local"));
          btnGlobal.addEventListener("click", () => close("global"));
          window.addEventListener("keydown", onKeyDown);

          document.body.appendChild(overlay);
          textarea.focus();
          textarea.select();
        });
      }

      function handleTemplatesDblClick(event) {
        const t = event?.target && event.target.nodeType === 1 ? event.target : event?.target?.parentElement;
        const td = t?.closest ? t.closest("td[data-bind]") : null;
        if (!td) return;

        const bind = String(td.dataset.bind || "").trim();
        if (!isEditableDescriptionBind(bind)) return;

        const card = td.closest(".template-block");
        const resultId = String(card?.dataset?.resultId || "").trim();
        const templateId = String(card?.dataset?.templateId || "").trim();
        if (!resultId || !templateId) return;

        const result = templateResultById.get(resultId) || null;
        if (!result) return;

        event.preventDefault();
        if (card && typeof card.click === "function") card.click();

        const title = labelForDescriptionBind(result, bind);

        // Multi-origin edit support (expressions / struct segments)
        try {
          const ctx = result?.context || null;
          const basePath = bind.slice(0, -".description".length);
          const node = ctx && typeof tpl.resolveBindPath === "function" ? tpl.resolveBindPath(ctx, basePath) : null;
          const baseOriginKey = String(node?.originKey || "").trim();

          const exprText = String(
            (typeof node?.text === "string" && node.text.trim()) ||
              (typeof node?.actual === "string" && node.actual.trim()) ||
              (typeof node?.name === "string" && node.name.trim()) ||
              "",
          ).trim();
          const callerKey = String(ctx?.caller?.key || "").trim();
          const routineKey = String(result?.routineKey || ctx?.routine?.key || "").trim();
          const evalRoutineKey = callerKey && typeof node?.actual === "string" ? callerKey : routineKey || callerKey;
          const callPath = Array.isArray(result?.callPath) ? result.callPath : null;

          if (state.model && evalRoutineKey && exprText && typeof ns.desc?.describeExpressionWithOrigin === "function") {
            const described = ns.desc.describeExpressionWithOrigin(state.model, evalRoutineKey, exprText, { callPath });
            const origins = Array.isArray(described?.origins) ? described.origins : [];

            if (origins.length > 1) {
              const targets = [];
              const seen = new Set();
              for (const o of origins) {
                const k = String(o?.key || "").trim();
                if (!k || seen.has(k)) continue;
                seen.add(k);
                targets.push({ key: k, label: originLabel(o), origin: o });
              }

              const overrides = typeof tpl.getLocalTemplateOverrides === "function" ? tpl.getLocalTemplateOverrides(templateId, resultId) : null;
              const overridesEntry = overrides && typeof overrides.get === "function" ? overrides.get(bind) : null;

              function hasLocalOverrideForTarget(targetKey) {
                const tk = String(targetKey || "").trim();
                if (!tk) return false;
                if (overridesEntry instanceof Map) return overridesEntry.has(tk);
                if (typeof overridesEntry === "string") return Boolean(baseOriginKey && tk === baseOriginKey && String(overridesEntry || "").trim());
                return false;
              }

              function localOverrideValueForTarget(targetKey) {
                const tk = String(targetKey || "").trim();
                if (!tk) return "";
                if (overridesEntry instanceof Map) return String(overridesEntry.get(tk) ?? "");
                if (typeof overridesEntry === "string" && baseOriginKey && tk === baseOriginKey) return String(overridesEntry ?? "");
                return "";
              }

              const initialByKey = {};
              for (const t2 of targets) {
                const k = String(t2?.key || "").trim();
                if (!k) continue;
                const localValue = localOverrideValueForTarget(k);
                if (localValue.trim()) {
                  initialByKey[k] = localValue;
                  continue;
                }
                const origin = t2.origin;
                const fallback = String(origin?.name || "").trim();
                initialByKey[k] = typeof ns.desc?.pickDescription === "function" ? ns.desc.pickDescription(origin?.entity || null, fallback) : fallback;
              }

              openDescriptionEditorDialogForTargets({ title, targets, initialByKey, initialKey: targets[0]?.key || "" }).then(
                ({ action, value, targetKey }) => {
                  const tk = String(targetKey || "").trim();
                  const nextValue = String(value ?? "").trim();
                  if (action === "cancel") return;
                  if (!tk) {
                    ui.setStatus("Cannot resolve object for this cell.", true);
                    return;
                  }

                  if (action === "clear") {
                    if (hasLocalOverrideForTarget(tk)) {
                      tpl.setLocalTemplateOverrideByOriginKey?.(templateId, resultId, bind, tk, "", baseOriginKey);
                      renderTemplates({ autoSelectResultId: resultId });
                      ui.setStatus("Cleared description (local).", false);
                      return;
                    }

                    if (!ns.notes?.setEntry) {
                      ui.setStatus("Cannot clear description for this cell.", true);
                      return;
                    }

                    tpl.setLocalTemplateOverrideByOriginKey?.(templateId, resultId, bind, tk, "", baseOriginKey);
                    ns.notes.setEntry(tk, { description: "" });
                    if (state.model && ns.notes?.applyToModel) ns.notes.applyToModel(state.model);
                    renderTemplates({ autoSelectResultId: resultId });
                    ui.setStatus("Cleared description.", false);
                    return;
                  }

                  if (action === "local") {
                    if (typeof tpl.setLocalTemplateOverrideByOriginKey === "function") {
                      tpl.setLocalTemplateOverrideByOriginKey(templateId, resultId, bind, tk, nextValue, baseOriginKey);
                    } else {
                      tpl.setLocalTemplateOverride?.(templateId, resultId, bind, nextValue);
                    }
                    renderTemplates({ autoSelectResultId: resultId });
                    ui.setStatus("Saved description (local).", false);
                    return;
                  }

                  if (action === "global") {
                    if (!ns.notes?.setEntry) {
                      ui.setStatus("Cannot update global description for this cell.", true);
                      return;
                    }
                    tpl.setLocalTemplateOverrideByOriginKey?.(templateId, resultId, bind, tk, "", baseOriginKey);
                    ns.notes.setEntry(tk, { description: nextValue });
                    if (state.model && ns.notes?.applyToModel) ns.notes.applyToModel(state.model);
                    renderTemplates({ autoSelectResultId: resultId });
                    ui.setStatus("Saved description (global).", false);
                  }
                },
              );

              return;
            }
          }
        } catch (_) {
          // ignore and fall back to single-key editor
        }

        const initial = String(td.textContent ?? "");

        openDescriptionEditorDialog({ title, value: initial }).then(({ action, value }) => {
          const nextValue = String(value ?? "").trim();
          if (action === "cancel") return;

          if (action === "clear") {
            const overrides = typeof tpl.getLocalTemplateOverrides === "function" ? tpl.getLocalTemplateOverrides(templateId, resultId) : null;
            if (overrides && typeof overrides.has === "function" && overrides.has(bind)) {
              tpl.setLocalTemplateOverride?.(templateId, resultId, bind, "");
              renderTemplates({ autoSelectResultId: resultId });
              ui.setStatus(" xa m t (template hin ti).", false);
              return;
            }

            const target = resolveGlobalDescriptionKey(result, bind);
            if (!target || !ns.notes?.setEntry) {
              ui.setStatus("Khng th xa m t cho mc ny.", true);
              return;
            }

            tpl.setLocalTemplateOverride?.(templateId, resultId, bind, "");
            ns.notes.setEntry(target.key, { description: "" });
            if (state.model && ns.notes?.applyToModel) ns.notes.applyToModel(state.model);
            renderTemplates({ autoSelectResultId: resultId });
            ui.setStatus(" xa m t.", false);
            return;
          }

          if (action === "local") {
            tpl.setLocalTemplateOverride(templateId, resultId, bind, nextValue);
            renderTemplates({ autoSelectResultId: resultId });
            ui.setStatus(" lu m t (ch template hin ti).", false);
            return;
          }

          if (action === "global") {
            const target = resolveGlobalDescriptionKey(result, bind);
            if (!target || !ns.notes?.setEntry) {
              ui.setStatus("Khng th cp nht ton b cho mc ny.", true);
              return;
            }

            tpl.setLocalTemplateOverride(templateId, resultId, bind, "");
            ns.notes.setEntry(target.key, { description: nextValue });
            if (state.model && ns.notes?.applyToModel) ns.notes.applyToModel(state.model);
            renderTemplates({ autoSelectResultId: resultId });
            ui.setStatus(" lu m t (ton b template).", false);
          }
        });
      }

      function updateTemplatesToolbar() {
        if (typeof lastToolbarUpdate === "function") lastToolbarUpdate();
      }

      function applyTemplateTreeState(host) {
        if (!host) return;

        const cards = Array.from(host.querySelectorAll(".template-block"));
        const collapsedDepths = [];

        for (const card of cards) {
          const depth = Math.max(0, Math.floor(Number(card.dataset.depth || 0)));
          while (collapsedDepths.length && depth <= collapsedDepths[collapsedDepths.length - 1]) collapsedDepths.pop();

          const hidden = collapsedDepths.length > 0;
          card.classList.toggle("is-tree-hidden", hidden);

          const resultId = String(card.dataset.resultId || "");
          const collapsed = collapsedTemplateResultIds.has(resultId);
          card.classList.toggle("is-collapsed", collapsed);

          const toggle = card.querySelector("button.template-block__toggle");
          if (toggle) toggle.setAttribute("aria-expanded", String(!collapsed));

          if (!hidden && collapsed) collapsedDepths.push(depth);
        }
      }

      function toggleTemplateCollapsed(resultId, host) {
        const id = String(resultId || "").trim();
        if (!id) return;
        if (collapsedTemplateResultIds.has(id)) collapsedTemplateResultIds.delete(id);
        else collapsedTemplateResultIds.add(id);
        applyTemplateTreeState(host || ui.$("templatesHost"));
      }

      function setTemplateSelected(resultId, selected) {
        const id = String(resultId || "").trim();
        if (!id) return;
        if (selected) selectedTemplateResultIds.add(id);
        else selectedTemplateResultIds.delete(id);
        updateTemplatesToolbar();
      }

      function cloneTableWithTrailingBlankRow(tableEl) {
        if (!tableEl || typeof tableEl.cloneNode !== "function") return null;
        const clone = tableEl.cloneNode(true);

        const colCount = clone.querySelectorAll("colgroup col").length || 1;

        const td = document.createElement("td");
        td.textContent = "\u00a0";
        td.style.border = "none";
        td.style.padding = "0";
        td.style.height = "18px";
        td.colSpan = colCount;

        const tr = document.createElement("tr");
        tr.appendChild(td);

        const tbody = clone.tBodies && clone.tBodies.length ? clone.tBodies[clone.tBodies.length - 1] : clone;
        tbody.appendChild(tr);

        return clone;
      }

      async function copySelectedTables() {
        if (!ui.clipboard?.copyHtml) {
          ui.setStatus("Clipboard module not loaded.", true);
          return;
        }

        const exporter = ns.templateExcelExport || null;

        const orderedIds = lastRenderOrder.filter((id) => selectedTemplateResultIds.has(id));
        const tables = orderedIds.map((id) => tableByResultId.get(id)).filter(Boolean);
        if (!tables.length) {
          ui.setStatus("No template selected.", true);
          return;
        }

        const html = tables
          .map((t, idx) => {
            if (idx < tables.length - 1) {
              const clone = cloneTableWithTrailingBlankRow(t);
              const tableHtml = clone ? (exporter?.toExcelHtml ? exporter.toExcelHtml(clone) : clone.outerHTML) : "";
              return `<div>${tableHtml}</div>`;
            }

            const tableHtml = exporter?.toExcelHtml ? exporter.toExcelHtml(t) : t.outerHTML;
            return `<div>${tableHtml}</div>`;
          })
          .join("\n");
        const plain = exporter?.toTsv ? tables.map((t) => exporter.toTsv(t)).join("\n\n") : tables.map((t) => t.innerText || "").join("\n\n");

        const ok = await ui.clipboard.copyHtml(html, plain);
        ui.setStatus(ok ? `Copied ${tables.length} table(s) to clipboard.` : "Copy failed (browser blocked clipboard).", !ok);
      }

      function renderTemplates(options) {
        const host = ui.$("templatesHost");
        if (!host) return;

        selectedTemplateCard = null;
        templateResultById = new Map();
        tableByResultId = new Map();
        lastRenderOrder = [];
        lastToolbarUpdate = null;

        if (typeof ui.clearAbapTemplateMarkers === "function") ui.clearAbapTemplateMarkers();

        const model = state.model;
        if (!model) {
          host.textContent = "Analyze to see templates.";
          host.classList.add("empty");
          return;
        }

        if (!ns.templateRegistry || !ns.templateConverter || !ns.tableRenderer) {
          host.textContent = "Template modules not loaded.";
          host.classList.add("empty");
          return;
        }

        const entries = tpl.listTemplateEntries();
        const templatesBySource = tpl.pickAutoTemplatesBySource(entries);
        if (templatesBySource.size === 0) {
          host.textContent = "No templates configured.";
          host.classList.add("empty");
          return;
        }

        const flow = tpl.buildTemplatesFlow(model, templatesBySource, { maxSteps: 900 });
        if (!flow.items.length) {
          host.textContent = "No template-mapped statements found.";
          host.classList.add("empty");
          return;
        }

        const markerItems = [];
        const autoSelectResultId = String(options?.autoSelectResultId || "");
        let autoSelectCard = null;

        host.classList.remove("empty");
        host.textContent = "";

        const toolbar = document.createElement("div");
        toolbar.className = "templates-toolbar";

        const toolbarCount = document.createElement("div");
        toolbarCount.className = "templates-toolbar__count";

        const toolbarActions = document.createElement("div");
        toolbarActions.className = "templates-toolbar__actions";

        const btnCopySelected = document.createElement("button");
        btnCopySelected.type = "button";
        btnCopySelected.className = "btn btn-sm btn-primary";
        btnCopySelected.textContent = "Copy selected";
        btnCopySelected.addEventListener("click", (e) => {
          e.preventDefault();
          copySelectedTables();
        });

        const btnClearSelected = document.createElement("button");
        btnClearSelected.type = "button";
        btnClearSelected.className = "btn btn-sm";
        btnClearSelected.textContent = "Clear selection";
        btnClearSelected.addEventListener("click", (e) => {
          e.preventDefault();
          selectedTemplateResultIds.clear();
          host.querySelectorAll(".template-block.is-multi-selected").forEach((c) => c.classList.remove("is-multi-selected"));
          host.querySelectorAll("input.template-block__select").forEach((cb) => (cb.checked = false));
          updateTemplatesToolbar();
        });

        toolbarActions.appendChild(btnCopySelected);
        toolbarActions.appendChild(btnClearSelected);

        toolbar.appendChild(toolbarCount);
        toolbar.appendChild(toolbarActions);

        host.appendChild(toolbar);

        lastToolbarUpdate = () => {
          const n = selectedTemplateResultIds.size;
          toolbarCount.textContent = `Selected: ${n}`;
          btnCopySelected.disabled = n === 0;
          btnClearSelected.disabled = n === 0;
        };
        updateTemplatesToolbar();

        for (const item of flow.items) {
          if (item.kind === "separator") {
            const sep = document.createElement("div");
            sep.className = "flow-separator";
            sep.textContent = item.label;
            host.appendChild(sep);
            continue;
          }

          if (item.kind === "note") {
            const note = document.createElement("div");
            note.className = "flow-note";
            note.textContent = item.text;
            host.appendChild(note);
            continue;
          }

          if (item.kind !== "template") continue;

          const result = item.result;
          templateResultById.set(result.resultId, result);
          lastRenderOrder.push(String(result.resultId || ""));

          if (result?.sourceRef?.startLine) {
            markerItems.push({
              resultId: result.resultId,
              objectId: result.objectId,
              templateId: result.templateId,
              startLine: result.sourceRef.startLine,
              endLine: result.sourceRef.endLine || result.sourceRef.startLine,
            });
          }

          const card = document.createElement("div");
          card.className = "template-block is-clickable";
          card.dataset.resultId = String(result.resultId || "");
          card.dataset.templateId = String(result.templateId || "");
          card.dataset.depth = String(item.depth || 0);
          card.style.marginLeft = `${Math.max(0, item.depth) * 18}px`;
          if (item.isRecursion || result.edge?.isInCycle) card.classList.add("is-cycle");

          const resultIdStr = String(result.resultId || "");

          const header = document.createElement("div");
          header.className = "template-block__header";

          const headerLeft = document.createElement("div");
          headerLeft.className = "template-block__header-left";

          const btnToggle = document.createElement("button");
          btnToggle.type = "button";
          btnToggle.className = "template-block__toggle";
          btnToggle.textContent = "";
          btnToggle.setAttribute("aria-label", "Collapse/expand");
          btnToggle.setAttribute("aria-expanded", String(!collapsedTemplateResultIds.has(resultIdStr)));
          btnToggle.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleTemplateCollapsed(resultIdStr, host);
          });

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "template-block__select";
          checkbox.checked = selectedTemplateResultIds.has(resultIdStr);
          card.classList.toggle("is-multi-selected", checkbox.checked);
          checkbox.addEventListener("click", (e) => e.stopPropagation());
          checkbox.addEventListener("change", (e) => {
            e.stopPropagation();
            const isOn = Boolean(checkbox.checked);
            setTemplateSelected(resultIdStr, isOn);
            card.classList.toggle("is-multi-selected", isOn);
          });

          const title = document.createElement("div");
          title.className = "template-block__title";
          const src = result.sourceRef;
          const lineText = src?.startLine
            ? src.endLine && src.endLine !== src.startLine
              ? ` (L${src.startLine}-L${src.endLine})`
              : ` (L${src.startLine})`
            : "";
          const loopText = item.isRecursion ? " (loop)" : "";

          const ctx = result?.context || null;
          const originalFirstLine = String(result?.original || "")
            .replace(/\r\n/g, "\n")
            .split("\n")[0]
            .trim();

          let mainText = "";

          const performName = String(ctx?.perform?.name || "").trim();
          if (performName) {
            mainText = `PERFORM ${performName}`;
          } else if (ctx?.if) {
            const k = String(ctx?.if?.kind || "IF").trim().toUpperCase() || "IF";
            const cond = String(ctx?.if?.condition || "").trim();
            mainText = cond ? `${k} ${cond}` : k;
          } else if (ctx?.assignment) {
            const lhs = String(ctx?.assignment?.lhs || "").trim();
            const rhs = String(ctx?.assignment?.rhs || "").trim();
            mainText = lhs && rhs ? `${lhs} = ${rhs}` : lhs ? `${lhs} = ...` : "Assignment";
          } else if (ctx?.message) {
            mainText = String(ctx?.message?.statement || "").trim() || "MESSAGE";
          } else if (ctx?.itabOp) {
            const st = String(ctx?.itabOp?.statement || "").trim();
            const kind = String(ctx?.itabOp?.kind || "ITAB").trim();
            const table = String(ctx?.table?.text || "").trim();
            const fallback = `${kind}${table ? ` ${table}` : ""}`.trim();
            mainText = st || fallback || "ITAB";
          } else if (originalFirstLine) {
            mainText = originalFirstLine;
          } else {
            mainText = String(result?.objectId || result?.kind || "Template");
          }

          title.textContent = `${mainText}${lineText}${loopText}`;

          headerLeft.appendChild(btnToggle);
          headerLeft.appendChild(checkbox);
          headerLeft.appendChild(title);

          const headerActions = document.createElement("div");
          headerActions.className = "template-block__actions";

          const btnCopy = document.createElement("button");
          btnCopy.type = "button";
          btnCopy.className = "btn btn-sm";
          btnCopy.textContent = "Copy";
          btnCopy.title = "Copy HTML table to clipboard (paste into Excel)";
          btnCopy.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!ui.clipboard?.copyHtml) {
              ui.setStatus("Clipboard module not loaded.", true);
              return;
            }
            const t = tableByResultId.get(resultIdStr);
            if (!t) {
              ui.setStatus("No table to copy.", true);
              return;
            }
            const exporter = ns.templateExcelExport || null;
            const html = exporter?.toExcelHtml ? exporter.toExcelHtml(t) : t.outerHTML;
            const plain = exporter?.toTsv ? exporter.toTsv(t) : t.innerText || title.textContent || "";
            const ok = await ui.clipboard.copyHtml(`<div>${html}</div>`, plain);
            ui.setStatus(ok ? "Copied HTML table (paste into Excel)." : "Copy failed (browser blocked clipboard).", !ok);
          });

          headerActions.appendChild(btnCopy);

          header.appendChild(headerLeft);
          header.appendChild(headerActions);
          card.appendChild(header);

          const tableWrap = document.createElement("div");
          tableWrap.className = "template-block__table";
          const tableEl = ns.tableRenderer.renderExcelLikeTable(result.filledConfig);
          tableWrap.appendChild(tableEl);
          card.appendChild(tableWrap);

          if (tableEl && tableEl.tagName === "TABLE") {
            tableByResultId.set(resultIdStr, tableEl);
          }

          card.addEventListener("click", () => {
            if (selectedTemplateCard) selectedTemplateCard.classList.remove("is-selected");
            selectedTemplateCard = card;
            card.classList.add("is-selected");
            ui.highlightSource(result.sourceRef?.startLine, result.sourceRef?.endLine);
          });

          host.appendChild(card);
          if (autoSelectResultId && result.resultId === autoSelectResultId) autoSelectCard = card;
        }

        const available = new Set(lastRenderOrder);
        for (const id of Array.from(selectedTemplateResultIds)) {
          if (!available.has(id)) selectedTemplateResultIds.delete(id);
        }
        for (const id of Array.from(collapsedTemplateResultIds)) {
          if (!available.has(id)) collapsedTemplateResultIds.delete(id);
        }
        applyTemplateTreeState(host);
        updateTemplatesToolbar();

        if (typeof ui.renderAbapTemplateMarkers === "function") ui.renderAbapTemplateMarkers(markerItems);

        if (autoSelectCard) {
          autoSelectCard.click();
          try {
            autoSelectCard.scrollIntoView({ block: "center", behavior: "smooth" });
          } catch (_) {
            autoSelectCard.scrollIntoView();
          }
        }
      }

      ui.handleTemplatesDblClick = handleTemplatesDblClick;
      ui.renderTemplates = renderTemplates;
      ui.scrollToTemplateResultId = scrollToTemplateResultId;
    })(window.AbapFlow);

    </script>
        <script>
    // js/ui_views.js
    (function (ns) {
      "use strict";

      const utils = ns.utils;
      const ui = ns.ui;
      const state = ui.state;
      const TRACE_ALL_GLOBALS_KEY = ui.constants.TRACE_ALL_GLOBALS_KEY;

      const sourceLink = ui.sourceLink;
      const renderAnnoSummaryHtml = ui.renderAnnoSummaryHtml;
      const renderInlineAnnoEditorHtml = ui.renderInlineAnnoEditorHtml;
      const wireInlineAnnoEditors = ui.wireInlineAnnoEditors;

      function renderDiagram() {
        const model = state.model;
        const host = ui.$("diagramHost");
        if (!host) return;
        host.innerHTML = "";
        if (!model) return;

        ns.diagram.render(model, host, {
          onNodeClick: (key) => {
            ui.selectObject(key, true);
            ui.setActiveTab("objects");
          },
        });
      }

      function goToTrace(routineKey, varName) {
        const model = state.model;
        if (!model) return;
        ui.setActiveTab("trace");
        const subSel = ui.$("traceSubroutine");
        if (subSel) subSel.value = routineKey;
        updateTraceVariables();
        const varSel = ui.$("traceVariable");
        if (varSel) varSel.value = varName;
        runTrace();
      }

      function renderSequenceControls() {
        const model = state.model;
        const sel = ui.$("seqRoot");
        if (!sel) return;
        sel.innerHTML = "";
        if (!model) return;

        const items = ns.sequence.getStartCandidates(model);
        for (const it of items) {
          const opt = document.createElement("option");
          opt.value = it.key;
          opt.textContent = it.label;
          sel.appendChild(opt);
        }

        const preferred =
          items.find((x) => x.key === ns.sequence.PROGRAM_ALL_KEY) ||
          items.find((x) => x.key === "EVENT:START-OF-SELECTION") ||
          items.find((x) => x.key === "EVENT:INITIALIZATION") ||
          items[0] ||
          null;
        if (preferred) sel.value = preferred.key;
      }

      function renderSequence() {
        const model = state.model;
        const host = ui.$("sequenceHost");
        if (!host) return;

        if (!model) {
          host.textContent = "Analyze to see sequence.";
          host.classList.add("empty");
          return;
        }

        host.classList.remove("empty");
        const startKey = ui.$("seqRoot")?.value;
        const maxSteps = Number(ui.$("seqMaxSteps")?.value || 200);
        const seq = ns.sequence.build(model, startKey, { maxSteps });
        ns.sequence.render(host, model, seq, {
          onParamClick: ({ routineKey, varName }) => goToTrace(routineKey, varName),
          onRowClick: ({ routineKey }) => ui.selectObject(routineKey, true),
        });
      }

      function renderJson() {
        const out = ui.$("jsonOutput");
        const model = state.model;
        if (!out) return;
        if (!model) {
          out.textContent = "Analyze to see JSON.";
          out.classList.add("empty");
          return;
        }
        out.classList.remove("empty");
        out.textContent = JSON.stringify(model.serialize(), null, 2);
      }

      function renderTraceSubroutines() {
        const model = state.model;
        const sel = ui.$("traceSubroutine");
        if (!sel) return;
        sel.innerHTML = "";
        if (!model) return;

        const globalsOpt = document.createElement("option");
        globalsOpt.value = TRACE_ALL_GLOBALS_KEY;
        globalsOpt.textContent = "CUSTOMISE (All globals)";
        sel.appendChild(globalsOpt);

        const sep = document.createElement("option");
        sep.disabled = true;
        sep.textContent = "";
        sel.appendChild(sep);

        const nodes = Array.from(model.nodes.values()).sort((a, b) => {
          const ka = a.kind === "EVENT" ? 0 : a.kind === "FORM" ? 1 : 2;
          const kb = b.kind === "EVENT" ? 0 : b.kind === "FORM" ? 1 : 2;
          if (ka !== kb) return ka - kb;
          return a.name.localeCompare(b.name);
        });

        for (const n of nodes) {
          const opt = document.createElement("option");
          opt.value = n.key;
          opt.textContent = `${n.kind} ${n.name}${n.isDefined ? "" : " (external)"}`;
          sel.appendChild(opt);
        }

        if (nodes.length > 0) sel.value = nodes[0].key;
        else sel.value = TRACE_ALL_GLOBALS_KEY;
        updateTraceVariables();
      }

      function updateTraceVariables() {
        const model = state.model;
        const subKey = ui.$("traceSubroutine")?.value;
        const sel = ui.$("traceVariable");
        if (!sel) return;
        sel.innerHTML = "";
        if (!model || !subKey) return;

        const vars =
          subKey === TRACE_ALL_GLOBALS_KEY
            ? ns.lineage.getGlobalVariables(model)
            : ns.lineage.getVariablesForRoutine(model, subKey, { globalMode: "used" });
        for (const v of vars) {
          const opt = document.createElement("option");
          opt.value = v.name;
          opt.textContent = `${v.name} (${v.scope})`;
          sel.appendChild(opt);
        }
      }

      function renderTraceResults(result) {
        const el = ui.$("traceResults");
        if (!el) return;
        if (!result || result.error) {
          el.textContent = result?.error || "Trace failed.";
          el.classList.add("empty");
          return;
        }

        const root = result.root;
        if (!root) {
          el.textContent = "No results.";
          el.classList.add("empty");
          return;
        }

        el.classList.remove("empty");

        function renderNode(node, indent) {
          const pad = indent * 14;
          const headerText = `${sourceLink(
            `${node.routineKind} ${node.routineName} (var ${node.varName})`,
            node.sourceRef,
          )}${node.cycle ? ' <span class="badge badge-danger">cycle</span>' : ""}${node.truncated ? ' <span class="badge">truncated</span>' : ""}`;
          const header = `<div class="trace-node__header" style="padding-left:${pad}px"><button type="button" class="trace-node__toggle" aria-expanded="true" title="Collapse/expand"></button><span class="trace-node__header-text">${headerText}</span></div>`;

          const decl = node.resolution?.decl;
          const declText = decl?.description ? ` - ${utils.escapeHtml(decl.description)}` : "";
          const scope = node.resolution?.scope ? `${node.resolution.scope}` : "unknown";
          const declLine = decl?.sourceRef?.startLine ? ` (line ${decl.sourceRef.startLine})` : "";
          let declStmt = "";
          if (decl && decl.declKind) {
            const declUpper = String(decl.declKind || "").toUpperCase();
            const valueKeyword = declUpper === "PARAMETERS" ? "DEFAULT" : "VALUE";
            declStmt = `${decl.declKind} ${decl.variableName}${decl.dataType ? ` TYPE ${decl.dataType}` : ""}${decl.value ? ` ${valueKeyword} ${decl.value}` : ""}`;
          } else if (decl && decl.kind && decl.name) {
            declStmt = `${decl.kind} ${decl.name}${decl.dataType ? ` TYPE ${decl.dataType}` : ""}`;
          }
          const declLinkText = declStmt ? ` | Decl: ${sourceLink(declStmt, decl?.sourceRef || null)}` : "";
          const meta = `<div class="trace-node__meta" style="padding-left:${pad}px">Scope: ${utils.escapeHtml(scope)}${utils.escapeHtml(declLine)}${declText}${declLinkText}</div>`;

          const routineKey = String(node.routineKey || "");
          const model = state.model;
          const routine = routineKey && routineKey !== "PROGRAM" ? model?.nodes?.get(routineKey) || null : null;
          const codeRoutineDesc = String(routine?.description || "").trim();
          const userRoutineDesc =
            routineKey === "PROGRAM" ? String(model?.userDescription || "").trim() : String(routine?.userDescription || "").trim();
          const userRoutineNote = routineKey === "PROGRAM" ? String(model?.userNote || "").trim() : String(routine?.userNote || "").trim();
          const routineSummary = renderAnnoSummaryHtml({
            codeDesc: codeRoutineDesc,
            userDesc: userRoutineDesc,
            userNote: userRoutineNote,
          });

          const routineEdit =
            routineKey && ns.notes
              ? renderInlineAnnoEditorHtml({
                  title: `Edit object notes  ${node.routineKind} ${node.routineName}`,
                  codeDesc: codeRoutineDesc,
                  userDesc: userRoutineDesc,
                  userNote: userRoutineNote,
                  annoType: "routine",
                  annoKey: routineKey,
                  attrs: { "data-routine-key": routineKey },
                })
              : "";

          let varSummary = "";
          let varEdit = "";
          let varTitle = "";
          const varCards = [];

          if (decl && ns.notes) {
            let originNode = node;
            let originDecl = decl;
            let originScopeName = String(node.resolution?.scope || "").toLowerCase();
            let originRoutineKey = routineKey;

            // If this variable is a PARAM, follow the first caller-chain until we reach a declared DATA/CONSTANTS/global.
            if (originScopeName === "parameter") {
              const seen = new Set();
              for (let i = 0; i < 30; i++) {
                const visitKey = `${originNode?.routineKey || ""}|${String(originNode?.varName || "").toLowerCase()}`;
                if (seen.has(visitKey)) break;
                seen.add(visitKey);

                const s = String(originNode?.resolution?.scope || "").toLowerCase();
                if (s !== "parameter") break;

                const next = (originNode?.calls || []).find((c) => c?.direction === "fromCaller" && c?.child) || null;
                if (!next?.child) break;
                originNode = next.child;
              }

              originRoutineKey = String(originNode?.routineKey || routineKey);
              originDecl = originNode?.resolution?.decl || null;
              originScopeName = String(originNode?.resolution?.scope || "").toLowerCase();
            }

            function isSimpleStructFieldName(name) {
              const s = String(name || "");
              if (!s.includes("-")) return false;
              if (s.includes("->") || s.includes("=>") || s.includes("~")) return false;
              return true;
            }

            function resolveTypeFieldForVirtualDecl(declObj) {
              const origin = declObj?.virtualOrigin && typeof declObj.virtualOrigin === "object" ? declObj.virtualOrigin : null;
              if (!origin || origin.kind !== "typeField") return null;

              const typeScopeKey = String(origin.typeScopeKey || "").trim() || "PROGRAM";
              const typeName = String(origin.typeName || "").trim();
              const fieldPath = String(origin.fieldPath || "").trim();
              if (!typeName || !fieldPath) return null;

              const typeKey = `${typeScopeKey}|${typeName.toLowerCase()}`;
              const typeDef = model?.typeDefs?.get ? model.typeDefs.get(typeKey) : null;
              const field = typeDef?.fields?.get ? typeDef.fields.get(fieldPath.toLowerCase()) : null;
              if (!field) return null;

              return { typeScopeKey, typeName, fieldPath, field };
            }

            function findDeclInScope(scopeKey, declKind, varName) {
              const sk = String(scopeKey || "").trim();
              const dk = String(declKind || "").trim().toUpperCase();
              const vnLower = String(varName || "").trim().toLowerCase();
              if (!sk || !dk || !vnLower) return null;

              if (sk === "PROGRAM") {
                const list = dk === "CONSTANTS" ? model.globalConstants : model.globalData;
                return (list || []).find((x) => String(x?.variableName || "").toLowerCase() === vnLower) || null;
              }

              const rNode = model?.nodes?.get ? model.nodes.get(sk) : null;
              const list = dk === "CONSTANTS" ? rNode?.localConstants : rNode?.localData;
              return (list || []).find((x) => String(x?.variableName || "").toLowerCase() === vnLower) || null;
            }

            function pushDeclVarCard(scopeKey, scopeLabel, declObj, label) {
              if (!declObj || !declObj.declKind || !declObj.variableName) return;
              const title = `Variable notes  ${label}${scopeLabel ? ` (${scopeLabel})` : ""}`;

              const typeField = declObj.isVirtual ? resolveTypeFieldForVirtualDecl(declObj) : null;
              const codeDesc = String((typeField?.field?.description ?? declObj.description) || "").trim();
              const userDesc = String((typeField?.field?.userDescription ?? declObj.userDescription) || "").trim();
              const userNote = String((typeField?.field?.userNote ?? declObj.userNote) || "").trim();
              const summary = renderAnnoSummaryHtml({ codeDesc, userDesc, userNote });

              if (typeField && ns.notes?.makeTypeFieldKey) {
                const key = ns.notes.makeTypeFieldKey(typeField.typeScopeKey, typeField.typeName, typeField.fieldPath);
                const editor = key
                  ? renderInlineAnnoEditorHtml({
                      title,
                      codeDesc,
                      userDesc,
                      userNote,
                      annoType: "typefield",
                      annoKey: key,
                      attrs: {
                        "data-type-scope-key": typeField.typeScopeKey,
                        "data-type-name": typeField.typeName,
                        "data-field-path": typeField.fieldPath,
                      },
                    })
                  : "";
                varCards.push(renderNotesCard("var", title, summary, editor));
                return;
              }

              if (ns.notes?.makeDeclKey) {
                const key = ns.notes.makeDeclKey(scopeKey, declObj.declKind, declObj.variableName);
                const editor = key
                  ? renderInlineAnnoEditorHtml({
                      title,
                      codeDesc,
                      userDesc,
                      userNote,
                      annoType: "decl",
                      annoKey: key,
                      attrs: {
                        "data-scope-key": scopeKey,
                        "data-decl-kind": declObj.declKind,
                        "data-var-name": declObj.variableName,
                      },
                    })
                  : "";
                varCards.push(renderNotesCard("var", title, summary, editor));
              }
            }

            if (originDecl && originScopeName === "parameter" && originDecl.name && ns.notes.makeParamKey) {
              const originRoutine = originRoutineKey && originRoutineKey !== "PROGRAM" ? model?.nodes?.get(originRoutineKey) || null : null;
              const originRoutineLabel = originRoutine ? `${originRoutine.kind} ${originRoutine.name}` : originRoutineKey || "";
              varTitle = `Variable notes  PARAM ${String(originDecl.name || "")}${originRoutineLabel ? ` (${originRoutineLabel})` : ""}`;
              const paramKey = ns.notes.makeParamKey(originRoutineKey, originDecl.name);
              const codeDesc = String(originDecl.description || "").trim();
              const userDesc = String(originDecl.userDescription || "").trim();
              const userNote = String(originDecl.userNote || "").trim();
              varSummary = renderAnnoSummaryHtml({ codeDesc, userDesc, userNote });

              if (paramKey) {
                varEdit = renderInlineAnnoEditorHtml({
                  title: `Edit variable notes  PARAM ${String(originDecl.name || "")}${originRoutineLabel ? ` (${originRoutineLabel})` : ""}`,
                  codeDesc,
                  userDesc,
                  userNote,
                  annoType: "param",
                  annoKey: paramKey,
                  attrs: {
                    "data-routine-key": originRoutineKey,
                    "data-param-name": String(originDecl.name || ""),
                  },
                });
              }

              varCards.push(renderNotesCard("var", varTitle, varSummary, varEdit));
            } else if (
              originDecl &&
              (originScopeName === "local" || originScopeName === "global") &&
              originDecl.declKind &&
              originDecl.variableName &&
              ns.notes.makeDeclKey
            ) {
              const scopeKey = originScopeName === "global" ? "PROGRAM" : originRoutineKey;
              const scopeRoutine = scopeKey && scopeKey !== "PROGRAM" ? model?.nodes?.get(scopeKey) || null : null;
              const scopeLabel = scopeKey === "PROGRAM" ? "PROGRAM (Globals)" : scopeRoutine ? `${scopeRoutine.kind} ${scopeRoutine.name}` : scopeKey || "";
              varTitle = `Variable notes  ${String(originDecl.declKind || "")} ${String(originDecl.variableName || "")}${
                scopeLabel ? ` (${scopeLabel})` : ""
              }`;
              const declKey = ns.notes.makeDeclKey(scopeKey, originDecl.declKind, originDecl.variableName);
              const codeDesc = String(originDecl.description || "").trim();
              const userDesc = String(originDecl.userDescription || "").trim();
              const userNote = String(originDecl.userNote || "").trim();
              varSummary = renderAnnoSummaryHtml({ codeDesc, userDesc, userNote });

              if (isSimpleStructFieldName(originDecl.variableName)) {
                const parts = String(originDecl.variableName || "")
                  .split("-")
                  .filter(Boolean);
                let cur = "";
                const fullLower = String(originDecl.variableName || "").toLowerCase();
                for (let i = 0; i < parts.length; i++) {
                  cur = cur ? `${cur}-${parts[i]}` : parts[i];
                  const declObj = findDeclInScope(scopeKey, originDecl.declKind, cur) || (cur.toLowerCase() === fullLower ? originDecl : null);
                  if (!declObj) continue;
                  const label = `${String(originDecl.declKind || "")} ${cur}`;
                  pushDeclVarCard(scopeKey, scopeLabel, declObj, label);
                }
              }

              if (declKey) {
                varEdit = renderInlineAnnoEditorHtml({
                  title: `Edit variable notes  ${String(originDecl.declKind || "")} ${String(originDecl.variableName || "")}${
                    scopeLabel ? ` (${scopeLabel})` : ""
                  }`,
                  codeDesc,
                  userDesc,
                  userNote,
                  annoType: "decl",
                  annoKey: declKey,
                  attrs: {
                    "data-scope-key": scopeKey,
                    "data-decl-kind": originDecl.declKind,
                    "data-var-name": originDecl.variableName,
                  },
                });
              }
            }
          }

          function renderNotesCard(cardKind, titleText, summaryHtml, editorHtml) {
            const title = String(titleText || "").trim();
            if (!title || (!summaryHtml && !editorHtml)) return "";
            const kind = String(cardKind || "").trim();
            const kindClass = kind ? ` trace-node__notes--${utils.escapeHtml(kind)}` : "";
            return `<div class="trace-node__notes${kindClass}" style="margin-left:${pad}px">
              <div class="trace-node__notes-title">${utils.escapeHtml(title)}</div>
              ${summaryHtml || ""}
              ${editorHtml || ""}
            </div>`;
          }

          const routineNotes = renderNotesCard("object", `Object notes  ${node.routineKind} ${node.routineName}`, routineSummary, routineEdit);
          if (varCards.length === 0) {
            const single = renderNotesCard("var", varTitle, varSummary, varEdit);
            if (single) varCards.push(single);
          }
          const notesHtml = `${routineNotes}${varCards.join("")}`;

          const writes = (node.writes || [])
            .map((w) => `<li>${sourceLink(`${w.variableName}  ${w.statement}`, w.sourceRef)}</li>`)
            .join("");
          const writesHtml = `<ul class="list trace-node__writes" style="margin-left:${pad}px">${writes || "<li>(no writes)</li>"}</ul>`;

          const children = (node.calls || [])
            .map((c) => {
              const dir = c.direction === "fromCaller" ? "from" : "via";
              const target = c.direction === "fromCaller" ? node.routineName : c.child.routineName;
              const label = c.label || `${dir} PERFORM ${target}: ${c.fromVar} -> ${c.toVar} (${c.mappingKind})`;
              const mapText = `<div class="trace-node__call" style="padding-left:${pad + 14}px">${sourceLink(label, c.edge?.sourceRef || null)}</div>`;
              return mapText + renderNode(c.child, indent + 1);
            })
            .join("");

          return `<div class="trace-node">${header}${meta}${notesHtml}${writesHtml}${children}</div>`;
        }

        el.innerHTML = renderNode(root, 0);
        wireInlineAnnoEditors(el);

        if (!el.dataset.traceTreeBound) {
          el.dataset.traceTreeBound = "1";
          el.addEventListener("click", (ev) => {
            const t = ev.target;
            if (!(t instanceof HTMLElement)) return;
            const btn = t.closest("button.trace-node__toggle");
            if (!btn) return;
            const nodeEl = btn.closest(".trace-node");
            if (!nodeEl) return;
            ev.preventDefault();
            ev.stopPropagation();
            const collapsed = nodeEl.classList.toggle("is-collapsed");
            btn.setAttribute("aria-expanded", String(!collapsed));
          });
        }
      }

      function runTrace() {
        const model = state.model;
        if (!model) return;
        const subKey = ui.$("traceSubroutine")?.value;
        const varName = ui.$("traceVariable")?.value;
        if (!subKey || !varName) return;
        const result =
          subKey === TRACE_ALL_GLOBALS_KEY
            ? ns.lineage.traceGlobalVariable(model, varName, { maxNodes: 400 })
            : ns.lineage.traceVariable(model, subKey, varName, { maxNodes: 400 });
        renderTraceResults(result);
      }

      ui.renderDiagram = renderDiagram;
      ui.renderSequenceControls = renderSequenceControls;
      ui.renderSequence = renderSequence;
      ui.renderJson = renderJson;
      ui.renderTraceSubroutines = renderTraceSubroutines;
      ui.updateTraceVariables = updateTraceVariables;
      ui.runTrace = runTrace;
    })(window.AbapFlow);

    </script>
        <script>
    // js/ui.js
    (function (ns) {
      "use strict";

      const ui = ns.ui;
      const state = ui.state;
      const MAIN_SPLIT_KEY = "abapflow-main-left-px";

      function exportNotes() {
        if (!ns.notes) {
          ui.setStatus("Notes module not loaded.", true);
          return;
        }
        const pid = ns.notes.getActiveProgramId ? ns.notes.getActiveProgramId() : "default";
        const stamp = new Date().toISOString().replace(/[:]/g, "-").slice(0, 19);
        const filename = `abapflow-notes-${pid}-${stamp}.json`;
        ui.downloadTextFile(filename, ns.notes.exportJson(), "application/json");
        ui.setStatus("Notes exported.", false);
      }

      async function importNotesFromFile(file) {
        if (!ns.notes) {
          ui.setStatus("Notes module not loaded.", true);
          return;
        }
        if (!file) return;
        const text = await file.text();
        const res = ns.notes.importJson(text, { mode: "merge" });
        if (!res.ok) {
          ui.setStatus(res.error || "Import failed.", true);
          return;
        }

        if (state.model) ns.notes.applyToModel(state.model);
        ui.renderObjectsTable();
        ui.renderDetails();
        if (document.getElementById("tab-sequence").classList.contains("is-active")) {
          ui.renderSequence();
        }
        if (document.getElementById("tab-templates")?.classList.contains("is-active")) {
          ui.renderTemplates();
        }
        ui.setStatus("Notes imported.", false);
      }

      async function analyze() {
        const input = ui.$("abapInput")?.value;
        if (!String(input || "").trim()) {
          ui.setStatus("Paste ABAP code first.", true);
          return;
        }

        try {
          if (ns.abapObjects?.whenReady) await ns.abapObjects.whenReady();
          if (ns.notes) ns.notes.setActiveProgramFromText(input);
          const model = ns.parser.parseProgram(input);
          if (ns.notes) ns.notes.applyToModel(model);
          state.model = model;
          state.selectedKey = "PROGRAM";

          ui.renderObjectsTable();
          ui.renderDetails();
          ui.renderDiagram();
          ui.renderSequenceControls();
          if (document.getElementById("tab-sequence").classList.contains("is-active")) {
            ui.renderSequence();
          } else {
            const host = ui.$("sequenceHost");
            if (host) {
              host.textContent = "Open the Sequence tab (or click Render) to render.";
              host.classList.add("empty");
            }
          }
          ui.renderTemplates();
          ui.renderJson();
          ui.renderTraceSubroutines();
          ui.setStatus(`Parsed ${model.nodes.size} objects, ${model.edges.length} PERFORM calls.`, false);
        } catch (err) {
          console.error(err);
          ui.setStatus(String(err?.message || err), true);
        }
      }

      function clearAll() {
        const input = ui.$("abapInput");
        if (input) input.value = "";

        state.model = null;
        state.selectedKey = null;

        ui.$("objectsTable")?.querySelector("tbody")?.replaceChildren();

        const details = ui.$("objectDetails");
        if (details) {
          details.textContent = "Analyze to see details.";
          details.classList.add("empty");
        }

        const diagram = ui.$("diagramHost");
        if (diagram) diagram.replaceChildren();

        const seqHost = ui.$("sequenceHost");
        if (seqHost) {
          seqHost.textContent = "Analyze to see sequence.";
          seqHost.classList.add("empty");
        }

        const json = ui.$("jsonOutput");
        if (json) {
          json.textContent = "Analyze to see JSON.";
          json.classList.add("empty");
        }

        const trace = ui.$("traceResults");
        if (trace) {
          trace.textContent = "Select a subroutine + variable and run trace.";
          trace.classList.add("empty");
        }

        ui.$("traceSubroutine")?.replaceChildren();
        ui.$("traceVariable")?.replaceChildren();
        ui.$("seqRoot")?.replaceChildren();

        ui.renderTemplates();
        ui.setStatus("Cleared.", false);
      }

      function initMainSplitter() {
        const main = document.querySelector(".app-main.app-main--resizable");
        const splitter = document.getElementById("mainSplitter");
        const leftPanel = document.querySelector(".panel.panel-left");

        if (!main || !splitter || !leftPanel) return;

        function readStored() {
          try {
            const n = Number(localStorage.getItem(MAIN_SPLIT_KEY));
            return Number.isFinite(n) && n > 0 ? n : 0;
          } catch (_) {
            return 0;
          }
        }

        function writeStored(px) {
          try {
            localStorage.setItem(MAIN_SPLIT_KEY, String(Math.round(px)));
          } catch (_) {}
        }

        function clampLeft(px) {
          const mainW = main.getBoundingClientRect().width;
          const splitterW = splitter.getBoundingClientRect().width;
          const minLeft = 320;
          const minRight = 420;
          const maxLeft = Math.max(minLeft, mainW - minRight - splitterW);
          return Math.max(minLeft, Math.min(maxLeft, px));
        }

        function applyLeft(px) {
          main.style.setProperty("--main-left", `${Math.round(px)}px`);
        }

        const stored = readStored();
        if (stored) applyLeft(clampLeft(stored));

        let dragging = false;
        let startX = 0;
        let startLeft = 0;
        let lastApplied = 0;

        function onMove(e) {
          if (!dragging) return;
          const dx = Number(e.clientX) - startX;
          const next = clampLeft(startLeft + dx);
          if (Math.abs(next - lastApplied) < 1) return;
          lastApplied = next;
          applyLeft(next);
        }

        function stopDrag() {
          if (!dragging) return;
          dragging = false;
          splitter.classList.remove("is-dragging");
          document.body.style.cursor = "";
          document.body.style.userSelect = "";
          if (lastApplied) writeStored(lastApplied);
          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", stopDrag);
          window.removeEventListener("pointercancel", stopDrag);
        }

        splitter.addEventListener("pointerdown", (e) => {
          if (!e || typeof e.clientX !== "number") return;
          dragging = true;
          splitter.classList.add("is-dragging");
          splitter.setPointerCapture?.(e.pointerId);
          startX = e.clientX;
          startLeft = leftPanel.getBoundingClientRect().width;
          lastApplied = startLeft;
          document.body.style.cursor = "col-resize";
          document.body.style.userSelect = "none";
          window.addEventListener("pointermove", onMove);
          window.addEventListener("pointerup", stopDrag);
          window.addEventListener("pointercancel", stopDrag);
        });

        splitter.addEventListener("keydown", (e) => {
          if (!e) return;
          if (e.key !== "ArrowLeft" && e.key !== "ArrowRight") return;
          e.preventDefault();
          const delta = e.key === "ArrowLeft" ? -24 : 24;
          const cur = leftPanel.getBoundingClientRect().width;
          const next = clampLeft(cur + delta);
          applyLeft(next);
          writeStored(next);
        });

        window.addEventListener("resize", () => {
          const cur = leftPanel.getBoundingClientRect().width;
          const next = clampLeft(cur);
          if (Math.abs(next - cur) >= 1) applyLeft(next);
        });
      }

      function init() {
        initMainSplitter();

        document.addEventListener("click", (ev) => {
          const t = ev.target;
          if (!(t instanceof HTMLElement)) return;
          if (!t.classList.contains("source-link")) return;
          ev.preventDefault();
          ui.highlightSource(t.dataset.start, t.dataset.end);
        });

        document.querySelectorAll(".tab").forEach((tab) => {
          tab.addEventListener("click", () => {
            const name = tab.dataset.tab;
            ui.setActiveTab(name);
            if (name === "sequence") {
              requestAnimationFrame(() => ui.renderSequence());
            }
            if (name === "templates") {
              requestAnimationFrame(() => ui.renderTemplates());
            }
            if (name === "config") {
              requestAnimationFrame(() => ui.renderAbapObjectsConfig?.());
            }
          });
        });

        ui.$("btnAnalyze")?.addEventListener("click", analyze);
        ui.$("btnLoadSample")?.addEventListener("click", () => {
          const abapInput = ui.$("abapInput");
          if (abapInput) abapInput.value = ns.sampleCode || "";
          ui.setStatus("Sample loaded. Click Analyze.", false);
        });
        ui.$("btnClear")?.addEventListener("click", clearAll);

        ui.$("btnExportNotes")?.addEventListener("click", exportNotes);
        ui.$("btnImportNotes")?.addEventListener("click", () => ui.$("notesImportFile")?.click());
        ui.$("notesImportFile")?.addEventListener("change", async (ev) => {
          const input = ev.target;
          const file = input?.files?.[0] || null;
          await importNotesFromFile(file);
          if (input) input.value = "";
        });

        ui.$("objectSearch")?.addEventListener("input", () => ui.renderObjectsTable());
        ui.$("traceSubroutine")?.addEventListener("change", ui.updateTraceVariables);
        ui.$("btnTrace")?.addEventListener("click", ui.runTrace);
        ui.$("btnSeqRender")?.addEventListener("click", ui.renderSequence);
        ui.$("seqRoot")?.addEventListener("change", ui.renderSequence);

        ui.$("templatesHost")?.addEventListener("dblclick", ui.handleTemplatesDblClick);

        const abapInput = ui.$("abapInput");
        if (abapInput && !abapInput.value.trim() && ns.sampleCode) {
          abapInput.value = ns.sampleCode;
        }
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })(window.AbapFlow);

    </script>
  <script>
(function(){
  'use strict';
  var ns = window.AbapFlow = window.AbapFlow || {};
  var map = ns.__inlineScriptBySrc = ns.__inlineScriptBySrc || {};
  Object.assign(map, {"js/abap_objects/templates/append.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const appendExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    grid: {\n      rows: 2,\n      cols: 4,\n      colWidths: {\n        A: 160,\n        B: 520,\n        C: 80,\n        D: 740,\n      },\n      rowHeights: {\n        1: 34,\n        2: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n      center: \"text-align:center;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Append\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"{line.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"C1\", text: \"TO\", class: [\"cell\", \"header\", \"center\"] },\n      { addr: \"D1\", text: \"{itab.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A2\", text: \"{labels.sortedBy}\", class: [\"cell\", \"header\"] },\n      { addr: \"B2\", text: \"{sortedBy.description}\", class: [\"cell\", \"wrap\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"append.excel-like-table\", appendExcelLikeTable);\n})(window.AbapFlow);\n", "js/abap_objects/templates/assignment.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const assignmentExcelLikeTable = {\n    type: \"excel-like-table\",\n    grid: {\n      rows: 2,\n      cols: 2,\n      colWidths: {\n        A: 420,\n        B: 700,\n      },\n      rowHeights: {\n        1: 34,\n        2: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Item\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"Value\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A2\", text: \"{item.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B2\", text: \"{value.description}\", class: [\"cell\", \"wrap\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"assignment.excel-like-table\", assignmentExcelLikeTable);\n})(window.AbapFlow);\n", "js/abap_objects/templates/if.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const ifExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    grid: {\n      rows: 3,\n      cols: 4,\n      colWidths: {\n        A: 420,\n        B: 220,\n        C: 520,\n        D: 220,\n      },\n      rowHeights: {\n        1: 34,\n        2: 30,\n        3: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n      center: \"text-align:center;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Item 1\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"Operator\", class: [\"cell\", \"header\"] },\n      { addr: \"C1\", text: \"Item 2\", class: [\"cell\", \"header\"] },\n      { addr: \"D1\", text: \"Associations\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A2\", text: \"{conditions[0].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B2\", text: \"{conditions[0].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C2\", text: \"{conditions[0].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D2\", text: \"{conditions[0].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A3\", text: \"{conditions[1].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B3\", text: \"{conditions[1].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C3\", text: \"{conditions[1].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D3\", text: \"{conditions[1].association}\", class: [\"cell\", \"mono\", \"center\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"if.excel-like-table\", ifExcelLikeTable);\n})(window.AbapFlow);\n", "js/abap_objects/templates/itabCollect.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const itabCollectExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    grid: {\n      rows: 7,\n      cols: 4,\n      colWidths: {\n        A: 420,\n        B: 220,\n        C: 520,\n        D: 220,\n      },\n      rowHeights: {\n        1: 30,\n        2: 30,\n        3: 30,\n        4: 30,\n        5: 30,\n        6: 30,\n        7: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n      center: \"text-align:center;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Internal table\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"{table.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A2\", text: \"{labels.target}\", class: [\"cell\", \"header\"] },\n      { addr: \"B2\", text: \"{target.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A3\", text: \"{labels.conditions}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A4\", text: \"{labels.condItem1}\", class: [\"cell\", \"header\"] },\n      { addr: \"B4\", text: \"{labels.condOperator}\", class: [\"cell\", \"header\"] },\n      { addr: \"C4\", text: \"{labels.condItem2}\", class: [\"cell\", \"header\"] },\n      { addr: \"D4\", text: \"{labels.condAssoc}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A5\", text: \"{conditions[0].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B5\", text: \"{conditions[0].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C5\", text: \"{conditions[0].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D5\", text: \"{conditions[0].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A6\", text: \"{conditions[1].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B6\", text: \"{conditions[1].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C6\", text: \"{conditions[1].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D6\", text: \"{conditions[1].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A7\", text: \"{labels.binarySearch}\", class: [\"cell\", \"header\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"itabCollect.excel-like-table\", itabCollectExcelLikeTable);\n})(window.AbapFlow);\n\n", "js/abap_objects/templates/itabDelete.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const itabDeleteExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    grid: {\n      rows: 7,\n      cols: 4,\n      colWidths: {\n        A: 420,\n        B: 220,\n        C: 520,\n        D: 220,\n      },\n      rowHeights: {\n        1: 30,\n        2: 30,\n        3: 30,\n        4: 30,\n        5: 30,\n        6: 30,\n        7: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n      center: \"text-align:center;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Internal table\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"{table.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A2\", text: \"{labels.target}\", class: [\"cell\", \"header\"] },\n      { addr: \"B2\", text: \"{target.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A3\", text: \"{labels.conditions}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A4\", text: \"{labels.condItem1}\", class: [\"cell\", \"header\"] },\n      { addr: \"B4\", text: \"{labels.condOperator}\", class: [\"cell\", \"header\"] },\n      { addr: \"C4\", text: \"{labels.condItem2}\", class: [\"cell\", \"header\"] },\n      { addr: \"D4\", text: \"{labels.condAssoc}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A5\", text: \"{conditions[0].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B5\", text: \"{conditions[0].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C5\", text: \"{conditions[0].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D5\", text: \"{conditions[0].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A6\", text: \"{conditions[1].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B6\", text: \"{conditions[1].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C6\", text: \"{conditions[1].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D6\", text: \"{conditions[1].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A7\", text: \"{labels.binarySearch}\", class: [\"cell\", \"header\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"itabDelete.excel-like-table\", itabDeleteExcelLikeTable);\n})(window.AbapFlow);\n\n", "js/abap_objects/templates/itabModify.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const itabModifyExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    grid: {\n      rows: 7,\n      cols: 4,\n      colWidths: {\n        A: 420,\n        B: 220,\n        C: 520,\n        D: 220,\n      },\n      rowHeights: {\n        1: 30,\n        2: 30,\n        3: 30,\n        4: 30,\n        5: 30,\n        6: 30,\n        7: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n      center: \"text-align:center;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Internal table\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"{table.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A2\", text: \"{labels.target}\", class: [\"cell\", \"header\"] },\n      { addr: \"B2\", text: \"{target.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A3\", text: \"{labels.conditions}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A4\", text: \"{labels.condItem1}\", class: [\"cell\", \"header\"] },\n      { addr: \"B4\", text: \"{labels.condOperator}\", class: [\"cell\", \"header\"] },\n      { addr: \"C4\", text: \"{labels.condItem2}\", class: [\"cell\", \"header\"] },\n      { addr: \"D4\", text: \"{labels.condAssoc}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A5\", text: \"{conditions[0].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B5\", text: \"{conditions[0].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C5\", text: \"{conditions[0].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D5\", text: \"{conditions[0].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A6\", text: \"{conditions[1].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B6\", text: \"{conditions[1].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C6\", text: \"{conditions[1].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D6\", text: \"{conditions[1].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A7\", text: \"{labels.binarySearch}\", class: [\"cell\", \"header\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"itabModify.excel-like-table\", itabModifyExcelLikeTable);\n})(window.AbapFlow);\n\n", "js/abap_objects/templates/itabRead.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const itabReadExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    grid: {\n      rows: 7,\n      cols: 4,\n      colWidths: {\n        A: 420,\n        B: 220,\n        C: 520,\n        D: 220,\n      },\n      rowHeights: {\n        1: 30,\n        2: 30,\n        3: 30,\n        4: 30,\n        5: 30,\n        6: 30,\n        7: 30,\n      },\n    },\n    css: {\n      header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n      center: \"text-align:center;\",\n    },\n    cells: [\n      { addr: \"A1\", text: \"Internal table\", class: [\"cell\", \"header\"] },\n      { addr: \"B1\", text: \"{table.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A2\", text: \"{labels.target}\", class: [\"cell\", \"header\"] },\n      { addr: \"B2\", text: \"{target.description}\", class: [\"cell\", \"wrap\"] },\n\n      { addr: \"A3\", text: \"{labels.conditions}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A4\", text: \"{labels.condItem1}\", class: [\"cell\", \"header\"] },\n      { addr: \"B4\", text: \"{labels.condOperator}\", class: [\"cell\", \"header\"] },\n      { addr: \"C4\", text: \"{labels.condItem2}\", class: [\"cell\", \"header\"] },\n      { addr: \"D4\", text: \"{labels.condAssoc}\", class: [\"cell\", \"header\"] },\n\n      { addr: \"A5\", text: \"{conditions[0].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B5\", text: \"{conditions[0].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C5\", text: \"{conditions[0].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D5\", text: \"{conditions[0].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A6\", text: \"{conditions[1].item1.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"B6\", text: \"{conditions[1].operator}\", class: [\"cell\", \"mono\", \"center\"] },\n      { addr: \"C6\", text: \"{conditions[1].item2.description}\", class: [\"cell\", \"wrap\"] },\n      { addr: \"D6\", text: \"{conditions[1].association}\", class: [\"cell\", \"mono\", \"center\"] },\n\n      { addr: \"A7\", text: \"{labels.binarySearch}\", class: [\"cell\", \"header\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"itabRead.excel-like-table\", itabReadExcelLikeTable);\n})(window.AbapFlow);\n\n", "js/abap_objects/templates/message.excel-like-table.js": "(function (ns) {\n    \"use strict\";\n\n    const messageExcelLikeTable = {\n        type: \"excel-like-table\",\n        compact: {\n            removeEmptyRows: true,\n        },\n        grid: {\n            rows: 8,\n            cols: 6,\n            colWidths: {\n                A: 260,\n                B: 360,\n                C: 220,\n                D: 420,\n                E: 220,\n                F: 260,\n            },\n            rowHeights: {\n                1: 30,\n                2: 30,\n                3: 30,\n                4: 30,\n                5: 30,\n                6: 30,\n                7: 30,\n                8: 30,\n            },\n        },\n        css: {\n            header: \"background:#9dc3e6;font-weight:700;color:#111;\",\n            cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n            mono: \"font-family:Consolas,monospace;\",\n            wrap: \"white-space:normal;line-height:1.25;\",\n            center: \"text-align:center;\",\n        },\n        cells: [\n            {\n                addr: \"A1\",\n                text: \"{labels.msgClass}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B1\",\n                text: \"{msgClass.description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"C1\",\n                text: \"{labels.msgNo}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"D1\",\n                text: \"{msgNo.description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"E1\",\n                text: \"{labels.displayLike}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"F1\",\n                text: \"{displayLike.description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A2\",\n                text: \"{labels.messageText}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B2\",\n                text: \"{messageText.description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A3\",\n                text: \"{labels.with1}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B3\",\n                text: \"{with[0].description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A4\",\n                text: \"{labels.with2}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B4\",\n                text: \"{with[1].description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A5\",\n                text: \"{labels.with3}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B5\",\n                text: \"{with[2].description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A6\",\n                text: \"{labels.with4}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B6\",\n                text: \"{with[3].description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A7\",\n                text: \"{labels.into}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B7\",\n                text: \"{into.description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n            {\n                addr: \"A8\",\n                text: \"{labels.raising}\",\n                class: [\"cell\", \"header\"],\n            },\n            {\n                addr: \"B8\",\n                text: \"{raising.description}\",\n                class: [\"cell\", \"wrap\"],\n            },\n        ],\n    };\n\n    ns.abapObjects?.defineTemplate?.(\"message.excel-like-table\", messageExcelLikeTable);\n})(window.AbapFlow);\n", "js/abap_objects/templates/perform.excel-like-table.js": "(function (ns) {\n  \"use strict\";\n\n  const performExcelLikeTable = {\n    type: \"excel-like-table\",\n    compact: { removeEmptyRows: true },\n    sectionLabels: {\n      tables: \"Table\",\n      using: \"Using\",\n      changing: \"Changing\",\n      raising: \"Raising\",\n    },\n    grid: {\n      rows: 9,\n      cols: 3,\n      colWidths: {\n        A: 160,\n        B: 190,\n        C: 860,\n      },\n      rowHeights: {\n        1: 34,\n        2: 30,\n        3: 30,\n        4: 30,\n        5: 30,\n        6: 30,\n        7: 30,\n        8: 30,\n        9: 30,\n      },\n    },\n    css: {\n      label: \"background:#f4b183;font-weight:600;color:#111;\",\n      cell: \"border:1px solid #222;padding:6px 8px;vertical-align:middle;background:#fff;color:#111;\",\n      mono: \"font-family:Consolas,monospace;\",\n      wrap: \"white-space:normal;line-height:1.25;\",\n    },\n    defaultCellClass: [\"gap\"],\n    cells: [\n      { addr: \"A1\", text: \"Thc hin\", class: [\"cell\", \"label\"] },\n      { addr: \"B1\", text: \"{perform.name}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C1\", text: \"{perform.description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A2\", text: \"{labels.tables}\", class: [\"cell\", \"label\"] },\n      { addr: \"B2\", text: \"{tables[0].actual}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C2\", text: \"{tables[0].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A3\", text: \"\", class: [\"cell\", \"label\"] },\n      { addr: \"B3\", text: \"{tables[1].actual}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C3\", text: \"{tables[1].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A4\", text: \"{labels.using}\", class: [\"cell\", \"label\"] },\n      { addr: \"B4\", text: \"{using[0].actual}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C4\", text: \"{using[0].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A5\", text: \"\", class: [\"cell\", \"label\"] },\n      { addr: \"B5\", text: \"{using[1].actual}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C5\", text: \"{using[1].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A6\", text: \"{labels.changing}\", class: [\"cell\", \"label\"] },\n      { addr: \"B6\", text: \"{changing[0].actual}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C6\", text: \"{changing[0].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A7\", text: \"\", class: [\"cell\", \"label\"] },\n      { addr: \"B7\", text: \"{changing[1].actual}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C7\", text: \"{changing[1].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A8\", text: \"{labels.raising}\", class: [\"cell\", \"label\"] },\n      { addr: \"B8\", text: \"{raising[0].name}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C8\", text: \"{raising[0].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n\n      { addr: \"A9\", text: \"\", class: [\"cell\", \"label\"] },\n      { addr: \"B9\", text: \"{raising[1].name}\", class: [\"cell\", \"mono\", \"gap-right\"] },\n      { addr: \"C9\", text: \"{raising[1].description}\", class: [\"cell\", \"wrap\", \"gap-left\"] },\n    ],\n  };\n\n  ns.abapObjects?.defineTemplate?.(\"perform.excel-like-table\", performExcelLikeTable);\n})(window.AbapFlow);\n\n"});

  var head = document && document.head;
  if (!head || head.__abapflowInlinePatched) return;
  head.__abapflowInlinePatched = true;

  var origAppend = head.appendChild.bind(head);
  head.appendChild = function(node){
    try {
      if (node && node.tagName === 'SCRIPT' && (node.src || node.getAttribute('src'))) {
        var attr = node.getAttribute ? (node.getAttribute('src') || '') : '';
        var key = String(attr || '').replace(/\\/g, '/').replace(/^\.\//, '');
        if (!key) {
          var abs = String(node.src || '');
          var base = String(document.baseURI || '').replace(/[^\/]*$/, '');
          if (abs && base && abs.indexOf(base) === 0) key = abs.slice(base.length);
          else key = abs;
          key = String(key || '').replace(/\\/g, '/').replace(/^\.\//, '');
        }

        if (key && map && typeof map === 'object' && Object.prototype.hasOwnProperty.call(map, key)) {
          var code = String(map[key] || '');
          node.removeAttribute && node.removeAttribute('src');
          node.textContent = code + "\n//# sourceURL=" + key;
          var onload = node.onload;
          var res = origAppend(node);
          if (typeof onload === 'function') setTimeout(function(){ onload.call(node); }, 0);
          return res;
        }
      }
    } catch (_) {
      // ignore and fall back
    }
    return origAppend(node);
  };
})();
</script>
</body>
</html>
