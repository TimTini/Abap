"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/03-statements.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    const exportingParams = parseFormParamDefs(\"EXPORTING\", valueMap.exportingRaw || \"\");\n    const changingParams = parseFormParamDefs(\"CHANGING\", valueMap.changingRaw || \"\");\n    const returningParams = parseFormParamDefs(\"RETURNING\", valueMap.returningRaw || \"\");\n    const exceptions = parseFormExceptions(valueMap.raisingRaw || \"\");\n\n    return {\n      name: valueMap.name || \"\",\n      params: [...importingParams, ...exportingParams, ...changingParams, ...returningParams],\n      exceptions\n    };\n  }\n\n  function buildPerformCallExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const ifCondition = map.ifCondition || \"\";\n\n    return {\n      performCall: {\n        form: map.form || \"\",\n        program: map.program || \"\",\n        ifCondition,\n        ifConditions: parseConditionClauses(ifCondition, { allowImplicitAnd: false }),\n        using: parseArgumentTokens(map.usingRaw || \"\").map((value) => ({ value })),\n        changing: parseArgumentTokens(map.changingRaw || \"\").map((value) => ({ value })),\n        tables: parseArgumentTokens(map.tablesRaw || \"\").map((value) => ({ value }))\n      }\n    };\n  }\n\n  function buildIfConditionExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const conditionRaw = map.condition || \"\";\n\n    return {\n      ifCondition: {\n        conditionRaw,\n        conditions: parseConditionClauses(conditionRaw, { allowImplicitAnd: false })\n      }\n    };\n  }\n\n  function buildSelectExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const whereRaw = map.where || \"\";\n    const havingRaw = map.having || \"\";\n\n    return {\n      select: {\n        whereRaw,\n        whereConditions: parseConditionClauses(whereRaw, { allowImplicitAnd: false }),\n        havingRaw,\n        havingConditions: parseConditionClauses(havingRaw, { allowImplicitAnd: false })\n      }\n    };\n  }\n\n  function buildReadTableExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const withKeyRaw = map.withKey || \"\";\n    const withTableKeyRaw = map.withTableKey || \"\";\n\n    const normalizedWithTableKey = normalizeReadTableKeyConditionSource(withTableKeyRaw);\n    const conditionSource = withTableKeyRaw ? normalizedWithTableKey : withKeyRaw;\n\n    return {\n      readTable: {\n        itab: map.itab || \"\",\n        index: map.index || \"\",\n        into: map.into || \"\",\n        assigning: map.assigning || \"\",\n        refInto: map.refInto || \"\",\n        withKeyRaw,\n        withTableKeyRaw,\n        conditions: parseConditionClauses(conditionSource, { allowImplicitAnd: true })\n      }\n    };\n  }\n\n  function buildLoopAtItabExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const whereRaw = map.where || \"\";\n\n    return {\n      loopAtItab: {\n        itab: map.itab || \"\",\n        into: map.into || \"\",\n        assigning: map.assigning || \"\",\n        refInto: map.refInto || \"\",\n        from: map.from || \"\",\n        to: map.to || \"\",\n        whereRaw,\n        conditions: parseConditionClauses(whereRaw, { allowImplicitAnd: false })\n      }\n    };\n  }\n\n  function buildModifyItabExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const whereRaw = map.where || \"\";\n\n    return {\n      modifyItab: {\n        itab: map.itab || map.itabOrDbtab || \"\",\n        from: map.from || \"\",\n        index: map.index || \"\",\n        transporting: map.transporting || \"\",\n        whereRaw,\n        conditions: parseConditionClauses(whereRaw, { allowImplicitAnd: false })\n      }\n    };\n  }\n\n  function buildDeleteItabExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const whereRaw = map.where || \"\";\n\n    return {\n      deleteItab: {\n        target: map.target || \"\",\n        from: map.from || \"\",\n        index: map.index || \"\",\n        whereRaw,\n        conditions: parseConditionClauses(whereRaw, { allowImplicitAnd: false })\n      }\n    };\n  }\n\n  function attachDeclarationRefs({ statements, objects, fileName }) {\n    const allObjects = collectAllObjects(objects);\n    const idToObject = new Map(allObjects.filter((obj) => obj && obj.id).map((obj) => [obj.id, obj]));\n    const procedureBlocks = allObjects\n      .filter((obj) => obj && [\"FORM\", \"METHOD\"].includes(obj.objectType))\n      .filter((obj) => obj.block && obj.block.lineEnd);\n    const classBlocks = allObjects\n      .filter((obj) => obj && obj.objectType === \"CLASS\")\n      .filter((obj) => obj.block && obj.block.lineEnd);\n\n    const classInfo = buildClassInfo(allObjects);\n    const scopeInfoById = buildScopeInfoById({ idToObject });\n\n    const declByScope = new Map();\n    ensureScopeMap(declByScope, 0);\n\n    for (const obj of allObjects) {\n      const scopeId = getDeclarationScopeId(obj, idToObject, procedureBlocks, classBlocks);\n      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);\n      const declaredNames = getDeclaredNamesFromObject(obj);\n      for (const name of declaredNames) {\n        addDecl(declByScope, scopeId, name, buildDeclInfoFromObject(obj, name, scopeInfo));\n      }\n\n      if (obj.objectType === \"FORM\" && obj.extras && obj.extras.form && Array.isArray(obj.extras.form.params)) {\n        const formScopeInfo = scopeInfoById.get(obj.id) || buildFallbackScopeInfo(obj.id);\n        for (const param of obj.extras.form.params) {\n          if (!param || !param.name) {\n            continue;\n          }\n          addDecl(declByScope, obj.id, param.name, {\n            id: obj.id,\n            objectType: \"FORM_PARAM\",\n            name: param.name,\n            file: obj.file || fileName || \"\",\n            lineStart: obj.lineStart || null,\n            raw: obj.raw || \"\",\n            comment: param.doc ? param.doc.text || \"\" : \"\",\n            scopeId: obj.id,\n            scopeLabel: formScopeInfo.scopeLabel,\n            scopeType: formScopeInfo.scopeType,\n            scopeName: formScopeInfo.scopeName\n          });\n        }\n      }\n    }\n\n    for (const statement of statements || []) {\n      const inlineNames = extractInlineDeclarations(statement.raw || \"\");\n      if (!inlineNames.length) {\n        continue;\n      }\n\n      const scopeId = getStatementScopeId(statement.lineStart, procedureBlocks, classBlocks);\n      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);\n      for (const name of inlineNames) {\n        addDecl(declByScope, scopeId, name, {\n          id: null,\n          objectType: \"INLINE\",\n          name,\n          file: fileName || \"\",\n          lineStart: statement.lineStart || null,\n          raw: statement.raw || \"\",\n          comment: statement.comment || \"\",\n          scopeId,\n          scopeLabel: scopeInfo.scopeLabel,\n          scopeType: scopeInfo.scopeType,\n          scopeName: scopeInfo.scopeName\n        });\n      }\n    }\n\n    const structDefs = buildStructDefsFromStatements({\n      statements,\n      procedureBlocks,\n      classBlocks,\n      scopeInfoById,\n      fileName: fileName || \"\"\n    });\n\n    attachStructFieldDecls({\n      allObjects,\n      idToObject,\n      declByScope,\n      scopeInfoById,\n      procedureBlocks,\n      classBlocks,\n      classInfo,\n      fileName: fileName || \"\",\n      structDefs\n    });\n\n    for (const obj of allObjects) {\n      const resolveContext = buildResolveContext(obj, idToObject, declByScope, classInfo);\n      annotateValuesWithDecls(obj.values, resolveContext);\n      annotateExtrasWithDecls(obj.extras, resolveContext);\n    }\n\n    attachPerformOriginDecls({ allObjects, formsByNameUpper: buildFormsByNameUpper(allObjects), scopeInfoById });\n\n    const decls = [];\n    for (const scopeMap of declByScope.values()) {\n      for (const decl of scopeMap.values()) {\n        decls.push(decl);\n      }\n    }\n    return decls;\n  }\n\n  function ensureStructDefScopeMap(mapByScope, scopeId) {\n    if (!mapByScope.has(scopeId)) {\n      mapByScope.set(scopeId, new Map());\n    }\n  }\n\n  function buildStructDefsFromStatements({ statements, procedureBlocks, classBlocks, scopeInfoById, fileName }) {\n    const dataByScope = new Map();\n    const typeByScope = new Map();\n\n    for (const statement of statements || []) {\n      const startKeyword = getStatementStartKeyword(statement.raw || \"\");\n      if (startKeyword !== \"DATA\" && startKeyword !== \"TYPES\") {\n        continue;\n      }\n\n      const lineEntries = Array.isArray(statement.lineEntries) ? statement.lineEntries : [];\n      if (!lineEntries.length) {\n        continue;\n      }\n\n      const scopeId = getStatementScopeId(statement.lineStart, procedureBlocks, classBlocks);\n      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);\n\n      const defs = parseStructDefsFromLineEntries({\n        kind: startKeyword,\n        lineEntries,\n        leadingComments: Array.isArray(statement.leadingComments) ? statement.leadingComments : [],\n        fileName: fileName || \"\",\n        scopeId,\n        scopeInfo\n      });\n\n      const target = startKeyword === \"DATA\" ? dataByScope : typeByScope;\n      ensureStructDefScopeMap(target, scopeId);\n      const scopeMap = target.get(scopeId);\n\n      for (const def of defs) {\n        if (!def || !def.nameUpper) {\n          continue;\n        }\n        if (!scopeMap.has(def.nameUpper)) {\n          scopeMap.set(def.nameUpper, def);\n        }\n      }\n    }\n\n    return { dataByScope, typeByScope };\n  }\n\n  function parseStructDefsFromLineEntries({ kind, lineEntries, leadingComments, fileName, scopeId, scopeInfo }) {\n    const defs = [];\n    let current = null;\n    const stack = [];\n    const leadingText = Array.isArray(leadingComments) ? leadingComments.filter(Boolean).join(\" \").trim() : \"\";\n\n    function currentNestedPrefix() {\n      if (stack.length <= 1) {\n        return \"\";\n      }\n      return stack\n        .slice(1)\n        .map((ctx) => ctx.name)\n        .filter(Boolean)\n        .join(\"-\");\n    }\n\n    function addField(path, info) {\n      if (!current || !path) {\n        return;\n      }\n\n      const normalized = normalizeIdentifierCandidate(path);\n      if (!normalized) {\n        return;\n      }\n\n      const pathUpper = normalized.toUpperCase();\n      if (!current.fields.has(pathUpper)) {\n        current.fields.set(pathUpper, {\n          path: normalized,\n          pathUpper,\n          file: fileName || \"\",\n          lineStart: info && info.lineStart ? info.lineStart : null,\n          raw: info && info.raw ? info.raw : \"\",\n          comment: info && info.comment ? info.comment : \"\"\n        });\n      }\n    }\n\n    for (const entry of lineEntries) {\n      const code = String(entry && entry.code ? entry.code : \"\").trim();\n      if (!code) {\n        continue;\n      }\n\n      const comment = entry && entry.comment ? String(entry.comment || \"\") : \"\";\n      const lineStart = entry && entry.line ? Number(entry.line || 0) || null : null;\n\n      const withoutDot = code.replace(/\\.$/, \"\").trim();\n      const segments = splitByCommaOutsideQuotes(withoutDot)\n        .map((segment) => segment.trim())\n        .filter(Boolean);\n\n      for (const segment of segments) {\n        const marker = parseStructMarker(segment);\n        if (marker && marker.kind === \"BEGIN\") {\n          const name = normalizeIdentifierCandidate(marker.name);\n          if (!name) {\n            continue;\n          }\n          const nameUpper = name.toUpperCase();\n\n          if (!stack.length) {\n            current = {\n              kind,\n              name,\n              nameUpper,\n              file: fileName || \"\",\n              scopeId,\n              scopeLabel: scopeInfo ? scopeInfo.scopeLabel : \"\",\n              lineStart,\n              rawStart: segment,\n              comment: String(comment || \"\").trim() || leadingText,\n              fields: new Map()\n            };\n            stack.push({ name, nameUpper });\n            continue;\n          }\n\n          const prefix = currentNestedPrefix();\n          const path = prefix ? `${prefix}-${name}` : name;\n          addField(path, { lineStart, raw: segment, comment: String(comment || \"\").trim() });\n          stack.push({ name, nameUpper });\n          continue;\n        }\n\n        if (marker && marker.kind === \"END\") {\n          const name = normalizeIdentifierCandidate(marker.name);\n          const nameUpper = name ? name.toUpperCase() : \"\";\n\n          if (stack.length) {\n            const top = stack[stack.length - 1];\n            if (top && top.nameUpper && nameUpper && top.nameUpper === nameUpper) {\n              stack.pop();\n            } else {\n              stack.pop();\n            }\n          }\n\n          if (!stack.length && current) {\n            defs.push(current);\n            current = null;\n          }\n          continue;\n        }\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
