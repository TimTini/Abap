"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/01-context.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "(function (root, factory) {\n  if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n    return;\n  }\n\n  root.AbapParser = factory();\n})(typeof globalThis !== \"undefined\" ? globalThis : (typeof self !== \"undefined\" ? self : this), function () {\n  \"use strict\";\n\n  class AbapObject {\n    constructor({\n      id = null,\n      parent = null,\n      objectType,\n      file,\n      lineStart,\n      raw,\n      block = null,\n      extras = null,\n      comment,\n      keywords,\n      values,\n      children = []\n    }) {\n      this.id = id;\n      this.parent = parent;\n      this.objectType = objectType;\n      this.file = file;\n      this.lineStart = lineStart;\n      this.raw = raw;\n      this.block = block;\n      this.extras = extras;\n      this.comment = comment;\n      if (keywords && Object.keys(keywords).length) {\n        this.keywords = keywords;\n      }\n      if (values && Object.keys(values).length) {\n        this.values = values;\n      }\n      this.children = children;\n    }\n  }\n\n  const registeredConfigs = [];\n\n  function registerConfig(config) {\n    registeredConfigs.push(normalizeConfig(config));\n  }\n\n  function getConfigs() {\n    return registeredConfigs.slice();\n  }\n\n  function normalizeConfig(config) {\n    const normalized = {\n      ...config,\n      match: config.match || {},\n      block: config.block || null,\n      keywordLabels: normalizeMapKeys(config.keywordLabels),\n      keywordPhrases: normalizeMapKeys(config.keywordPhrases),\n      captureRules: normalizeCaptureRules(config.captureRules),\n      valueDescriptions: normalizeValueDescriptions(config.valueDescriptions)\n    };\n\n    if (normalized.match.startKeyword) {\n      normalized.match.startKeyword = String(normalized.match.startKeyword).toUpperCase();\n    }\n\n    if (normalized.match.startPhrase) {\n      normalized.match.startTokens = String(normalized.match.startPhrase)\n        .trim()\n        .toUpperCase()\n        .split(/\\s+/)\n        .filter(Boolean);\n    } else {\n      normalized.match.startTokens = [];\n    }\n\n    if (normalized.block && normalized.block.endKeyword) {\n      normalized.block = {\n        ...normalized.block,\n        endKeyword: String(normalized.block.endKeyword).toUpperCase()\n      };\n    }\n\n    return normalized;\n  }\n\n  function normalizeMapKeys(map) {\n    if (!map) {\n      return {};\n    }\n\n    const output = {};\n    for (const key of Object.keys(map)) {\n      output[String(key).toUpperCase()] = map[key];\n    }\n    return output;\n  }\n\n  function normalizeCaptureRules(rules) {\n    if (!Array.isArray(rules)) {\n      return [];\n    }\n\n    return rules.map((rule) => {\n      const after = rule.after || \"\";\n      const afterTokens = String(after)\n        .trim()\n        .toUpperCase()\n        .split(/\\s+/)\n        .filter(Boolean);\n\n      const stopTokensUpper = Array.isArray(rule.stopTokens)\n        ? rule.stopTokens\n            .map((token) => String(token).trim().toUpperCase())\n            .filter(Boolean)\n        : [];\n\n      return {\n        ...rule,\n        afterTokens,\n        capture: rule.capture || \"next\",\n        stopTokensUpper\n      };\n    });\n  }\n\n  function normalizeValueDescriptions(desc) {\n    if (!desc) {\n      return {};\n    }\n\n    const output = {};\n    for (const key of Object.keys(desc)) {\n      output[key] = normalizeMapKeys(desc[key]);\n    }\n    return output;\n  }\n\n  function parseAbapText(content, configs, fileName) {\n    const lines = String(content || \"\").split(/\\r?\\n/);\n    const statements = collectStatements(lines);\n    const list = Array.isArray(configs) ? configs : registeredConfigs;\n    const objects = parseStatements(statements, list, fileName || \"\");\n\n    const decls = attachDeclarationRefs({ statements, objects, fileName: fileName || \"\" });\n\n    return {\n      file: fileName || \"\",\n      objects,\n      decls\n    };\n  }\n\n  function pickPreferredStatementComment(statementBuffer) {\n    if (!statementBuffer || typeof statementBuffer !== \"object\") {\n      return \"\";\n    }\n\n    const lineEntries = Array.isArray(statementBuffer.lineEntries) ? statementBuffer.lineEntries : [];\n    for (const entry of lineEntries) {\n      const inline = entry && typeof entry.comment === \"string\" ? entry.comment.trim() : \"\";\n      if (inline) {\n        return inline;\n      }\n    }\n\n    const leading = Array.isArray(statementBuffer.leadingCommentLines) ? statementBuffer.leadingCommentLines : [];\n    if (leading.length !== 1) {\n      return \"\";\n    }\n\n    const candidate = leading[0];\n    const text = candidate && typeof candidate.text === \"string\" ? candidate.text.trim() : \"\";\n    const line = candidate ? Number(candidate.line || 0) || 0 : 0;\n    const lineStart = Number(statementBuffer.lineStart || 0) || 0;\n\n    if (!text || !lineStart || line !== lineStart - 1) {\n      return \"\";\n    }\n\n    return text;\n  }\n\n  function collectStatements(lines) {\n    const statements = [];\n    let current = null;\n    let pendingComments = [];\n\n    for (let index = 0; index < lines.length; index += 1) {\n      const lineNumber = index + 1;\n      const rawLine = lines[index];\n      const trimmed = rawLine.trim();\n\n      if (!trimmed) {\n        if (!current) {\n          pendingComments = [];\n        }\n        continue;\n      }\n\n      if (isCommentLine(trimmed)) {\n        const commentText = normalizeComment(trimmed);\n        if (commentText) {\n          if (current) {\n            current.comments.push(commentText);\n          } else {\n            pendingComments.push({ line: lineNumber, text: commentText });\n          }\n        } else if (!current) {\n          // Decorative comment-only lines behave like blank separators.\n          pendingComments = [];\n        }\n        continue;\n      }\n\n      const { code, comment } = splitCodeAndInlineComment(rawLine);\n      const codeTrim = code.trim();\n\n      if (!codeTrim) {\n        if (comment) {\n          pendingComments.push({ line: lineNumber, text: comment });\n        } else if (!current) {\n          // Decorative inline-only comment (e.g. `\"----\"`) is treated as blank.\n          pendingComments = [];\n        }\n        continue;\n      }\n\n      if (!current) {\n        const leadingCommentLines = pendingComments.slice();\n        const leadingComments = leadingCommentLines\n          .map((entry) => (entry && typeof entry.text === \"string\" ? entry.text : \"\"))\n          .filter(Boolean);\n\n        current = {\n          lineStart: lineNumber,\n          rawParts: [],\n          comments: leadingComments.slice(),\n          leadingComments,\n          leadingCommentLines,\n          lineEntries: []\n        };\n        pendingComments = [];\n      }\n\n      current.rawParts.push(codeTrim);\n      if (comment) {\n        current.comments.push(comment);\n      }\n      current.lineEntries.push({ line: lineNumber, code: codeTrim, comment: comment || \"\" });\n\n      if (codeTrim.endsWith(\".\")) {\n        const raw = current.rawParts.join(\" \").replace(/\\s+/g, \" \").trim();\n        const commentText = pickPreferredStatementComment(current);\n\n        statements.push({\n          lineStart: current.lineStart,\n          raw,\n          comment: commentText,\n          commentLines: current.comments.filter(Boolean),\n          leadingComments: current.leadingComments ? current.leadingComments.slice() : [],\n          lineEntries: current.lineEntries.slice()\n        });\n\n        current = null;\n      }\n    }\n\n    return statements;\n  }\n\n  function isCommentLine(trimmedLine) {\n    return trimmedLine.startsWith(\"*\") || trimmedLine.startsWith('\"');\n  }\n\n  function normalizeComment(trimmedLine) {\n    const normalizeText = (text) => {\n      const trimmed = String(text || \"\").trim();\n      if (!trimmed) {\n        return \"\";\n      }\n\n      // Treat separator-only comment content as empty.\n      if (\n        !/[A-Za-z0-9\\u00C0-\\u024F\\u1E00-\\u1EFF]/.test(trimmed) &&\n        /^[\\s*&\\-_=~#|\\\\/.:;,+(){}\\[\\]<>]+$/.test(trimmed)\n      ) {\n        return \"\";\n      }\n\n      return trimmed;\n    };\n\n    if (trimmedLine.startsWith(\"*\") || trimmedLine.startsWith('\"')) {\n      return normalizeText(trimmedLine.slice(1));\n    }\n    return normalizeText(trimmedLine);\n  }\n\n  function splitCodeAndInlineComment(line) {\n    const text = String(line || \"\");\n    let inSingleQuote = false;\n    let inPipe = false;\n\n    for (let index = 0; index < text.length; index += 1) {\n      const char = text[index];\n      const next = index + 1 < text.length ? text[index + 1] : \"\";\n\n      if (char === \"'\" && !inPipe) {\n        if (inSingleQuote && next === \"'\") {\n          index += 1;\n          continue;\n        }\n        inSingleQuote = !inSingleQuote;\n        continue;\n      }\n\n      if (char === \"|\" && !inSingleQuote) {\n        if (inPipe && next === \"|\") {\n          index += 1;\n          continue;\n        }\n        inPipe = !inPipe;\n        continue;\n      }\n\n      if (char === '\"' && !inSingleQuote && !inPipe) {\n        const code = text.slice(0, index);\n        const comment = normalizeComment(text.slice(index + 1));\n        return { code, comment };\n      }\n    }\n\n    return { code: text, comment: \"\" };\n  }\n\n  function parseStatements(statements, configs, fileName) {\n    const roots = [];\n    const stack = [];\n    let nextId = 1;\n\n    for (const statement of statements) {\n      const statementStart = getStatementStartKeyword(statement.raw);\n      const currentFrame = stack.length ? stack[stack.length - 1] : null;\n\n      if (currentFrame && statementStart === currentFrame.endKeyword) {\n        currentFrame.node.block.endRaw = statement.raw;\n        currentFrame.node.block.lineEnd = statement.lineStart;\n        stack.pop();\n        continue;\n      }\n\n      const parentId = currentFrame ? currentFrame.node.id : null;\n      const parsedList = parseStatement(statement, configs, fileName, parentId, () => nextId++);\n      if (!parsedList || !parsedList.length) {\n        continue;\n      }\n\n      const targetList = currentFrame ? currentFrame.node.children : roots;\n      for (const node of parsedList) {\n        targetList.push(node);\n        if (node.block && node.block.endKeyword) {\n          stack.push({ node, endKeyword: node.block.endKeyword });\n        }\n      }\n    }\n\n    return roots;\n  }\n\n  function getStatementStartKeyword(raw) {\n    const tokens = tokenize(raw);\n    if (!tokens.length) {\n      return \"\";\n    }\n    return tokens[0].upper;\n  }\n\n  function parseStatement(statement, configs, fileName, parentId, nextId) {\n    const tokens = tokenize(statement.raw);\n    if (tokens.length === 0) {\n      return null;\n    }\n\n    for (const config of configs) {\n      if (!matchesConfig(tokens, config, statement.raw)) {\n        continue;\n      }\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
