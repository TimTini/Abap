"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/06-conditions.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    const results = [];\n\n    [\n      /@?DATA\\s*\\(\\s*([^)]+)\\s*\\)/gi,\n      /@?FINAL\\s*\\(\\s*([^)]+)\\s*\\)/gi,\n      /FIELD-SYMBOL\\s*\\(\\s*(<[^>]+>)\\s*\\)/gi\n    ].forEach((regex) => {\n      let match = null;\n      while ((match = regex.exec(text))) {\n        const candidate = normalizeIdentifierCandidate(match[1]);\n        if (candidate) {\n          results.push(candidate);\n        }\n      }\n    });\n\n    return Array.from(new Set(results));\n  }\n\n  function normalizeIdentifierCandidate(raw) {\n    const trimmed = String(raw || \"\").trim();\n    if (!trimmed) {\n      return \"\";\n    }\n    if (/^<[^>]+>$/.test(trimmed)) {\n      return trimmed;\n    }\n    if (/^SY-[A-Za-z_][A-Za-z0-9_]*$/i.test(trimmed)) {\n      return trimmed.toUpperCase();\n    }\n    if (/^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(-[A-Za-z_][A-Za-z0-9_]*)+$/i.test(trimmed)) {\n      return trimmed;\n    }\n    if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(trimmed)) {\n      return trimmed;\n    }\n    return \"\";\n  }\n\n  function buildResolveContext(obj, idToObject, declByScope, classInfo) {\n    const procId = getProcedureScopeId(obj, idToObject);\n    const methodBlock = findAncestor(obj, idToObject, \"METHOD\");\n    const classBlock = findAncestor(obj, idToObject, \"CLASS\");\n\n    const classNameUpper = classBlock ? getFirstValue(classBlock.values, \"name\").toUpperCase() : \"\";\n    const methodNameUpper = methodBlock ? getFirstValue(methodBlock.values, \"name\").toUpperCase() : \"\";\n    const classDef = classNameUpper && classInfo.byName.get(classNameUpper)\n      ? classInfo.byName.get(classNameUpper).definition\n      : null;\n\n    const methodParamsEntry = classNameUpper && methodNameUpper\n      ? classInfo.methodParamsByClassAndName.get(`${classNameUpper}:${methodNameUpper}`)\n      : null;\n\n    return {\n      obj,\n      procId,\n      classNameUpper,\n      methodNameUpper,\n      classDefId: classDef ? classDef.id : 0,\n      declByScope,\n      methodParamsByNameUpper: methodParamsEntry ? methodParamsEntry.paramsByNameUpper : null\n    };\n  }\n\n  function findAncestor(obj, idToObject, objectType) {\n    let current = obj;\n    while (current) {\n      if (current.objectType === objectType) {\n        return current;\n      }\n      current = current.parent ? idToObject.get(current.parent) : null;\n    }\n    return null;\n  }\n\n  function annotateValuesWithDecls(values, context) {\n    const annotateEntry = (entry) => {\n      if (!entry || !entry.value) {\n        return;\n      }\n      const ref = extractFirstIdentifierFromExpression(entry.value);\n      if (!ref) {\n        return;\n      }\n      const decl = resolveDecl(ref, context);\n      if (!decl) {\n        return;\n      }\n      entry.declRef = ref;\n      entry.decl = decl;\n    };\n\n    if (Array.isArray(values)) {\n      for (const entry of values) {\n        annotateEntry(entry);\n      }\n      return;\n    }\n\n    if (!values || typeof values !== \"object\") {\n      return;\n    }\n\n    for (const key of Object.keys(values)) {\n      const entryOrList = values[key];\n      if (Array.isArray(entryOrList)) {\n        for (const entry of entryOrList) {\n          annotateEntry(entry);\n        }\n        continue;\n      }\n      annotateEntry(entryOrList);\n    }\n  }\n\n  function annotateExtrasWithDecls(extras, context) {\n    if (!extras || typeof extras !== \"object\") {\n      return;\n    }\n\n    if (extras.callFunction) {\n      annotateCallFunctionExtras(extras.callFunction, context);\n    }\n\n    if (extras.callMethod) {\n      annotateCallMethodExtras(extras.callMethod, context);\n    }\n\n    if (extras.performCall) {\n      annotatePerformCallExtras(extras.performCall, context);\n    }\n\n    if (extras.ifCondition) {\n      annotateIfConditionExtras(extras.ifCondition, context);\n    }\n\n    if (extras.select) {\n      annotateSelectExtras(extras.select, context);\n    }\n\n    if (extras.readTable) {\n      annotateReadTableExtras(extras.readTable, context);\n    }\n\n    if (extras.loopAtItab) {\n      annotateLoopAtItabExtras(extras.loopAtItab, context);\n    }\n\n    if (extras.modifyItab) {\n      annotateModifyItabExtras(extras.modifyItab, context);\n    }\n\n    if (extras.deleteItab) {\n      annotateDeleteItabExtras(extras.deleteItab, context);\n    }\n  }\n\n  function annotateCallFunctionExtras(callFunction, context) {\n    for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"tables\", \"exceptions\"]) {\n      const list = callFunction && Array.isArray(callFunction[sectionName]) ? callFunction[sectionName] : [];\n      for (const entry of list) {\n        if (!entry || !entry.value) {\n          continue;\n        }\n        const ref = extractFirstIdentifierFromExpression(entry.value);\n        if (!ref) {\n          continue;\n        }\n        entry.valueRef = ref;\n        entry.valueDecl = resolveDecl(ref, context);\n      }\n    }\n  }\n\n  function annotateCallMethodExtras(callMethod, context) {\n    for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"receiving\", \"exceptions\"]) {\n      const list = callMethod && Array.isArray(callMethod[sectionName]) ? callMethod[sectionName] : [];\n      for (const entry of list) {\n        if (!entry || !entry.value) {\n          continue;\n        }\n        const ref = extractFirstIdentifierFromExpression(entry.value);\n        if (!ref) {\n          continue;\n        }\n        entry.valueRef = ref;\n        entry.valueDecl = resolveDecl(ref, context);\n      }\n    }\n  }\n\n  function annotatePerformCallExtras(performCall, context) {\n    for (const sectionName of [\"using\", \"changing\", \"tables\"]) {\n      const list = performCall && Array.isArray(performCall[sectionName]) ? performCall[sectionName] : [];\n      for (const entry of list) {\n        if (!entry || !entry.value) {\n          continue;\n        }\n        const ref = extractFirstIdentifierFromExpression(entry.value);\n        if (!ref) {\n          continue;\n        }\n        entry.valueRef = ref;\n        entry.valueDecl = resolveDecl(ref, context);\n      }\n    }\n\n    annotateConditionClausesWithDecls(performCall ? performCall.ifConditions : null, context);\n  }\n\n  function annotateIfConditionExtras(ifCondition, context) {\n    if (!ifCondition || typeof ifCondition !== \"object\") {\n      return;\n    }\n    annotateConditionClausesWithDecls(ifCondition.conditions, context);\n  }\n\n  function annotateSelectExtras(selectExtras, context) {\n    if (!selectExtras || typeof selectExtras !== \"object\") {\n      return;\n    }\n    annotateConditionClausesWithDecls(selectExtras.whereConditions, context);\n    annotateConditionClausesWithDecls(selectExtras.havingConditions, context);\n  }\n\n  function annotateConditionClausesWithDecls(conditions, context) {\n    const list = Array.isArray(conditions) ? conditions : [];\n    for (const clause of list) {\n      if (!clause || typeof clause !== \"object\") {\n        continue;\n      }\n\n      const leftRef = extractFirstIdentifierFromExpression(clause.leftOperand);\n      if (leftRef) {\n        clause.leftOperandRef = leftRef;\n        clause.leftOperandDecl = resolveDecl(leftRef, context) || buildSyntheticConditionOperandDeclInfo(clause.leftOperand, leftRef);\n      } else {\n        clause.leftOperandDecl = buildSyntheticConditionOperandDeclInfo(clause.leftOperand, \"\");\n      }\n\n      const operatorUpper = String(clause.comparisonOperator || \"\").toUpperCase();\n      const skipRightAnnotation = operatorUpper === \"IS\" && isUnaryIsPredicate(clause.rightOperand);\n      const rightRef = skipRightAnnotation ? \"\" : extractFirstIdentifierFromExpression(clause.rightOperand);\n      if (rightRef) {\n        clause.rightOperandRef = rightRef;\n        clause.rightOperandDecl = resolveDecl(rightRef, context) || buildSyntheticConditionOperandDeclInfo(clause.rightOperand, rightRef);\n      } else if (skipRightAnnotation) {\n        clause.rightOperandDecl = buildUnaryIsPredicateDeclInfo(clause.rightOperand);\n      } else {\n        clause.rightOperandDecl = buildSyntheticConditionOperandDeclInfo(clause.rightOperand, \"\");\n      }\n    }\n  }\n\n  function isUnaryIsPredicate(value) {\n    const text = String(value || \"\").trim();\n    if (!text) {\n      return false;\n    }\n    return /^(?:NOT\\s+)?(?:INITIAL|ASSIGNED|BOUND|SUPPLIED|REQUESTED)$/i.test(text);\n  }\n\n  function buildUnaryIsPredicateDeclInfo(value) {\n    const text = String(value || \"\").trim().toUpperCase().replace(/\\s+/g, \" \");\n    if (!text) {\n      return null;\n    }\n    return {\n      id: null,\n      objectType: \"SYSTEM\",\n      name: text,\n      file: \"\",\n      lineStart: null,\n      raw: \"\",\n      comment: \"\",\n      scopeId: 0,\n      scopeLabel: \"SYSTEM\",\n      scopeType: \"SYSTEM\",\n      scopeName: \"\"\n    };\n  }\n\n  function buildSyntheticConditionOperandDeclInfo(rawValue, preferredName) {\n    const rawText = String(rawValue || \"\").trim();\n    const preferredText = String(preferredName || \"\").trim();\n    const name = preferredText || rawText;\n    if (!name) {\n      return null;\n    }\n    return {\n      id: null,\n      objectType: \"CONDITION_VALUE\",\n      name,\n      file: \"\",\n      lineStart: null,\n      raw: rawText,\n      comment: \"\",\n      scopeId: 0,\n      scopeLabel: \"CONDITION\",\n      scopeType: \"SYSTEM\",\n      scopeName: \"\"\n    };\n  }\n\n  function annotateReadTableExtras(readTable, context) {\n    if (!readTable || typeof readTable !== \"object\") {\n      return;\n    }\n    annotateConditionClausesWithDecls(readTable.conditions, context);\n  }\n\n  function annotateLoopAtItabExtras(loopAtItab, context) {\n    if (!loopAtItab || typeof loopAtItab !== \"object\") {\n      return;\n    }\n    annotateConditionClausesWithDecls(loopAtItab.conditions, context);\n  }\n\n  function annotateModifyItabExtras(modifyItab, context) {\n    if (!modifyItab || typeof modifyItab !== \"object\") {\n      return;\n    }\n    annotateConditionClausesWithDecls(modifyItab.conditions, context);\n  }\n\n  function annotateDeleteItabExtras(deleteItab, context) {\n    if (!deleteItab || typeof deleteItab !== \"object\") {\n      return;\n    }\n    annotateConditionClausesWithDecls(deleteItab.conditions, context);\n  }\n\n  function resolveDecl(identifier, context) {\n    const normalized = normalizeIdentifierCandidate(identifier);\n    if (!normalized) {\n      return null;\n    }\n    const upper = normalized.toUpperCase();\n\n    const procMap = context.procId ? context.declByScope.get(context.procId) : null;\n    if (procMap && procMap.has(upper)) {\n      return procMap.get(upper);\n    }\n\n    const methodParams = context.methodParamsByNameUpper;\n    if (methodParams && methodParams.has(upper)) {\n      return methodParams.get(upper);\n    }\n\n    const classMap = context.classDefId ? context.declByScope.get(context.classDefId) : null;\n    if (classMap && classMap.has(upper)) {\n      return classMap.get(upper);\n    }\n\n    const globalMap = context.declByScope.get(0);\n    if (globalMap && globalMap.has(upper)) {\n      return globalMap.get(upper);\n    }\n\n    const systemDecl = buildSystemDeclInfo(normalized);\n    if (systemDecl) {\n      return systemDecl;\n    }\n\n    return null;\n  }\n\n  function buildSystemDeclInfo(identifier) {\n    const upper = String(identifier || \"\").trim().toUpperCase();\n    if (!upper) {\n      return null;\n    }\n\n    const known = new Set([\n      \"ABAP_TRUE\",\n      \"ABAP_FALSE\",\n      \"ABAP_UNDEFINED\",\n      \"SPACE\",\n      \"SY-SUBRC\",\n      \"SY-TABIX\",\n      \"SY-UNAME\",\n      \"SY-REPID\"\n    ]);\n\n    if (!upper.startsWith(\"SY-\") && !known.has(upper)) {\n      return null;\n    }\n\n    return {\n      id: null,\n      objectType: \"SYSTEM\",\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
