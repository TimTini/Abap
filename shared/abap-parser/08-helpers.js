"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/08-helpers.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\n      map[name] = [current, entry];\n    }\n    return map;\n  }\n\n  function parseFormSignature(valueMap) {\n    const usingParams = parseFormParamDefs(\"USING\", valueMap.usingRaw || \"\");\n    const changingParams = parseFormParamDefs(\"CHANGING\", valueMap.changingRaw || \"\");\n    const tablesParams = parseFormParamDefs(\"TABLES\", valueMap.tablesRaw || \"\");\n    const exceptions = parseFormExceptions(valueMap.raisingRaw || \"\");\n\n    const params = [...usingParams, ...changingParams, ...tablesParams];\n    const namesUpper = new Set(params.map((param) => param.name.toUpperCase()));\n\n    return {\n      params,\n      exceptions,\n      namesUpper\n    };\n  }\n\n  function parseFormParamDefs(section, segmentRaw) {\n    const trimmed = String(segmentRaw || \"\").trim();\n    if (!trimmed) {\n      return [];\n    }\n\n    const tokens = tokenize(`${trimmed}.`);\n    const params = [];\n    const seen = new Set();\n\n    for (let index = 0; index < tokens.length; index += 1) {\n      const tokenUpper = tokens[index].upper;\n      if (![\"TYPE\", \"LIKE\", \"STRUCTURE\"].includes(tokenUpper)) {\n        continue;\n      }\n\n      const nameToken = tokens[index - 1];\n      if (!nameToken) {\n        continue;\n      }\n\n      const name = normalizeFormParamName(nameToken.raw);\n      if (!name) {\n        continue;\n      }\n\n      const key = `${section}:${name.toUpperCase()}`;\n      if (seen.has(key)) {\n        continue;\n      }\n\n      const typing = readTyping(tokens, index);\n      params.push({\n        section,\n        name,\n        typing\n      });\n\n      seen.add(key);\n    }\n\n    if (params.length) {\n      return params;\n    }\n\n    for (const token of tokens) {\n      const name = normalizeFormParamName(token.raw);\n      if (!name) {\n        continue;\n      }\n      const key = `${section}:${name.toUpperCase()}`;\n      if (seen.has(key)) {\n        continue;\n      }\n      params.push({\n        section,\n        name,\n        typing: null\n      });\n      seen.add(key);\n    }\n\n    return params;\n  }\n\n  function readTyping(tokens, keywordIndex) {\n    const kind = tokens[keywordIndex].upper;\n    const next = tokens[keywordIndex + 1];\n    const next2 = tokens[keywordIndex + 2];\n    const next3 = tokens[keywordIndex + 3];\n\n    if ((kind === \"TYPE\" || kind === \"LIKE\") && next && next.upper === \"REF\" && next2 && next2.upper === \"TO\" && next3) {\n      return { kind: `${kind} REF TO`, value: next3.raw };\n    }\n\n    if (next) {\n      return { kind, value: next.raw };\n    }\n\n    return { kind, value: \"\" };\n  }\n\n  function parseFormExceptions(segmentRaw) {\n    const trimmed = String(segmentRaw || \"\").trim();\n    if (!trimmed) {\n      return [];\n    }\n\n    const tokens = tokenize(`${trimmed}.`);\n    return tokens\n      .map((token) => token.raw)\n      .filter(Boolean)\n      .map((name) => ({ name }));\n  }\n\n  function normalizeFormParamName(raw) {\n    const trimmed = String(raw || \"\").trim();\n    if (!trimmed) {\n      return \"\";\n    }\n\n    const valueMatch = trimmed.match(/^VALUE\\(([^)]+)\\)$/i);\n    const candidate = valueMatch ? valueMatch[1] : trimmed;\n    const cleaned = candidate.replace(/^[([{]+/, \"\").replace(/[)\\]}]+$/, \"\").trim();\n\n    if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(cleaned)) {\n      return \"\";\n    }\n\n    return cleaned;\n  }\n\n  function parseFormDocComment(commentLines) {\n    const params = [];\n    let formName = \"\";\n\n    for (const line of commentLines || []) {\n      const text = String(line || \"\").trim();\n      if (!text) {\n        continue;\n      }\n\n      if (!formName) {\n        const match = text.match(/\\bForm\\s+([A-Za-z_][A-Za-z0-9_]*)\\b/i);\n        if (match) {\n          formName = match[1];\n        }\n      }\n\n      const paramMatch = text.match(/^(-->|<--|<->)\\s+([A-Za-z_][A-Za-z0-9_]*)\\s*(.*)$/);\n      if (!paramMatch) {\n        continue;\n      }\n\n      const direction = decodeArrowDirection(paramMatch[1]);\n      const name = paramMatch[2];\n      const desc = String(paramMatch[3] || \"\").trim();\n\n      params.push({\n        direction,\n        name,\n        text: desc\n      });\n    }\n\n    return {\n      formName,\n      params\n    };\n  }\n\n  function decodeArrowDirection(symbol) {\n    if (symbol === \"-->\") {\n      return \"in\";\n    }\n    if (symbol === \"<--\") {\n      return \"out\";\n    }\n    return \"inout\";\n  }\n\n  function isChainedStatementStart(raw, startKeyword) {\n    if (!startKeyword) {\n      return false;\n    }\n\n    const pattern = new RegExp(`^\\\\s*${escapeRegExp(startKeyword)}\\\\s*:`, \"i\");\n    return pattern.test(raw);\n  }\n\n  function splitChainedStatementWithMeta(statement, startKeyword) {\n    const raw = statement && typeof statement.raw === \"string\" ? statement.raw : \"\";\n    const baseLineStart = statement && statement.lineStart ? Number(statement.lineStart) || null : null;\n    const lineEntries = statement && Array.isArray(statement.lineEntries) ? statement.lineEntries : [];\n\n    if (!lineEntries.length) {\n      const parts = splitChainedStatement(raw, startKeyword);\n      return parts.map((partRaw) => ({\n        raw: partRaw,\n        lineStart: baseLineStart,\n        comment: statement && typeof statement.comment === \"string\" ? statement.comment : \"\",\n        commentLines: statement && Array.isArray(statement.commentLines) ? statement.commentLines.slice() : []\n      }));\n    }\n\n    const prefixPattern = new RegExp(`^\\\\s*${escapeRegExp(startKeyword)}\\\\s*:\\\\s*`, \"i\");\n    const segments = [];\n\n    let current = \"\";\n    let currentStartLine = null;\n    let inSingleQuote = false;\n    let inPipe = false;\n\n    const pushSegment = ({ comment, endLine }) => {\n      const text = current.replace(/\\s+/g, \" \").trim();\n      if (!text) {\n        current = \"\";\n        currentStartLine = null;\n        return;\n      }\n\n      const commentText = String(comment || \"\").trim();\n      segments.push({\n        raw: `${startKeyword} ${text}.`,\n        lineStart: currentStartLine || endLine || baseLineStart,\n        comment: commentText,\n        commentLines: commentText ? [commentText] : []\n      });\n      current = \"\";\n      currentStartLine = null;\n    };\n\n    for (const entry of lineEntries) {\n      const lineNumber = entry && entry.line ? Number(entry.line || 0) || null : null;\n      const lineComment = entry && entry.comment ? String(entry.comment || \"\").trim() : \"\";\n      let code = entry && entry.code ? String(entry.code || \"\") : \"\";\n      code = code.trim();\n      if (!code) {\n        continue;\n      }\n      code = code.replace(prefixPattern, \"\").trim();\n      if (!code) {\n        continue;\n      }\n\n      if (current.trim()) {\n        current += \" \";\n      }\n\n      for (let index = 0; index < code.length; index += 1) {\n        const char = code[index];\n        const next = index + 1 < code.length ? code[index + 1] : \"\";\n\n        if (char === \"'\" && !inPipe) {\n          if (inSingleQuote && next === \"'\") {\n            if (!currentStartLine && current.trim().length === 0) {\n              currentStartLine = lineNumber || baseLineStart;\n            }\n            current += \"''\";\n            index += 1;\n            continue;\n          }\n          inSingleQuote = !inSingleQuote;\n          if (!currentStartLine && current.trim().length === 0 && char.trim()) {\n            currentStartLine = lineNumber || baseLineStart;\n          }\n          current += char;\n          continue;\n        }\n\n        if (char === \"|\" && !inSingleQuote) {\n          if (inPipe && next === \"|\") {\n            if (!currentStartLine && current.trim().length === 0) {\n              currentStartLine = lineNumber || baseLineStart;\n            }\n            current += \"||\";\n            index += 1;\n            continue;\n          }\n          inPipe = !inPipe;\n          if (!currentStartLine && current.trim().length === 0 && char.trim()) {\n            currentStartLine = lineNumber || baseLineStart;\n          }\n          current += char;\n          continue;\n        }\n\n        if (char === \",\" && !inSingleQuote && !inPipe) {\n          const rest = code.slice(index + 1).trim();\n          const commentForSegment = rest ? \"\" : lineComment;\n          pushSegment({ comment: commentForSegment, endLine: lineNumber });\n          continue;\n        }\n\n        if (char === \".\" && !inSingleQuote && !inPipe) {\n          const rest = code.slice(index + 1).trim();\n          if (!rest) {\n            pushSegment({ comment: lineComment, endLine: lineNumber });\n            break;\n          }\n        }\n\n        if (!currentStartLine && current.trim().length === 0 && char.trim()) {\n          currentStartLine = lineNumber || baseLineStart;\n        }\n        current += char;\n      }\n    }\n\n    if (current.trim()) {\n      pushSegment({ comment: \"\", endLine: null });\n    }\n\n    if (!segments.length) {\n      return splitChainedStatement(raw, startKeyword).map((partRaw) => ({\n        raw: partRaw,\n        lineStart: baseLineStart,\n        comment: \"\",\n        commentLines: []\n      }));\n    }\n\n    return segments;\n  }\n\n  function splitChainedStatement(raw, startKeyword) {\n    const pattern = new RegExp(`^\\\\s*${escapeRegExp(startKeyword)}\\\\s*:\\\\s*`, \"i\");\n    const match = raw.match(pattern);\n    if (!match) {\n      return [raw];\n    }\n\n    let body = raw.slice(match[0].length).trim();\n    body = body.replace(/\\.$/, \"\").trim();\n    if (!body) {\n      return [];\n    }\n\n    const parts = splitByCommaOutsideQuotes(body)\n      .map((part) => part.trim())\n      .filter(Boolean);\n\n    return parts.map((part) => `${startKeyword} ${part}.`);\n  }\n\n  function splitByCommaOutsideQuotes(text) {\n    const parts = [];\n    let current = \"\";\n    let inSingleQuote = false;\n    let inPipe = false;\n\n    for (let index = 0; index < text.length; index += 1) {\n      const char = text[index];\n      const next = index + 1 < text.length ? text[index + 1] : \"\";\n\n      if (char === \"'\" && !inPipe) {\n        if (inSingleQuote && next === \"'\") {\n          current += \"''\";\n          index += 1;\n          continue;\n        }\n        inSingleQuote = !inSingleQuote;\n        current += char;\n        continue;\n      }\n\n      if (char === \"|\" && !inSingleQuote) {\n        if (inPipe && next === \"|\") {\n          current += \"||\";\n          index += 1;\n          continue;\n        }\n        inPipe = !inPipe;\n        current += char;\n        continue;\n      }\n\n      if (char === \",\" && !inSingleQuote && !inPipe) {\n        parts.push(current.trim());\n        current = \"\";\n        continue;\n      }\n\n      current += char;\n    }\n\n    if (current.trim()) {\n      parts.push(current.trim());\n    }\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
