"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/05-extras.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    const line = obj.lineStart || 0;\n    return getStatementScopeId(line, [], classBlocks);\n  }\n\n  function getProcedureScopeId(obj, idToObject) {\n    let current = obj;\n    while (current) {\n      if (current.objectType === \"FORM\" || current.objectType === \"METHOD\") {\n        return current.id || 0;\n      }\n      current = current.parent ? idToObject.get(current.parent) : null;\n    }\n    return 0;\n  }\n\n  function getStatementScopeId(lineStart, procedureBlocks, classBlocks) {\n    const proc = findInnermostBlock(lineStart, procedureBlocks);\n    if (proc) {\n      return proc.id || 0;\n    }\n    const cls = findInnermostBlock(lineStart, classBlocks);\n    if (cls) {\n      return cls.id || 0;\n    }\n    return 0;\n  }\n\n  function findInnermostBlock(line, blocks) {\n    let best = null;\n    let bestSize = Infinity;\n    const currentLine = Number(line || 0);\n\n    for (const block of blocks || []) {\n      const start = Number(block.lineStart || 0);\n      const end = Number(block.block && block.block.lineEnd ? block.block.lineEnd : 0);\n      if (!start || !end) {\n        continue;\n      }\n      if (currentLine < start || currentLine > end) {\n        continue;\n      }\n      const size = end - start;\n      if (size < bestSize) {\n        best = block;\n        bestSize = size;\n      }\n    }\n\n    return best;\n  }\n\n  function getDeclaredNamesFromObject(obj) {\n    if (!obj || !obj.objectType) {\n      return [];\n    }\n\n    const structMeta = obj.extras && typeof obj.extras === \"object\" ? obj.extras.structDef : null;\n    if (structMeta && structMeta.isDecl === false) {\n      return [];\n    }\n\n    const type = obj.objectType;\n    if ([\"DATA\", \"CONSTANTS\", \"PARAMETERS\", \"SELECT-OPTIONS\", \"TYPES\", \"RANGES\", \"STATICS\", \"CLASS-DATA\", \"FIELD-SYMBOLS\"].includes(type)) {\n      const name = getFirstValue(obj.values, \"name\");\n      return name ? [name] : [];\n    }\n\n    return [];\n  }\n\n  function buildDeclInfoFromObject(obj, name, scopeInfo) {\n    const scope = scopeInfo || buildFallbackScopeInfo(0);\n    return {\n      id: obj.id || null,\n      objectType: obj.objectType || \"\",\n      name: normalizeIdentifierCandidate(name) || name || \"\",\n      file: obj.file || \"\",\n      lineStart: obj.lineStart || null,\n      raw: obj.raw || \"\",\n      comment: obj.comment || \"\",\n      scopeId: scope.scopeId,\n      scopeLabel: scope.scopeLabel,\n      scopeType: scope.scopeType,\n      scopeName: scope.scopeName\n    };\n  }\n\n  function buildFallbackScopeInfo(scopeId) {\n    const id = Number(scopeId || 0) || 0;\n    if (!id) {\n      return { scopeId: 0, scopeType: \"GLOBAL\", scopeLabel: \"GLOBAL\", scopeName: \"\" };\n    }\n    return { scopeId: id, scopeType: \"SCOPE\", scopeLabel: `SCOPE:${id}`, scopeName: \"\" };\n  }\n\n  function buildScopeInfoById({ idToObject }) {\n    const map = new Map();\n    map.set(0, buildFallbackScopeInfo(0));\n\n    for (const [id, obj] of idToObject.entries()) {\n      if (!obj || !obj.objectType) {\n        continue;\n      }\n\n      const type = obj.objectType;\n      if (![\"FORM\", \"METHOD\", \"CLASS\", \"METHODS\", \"CLASS-METHODS\"].includes(type)) {\n        continue;\n      }\n\n      if (type === \"FORM\") {\n        const formName = getFirstValue(obj.values, \"name\") || \"\";\n        const upper = formName ? formName.toUpperCase() : \"\";\n        map.set(id, {\n          scopeId: id,\n          scopeType: \"FORM\",\n          scopeLabel: upper ? `FORM:${upper}` : `FORM:${id}`,\n          scopeName: formName\n        });\n        continue;\n      }\n\n      if (type === \"METHOD\") {\n        const methodName = getFirstValue(obj.values, \"name\") || \"\";\n        const methodUpper = methodName ? methodName.toUpperCase() : \"\";\n        const classUpper = findAncestorNameUpper(obj, idToObject, \"CLASS\");\n        const label = classUpper && methodUpper\n          ? `METHOD:${classUpper}=>${methodUpper}`\n          : methodUpper\n              ? `METHOD:${methodUpper}`\n              : `METHOD:${id}`;\n\n        map.set(id, {\n          scopeId: id,\n          scopeType: \"METHOD\",\n          scopeLabel: label,\n          scopeName: methodName\n        });\n        continue;\n      }\n\n      if (type === \"CLASS\") {\n        const className = getFirstValue(obj.values, \"name\") || \"\";\n        const classUpper = className ? className.toUpperCase() : \"\";\n        map.set(id, {\n          scopeId: id,\n          scopeType: \"CLASS\",\n          scopeLabel: classUpper ? `CLASS:${classUpper}` : `CLASS:${id}`,\n          scopeName: className\n        });\n        continue;\n      }\n\n      if (type === \"METHODS\" || type === \"CLASS-METHODS\") {\n        const methodName = getFirstValue(obj.values, \"name\") || \"\";\n        const methodUpper = methodName ? methodName.toUpperCase() : \"\";\n        const classUpper = findAncestorNameUpper(obj, idToObject, \"CLASS\");\n        const label = classUpper && methodUpper\n          ? `METHODSIG:${classUpper}=>${methodUpper}`\n          : methodUpper\n              ? `METHODSIG:${methodUpper}`\n              : `METHODSIG:${id}`;\n\n        map.set(id, {\n          scopeId: id,\n          scopeType: \"METHODSIG\",\n          scopeLabel: label,\n          scopeName: methodName\n        });\n      }\n    }\n\n    return map;\n  }\n\n  function findAncestorNameUpper(obj, idToObject, objectType) {\n    let current = obj;\n    while (current) {\n      if (current.objectType === objectType) {\n        const name = getFirstValue(current.values, \"name\") || \"\";\n        return name ? name.toUpperCase() : \"\";\n      }\n      current = current.parent ? idToObject.get(current.parent) : null;\n    }\n    return \"\";\n  }\n\n  function buildFormsByNameUpper(allObjects) {\n    const map = new Map();\n    for (const obj of allObjects || []) {\n      if (!obj || obj.objectType !== \"FORM\") {\n        continue;\n      }\n\n      const name = getFirstValue(obj.values, \"name\") || (obj.extras && obj.extras.form ? obj.extras.form.name : \"\");\n      if (!name) {\n        continue;\n      }\n\n      const upper = String(name).toUpperCase();\n      if (!map.has(upper)) {\n        map.set(upper, obj);\n      }\n    }\n    return map;\n  }\n\n  function declIdentityKey(decl) {\n    if (!decl) {\n      return \"\";\n    }\n    const objectType = decl.objectType || \"\";\n    const scopeLabel = decl.scopeLabel || \"\";\n    const name = decl.name || \"\";\n    const file = decl.file || \"\";\n    const line = decl.lineStart || \"\";\n    return `${objectType}|${scopeLabel}|${name}|${file}|${line}`;\n  }\n\n  function attachPerformOriginDecls({ allObjects, formsByNameUpper }) {\n    const formParamSections = new Set([\"USING\", \"CHANGING\", \"TABLES\"]);\n\n    const forms = Array.from(formsByNameUpper.values())\n      .filter((obj) => obj && obj.id && obj.extras && obj.extras.form && Array.isArray(obj.extras.form.params));\n\n    const formParamsByFormId = new Map();\n    const originsByFormIdAndParamUpper = new Map();\n\n    for (const form of forms) {\n      const params = form.extras.form.params.filter((param) => param && formParamSections.has(param.section));\n      const byNameUpper = new Map(params.map((param) => [param.name.toUpperCase(), param]));\n      const bySection = { USING: [], CHANGING: [], TABLES: [] };\n      for (const param of params) {\n        bySection[param.section].push(param);\n      }\n\n      formParamsByFormId.set(form.id, { form, byNameUpper, bySection });\n\n      const originByParam = new Map();\n      for (const param of params) {\n        originByParam.set(param.name.toUpperCase(), new Map());\n      }\n      originsByFormIdAndParamUpper.set(form.id, originByParam);\n    }\n\n    const performCalls = (allObjects || []).filter(\n      (obj) => obj && obj.objectType === \"PERFORM\" && obj.extras && obj.extras.performCall\n    );\n\n    function getOriginsForFormParamDecl(decl) {\n      if (!decl || decl.objectType !== \"FORM_PARAM\" || !decl.id || !decl.name) {\n        return new Map();\n      }\n      const byParam = originsByFormIdAndParamUpper.get(decl.id);\n      if (!byParam) {\n        return new Map();\n      }\n      return byParam.get(decl.name.toUpperCase()) || new Map();\n    }\n\n    function originsFromValueDecl(valueDecl) {\n      if (!valueDecl) {\n        return new Map();\n      }\n      if (valueDecl.objectType === \"FORM_PARAM\") {\n        return new Map(getOriginsForFormParamDecl(valueDecl));\n      }\n      const key = declIdentityKey(valueDecl);\n      return key ? new Map([[key, valueDecl]]) : new Map();\n    }\n\n    function unionInto(target, source) {\n      if (!target || !source) {\n        return false;\n      }\n      let changed = false;\n      for (const [key, decl] of source.entries()) {\n        if (!target.has(key)) {\n          target.set(key, decl);\n          changed = true;\n        }\n      }\n      return changed;\n    }\n\n    const maxIterations = 50;\n    for (let iter = 0; iter < maxIterations; iter += 1) {\n      let changed = false;\n\n      for (const callObj of performCalls) {\n        const call = callObj.extras.performCall;\n        const formNameUpper = String(call.form || \"\").toUpperCase();\n        if (!formNameUpper) {\n          continue;\n        }\n\n        const calleeForm = formsByNameUpper.get(formNameUpper);\n        if (!calleeForm || !calleeForm.id) {\n          continue;\n        }\n\n        const calleeInfo = formParamsByFormId.get(calleeForm.id);\n        if (!calleeInfo) {\n          continue;\n        }\n\n        const calleeOrigins = originsByFormIdAndParamUpper.get(calleeForm.id);\n        if (!calleeOrigins) {\n          continue;\n        }\n\n        for (const section of [\"USING\", \"CHANGING\", \"TABLES\"]) {\n          const formalParams = calleeInfo.bySection[section] || [];\n          const actualArgs = Array.isArray(call[section.toLowerCase()]) ? call[section.toLowerCase()] : [];\n          const max = Math.min(formalParams.length, actualArgs.length);\n\n          for (let index = 0; index < max; index += 1) {\n            const formal = formalParams[index];\n            const actual = actualArgs[index];\n            if (!formal || !formal.name || !actual) {\n              continue;\n            }\n\n            const target = calleeOrigins.get(formal.name.toUpperCase());\n            if (!target) {\n              continue;\n            }\n\n            const sourceOrigins = originsFromValueDecl(actual.valueDecl);\n            if (unionInto(target, sourceOrigins)) {\n              changed = true;\n            }\n          }\n        }\n      }\n\n      if (!changed) {\n        break;\n      }\n    }\n\n    for (const form of forms) {\n      const originByParam = originsByFormIdAndParamUpper.get(form.id);\n      if (!originByParam) {\n        continue;\n      }\n\n      for (const param of form.extras.form.params) {\n        if (!param || !param.name || !formParamSections.has(param.section)) {\n          continue;\n        }\n        const originMap = originByParam.get(param.name.toUpperCase());\n        param.originDecls = originMap ? Array.from(originMap.values()) : [];\n      }\n    }\n\n    for (const callObj of performCalls) {\n      const call = callObj.extras.performCall;\n      for (const sectionName of [\"using\", \"changing\", \"tables\"]) {\n        const list = Array.isArray(call[sectionName]) ? call[sectionName] : [];\n        for (const entry of list) {\n          entry.originDecls = Array.from(originsFromValueDecl(entry.valueDecl).values());\n        }\n      }\n    }\n\n    for (const obj of allObjects || []) {\n      if (!obj || !obj.extras) {\n        continue;\n      }\n\n      if (obj.extras.callFunction) {\n        for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"tables\", \"exceptions\"]) {\n          const list = Array.isArray(obj.extras.callFunction[sectionName]) ? obj.extras.callFunction[sectionName] : [];\n          for (const entry of list) {\n            entry.originDecls = Array.from(originsFromValueDecl(entry.valueDecl).values());\n          }\n        }\n      }\n\n      if (obj.extras.callMethod) {\n        for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"receiving\", \"exceptions\"]) {\n          const list = Array.isArray(obj.extras.callMethod[sectionName]) ? obj.extras.callMethod[sectionName] : [];\n          for (const entry of list) {\n            entry.originDecls = Array.from(originsFromValueDecl(entry.valueDecl).values());\n          }\n        }\n      }\n    }\n  }\n\n  function extractInlineDeclarations(raw) {\n    const text = String(raw || \"\");\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
