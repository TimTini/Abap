"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/09-public-api.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    return parts;\n  }\n\n  function escapeRegExp(text) {\n    return String(text).replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  }\n\n  function tokenize(statementRaw) {\n    const trimmed = statementRaw.trim();\n    if (!trimmed) {\n      return [];\n    }\n\n    const withoutDot = trimmed.replace(/\\.$/, \"\").trim();\n    const tokens = [];\n    let index = 0;\n\n    while (index < withoutDot.length) {\n      const char = withoutDot[index];\n\n      if (/\\s/.test(char)) {\n        index += 1;\n        continue;\n      }\n\n      if (char === \"'\" || char === \"|\") {\n        const quoteChar = char;\n        let end = index + 1;\n        while (end < withoutDot.length) {\n          const current = withoutDot[end];\n          const next = end + 1 < withoutDot.length ? withoutDot[end + 1] : \"\";\n          if (current === quoteChar) {\n            if ((quoteChar === \"'\" || quoteChar === \"|\") && next === quoteChar) {\n              end += 2;\n              continue;\n            }\n            end += 1;\n            break;\n          }\n          end += 1;\n        }\n        const token = withoutDot.slice(index, end);\n        tokens.push(token);\n        index = end;\n        continue;\n      }\n\n      let end = index + 1;\n      while (end < withoutDot.length && !/\\s/.test(withoutDot[end])) {\n        end += 1;\n      }\n      const token = withoutDot.slice(index, end);\n      tokens.push(token);\n      index = end;\n    }\n\n    return tokens\n      .map((token) => token.replace(/[,:\\u00A0]+$/, \"\"))\n      .filter(Boolean)\n      .map((token) => ({\n        raw: token,\n        upper: token.toUpperCase()\n      }));\n  }\n\n  function detectKeywords(tokens, config) {\n    const keywords = [];\n    const phraseEntries = buildPhraseEntries(config.keywordPhrases);\n\n    for (let i = 0; i < tokens.length; i += 1) {\n      const match = matchPhraseAt(tokens, i, phraseEntries);\n      if (match) {\n        const phraseText = tokens\n          .slice(i, i + match.length)\n          .map((token) => token.raw)\n          .join(\" \");\n\n        keywords.push({ text: phraseText, label: match.label });\n        i += match.length - 1;\n        continue;\n      }\n\n      const label = config.keywordLabels[tokens[i].upper];\n      if (label) {\n        keywords.push({ text: tokens[i].raw, label });\n      }\n    }\n\n    return keywords;\n  }\n\n  function buildPhraseEntries(phraseMap) {\n    return Object.entries(phraseMap || {})\n      .map(([phrase, label]) => ({\n        phrase,\n        label,\n        tokens: phrase.split(/\\s+/)\n      }))\n      .sort((a, b) => b.tokens.length - a.tokens.length);\n  }\n\n  function matchPhraseAt(tokens, index, phraseEntries) {\n    for (const entry of phraseEntries) {\n      if (index + entry.tokens.length > tokens.length) {\n        continue;\n      }\n\n      let matches = true;\n      for (let offset = 0; offset < entry.tokens.length; offset += 1) {\n        if (tokens[index + offset].upper !== entry.tokens[offset]) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (matches) {\n        return {\n          phrase: entry.phrase,\n          label: entry.label,\n          length: entry.tokens.length\n        };\n      }\n    }\n\n    return null;\n  }\n\n  function captureValues(tokens, config, commentText) {\n    const values = [];\n    const descMap = config.valueDescriptions || {};\n    const rules = (config.captureRules || []).filter(\n      (rule) => rule.afterTokens && rule.afterTokens.length\n    );\n    const statementDesc = commentText || \"\";\n\n    for (let index = 0; index < tokens.length; index += 1) {\n      let bestRule = null;\n\n      for (const rule of rules) {\n        if (!matchesTokens(tokens, index, rule.afterTokens)) {\n          continue;\n        }\n\n        if (!bestRule || rule.afterTokens.length > bestRule.afterTokens.length) {\n          bestRule = rule;\n        }\n      }\n\n      if (!bestRule) {\n        continue;\n      }\n\n      const valueIndex = index + bestRule.afterTokens.length;\n      if (valueIndex < tokens.length) {\n        const captured = captureValue(tokens, valueIndex, bestRule);\n        const userDesc = resolveUserDesc(descMap, bestRule.descKey, captured.upper);\n\n        values.push({\n          name: bestRule.name,\n          value: captured.raw,\n          label: bestRule.label || bestRule.name,\n          userDesc: userDesc || \"\",\n          codeDesc: statementDesc\n        });\n      }\n\n      index += bestRule.afterTokens.length - 1;\n    }\n\n    return values;\n  }\n\n  function captureAssignmentValues(tokens, commentText) {\n    if (!Array.isArray(tokens) || tokens.length < 3) {\n      return [];\n    }\n\n    const statementDesc = commentText || \"\";\n    const target = tokens[0] ? tokens[0].raw : \"\";\n    const op = tokens[1] ? tokens[1].raw : \"\";\n    const expr = tokens\n      .slice(2)\n      .map((t) => t.raw)\n      .join(\" \")\n      .trim();\n\n    return [\n      { name: \"target\", value: target, label: \"target\", userDesc: \"\", codeDesc: statementDesc },\n      { name: \"op\", value: op, label: \"op\", userDesc: \"\", codeDesc: statementDesc },\n      { name: \"expr\", value: expr, label: \"expr\", userDesc: \"\", codeDesc: statementDesc }\n    ];\n  }\n\n  function captureMethodCallExpressionValues(raw, commentText) {\n    const parsed = parseMethodCallExpressionFromRaw(raw);\n    if (!parsed) {\n      return [];\n    }\n\n    const statementDesc = commentText || \"\";\n    const values = [];\n    const addEntry = (name, value, label) => {\n      const text = String(value || \"\").trim();\n      if (!text) {\n        return;\n      }\n      values.push({\n        name,\n        value: text,\n        label: label || name,\n        userDesc: \"\",\n        codeDesc: statementDesc\n      });\n    };\n\n    addEntry(\"target\", parsed.callTarget, \"target\");\n\n    if (parsed.receivingTarget && !parsed.sectionRawByName.receivingRaw) {\n      addEntry(\"receivingRaw\", `result = ${parsed.receivingTarget}`, \"receiving\");\n    }\n\n    for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"receiving\", \"exceptions\"]) {\n      const rawKey = `${sectionName}Raw`;\n      addEntry(rawKey, parsed.sectionRawByName[rawKey], sectionName);\n    }\n\n    return values;\n  }\n\n  function parseMethodCallExpressionFromRaw(raw) {\n    const textRaw = String(raw || \"\").trim();\n    if (!textRaw) {\n      return null;\n    }\n\n    const text = textRaw.endsWith(\".\")\n      ? textRaw.slice(0, -1).trim()\n      : textRaw;\n\n    if (!text || /^CALL\\s+METHOD\\b/i.test(text)) {\n      return null;\n    }\n\n    let receivingTarget = \"\";\n    let callExpr = text;\n\n    const assignmentMatch = text.match(\n      /^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*(?:-[A-Za-z_][A-Za-z0-9_]*)*)\\s*=\\s*(.+)$/i\n    );\n    if (assignmentMatch) {\n      receivingTarget = assignmentMatch[1].trim();\n      callExpr = assignmentMatch[2].trim();\n    }\n\n    const targetMatch = callExpr.match(\n      /^((?:<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(?:->|=>)(?:[A-Za-z_][A-Za-z0-9_]*~)?[A-Za-z_][A-Za-z0-9_]*)\\s*\\(/i\n    );\n    if (!targetMatch) {\n      return null;\n    }\n\n    const callTarget = targetMatch[1].trim();\n    const openIndex = callExpr.indexOf(\"(\");\n    const closeIndex = callExpr.lastIndexOf(\")\");\n    if (openIndex < 0 || closeIndex <= openIndex || closeIndex !== callExpr.length - 1) {\n      return null;\n    }\n    const argsRaw = callExpr.slice(openIndex + 1, closeIndex).trim();\n\n    return {\n      receivingTarget,\n      callExpr,\n      callTarget,\n      argsRaw,\n      sectionRawByName: parseMethodCallExpressionSectionRaw(argsRaw)\n    };\n  }\n\n  function parseMethodCallExpressionSectionRaw(argsRaw) {\n    const output = {\n      exportingRaw: \"\",\n      importingRaw: \"\",\n      changingRaw: \"\",\n      receivingRaw: \"\",\n      exceptionsRaw: \"\"\n    };\n\n    const trimmed = String(argsRaw || \"\").trim();\n    if (!trimmed) {\n      return output;\n    }\n\n    const tokens = tokenize(`${trimmed}.`);\n    if (!tokens.length) {\n      return output;\n    }\n\n    const sectionByUpper = {\n      EXPORTING: \"exportingRaw\",\n      IMPORTING: \"importingRaw\",\n      CHANGING: \"changingRaw\",\n      RECEIVING: \"receivingRaw\",\n      EXCEPTIONS: \"exceptionsRaw\"\n    };\n    const sectionSet = new Set(Object.keys(sectionByUpper));\n    const markers = [];\n    for (let index = 0; index < tokens.length; index += 1) {\n      if (sectionSet.has(tokens[index].upper)) {\n        markers.push({ sectionUpper: tokens[index].upper, startIndex: index });\n      }\n    }\n\n    if (!markers.length) {\n      output.exportingRaw = trimmed;\n      return output;\n    }\n\n    for (let index = 0; index < markers.length; index += 1) {\n      const marker = markers[index];\n      const next = markers[index + 1];\n      const segmentStart = marker.startIndex + 1;\n      const segmentEnd = next ? next.startIndex : tokens.length;\n      const segmentRaw = tokens\n        .slice(segmentStart, segmentEnd)\n        .map((token) => token.raw)\n        .join(\" \")\n        .trim();\n      const key = sectionByUpper[marker.sectionUpper];\n      if (!key || !segmentRaw) {\n        continue;\n      }\n      output[key] = output[key]\n        ? `${output[key]} ${segmentRaw}`\n        : segmentRaw;\n    }\n\n    return output;\n  }\n\n  function captureValue(tokens, startIndex, rule) {\n    if (rule.capture === \"rest\") {\n      const stopTokens = rule.stopTokensUpper || [];\n      const parts = [];\n      for (let i = startIndex; i < tokens.length; i += 1) {\n        if (stopTokens.length && stopTokens.includes(tokens[i].upper)) {\n          break;\n        }\n        parts.push(tokens[i].raw);\n      }\n      const raw = parts.join(\" \").trim();\n      return { raw, upper: raw.toUpperCase() };\n    }\n\n    const token = tokens[startIndex];\n    return token ? { raw: token.raw, upper: token.upper } : { raw: \"\", upper: \"\" };\n  }\n\n  function matchesTokens(tokens, startIndex, expectedTokens) {\n    if (startIndex + expectedTokens.length > tokens.length) {\n      return false;\n    }\n\n    for (let offset = 0; offset < expectedTokens.length; offset += 1) {\n      if (tokens[startIndex + offset].upper !== expectedTokens[offset]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function resolveUserDesc(descMap, descKey, valueUpper) {\n    if (!descKey) {\n      return \"\";\n    }\n\n    const map = descMap[descKey];\n    if (!map) {\n      return \"\";\n    }\n\n    return map[valueUpper] || \"\";\n  }\n\n  return {\n    AbapObject,\n    normalizeConfig,\n    registerConfig,\n    getConfigs,\n    parseAbapText\n  };\n});\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
