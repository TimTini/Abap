"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/05-render-values.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "        originDecls: origins,\n        valueRef: \"\"\n      });\n    });\n  }\n\n  function buildParsedRowsFromExceptions(sectionName, list, baseEntry) {\n    const items = Array.isArray(list) ? list : [];\n    return items.map((item, index) => {\n      const name = item && item.name ? String(item.name) : \"\";\n      return makeParsedValueRow({\n        sectionName,\n        indexOneBased: index + 1,\n        valueText: name,\n        baseEntry,\n        decl: baseEntry && baseEntry.decl ? baseEntry.decl : null,\n        valueDecl: null,\n        originDecls: item && Array.isArray(item.originDecls) ? item.originDecls : [],\n        valueRef: \"\"\n      });\n    });\n  }\n\n  function buildParsedRowsForRawEntry(obj, baseEntry) {\n    if (!obj || !baseEntry) {\n      return [];\n    }\n\n    const extras = obj.extras && typeof obj.extras === \"object\" ? obj.extras : null;\n    if (!extras) {\n      return [];\n    }\n\n    const rawName = baseEntry.name ? String(baseEntry.name).trim().toLowerCase() : \"\";\n    if (!rawName) {\n      return [];\n    }\n\n    if (extras.performCall) {\n      const sectionMap = {\n        usingraw: \"using\",\n        changingraw: \"changing\",\n        tablesraw: \"tables\"\n      };\n      const sectionName = sectionMap[rawName];\n      if (sectionName) {\n        return buildParsedRowsFromPerformList(sectionName, extras.performCall[sectionName], baseEntry);\n      }\n    }\n\n    if (extras.callFunction) {\n      const sectionMap = {\n        exportingraw: \"exporting\",\n        importingraw: \"importing\",\n        changingraw: \"changing\",\n        tablesraw: \"tables\",\n        exceptionsraw: \"exceptions\"\n      };\n      const sectionName = sectionMap[rawName];\n      if (sectionName) {\n        return buildParsedRowsFromAssignments(sectionName, extras.callFunction[sectionName], baseEntry);\n      }\n    }\n\n    if (extras.callMethod) {\n      const sectionMap = {\n        exportingraw: \"exporting\",\n        importingraw: \"importing\",\n        changingraw: \"changing\",\n        receivingraw: \"receiving\",\n        exceptionsraw: \"exceptions\"\n      };\n      const sectionName = sectionMap[rawName];\n      if (sectionName) {\n        return buildParsedRowsFromAssignments(sectionName, extras.callMethod[sectionName], baseEntry);\n      }\n    }\n\n    if (extras.form) {\n      const paramsByRawName = {\n        usingraw: \"USING\",\n        changingraw: \"CHANGING\",\n        tablesraw: \"TABLES\"\n      };\n      if (Object.prototype.hasOwnProperty.call(paramsByRawName, rawName)) {\n        const sectionUpper = paramsByRawName[rawName];\n        const params = Array.isArray(extras.form.params)\n          ? extras.form.params.filter((param) => String(param && param.section ? param.section : \"\").toUpperCase() === sectionUpper)\n          : [];\n        return buildParsedRowsFromParams(sectionUpper.toLowerCase(), params, baseEntry);\n      }\n      if (rawName === \"raisingraw\") {\n        return buildParsedRowsFromExceptions(\"raising\", extras.form.exceptions, baseEntry);\n      }\n    }\n\n    if (extras.methodSignature) {\n      const paramsByRawName = {\n        importingraw: \"IMPORTING\",\n        exportingraw: \"EXPORTING\",\n        changingraw: \"CHANGING\",\n        returningraw: \"RETURNING\"\n      };\n      if (Object.prototype.hasOwnProperty.call(paramsByRawName, rawName)) {\n        const sectionUpper = paramsByRawName[rawName];\n        const params = Array.isArray(extras.methodSignature.params)\n          ? extras.methodSignature.params.filter((param) => String(param && param.section ? param.section : \"\").toUpperCase() === sectionUpper)\n          : [];\n        return buildParsedRowsFromParams(sectionUpper.toLowerCase(), params, baseEntry);\n      }\n      if (rawName === \"raisingraw\") {\n        return buildParsedRowsFromExceptions(\"raising\", extras.methodSignature.exceptions, baseEntry);\n      }\n    }\n\n    return [];\n  }\n\n  function cloneValueEntryForOutput(entry) {\n    if (!entry || typeof entry !== \"object\") {\n      return entry;\n    }\n    const out = { ...entry };\n    if (Array.isArray(entry.originDecls)) {\n      out.originDecls = entry.originDecls.slice();\n    }\n    return out;\n  }\n\n  function ensureEntryDeclForOutput(obj, entry) {\n    if (!entry || typeof entry !== \"object\") {\n      return entry;\n    }\n    const source = getDeclSourceContextFromObject(obj);\n    const entryName = String(entry.name || \"value\").trim() || \"value\";\n    return ensureEntryDeclWithSynthetic(entry, {\n      pathKey: buildPathKeyFromParts([buildObjectPathBase(obj), \"values\", entryName]),\n      file: source.file,\n      lineStart: source.lineStart,\n      raw: source.raw,\n      role: \"value\"\n    });\n  }\n\n  function buildRenderableValueEntries(obj) {\n    const values = getValueEntries(obj);\n    if (!values.length) {\n      return [];\n    }\n\n    const rows = [];\n    for (const entry of values) {\n      const rawRow = cloneValueEntryForOutput(entry);\n      if (!isRawValueEntry(entry)) {\n        rows.push(ensureEntryDeclForOutput(obj, rawRow));\n        continue;\n      }\n\n      const parsedRows = buildParsedRowsForRawEntry(obj, entry);\n      if (parsedRows.length) {\n        for (const parsedRow of parsedRows) {\n          rows.push(ensureEntryDeclForOutput(obj, cloneValueEntryForOutput(parsedRow)));\n        }\n      } else {\n        rows.push(ensureEntryDeclForOutput(obj, rawRow));\n      }\n    }\n\n    return rows;\n  }\n\n  function renderValues(obj) {\n    const values = buildRenderableValueEntries(obj);\n    if (!values.length) {\n      return null;\n    }\n\n    const table = el(\"table\");\n    const thead = el(\"thead\");\n    const headRow = el(\"tr\");\n    for (const name of [\"name\", \"value\", \"label\", \"codeDesc\", \"declName\", \"declDesc\"]) {\n      headRow.appendChild(el(\"th\", { text: name }));\n    }\n    thead.appendChild(headRow);\n    table.appendChild(thead);\n\n    const tbody = el(\"tbody\");\n    for (const entry of values) {\n      const row = el(\"tr\");\n      const relatedDecls = collectDeclsForValueEntry(obj, entry);\n      const declListCells = renderDeclListCells(\n        relatedDecls.length ? relatedDecls : null,\n        relatedDecls.length ? null : entry && entry.decl\n      );\n      row.appendChild(el(\"td\", { text: entry && entry.name ? String(entry.name) : \"\" }));\n      row.appendChild(el(\"td\", { text: entry && entry.value ? String(entry.value) : \"\" }));\n      row.appendChild(el(\"td\", { text: entry && entry.label ? String(entry.label) : \"\" }));\n      row.appendChild(el(\"td\", { text: entry && entry.codeDesc ? String(entry.codeDesc) : \"\" }));\n      row.appendChild(declListCells.nameCell);\n      row.appendChild(declListCells.descCell);\n      tbody.appendChild(row);\n    }\n    table.appendChild(tbody);\n    return table;\n  }\n\n  function buildExtrasEntryPathKey(obj, extrasScope, sectionName, indexOneBased, itemKind) {\n    return buildPathKeyFromParts([\n      buildObjectPathBase(obj),\n      \"extras\",\n      extrasScope || \"extras\",\n      sectionName || \"section\",\n      `${itemKind || \"item\"}[${indexOneBased}]`\n    ]);\n  }\n\n  function normalizeExtrasEntryForOutput(obj, extrasScope, sectionName, indexOneBased, entry) {\n    if (!entry || typeof entry !== \"object\") {\n      return entry;\n    }\n\n    const source = getDeclSourceContextFromObject(obj);\n    const basePath = buildExtrasEntryPathKey(obj, extrasScope, sectionName, indexOneBased, \"item\");\n    let next = cloneValueEntryForOutput(entry);\n    next = ensureEntryDeclWithSynthetic(next, {\n      pathKey: basePath,\n      file: source.file,\n      lineStart: source.lineStart,\n      raw: source.raw,\n      role: `${extrasScope || \"extras\"}:${sectionName || \"entry\"}`\n    });\n    next = ensureValueDeclWithSynthetic(next, {\n      pathKey: basePath,\n      file: source.file,\n      lineStart: source.lineStart,\n      raw: source.raw,\n      role: `${extrasScope || \"extras\"}:${sectionName || \"entry\"}:value`,\n      nameHint: sectionName || \"value\"\n    });\n    return next;\n  }\n\n  function renderAssignmentTable(title, list, context) {\n    const items = Array.isArray(list) ? list : [];\n    if (!items.length) {\n      return null;\n    }\n\n    const obj = context && context.obj ? context.obj : null;\n    const extrasScope = context && context.extrasScope ? String(context.extrasScope) : \"extras\";\n\n    const section = el(\"div\");\n    section.appendChild(el(\"div\", { className: \"muted\", text: title }));\n\n    const table = el(\"table\");\n    const thead = el(\"thead\");\n    const headRow = el(\"tr\");\n    for (const key of [\"name\", \"value\", \"ref\", \"declName\", \"declDesc\"]) {\n      headRow.appendChild(el(\"th\", { text: key }));\n    }\n    thead.appendChild(headRow);\n    table.appendChild(thead);\n\n    const tbody = el(\"tbody\");\n    for (let index = 0; index < items.length; index += 1) {\n      const entry = items[index];\n      const normalizedEntry = normalizeExtrasEntryForOutput(obj, extrasScope, title, index + 1, entry);\n      const row = el(\"tr\");\n      row.appendChild(el(\"td\", { text: normalizedEntry && normalizedEntry.name ? String(normalizedEntry.name) : \"\" }));\n      row.appendChild(el(\"td\", { text: normalizedEntry && normalizedEntry.value ? String(normalizedEntry.value) : \"\" }));\n      row.appendChild(el(\"td\", { text: normalizedEntry && normalizedEntry.valueRef ? String(normalizedEntry.valueRef) : \"\" }));\n      const { nameCell, descCell } = renderDeclListCells(\n        normalizedEntry && normalizedEntry.originDecls,\n        normalizedEntry && normalizedEntry.valueDecl\n      );\n      row.appendChild(nameCell);\n      row.appendChild(descCell);\n      tbody.appendChild(row);\n    }\n    table.appendChild(tbody);\n    section.appendChild(table);\n    return section;\n  }\n\n  function renderValueListTable(title, list, context) {\n    const items = Array.isArray(list) ? list : [];\n    if (!items.length) {\n      return null;\n    }\n\n    const obj = context && context.obj ? context.obj : null;\n    const extrasScope = context && context.extrasScope ? String(context.extrasScope) : \"extras\";\n\n    const section = el(\"div\");\n    section.appendChild(el(\"div\", { className: \"muted\", text: title }));\n\n    const table = el(\"table\");\n    const thead = el(\"thead\");\n    const headRow = el(\"tr\");\n    for (const key of [\"value\", \"ref\", \"declName\", \"declDesc\"]) {\n      headRow.appendChild(el(\"th\", { text: key }));\n    }\n    thead.appendChild(headRow);\n    table.appendChild(thead);\n\n    const tbody = el(\"tbody\");\n    for (let index = 0; index < items.length; index += 1) {\n      const entry = items[index];\n      const normalizedEntry = normalizeExtrasEntryForOutput(obj, extrasScope, title, index + 1, entry);\n      const row = el(\"tr\");\n      row.appendChild(el(\"td\", { text: normalizedEntry && normalizedEntry.value ? String(normalizedEntry.value) : \"\" }));\n      row.appendChild(el(\"td\", { text: normalizedEntry && normalizedEntry.valueRef ? String(normalizedEntry.valueRef) : \"\" }));\n      const { nameCell, descCell } = renderDeclListCells(\n        normalizedEntry && normalizedEntry.originDecls,\n        normalizedEntry && normalizedEntry.valueDecl\n      );\n      row.appendChild(nameCell);\n      row.appendChild(descCell);\n      tbody.appendChild(row);\n    }\n    table.appendChild(tbody);\n    section.appendChild(table);\n    return section;\n  }\n\n  function resolveConditionDeclForViewer(decl, refCandidate) {\n    if (decl && typeof decl === \"object\") {\n      return decl;\n    }\n\n    const ref = String(refCandidate || \"\").trim();\n    if (!ref) {\n      return null;\n    }\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
