"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/02-search-index.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "      }\n    }\n\n    if (extras.form && Array.isArray(extras.form.params)) {\n      for (const param of extras.form.params) {\n        addDeclList(param && param.originDecls);\n      }\n    }\n\n    collectConditionDeclsFromExtras(extras, addDecl);\n\n    const seen = new Set();\n    const parts = [];\n    for (const decl of decls) {\n      const key = getDeclOverrideStorageKey(decl) || stringifyDecl(decl);\n      if (!key || seen.has(key)) {\n        continue;\n      }\n      seen.add(key);\n      parts.push(String(decl.name || \"\"));\n      const desc = getEffectiveDeclDesc(decl);\n      if (desc) {\n        parts.push(desc);\n      }\n    }\n\n    return parts.filter(Boolean).join(\"\\n\");\n  }\n\n  function buildSearchIndex(objects) {\n    const map = new Map();\n    walkObjects(objects, (obj) => {\n      const id = normalizeId(obj && obj.id);\n      if (!id) {\n        return;\n      }\n\n      const keywordEntries = getKeywordEntries(obj);\n      const keywordsText = keywordEntries.length\n        ? keywordEntries.map((k) => `${k.text || \"\"} ${k.label || \"\"}`.trim()).join(\"\\n\")\n        : \"\";\n\n      const valueEntries = getValueEntries(obj);\n      const valuesText = valueEntries.length\n        ? valueEntries\n            .map((v) => {\n              const declText = stringifyDecl(v && v.decl);\n              const declDesc = getEffectiveDeclDesc(v && v.decl);\n              return [\n                v && v.name ? String(v.name) : \"\",\n                v && v.value ? String(v.value) : \"\",\n                v && v.label ? String(v.label) : \"\",\n                v && v.codeDesc ? String(v.codeDesc) : \"\",\n                v && v.declRef ? String(v.declRef) : \"\",\n                declText,\n                declDesc\n              ]\n                .filter(Boolean)\n                .join(\" \");\n            })\n            .join(\"\\n\")\n        : \"\";\n\n      const extrasText = obj.extras && typeof obj.extras === \"object\" ? safeJson(obj.extras, false) : \"\";\n      const extrasDeclText = collectDeclSearchTextFromExtras(obj.extras);\n\n      const haystack = [\n        obj.objectType || \"\",\n        obj.raw || \"\",\n        obj.comment || \"\",\n        keywordsText,\n        valuesText,\n        extrasText,\n        extrasDeclText\n      ]\n        .filter(Boolean)\n        .join(\"\\n\")\n        .toLowerCase();\n\n      map.set(id, haystack);\n    });\n    return map;\n  }\n\n  function computeLineOffsets(text) {\n    const value = String(text || \"\");\n    const offsets = [0];\n    for (let i = 0; i < value.length; i += 1) {\n      if (value[i] === \"\\n\") {\n        offsets.push(i + 1);\n      }\n    }\n    return offsets;\n  }\n\n  function getSelectionRangeForLines(text, lineStart, lineEnd) {\n    const value = String(text || \"\");\n    const offsets = state.inputLineOffsets.length ? state.inputLineOffsets : computeLineOffsets(value);\n    const start = Math.max(1, Number(lineStart) || 1);\n    const end = Math.max(start, Number(lineEnd) || start);\n    const startLineIndex = start - 1;\n    const endLineIndex = end - 1;\n    const startOffset = offsets[startLineIndex] ?? 0;\n    const endOffset = offsets[endLineIndex + 1] ?? value.length;\n    return { start: startOffset, end: Math.max(startOffset, endOffset) };\n  }\n\n  function selectCodeLines(lineStart, lineEnd) {\n    const text = els.inputText.value || \"\";\n    state.inputLineOffsets = computeLineOffsets(text);\n    const range = getSelectionRangeForLines(text, lineStart, lineEnd);\n    els.inputText.focus();\n    els.inputText.setSelectionRange(range.start, range.end);\n    syncInputGutterScroll();\n  }\n\n  function scrollElementInContainer(container, element, options) {\n    if (!container || !element || typeof container.scrollTop !== \"number\") {\n      return;\n    }\n\n    const opts = options && typeof options === \"object\" ? options : {};\n    const mode = String(opts.mode || \"nearest\").toLowerCase();\n    const padTop = Math.max(0, Number(opts.padTop) || 0);\n    const padBottom = Math.max(0, Number(opts.padBottom) || 0);\n    const behavior = opts.behavior === \"smooth\" ? \"smooth\" : \"auto\";\n\n    const containerRect = container.getBoundingClientRect();\n    const elementRect = element.getBoundingClientRect();\n    if (!containerRect || !elementRect || !Number.isFinite(containerRect.top) || !Number.isFinite(elementRect.top)) {\n      return;\n    }\n\n    const currentTop = Number(container.scrollTop || 0) || 0;\n    let nextTop = currentTop;\n\n    if (mode === \"start\") {\n      nextTop = currentTop + (elementRect.top - containerRect.top) - padTop;\n    } else if (mode === \"center\") {\n      nextTop = currentTop\n        + (elementRect.top + (elementRect.height / 2))\n        - (containerRect.top + (containerRect.height / 2));\n    } else {\n      const topLimit = containerRect.top + padTop;\n      const bottomLimit = containerRect.bottom - padBottom;\n      if (elementRect.top < topLimit) {\n        nextTop = currentTop + (elementRect.top - topLimit);\n      } else if (elementRect.bottom > bottomLimit) {\n        nextTop = currentTop + (elementRect.bottom - bottomLimit);\n      } else {\n        return;\n      }\n    }\n\n    const maxTop = Math.max(0, Number(container.scrollHeight || 0) - Number(container.clientHeight || 0));\n    const clampedTop = Math.max(0, Math.min(maxTop, Math.round(nextTop)));\n    if (Math.abs(clampedTop - currentTop) < 1) {\n      return;\n    }\n\n    if (typeof container.scrollTo === \"function\") {\n      container.scrollTo({ top: clampedTop, behavior });\n    } else {\n      container.scrollTop = clampedTop;\n    }\n  }\n\n  function setSelectedCard(id, options) {\n    const normalized = normalizeId(id);\n    if (!normalized) {\n      return;\n    }\n    const opts = options && typeof options === \"object\" ? options : {};\n    const shouldScroll = opts.scroll !== false;\n    const scrollMode = String(opts.scrollMode || \"start\").toLowerCase();\n\n    if (state.selectedId) {\n      const prev = els.output.querySelector(`[data-id=\"${escapeSelectorValue(state.selectedId)}\"]`);\n      if (prev) {\n        prev.classList.remove(\"selected\");\n      }\n    }\n\n    state.selectedId = normalized;\n    const next = els.output.querySelector(`[data-id=\"${escapeSelectorValue(normalized)}\"]`);\n    if (next) {\n      next.classList.add(\"selected\");\n      if (shouldScroll) {\n        scrollElementInContainer(els.output, next, { mode: scrollMode, padTop: 10, padBottom: 10 });\n      }\n    }\n  }\n\n  function setSelectedTemplateBlock(index, options) {\n    if (!els.templatePreviewOutput) {\n      return;\n    }\n\n    const opts = options && typeof options === \"object\" ? options : {};\n    const shouldScroll = opts.scroll !== false;\n    const scrollMode = String(opts.scrollMode || \"start\").toLowerCase();\n    const normalized = String(index === undefined || index === null ? \"\" : index).trim();\n    if (!normalized) {\n      return;\n    }\n\n    if (state.selectedTemplateIndex !== \"\") {\n      const prev = els.templatePreviewOutput.querySelector(\n        `.template-block[data-template-index=\"${escapeSelectorValue(state.selectedTemplateIndex)}\"]`\n      );\n      if (prev) {\n        prev.classList.remove(\"selected\");\n      }\n    }\n\n    state.selectedTemplateIndex = normalized;\n    const next = els.templatePreviewOutput.querySelector(\n      `.template-block[data-template-index=\"${escapeSelectorValue(normalized)}\"]`\n    );\n    if (next) {\n      next.classList.add(\"selected\");\n      if (shouldScroll) {\n        scrollElementInContainer(els.templatePreviewOutput, next, { mode: scrollMode, padTop: 10, padBottom: 10 });\n      }\n    }\n  }\n\n  function setSelectedDeclRow(declKey) {\n    const key = String(declKey || \"\").trim();\n    if (!key || !els.declDescTable) {\n      return;\n    }\n\n    if (state.selectedDeclKey) {\n      const prev = els.declDescTable.querySelector(`tr[data-decl-key=\"${escapeSelectorValue(state.selectedDeclKey)}\"]`);\n      if (prev) {\n        prev.classList.remove(\"desc-selected\");\n      }\n    }\n\n    state.selectedDeclKey = key;\n    const next = els.declDescTable.querySelector(`tr[data-decl-key=\"${escapeSelectorValue(key)}\"]`);\n    if (next) {\n      next.classList.add(\"desc-selected\");\n      scrollElementInContainer(els.declDescPanel, next, { mode: \"nearest\", padTop: 8, padBottom: 8 });\n    }\n  }\n\n  function countInputLines(value) {\n    const text = String(value || \"\");\n    if (!text) {\n      return 1;\n    }\n    return text.split(\"\\n\").length;\n  }\n\n  function syncInputGutterScroll() {\n    if (!els.inputText || !els.inputGutterContent) {\n      return;\n    }\n\n    const scrollTop = Number(els.inputText.scrollTop || 0) || 0;\n    els.inputGutterContent.style.transform = `translateY(${-scrollTop}px)`;\n  }\n\n  function rebuildInputGutter() {\n    if (!els.inputText || !els.inputGutterContent) {\n      return;\n    }\n\n    const trimmed = String(els.inputText.value || \"\").trim();\n    const isJsonLike = (trimmed.startsWith(\"{\") || trimmed.startsWith(\"[\")) && trimmed.length > 1;\n    state.inputMode = isJsonLike ? \"json\" : \"abap\";\n\n    const lineCount = Math.max(1, countInputLines(els.inputText.value || \"\"));\n    if (lineCount === state.inputLineCount && state.inputGutterButtonsByLine.size) {\n      syncInputGutterScroll();\n      refreshInputGutterTargets();\n      return;\n    }\n\n    state.inputLineCount = lineCount;\n    state.inputGutterButtonsByLine = new Map();\n\n    const frag = document.createDocumentFragment();\n    for (let line = 1; line <= lineCount; line += 1) {\n      const row = document.createElement(\"div\");\n      row.className = \"gutter-line\";\n\n      const btn = document.createElement(\"button\");\n      btn.type = \"button\";\n      btn.className = \"gutter-jump\";\n      btn.textContent = \"â†ª\";\n      btn.hidden = true;\n      btn.setAttribute(\"data-line\", String(line));\n      row.appendChild(btn);\n\n      const num = document.createElement(\"span\");\n      num.className = \"gutter-num\";\n      num.textContent = String(line);\n      row.appendChild(num);\n\n      state.inputGutterButtonsByLine.set(line, btn);\n      frag.appendChild(row);\n    }\n\n    els.inputGutterContent.replaceChildren(frag);\n    syncInputGutterScroll();\n    refreshInputGutterTargets();\n  }\n\n  function computeInputGutterTargetsForOutput() {\n    const targets = new Map();\n    if (!els.output) {\n      return targets;\n    }\n\n    const cards = els.output.querySelectorAll(\".card[data-id][data-line-start]\");\n    for (const card of Array.from(cards)) {\n      const line = Number(card.getAttribute(\"data-line-start\")) || 0;\n      const id = String(card.getAttribute(\"data-id\") || \"\");\n      if (!line || !id || targets.has(line)) {\n        continue;\n      }\n      targets.set(line, { kind: \"output\", id });\n    }\n\n    return targets;\n  }\n\n  function computeInputGutterTargetsForDescriptions() {\n    const targets = new Map();\n    if (!els.declDescTable) {\n      return targets;\n    }\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
