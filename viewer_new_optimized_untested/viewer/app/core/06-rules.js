"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/01-core.js";
  const partKey = "viewer/app/core/06-rules.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\n  function parseCellRef(cellRef) {\n    const raw = String(cellRef || \"\").trim().toUpperCase();\n    const match = /^([A-Z]+)([1-9][0-9]*)$/.exec(raw);\n    if (!match) {\n      throw new Error(`Invalid cell ref \"${cellRef}\". Expected format like A1.`);\n    }\n\n    const letters = match[1];\n    const row = Number(match[2]) || 0;\n    let col = 0;\n    for (let i = 0; i < letters.length; i += 1) {\n      col = (col * 26) + (letters.charCodeAt(i) - 64);\n    }\n\n    if (!row || !col) {\n      throw new Error(`Invalid cell ref \"${cellRef}\".`);\n    }\n\n    return { row, col, raw };\n  }\n\n  function parseRangeKey(rangeKey) {\n    const raw = String(rangeKey || \"\").trim().toUpperCase();\n    if (!raw) {\n      throw new Error(\"Range key is empty.\");\n    }\n\n    const parts = raw.split(\":\").map((item) => item.trim()).filter(Boolean);\n    if (!parts.length || parts.length > 2) {\n      throw new Error(`Invalid range \"${rangeKey}\". Expected A1 or A1:B2.`);\n    }\n\n    const start = parseCellRef(parts[0]);\n    const end = parseCellRef(parts.length > 1 ? parts[1] : parts[0]);\n\n    return {\n      key: raw,\n      r1: Math.min(start.row, end.row),\n      c1: Math.min(start.col, end.col),\n      r2: Math.max(start.row, end.row),\n      c2: Math.max(start.col, end.col)\n    };\n  }\n\n  function isTemplateOptionConfigKey(rawKey) {\n    const key = String(rawKey || \"\").trim().toLowerCase();\n    if (!key) {\n      return false;\n    }\n    return (\n      key === \"_options\"\n      || key === \"options\"\n      || key === \"ranges\"\n      || key === \"compact\"\n      || key === \"hideemptyrows\"\n      || key === \"hiderowswithoutvalues\"\n      || key === \"expandmultilinerows\"\n      || key === \"removeemptyrows\"\n      || key === \"removeemptyrowsadvanced\"\n      || key === \"removeemptyrowsadv\"\n      || key === \"expandarrayrows\"\n      || key === \"arraytorows\"\n    );\n  }\n\n  function validateTemplateConfig(config) {\n    const errors = [];\n    if (!config || typeof config !== \"object\" || Array.isArray(config)) {\n      return { valid: false, errors: [\"Config must be a JSON object.\"] };\n    }\n\n    const version = Number(config.version);\n    if (version !== 1) {\n      errors.push(\"Config.version must be 1.\");\n    }\n\n    const templates = config.templates;\n    if (!templates || typeof templates !== \"object\" || Array.isArray(templates)) {\n      errors.push(\"Config.templates must be an object.\");\n      return { valid: false, errors };\n    }\n\n    const templateKeys = Object.keys(templates);\n    if (!templateKeys.length) {\n      errors.push(\"Config.templates must contain at least one template key.\");\n      return { valid: false, errors };\n    }\n\n    for (const templateKey of templateKeys) {\n      const templateDef = templates[templateKey];\n      if (!templateDef || typeof templateDef !== \"object\" || Array.isArray(templateDef)) {\n        errors.push(`templates.${templateKey} must be an object of range -> style.`);\n        continue;\n      }\n\n      const hasRangesObject = Object.prototype.hasOwnProperty.call(templateDef, \"ranges\");\n      const ranges = hasRangesObject ? templateDef.ranges : templateDef;\n      if (!ranges || typeof ranges !== \"object\" || Array.isArray(ranges)) {\n        errors.push(`templates.${templateKey}.ranges must be an object of range -> style.`);\n        continue;\n      }\n\n      const optionCandidates = [\"_options\", \"options\"];\n      for (const optKey of optionCandidates) {\n        if (!Object.prototype.hasOwnProperty.call(templateDef, optKey)) {\n          continue;\n        }\n        const optValue = templateDef[optKey];\n        if (!optValue || typeof optValue !== \"object\" || Array.isArray(optValue)) {\n          errors.push(`templates.${templateKey}.${optKey} must be an object.`);\n        }\n      }\n\n      for (const rangeKey of Object.keys(ranges)) {\n        if (isTemplateOptionConfigKey(rangeKey)) {\n          continue;\n        }\n        try {\n          parseRangeKey(rangeKey);\n        } catch (err) {\n          errors.push(`templates.${templateKey}.${rangeKey}: ${err && err.message ? err.message : err}`);\n        }\n\n        const cellConfig = ranges[rangeKey];\n        if (!cellConfig || typeof cellConfig !== \"object\" || Array.isArray(cellConfig)) {\n          errors.push(`templates.${templateKey}.${rangeKey} must be an object.`);\n        }\n      }\n    }\n\n    return { valid: errors.length === 0, errors };\n  }\n\n  function loadTemplateConfig() {\n    try {\n      const raw = localStorage.getItem(TEMPLATE_CONFIG_STORAGE_KEY_V1);\n      if (!raw) {\n        return getDefaultTemplateConfig();\n      }\n      const parsed = JSON.parse(raw);\n      const check = validateTemplateConfig(parsed);\n      if (!check.valid) {\n        return getDefaultTemplateConfig();\n      }\n      return parsed;\n    } catch {\n      return getDefaultTemplateConfig();\n    }\n  }\n\n  function saveTemplateConfig(config) {\n    try {\n      localStorage.setItem(TEMPLATE_CONFIG_STORAGE_KEY_V1, JSON.stringify(config || {}));\n    } catch {\n      // ignore\n    }\n  }\n\n  function normalizeTheme(value) {\n    return value === \"light\" ? \"light\" : \"dark\";\n  }\n\n  function loadTheme() {\n    try {\n      return normalizeTheme(localStorage.getItem(THEME_STORAGE_KEY_V1) || \"\");\n    } catch {\n      return \"dark\";\n    }\n  }\n\n  function applyTheme(nextTheme, { save } = {}) {\n    const normalized = normalizeTheme(nextTheme);\n    state.theme = normalized;\n    document.documentElement.setAttribute(\"data-theme\", normalized);\n\n    if (els.themeToggle) {\n      els.themeToggle.checked = normalized === \"dark\";\n    }\n\n    if (save === false) {\n      return;\n    }\n\n    try {\n      localStorage.setItem(THEME_STORAGE_KEY_V1, normalized);\n    } catch {\n      // ignore\n    }\n  }\n\n  function clampNumber(value, min, max) {\n    return Math.min(max, Math.max(min, value));\n  }\n\n  function normalizeLayoutSplit(value) {\n    const numeric = Number(value);\n    if (!Number.isFinite(numeric)) {\n      return LAYOUT_SPLIT_DEFAULT;\n    }\n    return clampNumber(numeric, LAYOUT_SPLIT_MIN, LAYOUT_SPLIT_MAX);\n  }\n\n  function loadLayoutSplit() {\n    try {\n      return normalizeLayoutSplit(localStorage.getItem(LAYOUT_SPLIT_STORAGE_KEY_V1));\n    } catch {\n      return LAYOUT_SPLIT_DEFAULT;\n    }\n  }\n\n  function saveLayoutSplit(value) {\n    try {\n      localStorage.setItem(LAYOUT_SPLIT_STORAGE_KEY_V1, String(normalizeLayoutSplit(value)));\n    } catch {\n      // ignore\n    }\n  }\n\n  function updateSplitterAria(leftPercent) {\n    if (!els.panelSplitter) {\n      return;\n    }\n\n    const left = Math.round(leftPercent);\n    const right = Math.round(100 - leftPercent);\n    els.panelSplitter.setAttribute(\"aria-valuemin\", String(LAYOUT_SPLIT_MIN));\n    els.panelSplitter.setAttribute(\"aria-valuemax\", String(LAYOUT_SPLIT_MAX));\n    els.panelSplitter.setAttribute(\"aria-valuenow\", String(left));\n    els.panelSplitter.setAttribute(\"aria-valuetext\", `${left}% code, ${right}% output`);\n  }\n\n  function applyLayoutSplit(nextPercent, { save } = {}) {\n    const normalized = normalizeLayoutSplit(nextPercent);\n    state.layoutLeftPane = normalized;\n    document.documentElement.style.setProperty(\"--layout-left-pane\", `${normalized}%`);\n    updateSplitterAria(normalized);\n\n    if (save === false) {\n      return;\n    }\n\n    saveLayoutSplit(normalized);\n  }\n\n  function isCompactLayout() {\n    if (typeof window.matchMedia === \"function\") {\n      return window.matchMedia(MOBILE_LAYOUT_QUERY).matches;\n    }\n    return window.innerWidth <= 980;\n  }\n\n  function setLayoutResizing(active) {\n    if (!els.mainLayout) {\n      return;\n    }\n    els.mainLayout.classList.toggle(\"is-resizing\", Boolean(active));\n  }\n\n  function initLayoutSplitter() {\n    applyLayoutSplit(loadLayoutSplit(), { save: false });\n\n    if (!els.mainLayout || !els.panelSplitter) {\n      return;\n    }\n\n    let dragging = false;\n    let activePointerId = null;\n\n    function applySplitFromClientX(clientX) {\n      const layoutRect = els.mainLayout.getBoundingClientRect();\n      const splitterRect = els.panelSplitter.getBoundingClientRect();\n      const usableWidth = layoutRect.width - splitterRect.width;\n      if (usableWidth <= 0) {\n        return;\n      }\n\n      const leftWidth = clientX - layoutRect.left - (splitterRect.width / 2);\n      const leftPercent = (leftWidth / usableWidth) * 100;\n      applyLayoutSplit(leftPercent, { save: false });\n    }\n\n    function onPointerMove(ev) {\n      if (!dragging || isCompactLayout()) {\n        return;\n      }\n      applySplitFromClientX(ev.clientX);\n      ev.preventDefault();\n    }\n\n    function stopDragging() {\n      if (!dragging) {\n        return;\n      }\n      dragging = false;\n      setLayoutResizing(false);\n      if (activePointerId !== null && typeof els.panelSplitter.releasePointerCapture === \"function\") {\n        try {\n          els.panelSplitter.releasePointerCapture(activePointerId);\n        } catch {\n          // ignore\n        }\n      }\n      activePointerId = null;\n      saveLayoutSplit(state.layoutLeftPane);\n      window.removeEventListener(\"pointermove\", onPointerMove);\n      window.removeEventListener(\"pointerup\", stopDragging);\n      window.removeEventListener(\"pointercancel\", stopDragging);\n    }\n\n    els.panelSplitter.addEventListener(\"pointerdown\", (ev) => {\n      if (ev.button !== 0 || isCompactLayout()) {\n        return;\n      }\n\n      dragging = true;\n      activePointerId = ev.pointerId;\n      setLayoutResizing(true);\n\n      if (typeof els.panelSplitter.setPointerCapture === \"function\") {\n        try {\n          els.panelSplitter.setPointerCapture(ev.pointerId);\n        } catch {\n          // ignore\n        }\n      }\n\n      applySplitFromClientX(ev.clientX);\n      window.addEventListener(\"pointermove\", onPointerMove);\n      window.addEventListener(\"pointerup\", stopDragging);\n      window.addEventListener(\"pointercancel\", stopDragging);\n      ev.preventDefault();\n    });\n\n    els.panelSplitter.addEventListener(\"keydown\", (ev) => {\n      if (isCompactLayout()) {\n        return;\n      }\n      if (ev.key !== \"ArrowLeft\" && ev.key !== \"ArrowRight\") {\n        return;\n      }\n\n      const step = ev.shiftKey ? 5 : 2;\n      const delta = ev.key === \"ArrowRight\" ? step : -step;\n      applyLayoutSplit(state.layoutLeftPane + delta);\n      ev.preventDefault();\n    });\n\n    window.addEventListener(\"resize\", () => {\n      if (isCompactLayout()) {\n        setLayoutResizing(false);\n        return;\n      }\n      applyLayoutSplit(state.layoutLeftPane, { save: false });\n    });\n  }\n\n  function validateRuleConfig(config) {\n    if (!config || typeof config !== \"object\" || Array.isArray(config)) {\n      return \"Config must be a JSON object.\";\n    }\n\n    if (!config.object || typeof config.object !== \"string\") {\n      return \"Missing config.object (string).\";\n    }\n\n    if (!config.match || typeof config.match !== \"object\" || Array.isArray(config.match)) {\n      return \"Missing config.match (object).\";\n    }\n\n    const match = config.match;\n    const hasMatch =\n      (typeof match.startKeyword === \"string\" && match.startKeyword.trim()) ||\n      (typeof match.startPhrase === \"string\" && match.startPhrase.trim()) ||\n      (typeof match.type === \"string\" && match.type.trim());\n\n    if (!hasMatch) {\n      return \"match must include startKeyword, startPhrase, or type.\";\n    }\n\n    if (config.block !== undefined && config.block !== null) {\n      if (typeof config.block !== \"object\" || Array.isArray(config.block)) {\n        return \"block must be an object (or null).\";\n      }\n      if (typeof config.block.endKeyword !== \"string\" || !config.block.endKeyword.trim()) {\n        return \"block.endKeyword must be a non-empty string.\";\n      }\n    }\n\n    if (config.extras !== undefined && config.extras !== null) {\n      if (typeof config.extras !== \"object\" || Array.isArray(config.extras)) {\n        return \"extras must be an object (or null).\";\n      }\n      if (typeof config.extras.type !== \"string\" || !config.extras.type.trim()) {\n        return \"extras.type must be a non-empty string.\";\n      }\n    }\n\n    if (config.keywordLabels !== undefined && config.keywordLabels !== null) {\n      if (typeof config.keywordLabels !== \"object\" || Array.isArray(config.keywordLabels)) {\n        return \"keywordLabels must be an object.\";\n      }\n    }\n\n    if (config.keywordPhrases !== undefined && config.keywordPhrases !== null) {\n      if (typeof config.keywordPhrases !== \"object\" || Array.isArray(config.keywordPhrases)) {\n        return \"keywordPhrases must be an object.\";\n      }\n    }\n\n    if (config.captureRules !== undefined && config.captureRules !== null && !Array.isArray(config.captureRules)) {\n      return \"captureRules must be an array.\";\n    }\n\n    if (Array.isArray(config.captureRules)) {\n      for (const rule of config.captureRules) {\n        if (!rule || typeof rule !== \"object\" || Array.isArray(rule)) {\n          return \"Each captureRules[] item must be an object.\";\n        }\n        if (typeof rule.after !== \"string\" || !rule.after.trim()) {\n          return \"Each captureRules[] item must have after (string).\";\n        }\n        if (typeof rule.name !== \"string\" || !rule.name.trim()) {\n          return \"Each captureRules[] item must have name (string).\";\n        }\n      }\n    }\n\n    return \"\";\n  }\n\n  function generateRuleId() {\n    const time = Date.now();\n    const rand = Math.random().toString(16).slice(2, 10);\n    return `rule-${time}-${rand}`;\n  }\n\n  function normalizeCustomRules(list) {\n    const output = [];\n    const items = Array.isArray(list) ? list : [];\n\n    for (const item of items) {\n      if (!item || typeof item !== \"object\" || Array.isArray(item)) {\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
