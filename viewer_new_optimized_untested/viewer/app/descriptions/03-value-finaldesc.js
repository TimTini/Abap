"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/02-descriptions.js";
  const partKey = "viewer/app/descriptions/03-value-finaldesc.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "      } else {\n        state.descOverrides[key] = skipNormalize ? { text: stored, noNormalize: true } : stored;\n      }\n    } else {\n      const structKey = state.activeEdit.structKey;\n      const itemKey = state.activeEdit.itemKey;\n      if (!structKey || !itemKey) {\n        return;\n      }\n\n      const structValue = action === \"clear\" ? \"\" : String((els.editStructDesc && els.editStructDesc.value) || \"\");\n      const itemValue = action === \"clear\" ? \"\" : String((els.editItemDesc && els.editItemDesc.value) || \"\");\n      const structTrimmed = structValue.trim();\n      const itemTrimmed = itemValue.trim();\n      const structStored = stripDeclCategoryPrefix(structTrimmed);\n      const itemStored = skipNormalize ? itemTrimmed : stripDeclCategoryPrefix(itemTrimmed);\n\n      if (!structStored) {\n        delete state.descOverrides[structKey];\n      } else {\n        state.descOverrides[structKey] = structStored;\n      }\n\n      if (!itemStored) {\n        delete state.descOverrides[itemKey];\n      } else {\n        state.descOverrides[itemKey] = skipNormalize ? { text: itemStored, noNormalize: true } : itemStored;\n      }\n    }\n\n    saveDescOverrides();\n    state.haystackById = buildSearchIndex(state.renderObjects);\n    renderOutput();\n    if (state.rightTab === \"descriptions\") {\n      renderDeclDescPanelUi();\n    }\n  }\n\n  function editDeclDesc(decl) {\n    if (!decl || !decl.name) {\n      return;\n    }\n\n    const isStructField = isStructFieldDecl(decl);\n\n    const key = getDeclOverrideStorageKey(decl);\n    if (!key) {\n      return;\n    }\n\n    const settings = state.settings || DEFAULT_SETTINGS;\n    const normalizeEnabled = Boolean(settings.normalizeDeclDesc);\n\n    const currentEntry = getDeclOverrideEntry(decl);\n    const current = currentEntry.text ? String(currentEntry.text) : \"\";\n    const effective = getEffectiveDeclDesc(decl);\n    const currentDisplay = current\n      ? (normalizeEnabled && !currentEntry.noNormalize ? normalizeDeclDescText(decl, current) : current)\n      : \"\";\n    const hintParts = [];\n    hintParts.push(`Key: ${key}`);\n    if (decl.scopeLabel) {\n      hintParts.push(`Scope: ${decl.scopeLabel}`);\n    }\n    if (decl.objectType) {\n      hintParts.push(`Type: ${decl.objectType}`);\n    }\n    if (decl.lineStart) {\n      hintParts.push(`Line: ${decl.lineStart}`);\n    }\n    const base = getBaseDeclDesc(decl);\n    const source = getSourceDeclDesc(decl);\n    if (base) {\n      hintParts.push(`Registry: ${base}`);\n    }\n    if (source) {\n      hintParts.push(`Comment: ${source}`);\n    }\n    if (decl.raw) {\n      hintParts.push(decl.raw);\n    }\n\n    if (!isStructField) {\n      openEditModal({\n        mode: \"single\",\n        key,\n        label: `${decl.objectType || \"DECL\"} ${getDeclTechName(decl)}`,\n        hint: hintParts.join(\" • \"),\n        initialValue: currentDisplay || effective,\n        skipNormalize: Boolean(currentEntry.noNormalize)\n      });\n      return;\n    }\n\n    const structDecl = buildStructDeclFromFieldDecl(decl);\n    const structKey = structDecl ? getDeclOverrideStorageKey(structDecl) : \"\";\n    if (!structKey) {\n      return;\n    }\n\n    const structCurrentEntry = structDecl ? getDeclOverrideEntry(structDecl) : { text: \"\", noNormalize: false };\n    const structCurrent = structCurrentEntry.text ? String(structCurrentEntry.text) : \"\";\n    const structEffective = structDecl ? getEffectiveDeclDesc(structDecl) : \"\";\n    const structCurrentDisplay = structDecl && structCurrent && normalizeEnabled\n      ? normalizeDeclDescText(structDecl, structCurrent)\n      : structCurrent;\n\n    hintParts.push(`StructKey: ${structKey}`);\n    hintParts.push(`ItemKey: ${key}`);\n\n    openEditModal({\n      mode: \"structField\",\n      structKey,\n      itemKey: key,\n      label: `${decl.objectType || \"DECL\"} ${getDeclTechName(decl)}`,\n      hint: hintParts.join(\" • \"),\n      structValue: structCurrentDisplay || structEffective,\n      itemValue: currentDisplay || getEffectiveDeclAtomicDescNormalized(decl),\n      skipNormalize: Boolean(currentEntry.noNormalize)\n    });\n  }\n\n  function escapeSelectorValue(value) {\n    const text = String(value || \"\");\n    if (window.CSS && typeof window.CSS.escape === \"function\") {\n      return window.CSS.escape(text);\n    }\n    return text.replace(/\"/g, '\\\\\"');\n  }\n\n  function safeJson(value, pretty) {\n    try {\n      return JSON.stringify(value, null, pretty ? 2 : 0);\n    } catch {\n      return \"\";\n    }\n  }\n\n  function sanitizeXmlText(value) {\n    const text = String(value ?? \"\");\n    // Keep: TAB (0x9), LF (0xA), CR (0xD)\n    return text.replace(/[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F\\u007F]/g, \"\");\n  }\n\n  function escapeXmlText(value) {\n    return sanitizeXmlText(value)\n      .replace(/&/g, \"&amp;\")\n      .replace(/</g, \"&lt;\")\n      .replace(/>/g, \"&gt;\")\n      .replace(/\"/g, \"&quot;\")\n      .replace(/'/g, \"&apos;\");\n  }\n\n  function toXmlTagName(key) {\n    const raw = String(key || \"\").trim();\n    if (!raw) {\n      return \"value\";\n    }\n\n    const normalized = raw.replace(/[^A-Za-z0-9_:-]/g, \"_\");\n    if (!/^[A-Za-z_]/.test(normalized)) {\n      return `_${normalized}`;\n    }\n    return normalized;\n  }\n\n  function getArrayItemTagName(keyHint) {\n    const key = String(keyHint || \"\").trim().toLowerCase();\n    if (key === \"objects\" || key === \"children\") {\n      return \"object\";\n    }\n    return \"item\";\n  }\n\n  function isPlainObjectRecord(value) {\n    return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n  }\n\n  function isAbapStatementObject(value) {\n    if (!isPlainObjectRecord(value)) {\n      return false;\n    }\n    const hasNodeShape = Object.prototype.hasOwnProperty.call(value, \"values\")\n      || Object.prototype.hasOwnProperty.call(value, \"extras\")\n      || Object.prototype.hasOwnProperty.call(value, \"children\");\n    if (!hasNodeShape) {\n      return false;\n    }\n    return (\n      Object.prototype.hasOwnProperty.call(value, \"objectType\")\n      && Object.prototype.hasOwnProperty.call(value, \"raw\")\n      && Object.prototype.hasOwnProperty.call(value, \"lineStart\")\n    );\n  }\n\n  function extractIdentifierCandidate(text) {\n    const raw = String(text || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n    if (raw.startsWith(\"'\") || raw.startsWith(\"|\")) {\n      return \"\";\n    }\n    if (/^[+-]?\\d/.test(raw)) {\n      return \"\";\n    }\n\n    const sysMatch = raw.match(/^SY-[A-Za-z_][A-Za-z0-9_]*/i);\n    if (sysMatch) {\n      return sysMatch[0].toUpperCase();\n    }\n\n    const fieldPathMatch = raw.match(\n      /^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(?:(?:->|=>|~|-)[A-Za-z_][A-Za-z0-9_]*)+/\n    );\n    if (fieldPathMatch) {\n      return String(fieldPathMatch[0] || \"\").trim();\n    }\n\n    const inlinePatterns = [\n      /@?DATA\\s*\\(\\s*([^)]+)\\s*\\)/i,\n      /@?FINAL\\s*\\(\\s*([^)]+)\\s*\\)/i,\n      /FIELD-SYMBOL\\s*\\(\\s*(<[^>]+>)\\s*\\)/i\n    ];\n    for (const regex of inlinePatterns) {\n      const match = regex.exec(raw);\n      if (!match || !match[1]) {\n        continue;\n      }\n      const candidate = String(match[1] || \"\").trim();\n      if (candidate) {\n        return candidate;\n      }\n    }\n\n    const genericMatch = raw.match(\n      /<[^>]+>|[A-Za-z_][A-Za-z0-9_]*(?:(?:->|=>|~|-)[A-Za-z_][A-Za-z0-9_]*)*/\n    );\n    return genericMatch ? String(genericMatch[0] || \"\").trim() : \"\";\n  }\n\n  function resolveFallbackFieldId(entry) {\n    if (!isPlainObjectRecord(entry)) {\n      return \"\";\n    }\n\n    const fromDeclRef = String(entry.declRef || \"\").trim();\n    if (fromDeclRef) {\n      return fromDeclRef;\n    }\n\n    const valueText = String(entry.value || \"\").trim();\n    const identifier = extractIdentifierCandidate(valueText);\n    if (identifier) {\n      return identifier;\n    }\n\n    if (valueText) {\n      return valueText;\n    }\n\n    const fromName = String(entry.name || \"\").trim();\n    if (fromName) {\n      return fromName;\n    }\n\n    return \"\";\n  }\n\n  function buildPathKeyFromParts(parts) {\n    const tokens = Array.isArray(parts) ? parts : [];\n    const cleaned = [];\n    for (const part of tokens) {\n      const token = String(part || \"\").trim();\n      if (token) {\n        cleaned.push(token);\n      }\n    }\n    return cleaned.join(\"/\");\n  }\n\n  function normalizeSyntheticPathKey(pathKey) {\n    const text = String(pathKey || \"\").trim();\n    if (!text) {\n      return \"ROOT\";\n    }\n    const normalized = text\n      .replace(/\\s+/g, \"_\")\n      .replace(/[^A-Za-z0-9_:\\-./[\\]#]/g, \"_\")\n      .toUpperCase();\n    return normalized || \"ROOT\";\n  }\n\n  function buildSyntheticDeclForPath({ pathKey, fieldId, file, lineStart, raw, role }) {\n    const name = String(fieldId || \"\").trim();\n    if (!name) {\n      return null;\n    }\n\n    const numericLine = lineStart === null || lineStart === undefined || lineStart === \"\"\n      ? null\n      : (Number(lineStart) || null);\n\n    const normalizedPath = normalizeSyntheticPathKey(pathKey);\n    return {\n      id: null,\n      objectType: \"PATH_DECL\",\n      name,\n      file: String(file || \"\"),\n      lineStart: numericLine,\n      raw: String(raw || \"\"),\n      comment: \"\",\n      scopeId: 0,\n      scopeLabel: `PATH:${normalizedPath}`,\n      scopeType: \"PATH\",\n      scopeName: String(role || \"\")\n    };\n  }\n\n  function getDeclSourceContextFromObject(obj) {\n    if (!isPlainObjectRecord(obj)) {\n      return { file: \"\", lineStart: null, raw: \"\" };\n    }\n    return {\n      file: String(obj.file || \"\"),\n      lineStart: obj.lineStart === null || obj.lineStart === undefined\n        ? null\n        : (Number(obj.lineStart) || null),\n      raw: String(obj.raw || \"\")\n    };\n  }\n\n  function buildObjectPathBase(obj) {\n    const id = normalizeId(obj && obj.id);\n    if (id) {\n      return `OBJECT:${id}`;\n    }\n    const type = String(obj && obj.objectType ? obj.objectType : \"OBJECT\").trim() || \"OBJECT\";\n    const file = String(obj && obj.file ? obj.file : \"\").trim() || \"NO_FILE\";\n    const line = obj && obj.lineStart ? String(obj.lineStart) : \"0\";\n    return `OBJECT:${type}:${file}:${line}`;\n  }\n\n  function hasAnyDecls(list) {\n    if (!Array.isArray(list)) {\n      return false;\n    }\n    return list.some((item) => item && typeof item === \"object\");\n  }\n\n  function ensureEntryDeclWithSynthetic(entry, options) {\n    if (!isPlainObjectRecord(entry)) {\n      return entry;\n    }\n    if (isDeclLikeObject(entry.decl)) {\n      return entry;\n    }\n\n    const fieldId = resolveFallbackFieldId(entry);\n    const pathKey = buildPathKeyFromParts([options && options.pathKey ? options.pathKey : \"\", \"decl\"]);\n    const syntheticDecl = buildSyntheticDeclForPath({\n      pathKey,\n      fieldId,\n      file: options && options.file ? options.file : \"\",\n      lineStart: options ? options.lineStart : null,\n      raw: options && options.raw ? options.raw : \"\",\n      role: options && options.role ? options.role : \"value\"\n    });\n    if (!syntheticDecl) {\n      return entry;\n    }\n\n    const next = { ...entry, decl: syntheticDecl };\n    if (!String(next.declRef || \"\").trim()) {\n      next.declRef = fieldId;\n    }\n    return next;\n  }\n\n  function ensureValueDeclWithSynthetic(entry, options) {\n    if (!isPlainObjectRecord(entry)) {\n      return entry;\n    }\n    if (isDeclLikeObject(entry.valueDecl) || hasAnyDecls(entry.originDecls)) {\n      return entry;\n    }\n\n    const sourceForId = {\n      declRef: String(entry.valueRef || entry.declRef || \"\").trim(),\n      value: entry.value,\n      name: entry.name || (options && options.nameHint ? options.nameHint : \"\")\n    };\n    const fieldId = resolveFallbackFieldId(sourceForId);\n    const pathKey = buildPathKeyFromParts([options && options.pathKey ? options.pathKey : \"\", \"valueDecl\"]);\n    const syntheticDecl = buildSyntheticDeclForPath({\n      pathKey,\n      fieldId,\n      file: options && options.file ? options.file : \"\",\n      lineStart: options ? options.lineStart : null,\n      raw: options && options.raw ? options.raw : \"\",\n      role: options && options.role ? options.role : \"value\"\n    });\n    if (!syntheticDecl) {\n      return entry;\n    }\n\n    return {\n      ...entry,\n      valueDecl: syntheticDecl\n    };\n  }\n\n  function ensureConditionClauseDeclsWithSynthetic(clause, options) {\n    if (!isPlainObjectRecord(clause)) {\n      return clause;\n    }\n\n    let next = clause;\n    const file = options && options.file ? options.file : \"\";\n    const lineStart = options ? options.lineStart : null;\n    const raw = options && options.raw ? options.raw : \"\";\n    const basePath = options && options.pathKey ? options.pathKey : \"\";\n\n    if (!isDeclLikeObject(clause.leftOperandDecl)) {\n      const leftFieldId = resolveFallbackFieldId({\n        declRef: clause.leftOperandRef,\n        value: clause.leftOperand,\n        name: \"leftOperand\"\n      });\n      const leftDecl = buildSyntheticDeclForPath({\n        pathKey: buildPathKeyFromParts([basePath, \"leftOperandDecl\"]),\n        fieldId: leftFieldId,\n        file,\n        lineStart,\n        raw,\n        role: \"leftOperand\"\n      });\n      if (leftDecl) {\n        if (next === clause) {\n          next = { ...clause };\n        }\n        next.leftOperandDecl = leftDecl;\n        if (!String(next.leftOperandRef || \"\").trim()) {\n          next.leftOperandRef = leftFieldId;\n        }\n      }\n    }\n\n    if (!isDeclLikeObject(clause.rightOperandDecl)) {\n      const rightFieldId = resolveFallbackFieldId({\n        declRef: clause.rightOperandRef,\n        value: clause.rightOperand,\n        name: \"rightOperand\"\n      });\n      const rightDecl = buildSyntheticDeclForPath({\n        pathKey: buildPathKeyFromParts([basePath, \"rightOperandDecl\"]),\n        fieldId: rightFieldId,\n        file,\n        lineStart,\n        raw,\n        role: \"rightOperand\"\n      });\n      if (rightDecl) {\n        if (next === clause) {\n          next = { ...clause };\n        }\n        next.rightOperandDecl = rightDecl;\n        if (!String(next.rightOperandRef || \"\").trim()) {\n          next.rightOperandRef = rightFieldId;\n        }\n      }\n    }\n\n    return next;\n  }\n\n  function normalizeXmlObjectId(value) {\n    if (value === null || value === undefined) {\n      return \"\";\n    }\n    return String(value);\n  }\n\n  function getFormNameFromNode(node) {\n    if (!node || typeof node !== \"object\") {\n      return \"\";\n    }\n    const valueName = getFirstValueFromValues(node.values, \"name\");\n    const extrasName = node.extras && node.extras.form && node.extras.form.name\n      ? String(node.extras.form.name)\n      : \"\";\n    return String(valueName || extrasName || \"\").trim();\n  }\n\n  function getPerformFormNameFromNode(node) {\n    if (!node || typeof node !== \"object\") {\n      return \"\";\n    }\n    const extrasName = node.extras && node.extras.performCall && node.extras.performCall.form\n      ? String(node.extras.performCall.form)\n      : \"\";\n    const valueName = getFirstValueFromValues(node.values, \"form\");\n    return String(extrasName || valueName || \"\").trim();\n  }\n\n  function getPerformProgramFromNode(node) {\n    if (!node || typeof node !== \"object\") {\n      return \"\";\n    }\n    const extrasProgram = node.extras && node.extras.performCall && node.extras.performCall.program\n      ? String(node.extras.performCall.program)\n      : \"\";\n    const valueProgram = getFirstValueFromValues(node.values, \"program\");\n    return String(extrasProgram || valueProgram || \"\").trim();\n  }\n\n  function buildFormsByNameUpperFromRoots(rawRoots) {\n    const map = new Map();\n    walkObjects(rawRoots, (obj) => {\n      if (!obj || obj.objectType !== \"FORM\") {\n        return;\n      }\n      const name = getFormNameFromNode(obj);\n      if (!name) {\n        return;\n      }\n      const upper = name.toUpperCase();\n      if (!map.has(upper)) {\n        map.set(upper, obj);\n      }\n    });\n    return map;\n  }\n\n  function buildRenderableObjects(rawRoots, options) {\n    const roots = Array.isArray(rawRoots) ? rawRoots : [];\n    if (!roots.length) {\n      return [];\n    }\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
