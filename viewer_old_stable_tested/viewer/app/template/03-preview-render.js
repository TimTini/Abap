"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/03-template-preview.js";
  const partKey = "viewer/app/template/03-preview-render.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "  }\n\n  function splitTemplateTextLines(text) {\n    const normalized = String(text === undefined || text === null ? \"\" : text)\n      .replace(/\\r\\n/g, \"\\n\")\n      .replace(/\\r/g, \"\\n\");\n    if (normalized === \"\") {\n      return [\"\"];\n    }\n    return normalized.split(\"\\n\");\n  }\n\n  function getTemplateTextLine(lines, index) {\n    const list = Array.isArray(lines) && lines.length ? lines : [\"\"];\n    const idx = Number(index) || 0;\n    if (idx < list.length) {\n      return String(list[idx] || \"\");\n    }\n    return String(list[list.length - 1] || \"\");\n  }\n\n  function cloneTemplateMatrixCell(cell) {\n    if (!cell || typeof cell !== \"object\") {\n      return createTemplateCellModel();\n    }\n    return {\n      text: String(cell.text || \"\"),\n      style: { ...(cell.style && typeof cell.style === \"object\" ? cell.style : {}) },\n      hidden: Boolean(cell.hidden),\n      rowspan: Number(cell.rowspan) || 1,\n      colspan: Number(cell.colspan) || 1,\n      hasPlaceholder: Boolean(cell.hasPlaceholder),\n      hasTokenValue: Boolean(cell.hasTokenValue)\n    };\n  }\n\n  function expandTemplateMatrixRows(matrix) {\n    const rows = Array.isArray(matrix)\n      ? matrix.map((row) => (Array.isArray(row) ? row.map((cell) => cloneTemplateMatrixCell(cell)) : []))\n      : [];\n    if (!rows.length) {\n      return rows;\n    }\n\n    for (let rowIndex = rows.length - 1; rowIndex >= 0; rowIndex -= 1) {\n      const row = rows[rowIndex];\n      if (!Array.isArray(row) || !row.length) {\n        continue;\n      }\n\n      const hasMergedCells = row.some((cell) => cell && (cell.hidden || cell.rowspan > 1 || cell.colspan > 1));\n      if (hasMergedCells) {\n        continue;\n      }\n\n      const lineByCol = new Map();\n      let maxLines = 1;\n      for (let colIndex = 0; colIndex < row.length; colIndex += 1) {\n        const cell = row[colIndex];\n        if (!cell || cell.hidden) {\n          continue;\n        }\n        const lines = splitTemplateTextLines(cell.text);\n        lineByCol.set(colIndex, lines);\n        maxLines = Math.max(maxLines, lines.length);\n      }\n\n      if (maxLines <= 1) {\n        continue;\n      }\n\n      for (let colIndex = 0; colIndex < row.length; colIndex += 1) {\n        const cell = row[colIndex];\n        if (!cell || cell.hidden) {\n          continue;\n        }\n        const lines = lineByCol.get(colIndex) || [String(cell.text || \"\")];\n        cell.text = getTemplateTextLine(lines, 0);\n      }\n\n      const extraRows = [];\n      for (let lineIndex = 1; lineIndex < maxLines; lineIndex += 1) {\n        const extraRow = row.map((cell) => cloneTemplateMatrixCell(cell));\n        for (let colIndex = 0; colIndex < extraRow.length; colIndex += 1) {\n          const cell = extraRow[colIndex];\n          if (!cell || cell.hidden) {\n            continue;\n          }\n          const lines = lineByCol.get(colIndex) || [String(cell.text || \"\")];\n          cell.text = getTemplateTextLine(lines, lineIndex);\n        }\n        extraRows.push(extraRow);\n      }\n\n      if (extraRows.length) {\n        rows.splice(rowIndex + 1, 0, ...extraRows);\n      }\n    }\n\n    return rows;\n  }\n\n  function isTemplateRowBlank(row) {\n    const list = Array.isArray(row) ? row : [];\n    for (const cell of list) {\n      if (!cell || cell.hidden) {\n        continue;\n      }\n      if (String(cell.text || \"\").trim() !== \"\") {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function getTemplateRowPlaceholderState(row) {\n    const list = Array.isArray(row) ? row : [];\n    let hasPlaceholder = false;\n    let hasTokenValue = false;\n    for (const cell of list) {\n      if (!cell || cell.hidden) {\n        continue;\n      }\n      if (cell.hasPlaceholder) {\n        hasPlaceholder = true;\n      }\n      if (cell.hasTokenValue) {\n        hasTokenValue = true;\n      }\n    }\n    return { hasPlaceholder, hasTokenValue };\n  }\n\n  function compactTemplateMatrixRows(matrix, options) {\n    const rows = Array.isArray(matrix) ? matrix : [];\n    if (!rows.length) {\n      return rows;\n    }\n\n    const removeAdvanced = options && options.hideRowsWithoutValues === true;\n    const removeEmpty = removeAdvanced || (options && options.hideEmptyRows === true);\n    if (!removeAdvanced && !removeEmpty) {\n      return rows;\n    }\n\n    const out = [];\n    for (const row of rows) {\n      const rowBlank = isTemplateRowBlank(row);\n      if (removeAdvanced) {\n        const stateRow = getTemplateRowPlaceholderState(row);\n        if (rowBlank || (stateRow.hasPlaceholder && !stateRow.hasTokenValue)) {\n          continue;\n        }\n        out.push(row);\n        continue;\n      }\n\n      if (removeEmpty && rowBlank) {\n        continue;\n      }\n      out.push(row);\n    }\n\n    return out;\n  }\n\n  function applyTemplatePreviewOptions(matrix, options) {\n    let next = Array.isArray(matrix) ? matrix : [];\n    if (!next.length) {\n      return next;\n    }\n    if (options && options.expandMultilineRows === true) {\n      next = expandTemplateMatrixRows(next);\n    }\n    return compactTemplateMatrixRows(next, options);\n  }\n\n  function buildTemplateGridModel(obj, templateMap, templateOptions) {\n    const map = templateMap && typeof templateMap === \"object\" ? templateMap : {};\n    const options = templateOptions && typeof templateOptions === \"object\"\n      ? templateOptions\n      : normalizeTemplatePreviewOptions(null, null, null);\n    const entries = [];\n    const errors = [];\n    let maxRow = 0;\n    let maxCol = 0;\n\n    for (const rangeKey of Object.keys(map)) {\n      if (isTemplateRangeMetaKey(rangeKey)) {\n        continue;\n      }\n      try {\n        const parsedRange = parseRangeKey(rangeKey);\n        entries.push({\n          rangeKey,\n          parsedRange,\n          config: map[rangeKey] && typeof map[rangeKey] === \"object\" ? map[rangeKey] : {}\n        });\n        maxRow = Math.max(maxRow, parsedRange.r2);\n        maxCol = Math.max(maxCol, parsedRange.c2);\n      } catch (err) {\n        errors.push(`${rangeKey}: ${err && err.message ? err.message : err}`);\n      }\n    }\n\n    if (!entries.length) {\n      return {\n        matrix: [],\n        maxRow: 0,\n        maxCol: 0,\n        errors\n      };\n    }\n\n    const matrix = Array.from({ length: maxRow }, () =>\n      Array.from({ length: maxCol }, () => createTemplateCellModel())\n    );\n\n    for (const entry of entries) {\n      const cfg = entry.config;\n      const range = entry.parsedRange;\n      const hasText = Object.prototype.hasOwnProperty.call(cfg, \"text\");\n      const textMeta = hasText ? resolveTemplateText(cfg.text, obj) : null;\n      const merge = cfg && cfg.merge === true;\n\n      if (merge) {\n        for (let row = range.r1; row <= range.r2; row += 1) {\n          for (let col = range.c1; col <= range.c2; col += 1) {\n            const cell = matrix[row - 1][col - 1];\n            if (!cell) {\n              continue;\n            }\n            const isAnchor = row === range.r1 && col === range.c1;\n            if (isAnchor) {\n              cell.hidden = false;\n              cell.rowspan = range.r2 - range.r1 + 1;\n              cell.colspan = range.c2 - range.c1 + 1;\n              if (hasText) {\n                cell.text = String(textMeta && textMeta.text ? textMeta.text : \"\");\n                cell.hasPlaceholder = cell.hasPlaceholder || Boolean(textMeta && textMeta.hasPlaceholder);\n                cell.hasTokenValue = cell.hasTokenValue || Boolean(textMeta && textMeta.hasTokenValue);\n              }\n              const cellStyle = buildTemplateCellStyle(cfg, {\n                isTop: true,\n                isRight: true,\n                isBottom: true,\n                isLeft: true,\n                isMergeAnchor: true\n              });\n              cell.style = { ...cell.style, ...cellStyle };\n            } else {\n              cell.hidden = true;\n              cell.rowspan = 1;\n              cell.colspan = 1;\n            }\n          }\n        }\n        continue;\n      }\n\n      for (let row = range.r1; row <= range.r2; row += 1) {\n        for (let col = range.c1; col <= range.c2; col += 1) {\n          const cell = matrix[row - 1][col - 1];\n          if (!cell) {\n            continue;\n          }\n          cell.hidden = false;\n          cell.rowspan = 1;\n          cell.colspan = 1;\n          if (hasText) {\n            cell.text = String(textMeta && textMeta.text ? textMeta.text : \"\");\n            cell.hasPlaceholder = cell.hasPlaceholder || Boolean(textMeta && textMeta.hasPlaceholder);\n            cell.hasTokenValue = cell.hasTokenValue || Boolean(textMeta && textMeta.hasTokenValue);\n          }\n          const cellStyle = buildTemplateCellStyle(cfg, {\n            isTop: row === range.r1,\n            isRight: col === range.c2,\n            isBottom: row === range.r2,\n            isLeft: col === range.c1,\n            isMergeAnchor: false\n          });\n          cell.style = { ...cell.style, ...cellStyle };\n        }\n      }\n    }\n\n    const compactedMatrix = applyTemplatePreviewOptions(matrix, options);\n    return {\n      matrix: compactedMatrix,\n      maxRow: compactedMatrix.length,\n      maxCol,\n      errors,\n      options\n    };\n  }\n\n  function renderTemplateTable(model) {\n    const matrix = model && Array.isArray(model.matrix) ? model.matrix : [];\n    if (!matrix.length) {\n      return null;\n    }\n    const options = model && model.options && typeof model.options === \"object\"\n      ? model.options\n      : normalizeTemplatePreviewOptions(null, null, null);\n    const squareCells = options.squareCells === true;\n    const squareCellSize = parseTemplateOptionNumber(options.squareCellSize, 18, 16, 240);\n\n    const table = el(\"table\", {\n      className: \"template-preview-table\",\n      attrs: {\n        style: \"border-collapse:collapse;table-layout:fixed;width:max-content;min-width:100%;\"\n      }\n    });\n    const tbody = el(\"tbody\");\n\n    for (let rowIndex = 0; rowIndex < matrix.length; rowIndex += 1) {\n      const row = matrix[rowIndex];\n      const tr = el(\"tr\");\n      for (let colIndex = 0; colIndex < row.length; colIndex += 1) {\n        const cell = row[colIndex];\n        if (!cell || cell.hidden) {\n          continue;\n        }\n\n        const td = document.createElement(\"td\");\n        if (cell.rowspan > 1) {\n          td.rowSpan = cell.rowspan;\n        }\n        if (cell.colspan > 1) {\n          td.colSpan = cell.colspan;\n        }\n\n        td.textContent = String(cell.text || \"\");\n        const colSpan = Math.max(1, Number(td.colSpan) || 1);\n        const rowSpan = Math.max(1, Number(td.rowSpan) || 1);\n        const baseMinWidth = squareCells ? `${squareCellSize}px` : \"56px\";\n        const baseMaxWidth = squareCells ? `${squareCellSize}px` : \"360px\";\n        const baseWidth = squareCells ? `${squareCellSize * colSpan}px` : \"\";\n        const baseMinHeight = squareCells ? `${squareCellSize}px` : \"\";\n        const baseHeight = squareCells ? `${squareCellSize * rowSpan}px` : \"\";\n        const baseTextOverflow = squareCells ? \"ellipsis\" : \"\";\n        const cssText = toInlineCssText({\n          \"min-width\": baseMinWidth,\n          \"max-width\": baseMaxWidth,\n          width: baseWidth,\n          \"min-height\": baseMinHeight,\n          height: baseHeight,\n          padding: \"4px 6px\",\n          border: \"none\",\n          \"vertical-align\": \"top\",\n          \"white-space\": \"pre-wrap\",\n          \"text-overflow\": baseTextOverflow,\n          \"box-sizing\": \"border-box\",\n          \"font-size\": \"10pt\",\n          \"font-family\": \"\\\"MS PGothic\\\", \\\"MS UI Gothic\\\", Meiryo, sans-serif\",\n          color: \"#111111\",\n          \"background-color\": \"#ffffff\",\n          ...cell.style\n        });\n        if (cssText) {\n          td.setAttribute(\"style\", cssText);\n        }\n\n        tr.appendChild(td);\n      }\n      tbody.appendChild(tr);\n    }\n\n    table.appendChild(tbody);\n    return table;\n  }\n\n  async function copyHtmlWithFallback(html, plainText) {\n    const safeHtml = String(html || \"\");\n    const safeText = String(plainText || \"\");\n\n    if (\n      safeHtml\n      && navigator.clipboard\n      && typeof navigator.clipboard.write === \"function\"\n      && typeof window.ClipboardItem === \"function\"\n    ) {\n      const item = new window.ClipboardItem({\n        \"text/html\": new Blob([safeHtml], { type: \"text/html\" }),\n        \"text/plain\": new Blob([safeText], { type: \"text/plain\" })\n      });\n      await navigator.clipboard.write([item]);\n      return;\n    }\n\n    if (navigator.clipboard && typeof navigator.clipboard.writeText === \"function\") {\n      await navigator.clipboard.writeText(safeText);\n      return;\n    }\n\n    const temp = document.createElement(\"div\");\n    temp.style.position = \"fixed\";\n    temp.style.left = \"-99999px\";\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
