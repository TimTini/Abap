"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/01-xml-export.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\"use strict\";\n\nwindow.AbapViewerModules = window.AbapViewerModules || {};\nwindow.AbapViewerModules.parts = window.AbapViewerModules.parts || {};\n\n  function isValueLikeEntryObject(value) {\n    if (!isPlainObjectRecord(value)) {\n      return false;\n    }\n    if (isDeclLikeObject(value) || isAbapStatementObject(value)) {\n      return false;\n    }\n    return (\n      hasValueLevelDescFields(value)\n      || Object.prototype.hasOwnProperty.call(value, \"declRef\")\n      || Object.prototype.hasOwnProperty.call(value, \"value\")\n      || Object.prototype.hasOwnProperty.call(value, \"name\")\n      || Object.prototype.hasOwnProperty.call(value, \"label\")\n    );\n  }\n\n  function isAssignmentLikeEntryObject(value) {\n    if (!isPlainObjectRecord(value)) {\n      return false;\n    }\n    if (isDeclLikeObject(value) || isAbapStatementObject(value)) {\n      return false;\n    }\n    const hasValueSignals = (\n      Object.prototype.hasOwnProperty.call(value, \"value\")\n      || Object.prototype.hasOwnProperty.call(value, \"valueRef\")\n      || Object.prototype.hasOwnProperty.call(value, \"valueDecl\")\n      || Object.prototype.hasOwnProperty.call(value, \"originDecls\")\n    );\n    if (!hasValueSignals) {\n      return false;\n    }\n    return (\n      Object.prototype.hasOwnProperty.call(value, \"name\")\n      || Object.prototype.hasOwnProperty.call(value, \"value\")\n      || Object.prototype.hasOwnProperty.call(value, \"valueRef\")\n    );\n  }\n\n  function isConditionClauseLikeObject(value) {\n    if (!isPlainObjectRecord(value)) {\n      return false;\n    }\n    return (\n      Object.prototype.hasOwnProperty.call(value, \"leftOperand\")\n      || Object.prototype.hasOwnProperty.call(value, \"rightOperand\")\n      || Object.prototype.hasOwnProperty.call(value, \"comparisonOperator\")\n    );\n  }\n\n  function normalizeEntryObjectForXml(value, keyHint, pathParts, ownerContext) {\n    if (!isPlainObjectRecord(value)) {\n      return value;\n    }\n    if (isDeclLikeObject(value) || isAbapStatementObject(value)) {\n      return value;\n    }\n\n    const pathKey = buildPathKeyFromParts(pathParts);\n    const pathLower = pathKey.toLowerCase();\n    const inValuesPath = pathLower.includes(\"/values/\");\n    const inExtrasPath = pathLower.includes(\"/extras/\");\n    const keyHintLower = String(keyHint || \"\").trim().toLowerCase();\n    const extrasItemLike = keyHintLower === \"item\";\n    const source = getDeclSourceContextFromObject(ownerContext);\n\n    let next = value;\n\n    if (inValuesPath && isValueLikeEntryObject(next)) {\n      next = ensureEntryDeclWithSynthetic(next, {\n        pathKey,\n        file: source.file,\n        lineStart: source.lineStart,\n        raw: source.raw,\n        role: \"xml:value\"\n      });\n    }\n\n    if (inExtrasPath && extrasItemLike) {\n      if (isConditionClauseLikeObject(next)) {\n        next = ensureConditionClauseDeclsWithSynthetic(next, {\n          pathKey,\n          file: source.file,\n          lineStart: source.lineStart,\n          raw: source.raw\n        });\n      }\n\n      if (isAssignmentLikeEntryObject(next)) {\n        next = ensureValueDeclWithSynthetic(next, {\n          pathKey,\n          file: source.file,\n          lineStart: source.lineStart,\n          raw: source.raw,\n          role: \"xml:extras:value\",\n          nameHint: String(keyHint || \"value\")\n        });\n      }\n\n      if (isValueLikeEntryObject(next)) {\n        next = ensureEntryDeclWithSynthetic(next, {\n          pathKey,\n          file: source.file,\n          lineStart: source.lineStart,\n          raw: source.raw,\n          role: \"xml:extras\"\n        });\n      }\n    }\n\n    return next;\n  }\n\n  function appendXmlValue(lines, keyHint, tagName, value, indent, pathParts, ownerContext) {\n    const pad = \" \".repeat(indent);\n    const currentPathParts = Array.isArray(pathParts) ? pathParts : [];\n    const currentOwnerContext = ownerContext && typeof ownerContext === \"object\" ? ownerContext : null;\n\n    if (value === undefined) {\n      return;\n    }\n\n    if (value === null) {\n      lines.push(`${pad}<${tagName}/>`);\n      return;\n    }\n\n    if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n      lines.push(`${pad}<${tagName}>${escapeXmlText(String(value))}</${tagName}>`);\n      return;\n    }\n\n    if (Array.isArray(value)) {\n      const itemTag = getArrayItemTagName(keyHint);\n      lines.push(`${pad}<${tagName}>`);\n      for (let index = 0; index < value.length; index += 1) {\n        const item = value[index];\n        const itemPathParts = currentPathParts.concat(`${itemTag}[${index + 1}]`);\n        appendXmlValue(lines, itemTag, itemTag, item, indent + 2, itemPathParts, currentOwnerContext);\n      }\n      lines.push(`${pad}</${tagName}>`);\n      return;\n    }\n\n    if (typeof value === \"object\") {\n      const nextOwnerContext = isAbapStatementObject(value) ? value : currentOwnerContext;\n      const normalizedValue = normalizeEntryObjectForXml(value, keyHint, currentPathParts, nextOwnerContext);\n      lines.push(`${pad}<${tagName}>`);\n\n      const valueIsDecl = isDeclObjectForXml(keyHint, normalizedValue);\n      let hasComputedFinalDesc = false;\n\n      if (valueIsDecl) {\n        const declDesc = getEffectiveDeclDesc(normalizedValue);\n        if (declDesc) {\n          lines.push(`${\" \".repeat(indent + 2)}<desc>${escapeXmlText(declDesc)}</desc>`);\n        } else {\n          lines.push(`${\" \".repeat(indent + 2)}<desc/>`);\n        }\n\n        const finalDeclDesc = getFinalDeclDesc(normalizedValue);\n        hasComputedFinalDesc = true;\n        if (finalDeclDesc) {\n          lines.push(`${\" \".repeat(indent + 2)}<finalDesc>${escapeXmlText(finalDeclDesc)}</finalDesc>`);\n        } else {\n          lines.push(`${\" \".repeat(indent + 2)}<finalDesc/>`);\n        }\n\n        const declName = getDeclDisplayName(normalizedValue) || getDeclTechName(normalizedValue);\n        lines.push(`${\" \".repeat(indent + 2)}<name>${escapeXmlText(declName)}</name>`);\n      }\n\n      if (!valueIsDecl) {\n        let shouldEmitFinalDesc = false;\n        let finalDesc = \"\";\n        if (hasValueLevelDescFields(normalizedValue)) {\n          shouldEmitFinalDesc = true;\n          finalDesc = resolveValueLevelFinalDesc(normalizedValue);\n        } else if (isDeclLikeObject(normalizedValue.decl)) {\n          shouldEmitFinalDesc = true;\n          finalDesc = getFinalDeclDesc(normalizedValue.decl);\n        }\n\n        if (shouldEmitFinalDesc) {\n          hasComputedFinalDesc = true;\n          if (finalDesc) {\n            lines.push(`${\" \".repeat(indent + 2)}<finalDesc>${escapeXmlText(finalDesc)}</finalDesc>`);\n          } else {\n            lines.push(`${\" \".repeat(indent + 2)}<finalDesc/>`);\n          }\n        }\n      }\n\n      const preferredOrder = [\n        \"id\",\n        \"parent\",\n        \"objectType\",\n        \"file\",\n        \"lineStart\",\n        \"comment\",\n        \"raw\",\n        \"keywords\",\n        \"values\",\n        \"extras\",\n        \"block\",\n        \"children\"\n      ];\n\n      const keys = Object.keys(normalizedValue);\n      keys.sort((a, b) => {\n        const ai = preferredOrder.indexOf(a);\n        const bi = preferredOrder.indexOf(b);\n        if (ai !== -1 || bi !== -1) {\n          return (ai === -1 ? 999 : ai) - (bi === -1 ? 999 : bi);\n        }\n        return a.localeCompare(b);\n      });\n\n      for (const key of keys) {\n        if (key === \"desc\" && valueIsDecl) {\n          // computed above\n          continue;\n        }\n        if (key === \"name\" && valueIsDecl) {\n          // computed above (normalized via settings)\n          continue;\n        }\n        if (key === \"finalDesc\" && hasComputedFinalDesc) {\n          continue;\n        }\n        const childTag = toXmlTagName(key);\n        appendXmlValue(\n          lines,\n          key,\n          childTag,\n          normalizedValue[key],\n          indent + 2,\n          currentPathParts.concat(key),\n          nextOwnerContext\n        );\n      }\n\n      lines.push(`${pad}</${tagName}>`);\n      return;\n    }\n\n    lines.push(`${pad}<${tagName}>${escapeXmlText(String(value))}</${tagName}>`);\n  }\n\n  function buildAbapFlowXml(data) {\n    const fileName = data && typeof data === \"object\" ? String(data.file || \"\") : \"\";\n    const objects = data && typeof data === \"object\" && Array.isArray(data.objects) ? data.objects : [];\n    const renderObjects = buildRenderableObjects(objects, RENDER_TREE_OPTIONS);\n    const exportRoots = buildXmlExportRoots(renderObjects);\n\n    const lines = ['<?xml version=\"1.0\" encoding=\"UTF-8\"?>', \"<abapflowObjects>\"];\n    if (fileName) {\n      lines.push(`  <file>${escapeXmlText(fileName)}</file>`);\n    }\n    lines.push(\"  <objects>\");\n    for (let index = 0; index < exportRoots.length; index += 1) {\n      const obj = exportRoots[index];\n      appendXmlValue(lines, \"object\", \"object\", obj, 4, [\"objects\", `object[${index + 1}]`], obj);\n    }\n    lines.push(\"  </objects>\");\n    lines.push(\"</abapflowObjects>\");\n\n    return lines.join(\"\\n\");\n  }\n\n  function walkObjects(roots, visit) {\n    const stack = Array.isArray(roots) ? roots.slice().reverse() : [];\n    while (stack.length) {\n      const node = stack.pop();\n      if (!node) {\n        continue;\n      }\n      visit(node);\n      const children = Array.isArray(node.children) ? node.children : [];\n      for (let i = children.length - 1; i >= 0; i -= 1) {\n        stack.push(children[i]);\n      }\n    }\n  }\n\n  function collectDeclSearchTextFromExtras(extras) {\n    if (!extras || typeof extras !== \"object\") {\n      return \"\";\n    }\n\n    const decls = [];\n    const addDecl = (decl) => {\n      if (decl && typeof decl === \"object\") {\n        decls.push(decl);\n      }\n    };\n    const addDeclList = (list) => {\n      if (!Array.isArray(list)) {\n        return;\n      }\n      for (const decl of list) {\n        addDecl(decl);\n      }\n    };\n\n    const collectFromAssignmentSections = (obj, sections) => {\n      for (const sectionName of sections) {\n        const list = obj && Array.isArray(obj[sectionName]) ? obj[sectionName] : [];\n        for (const entry of list) {\n          addDeclList(entry && entry.originDecls);\n          addDecl(entry && entry.valueDecl);\n        }\n      }\n    };\n\n    if (extras.callFunction) {\n      collectFromAssignmentSections(extras.callFunction, [\"exporting\", \"importing\", \"changing\", \"tables\", \"exceptions\"]);\n    }\n\n    if (extras.callMethod) {\n      collectFromAssignmentSections(extras.callMethod, [\"exporting\", \"importing\", \"changing\", \"receiving\", \"exceptions\"]);\n    }\n\n    if (extras.performCall) {\n      for (const sectionName of [\"using\", \"changing\", \"tables\"]) {\n        const list = Array.isArray(extras.performCall[sectionName]) ? extras.performCall[sectionName] : [];\n        for (const entry of list) {\n          addDeclList(entry && entry.originDecls);\n          addDecl(entry && entry.valueDecl);\n        }\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
