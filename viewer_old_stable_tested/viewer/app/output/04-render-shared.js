"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/04-render-shared.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "  }\n\n  var PERFORM_TRACE_META_KEY_OUTPUT = \"__abapPerformTraceBinding\";\n\n  function getDeclRenderKey(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n    return (\n      getDeclKey(decl) ||\n      [\n        decl.objectType || \"\",\n        decl.scopeLabel || \"\",\n        decl.name || \"\",\n        decl.file || \"\",\n        decl.lineStart || \"\"\n      ].join(\"|\")\n    );\n  }\n\n  function dedupeDecls(list) {\n    const output = [];\n    const seen = new Set();\n    for (const decl of list || []) {\n      if (!decl) {\n        continue;\n      }\n      const key = getDeclRenderKey(decl);\n      if (!key || seen.has(key)) {\n        continue;\n      }\n      seen.add(key);\n      output.push(decl);\n    }\n    return output;\n  }\n\n  function getExpandedPerformBindingContext(obj) {\n    if (!obj || typeof obj !== \"object\") {\n      return null;\n    }\n    const bindingContext = obj[PERFORM_TRACE_META_KEY_OUTPUT];\n    if (!bindingContext || typeof bindingContext !== \"object\") {\n      return null;\n    }\n    if (!(bindingContext.byParamUpper instanceof Map)) {\n      return null;\n    }\n    return bindingContext;\n  }\n\n  function resolveExpandedPerformTraceDecls(obj, decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return [];\n    }\n    if (String(decl.objectType || \"\").toUpperCase() !== \"FORM_PARAM\") {\n      return [];\n    }\n    const bindingContext = getExpandedPerformBindingContext(obj);\n    if (!bindingContext) {\n      return [];\n    }\n    const paramUpper = String(decl.name || \"\").trim().toUpperCase();\n    if (!paramUpper) {\n      return [];\n    }\n    const traceDecls = bindingContext.byParamUpper.get(paramUpper);\n    if (!Array.isArray(traceDecls) || !traceDecls.length) {\n      return [];\n    }\n    return dedupeDecls(traceDecls.filter((item) => item && typeof item === \"object\"));\n  }\n\n  function buildDeclTraceListForObject(obj, decl) {\n    const list = [];\n    if (decl && typeof decl === \"object\") {\n      list.push(decl);\n    }\n    const traceDecls = resolveExpandedPerformTraceDecls(obj, decl);\n    if (traceDecls.length) {\n      list.push(...traceDecls);\n    }\n    return dedupeDecls(list);\n  }\n\n  function getDeclListDisplayName(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const displayName = String(getDeclDisplayName(decl) || \"\").trim();\n    const descText = String(getEffectiveDeclDesc(decl) || \"\").trim();\n    if (\n      displayName &&\n      descText &&\n      displayName.localeCompare(descText, undefined, { sensitivity: \"accent\" }) === 0\n    ) {\n      const techName = String(getDeclTechName(decl) || \"\").trim();\n      if (techName) {\n        return techName;\n      }\n    }\n\n    return displayName || String(getDeclTechName(decl) || \"\").trim();\n  }\n\n  function renderDeclListCells(decls, fallbackDecl) {\n    const list = dedupeDecls(Array.isArray(decls) ? decls.filter(Boolean) : []);\n    const effectiveList = list.length ? list : dedupeDecls(fallbackDecl ? [fallbackDecl] : []);\n\n    const nameCell = el(\"td\");\n    const descCell = el(\"td\");\n\n    if (!effectiveList.length) {\n      return { nameCell, descCell };\n    }\n\n    const nameWrap = el(\"div\");\n    const descWrap = el(\"div\");\n\n    for (const decl of effectiveList) {\n      const nameLine = el(\"div\", { text: getDeclListDisplayName(decl) });\n      const title = buildDeclTitle(decl);\n      if (title) {\n        nameLine.title = title;\n      }\n\n      if (decl && decl.lineStart) {\n        nameLine.style.cursor = \"pointer\";\n        nameLine.addEventListener(\"click\", (ev) => {\n          ev.stopPropagation();\n          selectCodeLines(decl.lineStart, decl.lineStart);\n          if (decl.id) {\n            setSelectedCard(decl.id);\n          }\n        });\n      }\n\n      nameWrap.appendChild(nameLine);\n\n      const descLineWrap = el(\"div\", { className: \"decl-desc-line\" });\n      const descLineText = el(\"div\", { className: \"decl-desc-text\", text: getEffectiveDeclDesc(decl) || \"\" });\n      if (title) {\n        descLineText.title = title;\n      }\n      descLineWrap.appendChild(descLineText);\n\n      if (getDeclOverrideStorageKey(decl)) {\n        const btn = el(\"button\", {\n          className: \"icon-btn\",\n          text: \"âœŽ\",\n          attrs: {\n            type: \"button\",\n            title: \"Edit decl description\",\n            \"aria-label\": \"Edit decl description\"\n          }\n        });\n        btn.addEventListener(\"click\", (ev) => {\n          ev.stopPropagation();\n          editDeclDesc(decl);\n        });\n        descLineWrap.appendChild(btn);\n      }\n\n      descWrap.appendChild(descLineWrap);\n    }\n\n    nameCell.appendChild(nameWrap);\n    descCell.appendChild(descWrap);\n    return { nameCell, descCell };\n  }\n\n  function matchesFilters(obj) {\n    const typeOk = !state.type || obj.objectType === state.type;\n    if (!typeOk) {\n      return false;\n    }\n\n    if (!state.query) {\n      return true;\n    }\n\n    const id = normalizeId(obj && obj.id);\n    const haystack = id ? state.haystackById.get(id) : \"\";\n    return haystack ? haystack.includes(state.query) : false;\n  }\n\n  function filterTree(obj) {\n    const children = Array.isArray(obj.children) ? obj.children : [];\n    const filteredChildren = [];\n    for (const child of children) {\n      const filtered = filterTree(child);\n      if (filtered) {\n        filteredChildren.push(filtered);\n      }\n    }\n\n    const selfMatches = matchesFilters(obj);\n    if (!selfMatches && !filteredChildren.length) {\n      return null;\n    }\n\n    return { obj, children: filteredChildren, selfMatches };\n  }\n\n  function el(tag, options) {\n    const node = document.createElement(tag);\n    if (options && options.className) {\n      node.className = options.className;\n    }\n    if (options && options.text !== undefined) {\n      node.textContent = options.text;\n    }\n    if (options && options.attrs) {\n      for (const [key, value] of Object.entries(options.attrs)) {\n        node.setAttribute(key, String(value));\n      }\n    }\n    return node;\n  }\n\n  function renderKeywords(obj) {\n    const keywords = getKeywordEntries(obj);\n    if (!keywords.length) {\n      return null;\n    }\n\n    const wrap = el(\"div\");\n    for (const keyword of keywords) {\n      wrap.appendChild(\n        el(\"span\", {\n          className: \"pill\",\n          text: keyword && keyword.text ? String(keyword.text) : \"\",\n          attrs: keyword && keyword.label ? { title: String(keyword.label) } : {}\n        })\n      );\n    }\n    return wrap;\n  }\n\n  function collectDeclsForValueEntry(obj, entry) {\n    const decls = [];\n    const addDecl = (decl) => {\n      if (decl && typeof decl === \"object\") {\n        decls.push(decl);\n      }\n    };\n    const addDeclWithTrace = (decl) => {\n      if (!decl || typeof decl !== \"object\") {\n        return;\n      }\n      const traceList = buildDeclTraceListForObject(obj, decl);\n      if (!traceList.length) {\n        addDecl(decl);\n        return;\n      }\n      for (const traceDecl of traceList) {\n        addDecl(traceDecl);\n      }\n    };\n\n    const normalizedEntry = ensureEntryDeclForOutput(obj, cloneValueEntryForOutput(entry));\n\n    addDeclWithTrace(normalizedEntry && normalizedEntry.decl);\n    addDeclWithTrace(normalizedEntry && normalizedEntry.valueDecl);\n    if (normalizedEntry && Array.isArray(normalizedEntry.originDecls)) {\n      for (const originDecl of normalizedEntry.originDecls) {\n        addDeclWithTrace(originDecl);\n      }\n    }\n\n    const extras = obj && obj.extras && typeof obj.extras === \"object\" ? obj.extras : null;\n    if (!extras) {\n      return dedupeDecls(decls);\n    }\n\n    const entryName = String(normalizedEntry && normalizedEntry.name ? normalizedEntry.name : \"\").trim().toLowerCase();\n    if (!entryName) {\n      return dedupeDecls(decls);\n    }\n\n    if (entryName === \"condition\" && extras.ifCondition) {\n      collectConditionDeclsFromClauses(extras.ifCondition.conditions, addDeclWithTrace);\n    } else if (entryName === \"ifcondition\" && extras.performCall) {\n      collectConditionDeclsFromClauses(extras.performCall.ifConditions, addDeclWithTrace);\n    } else if (entryName === \"where\") {\n      if (extras.select) {\n        collectConditionDeclsFromClauses(extras.select.whereConditions, addDeclWithTrace);\n      }\n      if (extras.loopAtItab) {\n        collectConditionDeclsFromClauses(extras.loopAtItab.conditions, addDeclWithTrace);\n      }\n      if (extras.modifyItab) {\n        collectConditionDeclsFromClauses(extras.modifyItab.conditions, addDeclWithTrace);\n      }\n      if (extras.deleteItab) {\n        collectConditionDeclsFromClauses(extras.deleteItab.conditions, addDeclWithTrace);\n      }\n    } else if (entryName === \"having\" && extras.select) {\n      collectConditionDeclsFromClauses(extras.select.havingConditions, addDeclWithTrace);\n    } else if ((entryName === \"withkey\" || entryName === \"withtablekey\") && extras.readTable) {\n      collectConditionDeclsFromClauses(extras.readTable.conditions, addDeclWithTrace);\n    }\n\n    return dedupeDecls(decls);\n  }\n\n  function isRawValueEntry(entry) {\n    const name = entry && entry.name ? String(entry.name).trim() : \"\";\n    return Boolean(name) && /raw$/i.test(name);\n  }\n\n  function makeSectionIndexName(sectionName, indexOneBased) {\n    return `${sectionName}[${indexOneBased}]`;\n  }\n\n  function makeParsedValueRow({\n    sectionName,\n    indexOneBased,\n    valueText,\n    baseEntry,\n    decl,\n    valueDecl,\n    originDecls,\n    valueRef\n  }) {\n    const row = {\n      name: makeSectionIndexName(sectionName, indexOneBased),\n      value: valueText ? String(valueText) : \"\",\n      label: baseEntry && baseEntry.label ? String(baseEntry.label) : sectionName,\n      userDesc: baseEntry && baseEntry.userDesc ? String(baseEntry.userDesc) : \"\",\n      codeDesc: baseEntry && baseEntry.codeDesc ? String(baseEntry.codeDesc) : \"\"\n    };\n\n    if (decl && typeof decl === \"object\") {\n      row.decl = decl;\n    }\n    if (valueDecl && typeof valueDecl === \"object\") {\n      row.valueDecl = valueDecl;\n    }\n    if (Array.isArray(originDecls) && originDecls.length) {\n      row.originDecls = originDecls.filter((item) => item && typeof item === \"object\");\n    }\n    if (valueRef) {\n      row.declRef = String(valueRef);\n    }\n\n    return row;\n  }\n\n  function buildParsedRowsFromPerformList(sectionName, list, baseEntry) {\n    const items = Array.isArray(list) ? list : [];\n    return items.map((item, index) => makeParsedValueRow({\n      sectionName,\n      indexOneBased: index + 1,\n      valueText: item && item.value ? String(item.value) : \"\",\n      baseEntry,\n      decl: item && item.valueDecl ? item.valueDecl : (baseEntry && baseEntry.decl ? baseEntry.decl : null),\n      valueDecl: item && item.valueDecl ? item.valueDecl : null,\n      originDecls: item && Array.isArray(item.originDecls) ? item.originDecls : [],\n      valueRef: item && item.valueRef ? String(item.valueRef) : \"\"\n    }));\n  }\n\n  function buildParsedRowsFromAssignments(sectionName, list, baseEntry) {\n    const items = Array.isArray(list) ? list : [];\n    return items.map((item, index) => {\n      const leftName = item && item.name ? String(item.name) : \"\";\n      const rightValue = item && item.value ? String(item.value) : \"\";\n      const valueText = leftName && rightValue\n        ? `${leftName} = ${rightValue}`\n        : (leftName || rightValue);\n      return makeParsedValueRow({\n        sectionName,\n        indexOneBased: index + 1,\n        valueText,\n        baseEntry,\n        decl: item && item.valueDecl ? item.valueDecl : (baseEntry && baseEntry.decl ? baseEntry.decl : null),\n        valueDecl: item && item.valueDecl ? item.valueDecl : null,\n        originDecls: item && Array.isArray(item.originDecls) ? item.originDecls : [],\n        valueRef: item && item.valueRef ? String(item.valueRef) : \"\"\n      });\n    });\n  }\n\n  function buildParsedRowsFromParams(sectionName, list, baseEntry) {\n    const items = Array.isArray(list) ? list : [];\n    return items.map((param, index) => {\n      const paramName = param && param.name ? String(param.name) : \"\";\n      const typingText = formatTyping(param && param.typing);\n      const valueText = [paramName, typingText].filter(Boolean).join(\" \").trim();\n      const origins = param && Array.isArray(param.originDecls) ? param.originDecls : [];\n      return makeParsedValueRow({\n        sectionName,\n        indexOneBased: index + 1,\n        valueText,\n        baseEntry,\n        decl: origins.length ? origins[0] : (baseEntry && baseEntry.decl ? baseEntry.decl : null),\n        valueDecl: null,\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
