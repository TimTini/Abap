"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/06-render-extras.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    const decls = state.data && typeof state.data === \"object\" && Array.isArray(state.data.decls)\n      ? state.data.decls\n      : [];\n    if (!decls.length) {\n      return null;\n    }\n\n    const upperRef = ref.toUpperCase();\n    let matched = null;\n    for (const candidate of decls) {\n      if (!candidate || typeof candidate !== \"object\") {\n        continue;\n      }\n      const nameUpper = String(candidate.name || \"\").trim().toUpperCase();\n      if (!nameUpper || nameUpper !== upperRef) {\n        continue;\n      }\n\n      if (!matched) {\n        matched = candidate;\n      }\n\n      const scopeUpper = String(candidate.scopeLabel || \"\").trim().toUpperCase();\n      if (scopeUpper === \"GLOBAL\") {\n        return candidate;\n      }\n    }\n\n    return matched;\n  }\n\n  function renderConditionTable(title, clauses, context) {\n    const items = Array.isArray(clauses) ? clauses : [];\n    if (!items.length) {\n      return null;\n    }\n\n    const obj = context && context.obj ? context.obj : null;\n    const extrasScope = context && context.extrasScope ? String(context.extrasScope) : \"extras\";\n    const source = getDeclSourceContextFromObject(obj);\n\n    const section = el(\"div\");\n    if (title) {\n      section.appendChild(el(\"div\", { className: \"muted\", text: title }));\n    }\n\n    const table = el(\"table\");\n    const thead = el(\"thead\");\n    const headRow = el(\"tr\");\n    for (const key of [\n      \"leftOperand\",\n      \"operator\",\n      \"rightOperand\",\n      \"connector\",\n      \"leftRef\",\n      \"leftDeclName\",\n      \"leftDeclDesc\",\n      \"rightRef\",\n      \"rightDeclName\",\n      \"rightDeclDesc\"\n    ]) {\n      headRow.appendChild(el(\"th\", { text: key }));\n    }\n    thead.appendChild(headRow);\n    table.appendChild(thead);\n\n    const tbody = el(\"tbody\");\n    for (let index = 0; index < items.length; index += 1) {\n      const clause = items[index];\n      const clausePath = buildExtrasEntryPathKey(obj, extrasScope, title || \"conditions\", index + 1, \"clause\");\n      let normalizedClause = clause;\n      let leftRef = clause && clause.leftOperandRef ? String(clause.leftOperandRef) : \"\";\n      let rightRef = clause && clause.rightOperandRef ? String(clause.rightOperandRef) : \"\";\n      const row = el(\"tr\");\n      const leftDecl = resolveConditionDeclForViewer(\n        clause && clause.leftOperandDecl ? clause.leftOperandDecl : null,\n        leftRef || (clause && clause.leftOperand ? clause.leftOperand : \"\")\n      );\n      const rightDecl = resolveConditionDeclForViewer(\n        clause && clause.rightOperandDecl ? clause.rightOperandDecl : null,\n        rightRef || (clause && clause.rightOperand ? clause.rightOperand : \"\")\n      );\n      let effectiveLeftDecl = leftDecl;\n      let effectiveRightDecl = rightDecl;\n\n      if (!effectiveLeftDecl || !effectiveRightDecl) {\n        normalizedClause = ensureConditionClauseDeclsWithSynthetic(clause, {\n          pathKey: clausePath,\n          file: source.file,\n          lineStart: source.lineStart,\n          raw: source.raw\n        });\n        leftRef = normalizedClause && normalizedClause.leftOperandRef ? String(normalizedClause.leftOperandRef) : leftRef;\n        rightRef = normalizedClause && normalizedClause.rightOperandRef ? String(normalizedClause.rightOperandRef) : rightRef;\n        if (!effectiveLeftDecl) {\n          effectiveLeftDecl = normalizedClause && normalizedClause.leftOperandDecl\n            ? normalizedClause.leftOperandDecl\n            : null;\n        }\n        if (!effectiveRightDecl) {\n          effectiveRightDecl = normalizedClause && normalizedClause.rightOperandDecl\n            ? normalizedClause.rightOperandDecl\n            : null;\n        }\n      }\n\n      row.appendChild(el(\"td\", { text: normalizedClause && normalizedClause.leftOperand ? String(normalizedClause.leftOperand) : \"\" }));\n      row.appendChild(el(\"td\", { text: normalizedClause && normalizedClause.comparisonOperator ? String(normalizedClause.comparisonOperator) : \"\" }));\n      row.appendChild(el(\"td\", { text: normalizedClause && normalizedClause.rightOperand ? String(normalizedClause.rightOperand) : \"\" }));\n      row.appendChild(el(\"td\", { text: normalizedClause && normalizedClause.logicalConnector ? String(normalizedClause.logicalConnector) : \"\" }));\n      row.appendChild(el(\"td\", { text: leftRef }));\n\n      const leftTraceDecls = buildDeclTraceListForObject(obj, effectiveLeftDecl);\n      const leftDeclCells = renderDeclListCells(leftTraceDecls, effectiveLeftDecl);\n      row.appendChild(leftDeclCells.nameCell);\n      row.appendChild(leftDeclCells.descCell);\n\n      row.appendChild(el(\"td\", { text: rightRef }));\n      const rightTraceDecls = buildDeclTraceListForObject(obj, effectiveRightDecl);\n      const rightDeclCells = renderDeclListCells(rightTraceDecls, effectiveRightDecl);\n      row.appendChild(rightDeclCells.nameCell);\n      row.appendChild(rightDeclCells.descCell);\n\n      tbody.appendChild(row);\n    }\n\n    table.appendChild(tbody);\n    section.appendChild(table);\n    return section;\n  }\n\n  function appendConditionSection(wrap, title, rawText, clauses, context) {\n    if (!wrap) {\n      return;\n    }\n\n    const raw = String(rawText || \"\").trim();\n    if (raw) {\n      wrap.appendChild(el(\"div\", { className: \"muted\", text: raw }));\n    }\n\n    const table = renderConditionTable(title, clauses, context);\n    if (table) {\n      wrap.appendChild(table);\n    }\n  }\n\n  function renderParamsTable(title, params) {\n    const items = Array.isArray(params) ? params : [];\n    if (!items.length) {\n      return null;\n    }\n\n    const section = el(\"div\");\n    section.appendChild(el(\"div\", { className: \"muted\", text: title }));\n\n    const table = el(\"table\");\n    const thead = el(\"thead\");\n    const headRow = el(\"tr\");\n    for (const key of [\"section\", \"name\", \"typing\", \"doc\", \"declName\", \"declDesc\"]) {\n      headRow.appendChild(el(\"th\", { text: key }));\n    }\n    thead.appendChild(headRow);\n    table.appendChild(thead);\n\n    const tbody = el(\"tbody\");\n    for (const param of items) {\n      const row = el(\"tr\");\n      row.appendChild(el(\"td\", { text: param && param.section ? String(param.section) : \"\" }));\n      row.appendChild(el(\"td\", { text: param && param.name ? String(param.name) : \"\" }));\n      const typingText = formatTyping(param && param.typing);\n      row.appendChild(el(\"td\", { text: typingText }));\n      const docText = param && param.doc\n        ? [param.doc.direction || \"\", param.doc.text || \"\"].filter(Boolean).join(\" \")\n        : \"\";\n      row.appendChild(el(\"td\", { text: docText }));\n      const { nameCell, descCell } = renderDeclListCells(param && param.originDecls);\n      row.appendChild(nameCell);\n      row.appendChild(descCell);\n      tbody.appendChild(row);\n    }\n    table.appendChild(tbody);\n    section.appendChild(table);\n    return section;\n  }\n\n  function formatTyping(typing) {\n    if (!typing) {\n      return \"\";\n    }\n    if (typeof typing === \"string\") {\n      return typing;\n    }\n    if (Array.isArray(typing)) {\n      return typing.map((item) => formatTyping(item)).filter(Boolean).join(\" \");\n    }\n    if (typeof typing === \"object\") {\n      const kind = typing.kind ? String(typing.kind) : \"\";\n      let value = \"\";\n\n      if (typeof typing.value === \"string\") {\n        value = typing.value;\n      } else if (typing.value && typeof typing.value === \"object\") {\n        if (typeof typing.value.value === \"string\") {\n          value = typing.value.value;\n        } else if (typeof typing.value.raw === \"string\") {\n          value = typing.value.raw;\n        } else if (typeof typing.value.name === \"string\") {\n          value = typing.value.name;\n        } else {\n          value = safeJson(typing.value, false);\n        }\n      } else if (typing.value !== undefined && typing.value !== null) {\n        value = String(typing.value);\n      }\n\n      return [kind, value].filter(Boolean).join(\" \").trim();\n    }\n    return String(typing);\n  }\n\n  function renderNameList(title, items) {\n    const list = Array.isArray(items) ? items : [];\n    if (!list.length) {\n      return null;\n    }\n\n    const section = el(\"div\");\n    section.appendChild(el(\"div\", { className: \"muted\", text: title }));\n\n    const wrap = el(\"div\");\n    for (const entry of list) {\n      wrap.appendChild(el(\"span\", { className: \"pill\", text: entry && entry.name ? String(entry.name) : \"\" }));\n    }\n    section.appendChild(wrap);\n    return section;\n  }\n\n  function renderExtras(obj) {\n    const extras = obj.extras;\n    if (!extras || typeof extras !== \"object\") {\n      return null;\n    }\n\n    const wrap = el(\"div\", { className: \"extras\" });\n    wrap.appendChild(el(\"div\", { className: \"muted\", text: \"Extras\" }));\n\n    if (extras.form) {\n      const form = extras.form;\n      const titleParts = [form.name ? `FORM ${form.name}` : \"\"].filter(Boolean);\n      if (form.nameFromComment && form.nameFromComment !== form.name) {\n        titleParts.push(`(comment: ${form.nameFromComment})`);\n      }\n      if (titleParts.length) {\n        wrap.appendChild(el(\"div\", { className: \"muted\", text: titleParts.join(\" \") }));\n      }\n\n      const paramsTable = renderParamsTable(\"params\", form.params);\n      if (paramsTable) {\n        wrap.appendChild(paramsTable);\n      }\n\n      const exceptions = renderNameList(\"exceptions\", form.exceptions);\n      if (exceptions) {\n        wrap.appendChild(exceptions);\n      }\n\n      return wrap;\n    }\n\n    if (extras.methodSignature) {\n      const signature = extras.methodSignature;\n      if (signature.name) {\n        wrap.appendChild(el(\"div\", { className: \"muted\", text: `METHOD ${signature.name}` }));\n      }\n\n      const paramsTable = renderParamsTable(\"params\", signature.params);\n      if (paramsTable) {\n        wrap.appendChild(paramsTable);\n      }\n\n      const exceptions = renderNameList(\"exceptions\", signature.exceptions);\n      if (exceptions) {\n        wrap.appendChild(exceptions);\n      }\n\n      return wrap;\n    }\n\n    if (extras.callFunction) {\n      const call = extras.callFunction;\n      wrap.appendChild(el(\"div\", { className: \"muted\", text: call.name ? `CALL FUNCTION ${call.name}` : \"CALL FUNCTION\" }));\n      if (call.destination) {\n        wrap.appendChild(el(\"div\", { className: \"muted\", text: `DESTINATION ${call.destination}` }));\n      }\n\n      for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"tables\", \"exceptions\"]) {\n        const table = renderAssignmentTable(sectionName, call[sectionName], { obj, extrasScope: \"callFunction\" });\n        if (table) {\n          wrap.appendChild(table);\n        }\n      }\n\n      return wrap;\n    }\n\n    if (extras.callMethod) {\n      const call = extras.callMethod;\n      wrap.appendChild(el(\"div\", { className: \"muted\", text: call.target ? `CALL METHOD ${call.target}` : \"CALL METHOD\" }));\n\n      for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"receiving\", \"exceptions\"]) {\n        const table = renderAssignmentTable(sectionName, call[sectionName], { obj, extrasScope: \"callMethod\" });\n        if (table) {\n          wrap.appendChild(table);\n        }\n      }\n\n      return wrap;\n    }\n\n    if (extras.performCall) {\n      const call = extras.performCall;\n      wrap.appendChild(el(\"div\", { className: \"muted\", text: call.form ? `PERFORM ${call.form}` : \"PERFORM\" }));\n      if (call.program) {\n        wrap.appendChild(el(\"div\", { className: \"muted\", text: `IN PROGRAM ${call.program}` }));\n      }\n      appendConditionSection(\n        wrap,\n        \"ifConditions\",\n        call.ifCondition ? `IF ${call.ifCondition}` : \"\",\n        call.ifConditions,\n        { obj, extrasScope: \"performCall\" }\n      );\n\n      for (const sectionName of [\"using\", \"changing\", \"tables\"]) {\n        const table = renderValueListTable(sectionName, call[sectionName], { obj, extrasScope: \"performCall\" });\n        if (table) {\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
