"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/02-descriptions.js";
  const partKey = "viewer/app/descriptions/04-panel-render.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    const opts = {\n      expandPerformForms: true,\n      hideFormRoots: true,\n      maxExpandDepth: Number.POSITIVE_INFINITY,\n      ...(options && typeof options === \"object\" ? options : {})\n    };\n    const maxExpandDepth = Math.max(0, Number(opts.maxExpandDepth) || 0);\n    const formsByNameUpper = opts.expandPerformForms ? buildFormsByNameUpperFromRoots(roots) : new Map();\n    var PERFORM_TRACE_META_KEY_DESC = \"__abapPerformTraceBinding\";\n\n    const getDeclIdentityKey = (decl) => {\n      if (!decl || typeof decl !== \"object\") {\n        return \"\";\n      }\n      return [\n        decl.objectType || \"\",\n        decl.scopeLabel || \"\",\n        decl.name || \"\",\n        decl.file || \"\",\n        decl.lineStart || \"\"\n      ].join(\"|\");\n    };\n\n    const dedupeDeclList = (list) => {\n      const out = [];\n      const seen = new Set();\n      for (const decl of Array.isArray(list) ? list : []) {\n        if (!decl || typeof decl !== \"object\") {\n          continue;\n        }\n        const key = getDeclIdentityKey(decl);\n        if (!key || seen.has(key)) {\n          continue;\n        }\n        seen.add(key);\n        out.push(decl);\n      }\n      return out;\n    };\n\n    const resolveActualTraceDecls = (actualEntry, currentBindingContext) => {\n      if (!actualEntry || typeof actualEntry !== \"object\") {\n        return [];\n      }\n\n      const out = [];\n      const pushDecl = (decl) => {\n        if (decl && typeof decl === \"object\") {\n          out.push(decl);\n        }\n      };\n      const pushList = (decls) => {\n        for (const decl of Array.isArray(decls) ? decls : []) {\n          pushDecl(decl);\n        }\n      };\n\n      const valueDecl = actualEntry.valueDecl && typeof actualEntry.valueDecl === \"object\"\n        ? actualEntry.valueDecl\n        : null;\n      if (!valueDecl) {\n        pushList(actualEntry.originDecls);\n        return dedupeDeclList(out);\n      }\n\n      pushDecl(valueDecl);\n\n      const valueDeclType = String(valueDecl.objectType || \"\").toUpperCase();\n      if (valueDeclType === \"FORM_PARAM\") {\n        const paramUpper = String(valueDecl.name || \"\").trim().toUpperCase();\n        const byParamUpper = currentBindingContext && currentBindingContext.byParamUpper instanceof Map\n          ? currentBindingContext.byParamUpper\n          : null;\n        const externalDecls = byParamUpper && paramUpper ? byParamUpper.get(paramUpper) : null;\n        if (Array.isArray(externalDecls) && externalDecls.length) {\n          pushList(externalDecls);\n        } else {\n          pushList(actualEntry.originDecls);\n        }\n      } else {\n        pushList(actualEntry.originDecls);\n      }\n\n      return dedupeDeclList(out);\n    };\n\n    const buildPerformBindingContext = (performNode, resolvedForm, currentBindingContext) => {\n      if (!performNode || !resolvedForm) {\n        return null;\n      }\n\n      const call = performNode.extras && performNode.extras.performCall && typeof performNode.extras.performCall === \"object\"\n        ? performNode.extras.performCall\n        : null;\n      const formExtras = resolvedForm.extras && resolvedForm.extras.form && typeof resolvedForm.extras.form === \"object\"\n        ? resolvedForm.extras.form\n        : null;\n      const params = formExtras && Array.isArray(formExtras.params) ? formExtras.params : [];\n      if (!call || !params.length) {\n        return null;\n      }\n\n      const bySection = {\n        USING: [],\n        CHANGING: [],\n        TABLES: []\n      };\n      for (const param of params) {\n        if (!param || !param.name) {\n          continue;\n        }\n        const section = String(param.section || \"\").trim().toUpperCase();\n        if (!Object.prototype.hasOwnProperty.call(bySection, section)) {\n          continue;\n        }\n        bySection[section].push(param);\n      }\n\n      const byParamUpper = new Map();\n      for (const section of [\"USING\", \"CHANGING\", \"TABLES\"]) {\n        const formalParams = bySection[section] || [];\n        const actualArgs = Array.isArray(call[section.toLowerCase()]) ? call[section.toLowerCase()] : [];\n        const max = Math.min(formalParams.length, actualArgs.length);\n        for (let index = 0; index < max; index += 1) {\n          const formalParam = formalParams[index];\n          const actualArg = actualArgs[index];\n          if (!formalParam || !formalParam.name || !actualArg) {\n            continue;\n          }\n          const paramUpper = String(formalParam.name || \"\").trim().toUpperCase();\n          if (!paramUpper) {\n            continue;\n          }\n          const traceDecls = resolveActualTraceDecls(actualArg, currentBindingContext);\n          if (!traceDecls.length) {\n            continue;\n          }\n          byParamUpper.set(paramUpper, traceDecls);\n        }\n      }\n\n      if (!byParamUpper.size) {\n        return null;\n      }\n\n      return {\n        byParamUpper\n      };\n    };\n\n    const attachPerformBindingMetadata = (node, bindingContext) => {\n      if (!node || typeof node !== \"object\" || !bindingContext || !bindingContext.byParamUpper) {\n        return;\n      }\n      try {\n        Object.defineProperty(node, PERFORM_TRACE_META_KEY_DESC, {\n          value: bindingContext,\n          enumerable: false,\n          configurable: true\n        });\n      } catch {\n        // ignore metadata errors; rendering should keep working without trace metadata.\n      }\n    };\n\n    const cloneNode = (sourceNode, parentId, expandDepth, pathToken, forceSyntheticId, formCallStack, bindingContext) => {\n      if (!sourceNode || typeof sourceNode !== \"object\") {\n        return null;\n      }\n\n      if (opts.hideFormRoots && sourceNode.objectType === \"FORM\" && !forceSyntheticId) {\n        return null;\n      }\n\n      const out = {};\n      for (const key of Object.keys(sourceNode)) {\n        if (key === \"children\") {\n          continue;\n        }\n        out[key] = sourceNode[key];\n      }\n\n      if (forceSyntheticId) {\n        out.id = `PERFORM_EXPANDED:${pathToken}`;\n      }\n\n      if (parentId !== undefined) {\n        out.parent = parentId;\n      }\n      attachPerformBindingMetadata(out, bindingContext);\n\n      const ownId = out.id !== null && out.id !== undefined && String(out.id).trim() ? out.id : undefined;\n      const outChildren = [];\n\n      const sourceChildren = Array.isArray(sourceNode.children) ? sourceNode.children : [];\n      for (let index = 0; index < sourceChildren.length; index += 1) {\n        const child = sourceChildren[index];\n        const childPath = `${pathToken}.C${index}`;\n        const clonedChild = cloneNode(child, ownId, expandDepth, childPath, forceSyntheticId, formCallStack, bindingContext);\n        if (clonedChild) {\n          outChildren.push(clonedChild);\n        }\n      }\n\n      if (\n        opts.expandPerformForms &&\n        sourceNode.objectType === \"PERFORM\" &&\n        expandDepth < maxExpandDepth\n      ) {\n        const formName = getPerformFormNameFromNode(sourceNode);\n        const programName = getPerformProgramFromNode(sourceNode);\n        const formNameUpper = formName ? formName.toUpperCase() : \"\";\n        const resolvedForm = !programName && formNameUpper ? formsByNameUpper.get(formNameUpper) : null;\n        const isRecursiveCall = Boolean(formNameUpper) && Array.isArray(formCallStack) && formCallStack.includes(formNameUpper);\n\n        if (resolvedForm && !isRecursiveCall) {\n          const nextBindingContext = buildPerformBindingContext(sourceNode, resolvedForm, bindingContext);\n          const nextFormCallStack = formNameUpper\n            ? [...(Array.isArray(formCallStack) ? formCallStack : []), formNameUpper]\n            : (Array.isArray(formCallStack) ? formCallStack.slice() : []);\n          const formChildren = Array.isArray(resolvedForm.children) ? resolvedForm.children : [];\n          for (let index = 0; index < formChildren.length; index += 1) {\n            const formChild = formChildren[index];\n            const expandedPath = `${pathToken}.FORM:${formNameUpper}.C${index}`;\n            const clonedExpandedChild = cloneNode(\n              formChild,\n              ownId,\n              expandDepth + 1,\n              expandedPath,\n              true,\n              nextFormCallStack,\n              nextBindingContext\n            );\n            if (clonedExpandedChild) {\n              outChildren.push(clonedExpandedChild);\n            }\n          }\n        }\n      }\n\n      if (outChildren.length) {\n        out.children = outChildren;\n      } else if (Array.isArray(sourceNode.children)) {\n        out.children = [];\n      }\n\n      return out;\n    };\n\n    const output = [];\n    for (let index = 0; index < roots.length; index += 1) {\n      const root = roots[index];\n      const clonedRoot = cloneNode(root, null, 0, `ROOT${index}`, false, [], null);\n      if (clonedRoot) {\n        output.push(clonedRoot);\n      }\n    }\n\n    return output;\n  }\n\n  function buildXmlExportRoots(objects) {\n    const input = Array.isArray(objects) ? objects : [];\n    if (!input.length) {\n      return [];\n    }\n\n    const nodeById = new Map();\n    const idOrder = [];\n    const childIdsByParentId = new Map();\n    const topLevelNoIdNodes = [];\n\n    const pushChildId = (parentId, childId) => {\n      if (!parentId || !childId) {\n        return;\n      }\n      if (!childIdsByParentId.has(parentId)) {\n        childIdsByParentId.set(parentId, []);\n      }\n      const list = childIdsByParentId.get(parentId);\n      if (!list.includes(childId)) {\n        list.push(childId);\n      }\n    };\n\n    const stack = input\n      .filter((node) => node && typeof node === \"object\")\n      .map((node) => ({ node, isTopLevel: true }));\n\n    while (stack.length) {\n      const item = stack.pop();\n      const node = item && item.node;\n      if (!node || typeof node !== \"object\") {\n        continue;\n      }\n\n      const nodeId = normalizeXmlObjectId(node.id);\n      if (!nodeId) {\n        if (item.isTopLevel) {\n          topLevelNoIdNodes.push(node);\n        }\n      } else if (!nodeById.has(nodeId)) {\n        nodeById.set(nodeId, node);\n        idOrder.push(nodeId);\n      }\n\n      const parentId = normalizeXmlObjectId(node.parent);\n      if (nodeId && parentId) {\n        pushChildId(parentId, nodeId);\n      }\n\n      const children = Array.isArray(node.children) ? node.children : [];\n      for (let index = children.length - 1; index >= 0; index -= 1) {\n        const child = children[index];\n        if (!child || typeof child !== \"object\") {\n          continue;\n        }\n        const childId = normalizeXmlObjectId(child.id);\n        if (nodeId && childId) {\n          pushChildId(nodeId, childId);\n        }\n        stack.push({ node: child, isTopLevel: false });\n      }\n    }\n\n    if (!nodeById.size) {\n      return input.slice();\n    }\n\n    const cloneNodeNoId = (node, seenNoId) => {\n      if (!node || typeof node !== \"object\") {\n        return node;\n      }\n      if (seenNoId.has(node)) {\n        return null;\n      }\n\n      const nextSeenNoId = new Set(seenNoId);\n      nextSeenNoId.add(node);\n\n      const out = {};\n      for (const key of Object.keys(node)) {\n        if (key === \"children\") {\n          continue;\n        }\n        out[key] = node[key];\n      }\n\n      const children = Array.isArray(node.children) ? node.children : [];\n      const outChildren = [];\n      for (const child of children) {\n        if (!child || typeof child !== \"object\") {\n          continue;\n        }\n        const childId = normalizeXmlObjectId(child.id);\n        if (childId) {\n          // ID-based children are wired later from parent map.\n          continue;\n        }\n        const cloned = cloneNodeNoId(child, nextSeenNoId);\n        if (cloned) {\n          outChildren.push(cloned);\n        }\n      }\n\n      if (outChildren.length) {\n        out.children = outChildren;\n      } else if (Array.isArray(node.children) && node.children.length === 0) {\n        out.children = [];\n      }\n\n      return out;\n    };\n\n    const cloneNodeById = (nodeId, ancestorIds, emittedIds) => {\n      if (!nodeId || !nodeById.has(nodeId)) {\n        return null;\n      }\n      if (ancestorIds.has(nodeId)) {\n        return null;\n      }\n      if (emittedIds && emittedIds.has(nodeId)) {\n        return null;\n      }\n\n      const node = nodeById.get(nodeId);\n      const nextAncestors = new Set(ancestorIds);\n      nextAncestors.add(nodeId);\n      if (emittedIds) {\n        emittedIds.add(nodeId);\n      }\n\n      const out = {};\n      for (const key of Object.keys(node)) {\n        if (key === \"children\") {\n          continue;\n        }\n        out[key] = node[key];\n      }\n\n      const outChildren = [];\n\n      const explicitChildren = Array.isArray(node.children) ? node.children : [];\n      for (const child of explicitChildren) {\n        if (!child || typeof child !== \"object\") {\n          continue;\n        }\n        const childId = normalizeXmlObjectId(child.id);\n        if (childId) {\n          continue;\n        }\n        const clonedNoId = cloneNodeNoId(child, new Set());\n        if (clonedNoId) {\n          outChildren.push(clonedNoId);\n        }\n      }\n\n      const childIds = childIdsByParentId.get(nodeId) || [];\n      for (const childId of childIds) {\n        const cloned = cloneNodeById(childId, nextAncestors, emittedIds);\n        if (cloned) {\n          outChildren.push(cloned);\n        }\n      }\n\n      if (outChildren.length) {\n        out.children = outChildren;\n      } else if (Array.isArray(node.children) && node.children.length === 0) {\n        out.children = [];\n      }\n\n      return out;\n    };\n\n    const isRootId = (nodeId) => {\n      const node = nodeById.get(nodeId);\n      if (!node) {\n        return false;\n      }\n      const parentId = normalizeXmlObjectId(node.parent);\n      return !parentId || !nodeById.has(parentId);\n    };\n\n    const rootIds = [];\n    const addedRootIds = new Set();\n    const addRootId = (nodeId) => {\n      if (!nodeId || addedRootIds.has(nodeId) || !nodeById.has(nodeId)) {\n        return;\n      }\n      addedRootIds.add(nodeId);\n      rootIds.push(nodeId);\n    };\n\n    for (const topNode of input) {\n      const topId = normalizeXmlObjectId(topNode && topNode.id);\n      if (topId && isRootId(topId)) {\n        addRootId(topId);\n      }\n    }\n\n    for (const nodeId of idOrder) {\n      if (isRootId(nodeId)) {\n        addRootId(nodeId);\n      }\n    }\n\n    const reachableIds = new Set();\n    const markReachable = (nodeId) => {\n      if (!nodeId || reachableIds.has(nodeId) || !nodeById.has(nodeId)) {\n        return;\n      }\n      reachableIds.add(nodeId);\n      const childIds = childIdsByParentId.get(nodeId) || [];\n      for (const childId of childIds) {\n        markReachable(childId);\n      }\n    };\n\n    for (const rootId of rootIds) {\n      markReachable(rootId);\n    }\n\n    for (const nodeId of idOrder) {\n      if (!reachableIds.has(nodeId)) {\n        addRootId(nodeId);\n        markReachable(nodeId);\n      }\n    }\n\n    const roots = [];\n    const emittedIds = new Set();\n    for (const node of topLevelNoIdNodes) {\n      const cloned = cloneNodeNoId(node, new Set());\n      if (cloned) {\n        roots.push(cloned);\n      }\n    }\n    for (const rootId of rootIds) {\n      const cloned = cloneNodeById(rootId, new Set(), emittedIds);\n      if (cloned) {\n        roots.push(cloned);\n      }\n    }\n\n    return roots;\n  }\n\n  function isDeclLikeObject(value) {\n    if (!value || typeof value !== \"object\") {\n      return false;\n    }\n    return (\n      typeof value.objectType === \"string\" &&\n      typeof value.name === \"string\" &&\n      typeof value.scopeLabel === \"string\"\n    );\n  }\n\n  function isDeclHintKey(keyHint) {\n    const key = String(keyHint || \"\").trim();\n    if (!key) {\n      return false;\n    }\n    return /decl$/i.test(key);\n  }\n\n  function isDeclObjectForXml(keyHint, value) {\n    if (isDeclLikeObject(value)) {\n      return true;\n    }\n    if (!isDeclHintKey(keyHint) || !value || typeof value !== \"object\" || Array.isArray(value)) {\n      return false;\n    }\n    return (\n      typeof value.name === \"string\" ||\n      typeof value.objectType === \"string\" ||\n      typeof value.scopeLabel === \"string\" ||\n      typeof value.comment === \"string\"\n    );\n  }\n\n  function hasValueLevelDescFields(value) {\n    if (!value || typeof value !== \"object\" || Array.isArray(value)) {\n      return false;\n    }\n    return (\n      Object.prototype.hasOwnProperty.call(value, \"userDesc\") ||\n      Object.prototype.hasOwnProperty.call(value, \"codeDesc\")\n    );\n  }\n\n  function resolveValueLevelTechId(value) {\n    if (!value || typeof value !== \"object\") {\n      return \"\";\n    }\n\n    if (isDeclLikeObject(value.decl)) {\n      const declTech = String(getDeclTechName(value.decl) || \"\").trim();\n      if (declTech) {\n        return declTech;\n      }\n    }\n\n    const declRef = String(value.declRef || \"\").trim();\n    if (declRef) {\n      return declRef;\n    }\n\n    const identifier = extractIdentifierCandidate(value.value);\n    if (identifier) {\n      return identifier;\n    }\n\n    const rawValue = String(value.value || \"\").trim();\n    if (rawValue) {\n      return rawValue;\n    }\n\n    const fallbackName = String(value.name || \"\").trim();\n    return fallbackName;\n  }\n\n  const VALUE_LEVEL_IDENTIFIER_REGEX =\n    /<[^>]+>(?:(?:->|=>|~|-)[A-Za-z_][A-Za-z0-9_]*)*|SY-[A-Za-z_][A-Za-z0-9_]*|[A-Za-z_][A-Za-z0-9_]*(?:(?:->|=>|~|-)[A-Za-z_][A-Za-z0-9_]*)*/g;\n\n  function normalizeValueIdentifierKey(text) {\n    return String(text || \"\").trim().toUpperCase();\n  }\n\n  function buildValueLevelDeclReplacementMap(value, rawValueText) {\n    if (!value || typeof value !== \"object\" || !isDeclLikeObject(value.decl)) {\n      return null;\n    }\n\n    const replacement = String(getFinalDeclDesc(value.decl) || getDeclTechName(value.decl) || \"\").trim();\n    if (!replacement) {\n      return null;\n    }\n\n    const map = Object.create(null);\n    const register = (token) => {\n      const key = normalizeValueIdentifierKey(token);\n      if (!key) {\n        return;\n      }\n      map[key] = replacement;\n    };\n\n    register(value.declRef);\n    register(value.decl && value.decl.name);\n    register(extractIdentifierCandidate(rawValueText));\n\n    return Object.keys(map).length ? map : null;\n  }\n\n  function replaceIdentifiersOutsideLiterals(rawText, replacementMap) {\n    const text = String(rawText || \"\");\n    if (!text || !replacementMap || typeof replacementMap !== \"object\") {\n      return \"\";\n    }\n\n    let out = \"\";\n    let i = 0;\n    const length = text.length;\n\n    const replaceSegment = (segment) => segment.replace(VALUE_LEVEL_IDENTIFIER_REGEX, (token) => {\n      const key = normalizeValueIdentifierKey(token);\n      if (key && Object.prototype.hasOwnProperty.call(replacementMap, key)) {\n        return replacementMap[key];\n      }\n      return token;\n    });\n\n    while (i < length) {\n      const ch = text[i];\n\n      if (ch === \"'\" || ch === \"|\") {\n        const quote = ch;\n        const start = i;\n        i += 1;\n        while (i < length) {\n          if (text[i] !== quote) {\n            i += 1;\n            continue;\n          }\n          if (quote === \"'\" && i + 1 < length && text[i + 1] === \"'\") {\n            i += 2;\n            continue;\n          }\n          i += 1;\n          break;\n        }\n        out += text.slice(start, i);\n        continue;\n      }\n\n      const start = i;\n      while (i < length && text[i] !== \"'\" && text[i] !== \"|\") {\n        i += 1;\n      }\n      out += replaceSegment(text.slice(start, i));\n    }\n\n    return out;\n  }\n\n  function resolveValueLevelFinalDesc(value) {\n    if (!value || typeof value !== \"object\") {\n      return \"\";\n    }\n\n    const userDesc = String(value.userDesc || \"\").trim();\n    if (userDesc) {\n      const decl = value.decl;\n      if (decl && typeof decl === \"object\" && typeof normalizeDeclDescByTemplate === \"function\") {\n        const normalizedUserDesc = String(normalizeDeclDescByTemplate(decl, userDesc) || \"\").trim();\n        return normalizedUserDesc || userDesc;\n      }\n      return userDesc;\n    }\n\n    const codeDesc = String(value.codeDesc || \"\").trim();\n    if (codeDesc) {\n      return codeDesc;\n    }\n\n    const rawValueText = String(value.value || \"\");\n    if (rawValueText.trim()) {\n      const replacementMap = buildValueLevelDeclReplacementMap(value, rawValueText);\n      if (replacementMap) {\n        const replaced = replaceIdentifiersOutsideLiterals(rawValueText, replacementMap).trim();\n        if (replaced) {\n          return replaced;\n        }\n      }\n    }\n\n    return resolveValueLevelTechId(value);\n  }\n\nwindow.AbapViewerModules.factories = window.AbapViewerModules.factories || {};\nwindow.AbapViewerModules.factories[\"02-descriptions\"] = function registerDescriptions(runtime) {\n  const targetRuntime = runtime || (window.AbapViewerRuntime = window.AbapViewerRuntime || {});\n  targetRuntime.api = targetRuntime.api || {};\n  targetRuntime.api.renderDeclDescPanelUi = renderDeclDescPanelUi;\n  targetRuntime.api.getFinalDeclDesc = getFinalDeclDesc;\n  targetRuntime.api.getEffectiveDeclDesc = getEffectiveDeclDesc;\n  targetRuntime.api.resolveValueLevelFinalDesc = resolveValueLevelFinalDesc;\n  window.AbapViewerModules.parts[\"02-descriptions\"] = true;\n};\nwindow.AbapViewerModules.factories[\"02-descriptions\"](window.AbapViewerRuntime);\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
