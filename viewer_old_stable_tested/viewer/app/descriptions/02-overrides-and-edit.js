"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/02-descriptions.js";
  const partKey = "viewer/app/descriptions/02-overrides-and-edit.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    const nameInputs = els.settingsNameTemplates\n      ? els.settingsNameTemplates.querySelectorAll(\"input[data-code]\")\n      : [];\n\n    for (const input of Array.from(nameInputs)) {\n      const code = String(input.getAttribute(\"data-code\") || \"\").trim().toUpperCase();\n      if (!code) {\n        continue;\n      }\n      next.nameTemplatesByCode[code] = String(input.value || \"\");\n    }\n\n    state.settings = normalizeSettings(next);\n    saveSettings(state.settings);\n    state.haystackById = buildSearchIndex(state.renderObjects);\n    renderOutput();\n  }\n\n  function resetSettingsToDefault() {\n    state.settings = normalizeSettings(DEFAULT_SETTINGS);\n    saveSettings(state.settings);\n    renderSettingsModalUi();\n    state.haystackById = buildSearchIndex(state.renderObjects);\n    renderOutput();\n  }\n\n  function normalizeKeyToken(value) {\n    return String(value || \"\").trim().toUpperCase();\n  }\n\n  function getDeclFallbackKey(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const name = normalizeKeyToken(decl.name);\n    if (!name) {\n      return \"\";\n    }\n\n    const objectType = normalizeKeyToken(decl.objectType);\n    const file = String(decl.file || \"\").trim();\n    const line = decl.lineStart ? String(decl.lineStart) : \"\";\n    return `FALLBACK:${objectType}|${name}|${file}|${line}`;\n  }\n\n  function getDeclKey(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const scope = normalizeKeyToken(decl.scopeLabel);\n    const name = normalizeKeyToken(decl.name);\n\n    if (!scope || !name) {\n      return \"\";\n    }\n\n    return `${scope}:${name}`;\n  }\n\n  function getLegacyDeclKey(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const type = normalizeKeyToken(decl.objectType);\n    const name = normalizeKeyToken(decl.name);\n\n    if (!type || !name) {\n      return \"\";\n    }\n\n    return `${type}:NAME:${name}`;\n  }\n\n  function getDeclOverrideLookupKeys(decl) {\n    const keys = [];\n    const pushKey = (value) => {\n      const key = String(value || \"\").trim();\n      if (!key || keys.includes(key)) {\n        return;\n      }\n      keys.push(key);\n    };\n\n    pushKey(getDeclKey(decl));\n    pushKey(getLegacyDeclKey(decl));\n    pushKey(getDeclFallbackKey(decl));\n    return keys;\n  }\n\n  function getDeclOverrideStorageKey(decl) {\n    const keys = getDeclOverrideLookupKeys(decl);\n    return keys.length ? keys[0] : \"\";\n  }\n\n  function normalizeDescOverrideEntry(value) {\n    if (typeof value === \"string\") {\n      return { text: String(value || \"\"), noNormalize: false };\n    }\n    if (!value || typeof value !== \"object\" || Array.isArray(value)) {\n      return { text: \"\", noNormalize: false };\n    }\n\n    const text = typeof value.text === \"string\"\n      ? value.text\n      : typeof value.desc === \"string\"\n        ? value.desc\n        : typeof value.value === \"string\"\n          ? value.value\n          : \"\";\n\n    const noNormalize = Boolean(value.noNormalize || value.skipNormalize || value.disableNormalize || value.no_normalize);\n    return { text: String(text || \"\"), noNormalize };\n  }\n\n  function getDeclOverrideEntry(decl) {\n    const keys = getDeclOverrideLookupKeys(decl);\n    for (const key of keys) {\n      if (key && Object.prototype.hasOwnProperty.call(state.descOverrides || {}, key)) {\n        return normalizeDescOverrideEntry(state.descOverrides[key]);\n      }\n    }\n\n    const legacyKey = getLegacyDeclKey(decl);\n    if (legacyKey && Object.prototype.hasOwnProperty.call(state.descOverridesLegacy || {}, legacyKey)) {\n      return { text: String(state.descOverridesLegacy[legacyKey] || \"\"), noNormalize: false };\n    }\n\n    return { text: \"\", noNormalize: false };\n  }\n\n  function getDeclOverrideDesc(decl) {\n    return getDeclOverrideEntry(decl).text;\n  }\n\n  function getDeclOverrideNoNormalize(decl) {\n    return Boolean(getDeclOverrideEntry(decl).noNormalize);\n  }\n\n  function getBaseDeclDesc(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const objectType = normalizeKeyToken(decl.objectType);\n    const scopeType = normalizeKeyToken(decl.scopeType);\n    if (objectType === \"PATH_DECL\" || scopeType === \"PATH\") {\n      return \"\";\n    }\n\n    const registry = window.AbapVarDescriptions && typeof window.AbapVarDescriptions === \"object\"\n      ? window.AbapVarDescriptions\n      : null;\n    if (!registry) {\n      return \"\";\n    }\n\n    const nameUpper = normalizeKeyToken(decl.name);\n    if (!nameUpper) {\n      return \"\";\n    }\n\n    const scopeLabel = normalizeKeyToken(decl.scopeLabel);\n\n    if (objectType === \"SYSTEM\" || scopeLabel === \"SYSTEM\") {\n      const systemMap = registry.system && typeof registry.system === \"object\" ? registry.system : null;\n      if (systemMap && Object.prototype.hasOwnProperty.call(systemMap, nameUpper)) {\n        return String(systemMap[nameUpper] || \"\");\n      }\n    }\n\n    const byScope = registry.customByScope && typeof registry.customByScope === \"object\" ? registry.customByScope : null;\n    if (byScope && scopeLabel && Object.prototype.hasOwnProperty.call(byScope, scopeLabel)) {\n      const scopeMap = byScope[scopeLabel];\n      if (scopeMap && typeof scopeMap === \"object\" && Object.prototype.hasOwnProperty.call(scopeMap, nameUpper)) {\n        return String(scopeMap[nameUpper] || \"\");\n      }\n    }\n\n    const globalMap = registry.customGlobal && typeof registry.customGlobal === \"object\" ? registry.customGlobal : null;\n    if (globalMap && Object.prototype.hasOwnProperty.call(globalMap, nameUpper)) {\n      return String(globalMap[nameUpper] || \"\");\n    }\n\n    return \"\";\n  }\n\n  function getSourceDeclDesc(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n    return decl.comment ? String(decl.comment) : \"\";\n  }\n\n  function normalizeDeclDescText(decl, text) {\n    const settings = state.settings || DEFAULT_SETTINGS;\n    if (!settings.normalizeDeclDesc) {\n      return String(text || \"\").trim();\n    }\n    return normalizeDeclDescByTemplate(decl, text);\n  }\n\n  function stripDeclTemplateAffixes(text, template) {\n    const raw = String(text || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const tpl = String(template || \"\");\n    const marker = \"{{desc}}\";\n    const markerIndex = tpl.indexOf(marker);\n    if (markerIndex === -1) {\n      return raw;\n    }\n\n    const prefix = tpl.slice(0, markerIndex).trim();\n    const suffix = tpl.slice(markerIndex + marker.length).trim();\n\n    let next = raw;\n    if (prefix && next.toLowerCase().startsWith(prefix.toLowerCase())) {\n      next = next.slice(prefix.length).trim();\n    }\n    if (\n      suffix &&\n      next.length >= suffix.length &&\n      next.toLowerCase().endsWith(suffix.toLowerCase())\n    ) {\n      next = next.slice(0, next.length - suffix.length).trim();\n    }\n\n    return next || raw;\n  }\n\n  function normalizeDeclDescByTemplate(decl, text) {\n    const descTrimmed = String(text || \"\").trim();\n    if (!descTrimmed) {\n      return \"\";\n    }\n\n    const techName = getDeclTechName(decl);\n    const bare = stripAngleBrackets(techName);\n    if (bare.length < 3) {\n      return descTrimmed;\n    }\n\n    const code = bare.slice(1, 3).toUpperCase();\n    const settings = state.settings || DEFAULT_SETTINGS;\n    const templates = settings.nameTemplatesByCode || DEFAULT_SETTINGS.nameTemplatesByCode;\n    const template = templates && Object.prototype.hasOwnProperty.call(templates, code) ? String(templates[code] || \"\") : \"\";\n    if (!template.trim()) {\n      return descTrimmed;\n    }\n\n    const strippedKnownPrefix = stripDeclCategoryPrefix(descTrimmed);\n    const normalizedDesc = stripDeclTemplateAffixes(strippedKnownPrefix, template);\n    const normalized = template.replace(/\\{\\{desc\\}\\}/g, normalizedDesc).trim();\n    return normalized || descTrimmed;\n  }\n\n  function getEffectiveDeclAtomicDesc(decl) {\n    const override = getDeclOverrideDesc(decl);\n    if (override) {\n      return override;\n    }\n\n    const source = getSourceDeclDesc(decl);\n    if (source) {\n      return source;\n    }\n\n    return getBaseDeclDesc(decl);\n  }\n\n  function getEffectiveDeclAtomicDescNormalized(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const settings = state.settings || DEFAULT_SETTINGS;\n    const normalizeEnabled = Boolean(settings.normalizeDeclDesc);\n\n    const overrideEntry = getDeclOverrideEntry(decl);\n    const overrideText = overrideEntry.text ? String(overrideEntry.text) : \"\";\n    if (overrideText) {\n      if (!normalizeEnabled || overrideEntry.noNormalize) {\n        return overrideText;\n      }\n      return normalizeDeclDescText(decl, overrideText);\n    }\n\n    const source = getSourceDeclDesc(decl);\n    if (source) {\n      return normalizeEnabled ? normalizeDeclDescText(decl, source) : source;\n    }\n\n    const base = getBaseDeclDesc(decl);\n    if (base) {\n      return normalizeEnabled ? normalizeDeclDescText(decl, base) : base;\n    }\n\n    return String(getDeclTechName(decl) || \"\").trim();\n  }\n\n  function getFinalDeclAtomicDescNormalized(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const overrideEntry = getDeclOverrideEntry(decl);\n    const overrideText = overrideEntry.text ? String(overrideEntry.text) : \"\";\n    if (overrideText) {\n      return normalizeDeclDescByTemplate(decl, overrideText);\n    }\n\n    const codeDesc = getDeclCodeDesc(decl);\n    if (codeDesc) {\n      return normalizeDeclDescByTemplate(decl, codeDesc);\n    }\n\n    const techId = String(getDeclTechName(decl) || \"\").trim();\n    if (!techId) {\n      return \"\";\n    }\n\n    return normalizeDeclDescByTemplate(decl, techId);\n  }\n\n  function buildStructDeclFromFieldDecl(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return null;\n    }\n\n    if (!decl.scopeLabel || !decl.structName) {\n      return null;\n    }\n\n    return {\n      id: decl.structId || null,\n      objectType: decl.structObjectType || decl.objectType || \"STRUCT\",\n      name: String(decl.structName || \"\"),\n      file: decl.file || \"\",\n      lineStart: decl.structLineStart || null,\n      raw: decl.structRaw || \"\",\n      comment: decl.structComment || decl.structTypeComment || \"\",\n      scopeId: decl.scopeId || 0,\n      scopeLabel: decl.scopeLabel || \"\",\n      scopeType: decl.scopeType || \"\",\n      scopeName: decl.scopeName || \"\"\n    };\n  }\n\n  function stripStructNamePrefixFromItemText(itemText, structName) {\n    const raw = String(itemText || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const struct = String(structName || \"\").trim();\n    if (!struct) {\n      return raw;\n    }\n\n    const prefix = `${struct.toUpperCase()}-`;\n    if (raw.toUpperCase().startsWith(prefix)) {\n      return raw.slice(struct.length + 1).trim();\n    }\n\n    return raw;\n  }\n\n  function hasStructCompositeMeta(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return false;\n    }\n    const structName = String(decl.structName || \"\").trim();\n    const fieldPath = String(decl.fieldPath || \"\").trim();\n    return Boolean(structName && fieldPath);\n  }\n\n  function stripDeclCategoryPrefixDeep(text) {\n    let current = String(text || \"\").trim();\n    while (current) {\n      const next = stripDeclCategoryPrefix(current);\n      if (!next || next === current) {\n        break;\n      }\n      current = next;\n    }\n    return current;\n  }\n\n  function sanitizeStructCompositeText(text, decl) {\n    const raw = String(text || \"\").replace(/\\u00A0/g, \" \").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const parts = raw.split(\"-\");\n    if (parts.length < 2) {\n      return stripDeclCategoryPrefixDeep(raw);\n    }\n\n    const structPart = stripDeclCategoryPrefixDeep(parts.shift());\n    let itemPart = stripDeclCategoryPrefixDeep(parts.join(\"-\"));\n    itemPart = stripStructNamePrefixFromItemText(itemPart, String(decl && decl.structName ? decl.structName : \"\").trim());\n\n    if (!structPart) {\n      return itemPart;\n    }\n    if (!itemPart) {\n      return structPart;\n    }\n    return `${structPart}-${itemPart}`;\n  }\n\n  function getDeclTechNameSafe(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n    return String(getDeclTechName(decl) || decl.name || \"\").trim();\n  }\n\n  function isTechnicalFallbackDesc(decl, text) {\n    const candidate = String(text || \"\").trim();\n    if (!candidate) {\n      return false;\n    }\n    const tech = getDeclTechNameSafe(decl);\n    if (!tech) {\n      return false;\n    }\n    return candidate.toUpperCase() === tech.toUpperCase();\n  }\n\n  function formatStructFieldDesc(decl) {\n    if (!isStructFieldDecl(decl)) {\n      return getEffectiveDeclAtomicDesc(decl);\n    }\n\n    const settings = state.settings || DEFAULT_SETTINGS;\n    const template = settings.structDescTemplate || DEFAULT_SETTINGS.structDescTemplate;\n\n    const structTech = String(decl.structName || \"\").trim() || getDeclTechName(decl);\n    const itemTech = String(decl.fieldPath || \"\").trim() || (() => {\n      const tech = getDeclTechName(decl);\n      const structPrefix = String(decl.structName || \"\").trim();\n      if (structPrefix && tech.toUpperCase().startsWith(`${structPrefix.toUpperCase()}-`)) {\n        return tech.slice(structPrefix.length + 1);\n      }\n      return tech;\n    })();\n\n    const structDecl = buildStructDeclFromFieldDecl(decl);\n    const structDescRaw = structDecl ? getEffectiveDeclAtomicDescNormalized(structDecl) : \"\";\n    const itemDescRaw = getEffectiveDeclAtomicDescNormalized(decl);\n\n    const structText = stripDeclCategoryPrefix(String(structDescRaw || \"\").trim()) || structTech;\n    const itemTextRaw = stripDeclCategoryPrefix(String(itemDescRaw || \"\").trim()) || itemTech;\n    const itemText = stripStructNamePrefixFromItemText(itemTextRaw, String(decl.structName || \"\").trim() || structTech);\n\n    return String(template || DEFAULT_SETTINGS.structDescTemplate)\n      .replace(/\\{\\{struct\\}\\}/g, structText)\n      .replace(/\\{\\{item\\}\\}/g, itemText);\n  }\n\n  function getEffectiveDeclDesc(decl) {\n    if (!isStructFieldDecl(decl)) {\n      return getEffectiveDeclAtomicDescNormalized(decl);\n    }\n\n    const composed = sanitizeStructCompositeText(formatStructFieldDesc(decl), decl);\n    if (!hasStructCompositeMeta(decl)) {\n      const normalized = normalizeDeclDescByTemplate(decl, composed);\n      return normalized || composed;\n    }\n    return composed;\n  }\n\n  function formatStructFieldFinalDesc(decl) {\n    if (!isStructFieldDecl(decl)) {\n      return getFinalDeclAtomicDescNormalized(decl);\n    }\n\n    const structDecl = buildStructDeclFromFieldDecl(decl);\n    const structTextRaw = structDecl ? String(getFinalDeclAtomicDescNormalized(structDecl) || \"\").trim() : \"\";\n    const itemTextRaw = String(getFinalDeclAtomicDescNormalized(decl) || \"\").trim();\n    const structText = stripDeclCategoryPrefix(structTextRaw);\n    const itemTextNormalized = stripDeclCategoryPrefix(itemTextRaw);\n    const itemText = stripStructNamePrefixFromItemText(itemTextNormalized, String(decl.structName || \"\").trim());\n\n    if (!structText && !itemText) {\n      return \"\";\n    }\n    if (!structText) {\n      return itemText;\n    }\n    if (!itemText) {\n      return structText;\n    }\n\n    const settings = state.settings || DEFAULT_SETTINGS;\n    const template = settings.structDescTemplate || DEFAULT_SETTINGS.structDescTemplate;\n    return String(template || DEFAULT_SETTINGS.structDescTemplate)\n      .replace(/\\{\\{struct\\}\\}/g, structText)\n      .replace(/\\{\\{item\\}\\}/g, itemText);\n  }\n\n  function getFinalDeclDesc(decl) {\n    if (!isStructFieldDecl(decl)) {\n      return getFinalDeclAtomicDescNormalized(decl);\n    }\n\n    const composed = sanitizeStructCompositeText(formatStructFieldFinalDesc(decl), decl);\n    if (!composed) {\n      return \"\";\n    }\n\n    if (isTechnicalFallbackDesc(decl, composed)) {\n      return composed;\n    }\n\n    const normalized = normalizeDeclDescByTemplate(decl, composed);\n    return normalized || composed;\n  }\n\n  function openEditModal({ mode, key, structKey, itemKey, label, hint, initialValue, structValue, itemValue, skipNormalize }) {\n    const editMode = mode === \"structField\" ? \"structField\" : \"single\";\n\n    if (editMode === \"single\" && !key) {\n      return;\n    }\n\n    if (editMode === \"structField\" && (!structKey || !itemKey)) {\n      return;\n    }\n\n    if (!els.jsonModal.hidden) {\n      closeJsonModal();\n    }\n\n    state.activeEdit = editMode === \"structField\"\n      ? { mode: \"structField\", structKey, itemKey }\n      : { mode: \"single\", key };\n    els.editLabel.textContent = label ? String(label) : \"\";\n\n    const hintText = hint ? String(hint) : \"\";\n    els.editHint.textContent = hintText;\n    els.editHint.style.display = hintText ? \"block\" : \"none\";\n\n    if (els.editSingleWrap) {\n      els.editSingleWrap.hidden = editMode !== \"single\";\n    }\n    if (els.editStructWrap) {\n      els.editStructWrap.hidden = editMode !== \"structField\";\n    }\n\n    els.editDesc.value = \"\";\n    if (els.editStructDesc) {\n      els.editStructDesc.value = \"\";\n    }\n    if (els.editItemDesc) {\n      els.editItemDesc.value = \"\";\n    }\n    if (els.editSkipNormalize) {\n      els.editSkipNormalize.checked = Boolean(skipNormalize);\n    }\n\n    if (editMode === \"single\") {\n      els.editDesc.value = initialValue ? String(initialValue) : \"\";\n    } else {\n      if (els.editStructDesc) {\n        els.editStructDesc.value = structValue ? String(structValue) : \"\";\n      }\n      if (els.editItemDesc) {\n        els.editItemDesc.value = itemValue ? String(itemValue) : \"\";\n      }\n    }\n\n    els.editModal.hidden = false;\n    setTimeout(() => {\n      const target = editMode === \"structField\" && els.editStructDesc ? els.editStructDesc : els.editDesc;\n      target.focus();\n    }, 0);\n  }\n\n  function closeEditModal() {\n    els.editModal.hidden = true;\n    els.editDesc.value = \"\";\n    if (els.editStructDesc) {\n      els.editStructDesc.value = \"\";\n    }\n    if (els.editItemDesc) {\n      els.editItemDesc.value = \"\";\n    }\n    if (els.editSkipNormalize) {\n      els.editSkipNormalize.checked = false;\n    }\n    state.activeEdit = null;\n  }\n\n  function applyEditModal(action) {\n    if (!state.activeEdit) {\n      return;\n    }\n\n    const mode = state.activeEdit.mode === \"structField\" ? \"structField\" : \"single\";\n    const skipNormalize = Boolean(els.editSkipNormalize && els.editSkipNormalize.checked);\n\n    if (mode === \"single\") {\n      const key = state.activeEdit.key;\n      if (!key) {\n        return;\n      }\n\n      const value = action === \"clear\" ? \"\" : String(els.editDesc.value || \"\");\n      const trimmed = value.trim();\n      const stored = skipNormalize ? trimmed : stripDeclCategoryPrefix(trimmed);\n\n      if (!stored) {\n        delete state.descOverrides[key];\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
