<!--
  AUTO-GENERATED FILE
  Source: E:/Documents/MyGitProject/Abap/viewer_old_stable_tested/viewer/index.html
  Generator: scripts/build-inline-viewer.py
  Do not edit this file directly. Regenerate instead.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="abap-viewer-version" content="v2026.02.27-r5">
  <meta name="abap-viewer-updated-at" content="2026-02-27 15:10:13">
  <meta name="abap-viewer-updated-note" content="AI note: Added runtime hotfix for struct-field desc/finalDesc normalization to avoid duplicated STRUCT prefixes in composed struct-item text. Split runtime wrappers and prior finalDesc/template/gutter fixes preserved. Manual metadata only. Offline only.">
  <title>ABAP Parser Viewer</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b1220;
      --panel: #0f172a;
      --border: #22324a;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --hover: #1e293b;
      --gutter-bg: #0b1526;
      --code-bg: #0b1526;
      --pill-bg: #1e293b;
      --pill-text: #bfdbfe;
      --selected-row-bg: #1e293b;
      --tab-active-bg: #1e293b;
      --tab-active-border: #334155;
      --tab-active-text: #bfdbfe;
      --danger: #fca5a5;
      --overlay: rgba(0, 0, 0, 0.55);
      --selected-focus-ring: #f59e0b;
      --selected-focus-fill: rgba(245, 158, 11, 0.14);
      --layout-left-pane: 48%;
      --layout-splitter-size: 12px;
    }

    :root[data-theme="light"] {
      color-scheme: light;
      --bg: #f6f7f9;
      --panel: #ffffff;
      --border: #d8dde6;
      --text: #222b3a;
      --muted: #6b7280;
      --accent: #1f7ae0;
      --hover: #f3f4f6;
      --gutter-bg: #f8fafc;
      --code-bg: #f8fafc;
      --pill-bg: #eef2ff;
      --pill-text: #3730a3;
      --selected-row-bg: #eef2ff;
      --tab-active-bg: #eef2ff;
      --tab-active-border: #c7d2fe;
      --tab-active-text: #3730a3;
      --danger: #b42318;
      --overlay: rgba(15, 23, 42, 0.5);
      --selected-focus-ring: #d97706;
      --selected-focus-fill: rgba(217, 119, 6, 0.12);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, sans-serif;
      color: var(--text);
      background: var(--bg);
      height: 100vh;
      overflow: hidden;
    }

    .container {
      width: 100%;
      max-width: none;
      margin: 0;
      padding: 16px clamp(12px, 2vw, 24px);
      height: 100vh;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    header {
      margin-bottom: 20px;
    }

    header h1 {
      margin: 0 0 6px 0;
      font-size: 22px;
    }

    header p {
      margin: 0;
      color: var(--muted);
    }

    header .build-info {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
      font-family: Consolas, "Courier New", monospace;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }

    .controls input[type="file"] {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 6px;
      border-radius: 6px;
    }

    .controls button {
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
    }

    .controls input[type="search"],
    .controls select {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 13px;
      min-width: 220px;
    }

    .controls .toggle {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      color: var(--muted);
      font-size: 13px;
      user-select: none;
    }

    .controls .secondary {
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .controls .secondary:hover {
      background: var(--hover);
    }

    .secondary {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
    }

    .secondary:hover {
      background: var(--hover);
    }

    .controls .hint {
      flex-basis: 100%;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(320px, var(--layout-left-pane)) var(--layout-splitter-size) minmax(320px, 1fr);
      gap: 0;
      flex: 1;
      min-height: 0;
      align-items: stretch;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      min-height: 300px;
      display: flex;
      flex-direction: column;
      min-height: 0;
      min-width: 0;
    }

    .splitter {
      position: relative;
      touch-action: none;
      cursor: col-resize;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      background-clip: padding-box;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .splitter::before {
      content: "";
      width: 3px;
      height: min(72px, 40%);
      border-radius: 999px;
      background: var(--border);
      transition: background 0.15s ease;
    }

    .splitter:hover::before,
    .splitter:focus-visible::before,
    .layout.is-resizing .splitter::before {
      background: var(--accent);
    }

    .splitter:focus-visible {
      outline: none;
    }

    .layout.is-resizing,
    .layout.is-resizing * {
      cursor: col-resize !important;
      user-select: none;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .panel-header h2 {
      margin: 0;
      font-size: 18px;
    }

    .panel-tabs {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .tab-btn.active {
      background: var(--tab-active-bg);
      border-color: var(--tab-active-border);
      color: var(--tab-active-text);
    }

    .panel > h2 {
      margin: 0 0 10px 0;
      font-size: 18px;
    }

    #inputText {
      width: 100%;
      min-height: 360px;
      padding: 10px;
      font-family: Consolas, monospace;
      font-size: 13px;
      line-height: 18px;
      resize: none;
      flex: 1;
      min-height: 0;
      border: none;
      outline: none;
      white-space: pre;
      overflow-wrap: normal;
      background: transparent;
      color: var(--text);
    }

    .input-editor {
      width: 100%;
      display: flex;
      flex: 1;
      min-height: 0;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      background: var(--panel);
    }

    #inputGutter {
      width: 68px;
      flex: none;
      border-right: 1px solid var(--border);
      background: var(--gutter-bg);
      color: var(--muted);
      font-family: Consolas, monospace;
      font-size: 12px;
      line-height: 18px;
      position: relative;
      overflow: hidden;
      user-select: none;
    }

    #inputGutterContent {
      padding: 10px 6px;
      will-change: transform;
    }

    .gutter-line {
      height: 18px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .gutter-num {
      flex: 1;
      text-align: right;
    }

    .gutter-jump {
      border: 1px solid transparent;
      background: transparent;
      color: var(--muted);
      padding: 0 4px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      line-height: 1.2;
    }

    .gutter-jump:hover {
      background: var(--hover);
      border-color: var(--border);
      color: var(--text);
    }

    .gutter-jump:focus {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }

    .modal textarea {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      font-family: Consolas, monospace;
      font-size: 13px;
      resize: vertical;
      min-height: 140px;
      max-height: 40vh;
      background: var(--panel);
      color: var(--text);
    }

    .error {
      color: var(--danger);
      font-size: 13px;
      margin-top: 8px;
      white-space: pre-wrap;
    }

    #output {
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding-right: 6px;
    }

    #declDescPanel {
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding-right: 6px;
    }

    #templatePreviewPanel {
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding-right: 6px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #output[hidden],
    #templatePreviewPanel[hidden],
    #declDescPanel[hidden] {
      display: none !important;
    }

    .template-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .template-key-mode {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
      margin-right: auto;
    }

    .template-copy-mode {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
      user-select: none;
    }

    .template-key-badge {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 2px 8px;
      background: var(--pill-bg);
      color: var(--pill-text);
      font-family: Consolas, monospace;
      font-size: 11px;
    }

    .template-config-json {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      font-family: Consolas, monospace;
      font-size: 12px;
      resize: vertical;
      min-height: 180px;
      max-height: 42vh;
      background: var(--panel);
      color: var(--text);
    }

    .template-preview-output {
      flex: 1;
      min-height: 220px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: var(--code-bg);
    }

    .template-block {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 10px;
      background: var(--panel);
    }

    .template-block.selected {
      border-color: var(--selected-focus-ring);
      background: linear-gradient(var(--selected-focus-fill), var(--selected-focus-fill)), var(--panel);
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--selected-focus-ring) 45%, transparent);
    }

    .template-block:last-child {
      margin-bottom: 0;
    }

    .template-block-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
    }

    .template-block-title {
      margin: 0;
      font-size: 14px;
      line-height: 1.3;
    }

    .template-block-meta {
      color: var(--muted);
      font-size: 12px;
    }

    .template-block-actions {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .template-preview-table {
      width: max-content;
      min-width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
      border: 1px solid #000000;
      background: #ffffff;
      color: #111111;
    }

    .template-preview-table td {
      min-width: 56px;
      max-width: 360px;
      border: none;
      padding: 4px 6px;
      vertical-align: top;
      white-space: pre-wrap;
      font-size: 10pt;
      font-family: "MS PGothic", "MS UI Gothic", Meiryo, sans-serif;
      color: #111111;
      background: #ffffff;
    }

    .template-empty {
      color: var(--muted);
      font-size: 13px;
    }

    .template-error {
      color: var(--danger);
      font-size: 13px;
      white-space: pre-wrap;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .card.block {
      border-left: 4px solid var(--accent);
    }

    .card.selected {
      border-color: var(--selected-focus-ring);
      background: linear-gradient(var(--selected-focus-fill), var(--selected-focus-fill)), var(--panel);
      outline: 2px solid var(--selected-focus-ring);
      outline-offset: 1px;
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--selected-focus-ring) 45%, transparent);
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }

    .card-title {
      margin: 0;
      font-size: 16px;
      line-height: 1.2;
    }

    .card-actions {
      display: inline-flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .btn-ghost {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 4px 8px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .btn-ghost:hover {
      background: var(--hover);
    }

    .muted {
      color: var(--muted);
      font-size: 13px;
    }

    .raw {
      margin-top: 8px;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--code-bg);
      font-family: Consolas, monospace;
      font-size: 13px;
      white-space: pre-wrap;
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--pill-bg);
      color: var(--pill-text);
      font-size: 12px;
      margin: 2px 4px 2px 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 13px;
    }

    th, td {
      text-align: left;
      border-bottom: 1px solid var(--border);
      padding: 6px 4px;
      vertical-align: top;
    }

    tr.desc-selected td {
      background: var(--selected-row-bg);
    }

    .decl-desc,
    .decl-desc-line {
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .decl-desc-text {
      flex: 1;
      min-width: 0;
      white-space: pre-wrap;
    }

    .icon-btn {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
      padding: 2px 6px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      line-height: 1.1;
    }

    .icon-btn:hover {
      background: var(--hover);
      color: var(--text);
    }

    .icon-btn:focus {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }

    th {
      color: var(--muted);
      font-weight: 600;
    }

    .children {
      margin-top: 12px;
      padding-left: 12px;
      border-left: 2px solid var(--border);
    }

    .extras {
      margin-top: 10px;
      padding-top: 8px;
      border-top: 1px dashed var(--border);
    }

    pre {
      white-space: pre-wrap;
      margin: 6px 0 0 0;
    }

    .modal[hidden] {
      display: none;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: var(--overlay);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 1000;
    }

    .modal-content {
      width: min(1000px, 100%);
      max-height: 85vh;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      gap: 10px;
    }

    .modal-header .modal-actions {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .modal-body {
      padding: 12px;
      overflow: auto;
      min-height: 0;
    }

    .modal-body pre {
      white-space: pre;
      font-family: Consolas, monospace;
      font-size: 12px;
    }

    #editModal,
    #jsonModal {
      z-index: 1100;
    }

    @media (max-width: 980px) {
      .container {
        padding: 12px;
      }

      .layout {
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .splitter {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ABAP Parser Viewer</h1>
      <p>Paste ABAP code (or JSON output) and click Render.</p>
      <p class="build-info" id="buildInfo">Updated: manual timestamp not set.</p>
    </header>

    <div class="controls">
      <input type="file" id="fileInput" accept=".abap,.txt,.json,application/json,text/plain">
      <button type="button" id="parseBtn">Render</button>
      <input type="search" id="searchInput" placeholder="Search (raw/comment/value/decl)…">
      <select id="typeFilter">
        <option value="">All types</option>
      </select>
      <label class="toggle"><input type="checkbox" id="showRaw" checked>raw</label>
      <label class="toggle"><input type="checkbox" id="showKeywords" checked>keywords</label>
      <label class="toggle"><input type="checkbox" id="showValues" checked>values</label>
      <label class="toggle"><input type="checkbox" id="showExtras">extras</label>
      <label class="toggle"><input type="checkbox" id="themeToggle" checked>dark</label>
      <button type="button" id="expandAllBtn" class="secondary">Expand all</button>
      <button type="button" id="collapseAllBtn" class="secondary">Collapse all</button>
      <button type="button" id="clearFiltersBtn" class="secondary">Clear</button>
      <button type="button" id="descBtn" class="secondary">Descriptions</button>
      <button type="button" id="rulesBtn" class="secondary">Rules</button>
      <button type="button" id="settingsBtn" class="secondary">Settings</button>
      <button type="button" id="exportXmlBtn" class="secondary">Export XML</button>
      <span class="muted hint">Tip: click “Code” on a card to select the corresponding lines in the input; click “JSON” to inspect the raw object.</span>
    </div>

    <div class="layout" id="mainLayout">
      <div class="panel">
        <h2>Input (ABAP / JSON)</h2>
        <div class="input-editor" id="inputEditor">
          <div id="inputGutter"><div id="inputGutterContent"></div></div>
          <textarea id="inputText" placeholder="Paste ABAP code here" wrap="off"></textarea>
        </div>
        <div class="error" id="error"></div>
      </div>

      <div
        class="splitter"
        id="panelSplitter"
        role="separator"
        aria-label="Resize code and output panels"
        aria-orientation="vertical"
        tabindex="0"
      ></div>

      <div class="panel">
        <div class="panel-header">
          <h2 id="rightPanelTitle">Template Preview</h2>
          <div class="panel-tabs">
            <button type="button" id="rightTabOutputBtn" class="secondary tab-btn">Output</button>
            <button type="button" id="rightTabTemplateBtn" class="secondary tab-btn active">Template</button>
            <button type="button" id="rightTabDescBtn" class="secondary tab-btn">Descriptions</button>
            <button type="button" id="declDescJsonBtn" class="secondary" hidden>Storage JSON</button>
          </div>
        </div>
        <div id="output" class="muted" hidden>No data loaded.</div>
        <div id="templatePreviewPanel">
          <div class="template-controls">
            <span class="template-key-mode">
              Template key mode
              <span id="templateKeyMode" class="template-key-badge">AUTO: objectType -&gt; DEFAULT</span>
            </span>
            <label class="template-copy-mode">
              <input type="checkbox" id="templateCopyTableOnly" checked>
              Copy table only
            </label>
            <button type="button" id="templateCopyAllBtn" class="secondary">Copy All</button>
            <button type="button" id="templateResetBtn" class="secondary">Reset default</button>
            <button type="button" id="templateExportBtn" class="secondary">Export config</button>
            <button type="button" id="templateImportBtn" class="secondary">Import config</button>
            <button type="button" id="templateApplyBtn" class="secondary">Apply JSON</button>
            <input type="file" id="templateImportInput" accept=".json,application/json,text/plain" hidden>
          </div>
          <div id="templateConfigError" class="template-error"></div>
          <textarea id="templateConfigJson" class="template-config-json" spellcheck="false" placeholder="Template config JSON..."></textarea>
          <div id="templatePreviewOutput" class="template-preview-output muted">No data loaded.</div>
        </div>
        <div id="declDescPanel" hidden>
          <div class="controls" style="margin-bottom:8px">
            <input type="search" id="declDescSearch" placeholder="Search (type/scope/id/desc)…">
            <label class="toggle"><input type="checkbox" id="declDescMissingOnly" checked>missing only</label>
          </div>
          <div class="muted" style="margin-bottom:6px">Declaration types</div>
          <div id="declDescTypes" class="controls" style="margin-bottom:8px"></div>
          <div class="muted" id="declDescSummary" style="margin-bottom:8px"></div>
          <div id="declDescTable"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="modal" id="jsonModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <strong id="jsonTitle">Object JSON</strong>
        <div class="modal-actions">
          <button type="button" id="jsonCopyBtn" class="secondary">Copy</button>
          <button type="button" id="jsonCloseBtn" class="secondary">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <pre id="jsonPre"></pre>
      </div>
    </div>
  </div>

  <div class="modal" id="editModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <strong>Edit description</strong>
        <div class="modal-actions">
          <button type="button" id="editSaveBtn" class="secondary">Save</button>
          <button type="button" id="editClearBtn" class="secondary">Clear</button>
          <button type="button" id="editCancelBtn" class="secondary">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <div class="muted" id="editLabel" style="margin-bottom:8px"></div>
        <div class="muted" id="editHint" style="margin-bottom:8px"></div>
        <div id="editSingleWrap">
          <textarea id="editDesc" placeholder="Enter description…"></textarea>
        </div>
        <div id="editStructWrap" hidden>
          <div class="muted" style="margin-bottom:6px">Struct description</div>
          <textarea id="editStructDesc" placeholder="Enter struct description…"></textarea>
          <div class="muted" style="margin:8px 0 6px">Item description</div>
          <textarea id="editItemDesc" placeholder="Enter item description…"></textarea>
        </div>
        <div style="margin-top:8px">
          <label class="toggle"><input type="checkbox" id="editSkipNormalize">Skip normalization for this user description</label>
        </div>
        <div class="muted" style="margin-top:8px">Tip: Ctrl+Enter to save, Esc to close.</div>
      </div>
    </div>
  </div>

  <div class="modal" id="rulesModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <strong>Rules</strong>
        <div class="modal-actions">
          <button type="button" id="rulesNewBtn" class="secondary">New</button>
          <button type="button" id="rulesSaveBtn" class="secondary">Save</button>
          <button type="button" id="rulesDeleteBtn" class="secondary">Delete</button>
          <button type="button" id="rulesDownloadBtn" class="secondary">Download</button>
          <button type="button" id="rulesCloseBtn" class="secondary">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <div class="controls" style="margin-bottom:8px">
          <select id="rulesSelect" style="min-width:320px">
            <option value="">(New rule)</option>
          </select>
          <select id="rulesTemplate" style="min-width:220px">
            <option value="startKeyword">Template: startKeyword</option>
            <option value="startPhrase">Template: startPhrase</option>
            <option value="assignment">Template: assignment</option>
          </select>
          <span class="muted">Saved in browser (localStorage). Custom rules take priority when parsing.</span>
        </div>
        <div class="error" id="rulesError"></div>
        <textarea id="rulesJson" placeholder="Paste or edit config JSON here…"></textarea>
        <div class="muted" style="margin-top:8px">Tip: click Save, then Render to test; Download creates a .json you can add into /configs.</div>
      </div>
    </div>
  </div>

  <div class="modal" id="settingsModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <strong>Settings</strong>
        <div class="modal-actions">
          <button type="button" id="settingsSaveBtn" class="secondary">Save</button>
          <button type="button" id="settingsResetBtn" class="secondary">Reset</button>
          <button type="button" id="settingsCloseBtn" class="secondary">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <div class="muted" style="margin-bottom:8px">
          Placeholders:
          <code>{{struct}}</code>, <code>{{item}}</code>, <code>{{desc}}</code>
        </div>

        <div style="margin-bottom:16px">
          <label class="toggle"><input type="checkbox" id="settingsNormalizeDesc">Normalize decl <code>desc</code> (apply templates)</label>
        </div>

        <div style="margin-bottom:16px">
          <div class="muted" style="margin-bottom:6px">Declaration types shown in Descriptions modal</div>
          <div id="settingsDeclTypes" class="controls" style="margin-bottom:0"></div>
        </div>

        <div style="margin-bottom:16px">
          <div class="muted" style="margin-bottom:6px">Struct desc template (used for struct fields)</div>
          <input type="text" id="settingsStructTemplate" placeholder="{{struct}}-{{item}}" style="width:100%">
        </div>

        <div style="margin-bottom:8px">
          <div class="muted" style="margin-bottom:6px">Name normalization templates (use {{desc}})</div>
          <div id="settingsNameTemplates"></div>
        </div>

        <div class="muted" style="margin-top:8px">
          Prefix match: 1 char + CODE (e.g. <code>GCN_TOTAL</code>). If no description, keep technical ID.
        </div>
      </div>
    </div>
  </div>

  <script>
// inlined from: ../shared/abap-parser/01-context.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/01-context.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "(function (root, factory) {\n  if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n    return;\n  }\n\n  root.AbapParser = factory();\n})(typeof globalThis !== \"undefined\" ? globalThis : (typeof self !== \"undefined\" ? self : this), function () {\n  \"use strict\";\n\n  class AbapObject {\n    constructor({\n      id = null,\n      parent = null,\n      objectType,\n      file,\n      lineStart,\n      raw,\n      block = null,\n      extras = null,\n      comment,\n      keywords,\n      values,\n      children = []\n    }) {\n      this.id = id;\n      this.parent = parent;\n      this.objectType = objectType;\n      this.file = file;\n      this.lineStart = lineStart;\n      this.raw = raw;\n      this.block = block;\n      this.extras = extras;\n      this.comment = comment;\n      if (keywords && Object.keys(keywords).length) {\n        this.keywords = keywords;\n      }\n      if (values && Object.keys(values).length) {\n        this.values = values;\n      }\n      this.children = children;\n    }\n  }\n\n  const registeredConfigs = [];\n\n  function registerConfig(config) {\n    registeredConfigs.push(normalizeConfig(config));\n  }\n\n  function getConfigs() {\n    return registeredConfigs.slice();\n  }\n\n  function normalizeConfig(config) {\n    const normalized = {\n      ...config,\n      match: config.match || {},\n      block: config.block || null,\n      keywordLabels: normalizeMapKeys(config.keywordLabels),\n      keywordPhrases: normalizeMapKeys(config.keywordPhrases),\n      captureRules: normalizeCaptureRules(config.captureRules),\n      valueDescriptions: normalizeValueDescriptions(config.valueDescriptions)\n    };\n\n    if (normalized.match.startKeyword) {\n      normalized.match.startKeyword = String(normalized.match.startKeyword).toUpperCase();\n    }\n\n    if (normalized.match.startPhrase) {\n      normalized.match.startTokens = String(normalized.match.startPhrase)\n        .trim()\n        .toUpperCase()\n        .split(/\\s+/)\n        .filter(Boolean);\n    } else {\n      normalized.match.startTokens = [];\n    }\n\n    if (normalized.block && normalized.block.endKeyword) {\n      normalized.block = {\n        ...normalized.block,\n        endKeyword: String(normalized.block.endKeyword).toUpperCase()\n      };\n    }\n\n    return normalized;\n  }\n\n  function normalizeMapKeys(map) {\n    if (!map) {\n      return {};\n    }\n\n    const output = {};\n    for (const key of Object.keys(map)) {\n      output[String(key).toUpperCase()] = map[key];\n    }\n    return output;\n  }\n\n  function normalizeCaptureRules(rules) {\n    if (!Array.isArray(rules)) {\n      return [];\n    }\n\n    return rules.map((rule) => {\n      const after = rule.after || \"\";\n      const afterTokens = String(after)\n        .trim()\n        .toUpperCase()\n        .split(/\\s+/)\n        .filter(Boolean);\n\n      const stopTokensUpper = Array.isArray(rule.stopTokens)\n        ? rule.stopTokens\n            .map((token) => String(token).trim().toUpperCase())\n            .filter(Boolean)\n        : [];\n\n      return {\n        ...rule,\n        afterTokens,\n        capture: rule.capture || \"next\",\n        stopTokensUpper\n      };\n    });\n  }\n\n  function normalizeValueDescriptions(desc) {\n    if (!desc) {\n      return {};\n    }\n\n    const output = {};\n    for (const key of Object.keys(desc)) {\n      output[key] = normalizeMapKeys(desc[key]);\n    }\n    return output;\n  }\n\n  function parseAbapText(content, configs, fileName) {\n    const lines = String(content || \"\").split(/\\r?\\n/);\n    const statements = collectStatements(lines);\n    const list = Array.isArray(configs) ? configs : registeredConfigs;\n    const objects = parseStatements(statements, list, fileName || \"\");\n\n    const decls = attachDeclarationRefs({ statements, objects, fileName: fileName || \"\" });\n\n    return {\n      file: fileName || \"\",\n      objects,\n      decls\n    };\n  }\n\n  function pickPreferredStatementComment(statementBuffer) {\n    if (!statementBuffer || typeof statementBuffer !== \"object\") {\n      return \"\";\n    }\n\n    const lineEntries = Array.isArray(statementBuffer.lineEntries) ? statementBuffer.lineEntries : [];\n    for (const entry of lineEntries) {\n      const inline = entry && typeof entry.comment === \"string\" ? entry.comment.trim() : \"\";\n      if (inline) {\n        return inline;\n      }\n    }\n\n    const leading = Array.isArray(statementBuffer.leadingCommentLines) ? statementBuffer.leadingCommentLines : [];\n    if (leading.length !== 1) {\n      return \"\";\n    }\n\n    const candidate = leading[0];\n    const text = candidate && typeof candidate.text === \"string\" ? candidate.text.trim() : \"\";\n    const line = candidate ? Number(candidate.line || 0) || 0 : 0;\n    const lineStart = Number(statementBuffer.lineStart || 0) || 0;\n\n    if (!text || !lineStart || line !== lineStart - 1) {\n      return \"\";\n    }\n\n    return text;\n  }\n\n  function collectStatements(lines) {\n    const statements = [];\n    let current = null;\n    let pendingComments = [];\n\n    for (let index = 0; index < lines.length; index += 1) {\n      const lineNumber = index + 1;\n      const rawLine = lines[index];\n      const trimmed = rawLine.trim();\n\n      if (!trimmed) {\n        if (!current) {\n          pendingComments = [];\n        }\n        continue;\n      }\n\n      if (isCommentLine(trimmed)) {\n        const commentText = normalizeComment(trimmed);\n        if (commentText) {\n          if (current) {\n            current.comments.push(commentText);\n          } else {\n            pendingComments.push({ line: lineNumber, text: commentText });\n          }\n        } else if (!current) {\n          // Decorative comment-only lines behave like blank separators.\n          pendingComments = [];\n        }\n        continue;\n      }\n\n      const { code, comment } = splitCodeAndInlineComment(rawLine);\n      const codeTrim = code.trim();\n\n      if (!codeTrim) {\n        if (comment) {\n          pendingComments.push({ line: lineNumber, text: comment });\n        } else if (!current) {\n          // Decorative inline-only comment (e.g. `\"----\"`) is treated as blank.\n          pendingComments = [];\n        }\n        continue;\n      }\n\n      if (!current) {\n        const leadingCommentLines = pendingComments.slice();\n        const leadingComments = leadingCommentLines\n          .map((entry) => (entry && typeof entry.text === \"string\" ? entry.text : \"\"))\n          .filter(Boolean);\n\n        current = {\n          lineStart: lineNumber,\n          rawParts: [],\n          comments: leadingComments.slice(),\n          leadingComments,\n          leadingCommentLines,\n          lineEntries: []\n        };\n        pendingComments = [];\n      }\n\n      current.rawParts.push(codeTrim);\n      if (comment) {\n        current.comments.push(comment);\n      }\n      current.lineEntries.push({ line: lineNumber, code: codeTrim, comment: comment || \"\" });\n\n      if (codeTrim.endsWith(\".\")) {\n        const raw = current.rawParts.join(\" \").replace(/\\s+/g, \" \").trim();\n        const commentText = pickPreferredStatementComment(current);\n\n        statements.push({\n          lineStart: current.lineStart,\n          raw,\n          comment: commentText,\n          commentLines: current.comments.filter(Boolean),\n          leadingComments: current.leadingComments ? current.leadingComments.slice() : [],\n          lineEntries: current.lineEntries.slice()\n        });\n\n        current = null;\n      }\n    }\n\n    return statements;\n  }\n\n  function isCommentLine(trimmedLine) {\n    return trimmedLine.startsWith(\"*\") || trimmedLine.startsWith('\"');\n  }\n\n  function normalizeComment(trimmedLine) {\n    const normalizeText = (text) => {\n      const trimmed = String(text || \"\").trim();\n      if (!trimmed) {\n        return \"\";\n      }\n\n      // Treat separator-only comment content as empty.\n      if (\n        !/[A-Za-z0-9\\u00C0-\\u024F\\u1E00-\\u1EFF]/.test(trimmed) &&\n        /^[\\s*&\\-_=~#|\\\\/.:;,+(){}\\[\\]<>]+$/.test(trimmed)\n      ) {\n        return \"\";\n      }\n\n      return trimmed;\n    };\n\n    if (trimmedLine.startsWith(\"*\") || trimmedLine.startsWith('\"')) {\n      return normalizeText(trimmedLine.slice(1));\n    }\n    return normalizeText(trimmedLine);\n  }\n\n  function splitCodeAndInlineComment(line) {\n    const text = String(line || \"\");\n    let inSingleQuote = false;\n    let inPipe = false;\n\n    for (let index = 0; index < text.length; index += 1) {\n      const char = text[index];\n      const next = index + 1 < text.length ? text[index + 1] : \"\";\n\n      if (char === \"'\" && !inPipe) {\n        if (inSingleQuote && next === \"'\") {\n          index += 1;\n          continue;\n        }\n        inSingleQuote = !inSingleQuote;\n        continue;\n      }\n\n      if (char === \"|\" && !inSingleQuote) {\n        if (inPipe && next === \"|\") {\n          index += 1;\n          continue;\n        }\n        inPipe = !inPipe;\n        continue;\n      }\n\n      if (char === '\"' && !inSingleQuote && !inPipe) {\n        const code = text.slice(0, index);\n        const comment = normalizeComment(text.slice(index + 1));\n        return { code, comment };\n      }\n    }\n\n    return { code: text, comment: \"\" };\n  }\n\n  function parseStatements(statements, configs, fileName) {\n    const roots = [];\n    const stack = [];\n    let nextId = 1;\n\n    for (const statement of statements) {\n      const statementStart = getStatementStartKeyword(statement.raw);\n      const currentFrame = stack.length ? stack[stack.length - 1] : null;\n\n      if (currentFrame && statementStart === currentFrame.endKeyword) {\n        currentFrame.node.block.endRaw = statement.raw;\n        currentFrame.node.block.lineEnd = statement.lineStart;\n        stack.pop();\n        continue;\n      }\n\n      const parentId = currentFrame ? currentFrame.node.id : null;\n      const parsedList = parseStatement(statement, configs, fileName, parentId, () => nextId++);\n      if (!parsedList || !parsedList.length) {\n        continue;\n      }\n\n      const targetList = currentFrame ? currentFrame.node.children : roots;\n      for (const node of parsedList) {\n        targetList.push(node);\n        if (node.block && node.block.endKeyword) {\n          stack.push({ node, endKeyword: node.block.endKeyword });\n        }\n      }\n    }\n\n    return roots;\n  }\n\n  function getStatementStartKeyword(raw) {\n    const tokens = tokenize(raw);\n    if (!tokens.length) {\n      return \"\";\n    }\n    return tokens[0].upper;\n  }\n\n  function parseStatement(statement, configs, fileName, parentId, nextId) {\n    const tokens = tokenize(statement.raw);\n    if (tokens.length === 0) {\n      return null;\n    }\n\n    for (const config of configs) {\n      if (!matchesConfig(tokens, config, statement.raw)) {\n        continue;\n      }\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ../shared/abap-parser/02-config.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/02-config.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "      const startKeyword = config.match && config.match.startKeyword;\n      if (startKeyword && isChainedStatementStart(statement.raw, startKeyword)) {\n        const chainedStatements = splitChainedStatementWithMeta(statement, startKeyword);\n        const chainedObjects = [];\n        const structStack = [];\n\n        for (const segment of chainedStatements) {\n          const raw = segment && typeof segment === \"object\" ? segment.raw : segment;\n          const overrides = segment && typeof segment === \"object\"\n            ? {\n                lineStart: segment.lineStart || null,\n                comment: segment.comment || \"\",\n                commentLines: Array.isArray(segment.commentLines) ? segment.commentLines : []\n              }\n            : null;\n\n          const obj = buildObjectFromRaw(raw, config, statement, fileName, nextId(), parentId, overrides);\n          if (!obj) {\n            continue;\n          }\n\n          const segTokens = tokenize(raw);\n          const marker = detectStructMarkerFromTokens(segTokens, startKeyword);\n          if (marker) {\n            const normalizedName = normalizeIdentifierCandidate(marker.name);\n            const nameUpper = normalizedName ? normalizedName.toUpperCase() : \"\";\n            const rootUpper = structStack.length ? structStack[0].nameUpper : nameUpper;\n            const isRootBegin = marker.kind === \"BEGIN\" && structStack.length === 0;\n\n            if (marker.kind === \"BEGIN\") {\n              structStack.push({ nameUpper, name: normalizedName || marker.name });\n            } else if (marker.kind === \"END\") {\n              // Pop 1 level when names match; otherwise just pop once (best-effort).\n              if (structStack.length) {\n                const top = structStack[structStack.length - 1];\n                if (top && top.nameUpper && top.nameUpper === nameUpper) {\n                  structStack.pop();\n                } else {\n                  structStack.pop();\n                }\n              }\n            }\n\n            attachStructMeta(obj, {\n              kind: marker.kind,\n              rootNameUpper: rootUpper || nameUpper,\n              depth: marker.kind === \"BEGIN\" ? structStack.length : structStack.length + 1,\n              isDecl: isRootBegin\n            });\n          } else if (structStack.length) {\n            attachStructMeta(obj, {\n              kind: \"FIELD\",\n              rootNameUpper: structStack[0].nameUpper,\n              depth: structStack.length,\n              isDecl: false\n            });\n          } else {\n            attachStructMeta(obj, null);\n          }\n\n          chainedObjects.push(obj);\n        }\n\n        return chainedObjects.length ? chainedObjects : null;\n      }\n\n      const object = buildObjectFromRaw(statement.raw, config, statement, fileName, nextId(), parentId);\n      if (object && startKeyword) {\n        const marker = detectStructMarkerFromTokens(tokenize(statement.raw), startKeyword);\n        if (marker) {\n          const normalizedName = normalizeIdentifierCandidate(marker.name);\n          const nameUpper = normalizedName ? normalizedName.toUpperCase() : \"\";\n          attachStructMeta(object, {\n            kind: marker.kind,\n            rootNameUpper: nameUpper,\n            depth: 1,\n            isDecl: marker.kind === \"BEGIN\"\n          });\n        } else {\n          attachStructMeta(object, null);\n        }\n      }\n      return object ? [object] : null;\n    }\n\n    return null;\n  }\n\n  function detectStructMarkerFromTokens(tokens, startKeyword) {\n    if (!startKeyword || !Array.isArray(tokens) || tokens.length < 4) {\n      return null;\n    }\n\n    if (!tokens[0] || tokens[0].upper !== String(startKeyword).toUpperCase()) {\n      return null;\n    }\n\n    const t1 = tokens[1] ? tokens[1].upper : \"\";\n    const t2 = tokens[2] ? tokens[2].upper : \"\";\n    const t3 = tokens[3] ? tokens[3].raw : \"\";\n\n    if (t1 === \"BEGIN\" && t2 === \"OF\" && t3) {\n      return { kind: \"BEGIN\", name: t3 };\n    }\n\n    if (t1 === \"END\" && t2 === \"OF\" && t3) {\n      return { kind: \"END\", name: t3 };\n    }\n\n    return null;\n  }\n\n  function attachStructMeta(obj, meta) {\n    if (!obj) {\n      return;\n    }\n\n    if (!meta) {\n      return;\n    }\n\n    const existingExtras = obj.extras && typeof obj.extras === \"object\" ? obj.extras : null;\n    obj.extras = {\n      ...(existingExtras || {}),\n      structDef: {\n        kind: meta.kind || \"\",\n        rootNameUpper: meta.rootNameUpper || \"\",\n        depth: Number(meta.depth || 0) || 0,\n        isDecl: Boolean(meta.isDecl)\n      }\n    };\n  }\n\n  function matchesConfig(tokens, config, raw) {\n    const match = config.match || {};\n    const matchType = match.type ? String(match.type).trim().toLowerCase() : \"\";\n    if (matchType === \"assignment\") {\n      return isAssignmentStatement(tokens) && !isMethodCallExpressionStatement(raw);\n    }\n    if (matchType === \"methodcallexpr\") {\n      return isMethodCallExpressionStatement(raw);\n    }\n    if (match.startTokens && match.startTokens.length) {\n      return matchesTokens(tokens, 0, match.startTokens);\n    }\n\n    const startKeyword = match.startKeyword;\n    if (startKeyword) {\n      return tokens[0].upper === startKeyword;\n    }\n\n    return false;\n  }\n\n  function buildObjectFromRaw(raw, config, statement, fileName, id, parentId, overrides) {\n    return buildObjectFromRawWithOverrides(raw, config, statement, fileName, id, parentId, overrides || null);\n  }\n\n  function buildObjectFromRawWithOverrides(raw, config, statement, fileName, id, parentId, overrides) {\n    const tokens = tokenize(raw);\n    if (tokens.length === 0) {\n      return null;\n    }\n\n    const commentText = overrides && typeof overrides.comment === \"string\" ? overrides.comment : statement.comment;\n    const commentLines = overrides && Array.isArray(overrides.commentLines)\n      ? overrides.commentLines\n      : statement.commentLines || [];\n    const lineStart = overrides && overrides.lineStart ? Number(overrides.lineStart) || null : statement.lineStart;\n\n    const keywordEntries = detectKeywords(tokens, config);\n    const match = config.match || {};\n    const matchType = match.type ? String(match.type).trim().toLowerCase() : \"\";\n    let valueEntries = [];\n    if (matchType === \"assignment\") {\n      valueEntries = captureAssignmentValues(tokens, commentText);\n    } else if (matchType === \"methodcallexpr\") {\n      valueEntries = captureMethodCallExpressionValues(raw, commentText);\n    } else {\n      valueEntries = captureValues(tokens, config, commentText);\n    }\n\n    const keywords = groupEntriesByKey(keywordEntries, \"label\");\n    const values = groupEntriesByKey(valueEntries, \"name\");\n\n    const extras = buildExtras(config, {\n      raw,\n      values,\n      commentLines\n    });\n    const block = config.block && config.block.endKeyword\n      ? {\n          endKeyword: config.block.endKeyword,\n          endRaw: \"\",\n          lineEnd: null\n        }\n      : null;\n\n    return new AbapObject({\n      id,\n      parent: parentId,\n      objectType: config.object,\n      file: fileName,\n      lineStart,\n      raw,\n      block,\n      extras,\n      comment: commentText,\n      keywords,\n      values,\n      children: []\n    });\n  }\n\n  function isAssignmentStatement(tokens) {\n    if (!Array.isArray(tokens) || tokens.length < 3) {\n      return false;\n    }\n\n    const op = tokens[1] && tokens[1].upper ? tokens[1].upper : \"\";\n    const assignmentOps = new Set([\"=\", \"+=\", \"-=\", \"*=\", \"/=\", \"?=\"]);\n    return assignmentOps.has(op);\n  }\n\n  function isMethodCallExpressionStatement(raw) {\n    return Boolean(parseMethodCallExpressionFromRaw(raw));\n  }\n\n  function buildExtras(config, context) {\n    const extrasConfig = config.extras || null;\n    if (!extrasConfig || !extrasConfig.type) {\n      return null;\n    }\n\n    if (extrasConfig.type === \"form\") {\n      return buildFormExtras(context);\n    }\n\n    if (extrasConfig.type === \"callFunction\") {\n      return buildCallFunctionExtras(context);\n    }\n\n    if (extrasConfig.type === \"callMethod\") {\n      return buildCallMethodExtras(context);\n    }\n\n    if (extrasConfig.type === \"callMethodExpr\") {\n      return buildCallMethodExprExtras(context);\n    }\n\n    if (extrasConfig.type === \"methodSignature\") {\n      return buildMethodSignatureExtras(context);\n    }\n\n    if (extrasConfig.type === \"performCall\") {\n      return buildPerformCallExtras(context);\n    }\n\n    if (extrasConfig.type === \"ifCondition\") {\n      return buildIfConditionExtras(context);\n    }\n\n    if (extrasConfig.type === \"selectStatement\") {\n      return buildSelectExtras(context);\n    }\n\n    if (extrasConfig.type === \"readTable\") {\n      return buildReadTableExtras(context);\n    }\n\n    if (extrasConfig.type === \"loopAtItab\") {\n      return buildLoopAtItabExtras(context);\n    }\n\n    if (extrasConfig.type === \"modifyItab\") {\n      return buildModifyItabExtras(context);\n    }\n\n    if (extrasConfig.type === \"deleteItab\") {\n      return buildDeleteItabExtras(context);\n    }\n\n    return null;\n  }\n\n  function buildFormExtras({ raw, values, commentLines }) {\n    const map = valuesToFirstValueMap(values);\n    const formName = map.name || \"\";\n\n    const commentInfo = parseFormDocComment(commentLines || []);\n    const signature = parseFormSignature(map);\n\n    const docsByNameUpper = new Map(\n      commentInfo.params.map((param) => [param.name.toUpperCase(), param])\n    );\n\n    const params = signature.params.map((param) => {\n      const doc = docsByNameUpper.get(param.name.toUpperCase());\n      return {\n        ...param,\n        doc: doc ? { direction: doc.direction, text: doc.text } : null\n      };\n    });\n\n    const docOnly = commentInfo.params\n      .filter((param) => !signature.namesUpper.has(param.name.toUpperCase()))\n      .map((param) => ({\n        name: param.name,\n        section: \"DOC_ONLY\",\n        typing: null,\n        doc: { direction: param.direction, text: param.text }\n      }));\n\n    return {\n      form: {\n        name: formName,\n        nameFromComment: commentInfo.formName || \"\",\n        params: [...params, ...docOnly],\n        exceptions: signature.exceptions\n      }\n    };\n  }\n\n  function buildCallFunctionExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n\n    return {\n      callFunction: {\n        name: map.name || \"\",\n        destination: map.destination || \"\",\n        exporting: parseAssignments(map.exportingRaw || \"\"),\n        importing: parseAssignments(map.importingRaw || \"\"),\n        changing: parseAssignments(map.changingRaw || \"\"),\n        tables: parseAssignments(map.tablesRaw || \"\"),\n        exceptions: parseAssignments(map.exceptionsRaw || \"\")\n      }\n    };\n  }\n\n  function buildCallMethodExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n\n    return {\n      callMethod: {\n        target: map.target || \"\",\n        exporting: parseAssignments(map.exportingRaw || \"\"),\n        importing: parseAssignments(map.importingRaw || \"\"),\n        changing: parseAssignments(map.changingRaw || \"\"),\n        receiving: parseAssignments(map.receivingRaw || \"\"),\n        exceptions: parseAssignments(map.exceptionsRaw || \"\")\n      }\n    };\n  }\n\n  function buildCallMethodExprExtras({ raw, values }) {\n    const map = valuesToFirstValueMap(values);\n    const parsed = parseMethodCallExpressionFromRaw(raw);\n    const sections = parsed ? parsed.sectionRawByName : {\n      exportingRaw: \"\",\n      importingRaw: \"\",\n      changingRaw: \"\",\n      receivingRaw: \"\",\n      exceptionsRaw: \"\"\n    };\n\n    const receivingRaw = map.receivingRaw\n      || sections.receivingRaw\n      || (parsed && parsed.receivingTarget ? `result = ${parsed.receivingTarget}` : \"\");\n\n    return {\n      callMethod: {\n        target: map.target || (parsed ? parsed.callTarget : \"\"),\n        exporting: parseAssignments(map.exportingRaw || sections.exportingRaw || \"\"),\n        importing: parseAssignments(map.importingRaw || sections.importingRaw || \"\"),\n        changing: parseAssignments(map.changingRaw || sections.changingRaw || \"\"),\n        receiving: parseAssignments(receivingRaw),\n        exceptions: parseAssignments(map.exceptionsRaw || sections.exceptionsRaw || \"\")\n      }\n    };\n  }\n\n  function buildMethodSignatureExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const signature = parseMethodSignature(map);\n\n    return {\n      methodSignature: signature\n    };\n  }\n\n  function parseMethodSignature(valueMap) {\n    const importingParams = parseFormParamDefs(\"IMPORTING\", valueMap.importingRaw || \"\");\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ../shared/abap-parser/03-statements.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/03-statements.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    const exportingParams = parseFormParamDefs(\"EXPORTING\", valueMap.exportingRaw || \"\");\n    const changingParams = parseFormParamDefs(\"CHANGING\", valueMap.changingRaw || \"\");\n    const returningParams = parseFormParamDefs(\"RETURNING\", valueMap.returningRaw || \"\");\n    const exceptions = parseFormExceptions(valueMap.raisingRaw || \"\");\n\n    return {\n      name: valueMap.name || \"\",\n      params: [...importingParams, ...exportingParams, ...changingParams, ...returningParams],\n      exceptions\n    };\n  }\n\n  function buildPerformCallExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const ifCondition = map.ifCondition || \"\";\n\n    return {\n      performCall: {\n        form: map.form || \"\",\n        program: map.program || \"\",\n        ifCondition,\n        ifConditions: parseConditionClauses(ifCondition, { allowImplicitAnd: false }),\n        using: parseArgumentTokens(map.usingRaw || \"\").map((value) => ({ value })),\n        changing: parseArgumentTokens(map.changingRaw || \"\").map((value) => ({ value })),\n        tables: parseArgumentTokens(map.tablesRaw || \"\").map((value) => ({ value }))\n      }\n    };\n  }\n\n  function buildIfConditionExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const conditionRaw = map.condition || \"\";\n\n    return {\n      ifCondition: {\n        conditionRaw,\n        conditions: parseConditionClauses(conditionRaw, { allowImplicitAnd: false })\n      }\n    };\n  }\n\n  function buildSelectExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const whereRaw = map.where || \"\";\n    const havingRaw = map.having || \"\";\n\n    return {\n      select: {\n        whereRaw,\n        whereConditions: parseConditionClauses(whereRaw, { allowImplicitAnd: false }),\n        havingRaw,\n        havingConditions: parseConditionClauses(havingRaw, { allowImplicitAnd: false })\n      }\n    };\n  }\n\n  function buildReadTableExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const withKeyRaw = map.withKey || \"\";\n    const withTableKeyRaw = map.withTableKey || \"\";\n\n    const normalizedWithTableKey = normalizeReadTableKeyConditionSource(withTableKeyRaw);\n    const conditionSource = withTableKeyRaw ? normalizedWithTableKey : withKeyRaw;\n\n    return {\n      readTable: {\n        itab: map.itab || \"\",\n        index: map.index || \"\",\n        into: map.into || \"\",\n        assigning: map.assigning || \"\",\n        refInto: map.refInto || \"\",\n        withKeyRaw,\n        withTableKeyRaw,\n        conditions: parseConditionClauses(conditionSource, { allowImplicitAnd: true })\n      }\n    };\n  }\n\n  function buildLoopAtItabExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const whereRaw = map.where || \"\";\n\n    return {\n      loopAtItab: {\n        itab: map.itab || \"\",\n        into: map.into || \"\",\n        assigning: map.assigning || \"\",\n        refInto: map.refInto || \"\",\n        from: map.from || \"\",\n        to: map.to || \"\",\n        whereRaw,\n        conditions: parseConditionClauses(whereRaw, { allowImplicitAnd: false })\n      }\n    };\n  }\n\n  function buildModifyItabExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const whereRaw = map.where || \"\";\n\n    return {\n      modifyItab: {\n        itab: map.itab || map.itabOrDbtab || \"\",\n        from: map.from || \"\",\n        index: map.index || \"\",\n        transporting: map.transporting || \"\",\n        whereRaw,\n        conditions: parseConditionClauses(whereRaw, { allowImplicitAnd: false })\n      }\n    };\n  }\n\n  function buildDeleteItabExtras({ values }) {\n    const map = valuesToFirstValueMap(values);\n    const whereRaw = map.where || \"\";\n\n    return {\n      deleteItab: {\n        target: map.target || \"\",\n        from: map.from || \"\",\n        index: map.index || \"\",\n        whereRaw,\n        conditions: parseConditionClauses(whereRaw, { allowImplicitAnd: false })\n      }\n    };\n  }\n\n  function attachDeclarationRefs({ statements, objects, fileName }) {\n    const allObjects = collectAllObjects(objects);\n    const idToObject = new Map(allObjects.filter((obj) => obj && obj.id).map((obj) => [obj.id, obj]));\n    const procedureBlocks = allObjects\n      .filter((obj) => obj && [\"FORM\", \"METHOD\"].includes(obj.objectType))\n      .filter((obj) => obj.block && obj.block.lineEnd);\n    const classBlocks = allObjects\n      .filter((obj) => obj && obj.objectType === \"CLASS\")\n      .filter((obj) => obj.block && obj.block.lineEnd);\n\n    const classInfo = buildClassInfo(allObjects);\n    const scopeInfoById = buildScopeInfoById({ idToObject });\n\n    const declByScope = new Map();\n    ensureScopeMap(declByScope, 0);\n\n    for (const obj of allObjects) {\n      const scopeId = getDeclarationScopeId(obj, idToObject, procedureBlocks, classBlocks);\n      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);\n      const declaredNames = getDeclaredNamesFromObject(obj);\n      for (const name of declaredNames) {\n        addDecl(declByScope, scopeId, name, buildDeclInfoFromObject(obj, name, scopeInfo));\n      }\n\n      if (obj.objectType === \"FORM\" && obj.extras && obj.extras.form && Array.isArray(obj.extras.form.params)) {\n        const formScopeInfo = scopeInfoById.get(obj.id) || buildFallbackScopeInfo(obj.id);\n        for (const param of obj.extras.form.params) {\n          if (!param || !param.name) {\n            continue;\n          }\n          addDecl(declByScope, obj.id, param.name, {\n            id: obj.id,\n            objectType: \"FORM_PARAM\",\n            name: param.name,\n            file: obj.file || fileName || \"\",\n            lineStart: obj.lineStart || null,\n            raw: obj.raw || \"\",\n            comment: param.doc ? param.doc.text || \"\" : \"\",\n            scopeId: obj.id,\n            scopeLabel: formScopeInfo.scopeLabel,\n            scopeType: formScopeInfo.scopeType,\n            scopeName: formScopeInfo.scopeName\n          });\n        }\n      }\n    }\n\n    for (const statement of statements || []) {\n      const inlineNames = extractInlineDeclarations(statement.raw || \"\");\n      if (!inlineNames.length) {\n        continue;\n      }\n\n      const scopeId = getStatementScopeId(statement.lineStart, procedureBlocks, classBlocks);\n      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);\n      for (const name of inlineNames) {\n        addDecl(declByScope, scopeId, name, {\n          id: null,\n          objectType: \"INLINE\",\n          name,\n          file: fileName || \"\",\n          lineStart: statement.lineStart || null,\n          raw: statement.raw || \"\",\n          comment: statement.comment || \"\",\n          scopeId,\n          scopeLabel: scopeInfo.scopeLabel,\n          scopeType: scopeInfo.scopeType,\n          scopeName: scopeInfo.scopeName\n        });\n      }\n    }\n\n    const structDefs = buildStructDefsFromStatements({\n      statements,\n      procedureBlocks,\n      classBlocks,\n      scopeInfoById,\n      fileName: fileName || \"\"\n    });\n\n    attachStructFieldDecls({\n      allObjects,\n      idToObject,\n      declByScope,\n      scopeInfoById,\n      procedureBlocks,\n      classBlocks,\n      classInfo,\n      fileName: fileName || \"\",\n      structDefs\n    });\n\n    for (const obj of allObjects) {\n      const resolveContext = buildResolveContext(obj, idToObject, declByScope, classInfo);\n      annotateValuesWithDecls(obj.values, resolveContext);\n      annotateExtrasWithDecls(obj.extras, resolveContext);\n    }\n\n    attachPerformOriginDecls({ allObjects, formsByNameUpper: buildFormsByNameUpper(allObjects), scopeInfoById });\n\n    const decls = [];\n    for (const scopeMap of declByScope.values()) {\n      for (const decl of scopeMap.values()) {\n        decls.push(decl);\n      }\n    }\n    return decls;\n  }\n\n  function ensureStructDefScopeMap(mapByScope, scopeId) {\n    if (!mapByScope.has(scopeId)) {\n      mapByScope.set(scopeId, new Map());\n    }\n  }\n\n  function buildStructDefsFromStatements({ statements, procedureBlocks, classBlocks, scopeInfoById, fileName }) {\n    const dataByScope = new Map();\n    const typeByScope = new Map();\n\n    for (const statement of statements || []) {\n      const startKeyword = getStatementStartKeyword(statement.raw || \"\");\n      if (startKeyword !== \"DATA\" && startKeyword !== \"TYPES\") {\n        continue;\n      }\n\n      const lineEntries = Array.isArray(statement.lineEntries) ? statement.lineEntries : [];\n      if (!lineEntries.length) {\n        continue;\n      }\n\n      const scopeId = getStatementScopeId(statement.lineStart, procedureBlocks, classBlocks);\n      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);\n\n      const defs = parseStructDefsFromLineEntries({\n        kind: startKeyword,\n        lineEntries,\n        leadingComments: Array.isArray(statement.leadingComments) ? statement.leadingComments : [],\n        fileName: fileName || \"\",\n        scopeId,\n        scopeInfo\n      });\n\n      const target = startKeyword === \"DATA\" ? dataByScope : typeByScope;\n      ensureStructDefScopeMap(target, scopeId);\n      const scopeMap = target.get(scopeId);\n\n      for (const def of defs) {\n        if (!def || !def.nameUpper) {\n          continue;\n        }\n        if (!scopeMap.has(def.nameUpper)) {\n          scopeMap.set(def.nameUpper, def);\n        }\n      }\n    }\n\n    return { dataByScope, typeByScope };\n  }\n\n  function parseStructDefsFromLineEntries({ kind, lineEntries, leadingComments, fileName, scopeId, scopeInfo }) {\n    const defs = [];\n    let current = null;\n    const stack = [];\n    const leadingText = Array.isArray(leadingComments) ? leadingComments.filter(Boolean).join(\" \").trim() : \"\";\n\n    function currentNestedPrefix() {\n      if (stack.length <= 1) {\n        return \"\";\n      }\n      return stack\n        .slice(1)\n        .map((ctx) => ctx.name)\n        .filter(Boolean)\n        .join(\"-\");\n    }\n\n    function addField(path, info) {\n      if (!current || !path) {\n        return;\n      }\n\n      const normalized = normalizeIdentifierCandidate(path);\n      if (!normalized) {\n        return;\n      }\n\n      const pathUpper = normalized.toUpperCase();\n      if (!current.fields.has(pathUpper)) {\n        current.fields.set(pathUpper, {\n          path: normalized,\n          pathUpper,\n          file: fileName || \"\",\n          lineStart: info && info.lineStart ? info.lineStart : null,\n          raw: info && info.raw ? info.raw : \"\",\n          comment: info && info.comment ? info.comment : \"\"\n        });\n      }\n    }\n\n    for (const entry of lineEntries) {\n      const code = String(entry && entry.code ? entry.code : \"\").trim();\n      if (!code) {\n        continue;\n      }\n\n      const comment = entry && entry.comment ? String(entry.comment || \"\") : \"\";\n      const lineStart = entry && entry.line ? Number(entry.line || 0) || null : null;\n\n      const withoutDot = code.replace(/\\.$/, \"\").trim();\n      const segments = splitByCommaOutsideQuotes(withoutDot)\n        .map((segment) => segment.trim())\n        .filter(Boolean);\n\n      for (const segment of segments) {\n        const marker = parseStructMarker(segment);\n        if (marker && marker.kind === \"BEGIN\") {\n          const name = normalizeIdentifierCandidate(marker.name);\n          if (!name) {\n            continue;\n          }\n          const nameUpper = name.toUpperCase();\n\n          if (!stack.length) {\n            current = {\n              kind,\n              name,\n              nameUpper,\n              file: fileName || \"\",\n              scopeId,\n              scopeLabel: scopeInfo ? scopeInfo.scopeLabel : \"\",\n              lineStart,\n              rawStart: segment,\n              comment: String(comment || \"\").trim() || leadingText,\n              fields: new Map()\n            };\n            stack.push({ name, nameUpper });\n            continue;\n          }\n\n          const prefix = currentNestedPrefix();\n          const path = prefix ? `${prefix}-${name}` : name;\n          addField(path, { lineStart, raw: segment, comment: String(comment || \"\").trim() });\n          stack.push({ name, nameUpper });\n          continue;\n        }\n\n        if (marker && marker.kind === \"END\") {\n          const name = normalizeIdentifierCandidate(marker.name);\n          const nameUpper = name ? name.toUpperCase() : \"\";\n\n          if (stack.length) {\n            const top = stack[stack.length - 1];\n            if (top && top.nameUpper && nameUpper && top.nameUpper === nameUpper) {\n              stack.pop();\n            } else {\n              stack.pop();\n            }\n          }\n\n          if (!stack.length && current) {\n            defs.push(current);\n            current = null;\n          }\n          continue;\n        }\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ../shared/abap-parser/04-parse-core.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/04-parse-core.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\n        if (!stack.length || !current) {\n          continue;\n        }\n\n        const fieldName = extractStructFieldName(segment);\n        if (!fieldName) {\n          continue;\n        }\n\n        const prefix = currentNestedPrefix();\n        const path = prefix ? `${prefix}-${fieldName}` : fieldName;\n        addField(path, { lineStart, raw: segment, comment: String(comment || \"\").trim() });\n      }\n    }\n\n    return defs;\n  }\n\n  function parseStructMarker(segment) {\n    const text = String(segment || \"\");\n    const beginMatch = text.match(/\\bBEGIN\\s+OF\\s+([A-Za-z_][A-Za-z0-9_]*)/i);\n    if (beginMatch) {\n      return { kind: \"BEGIN\", name: beginMatch[1] };\n    }\n\n    const endMatch = text.match(/\\bEND\\s+OF\\s+([A-Za-z_][A-Za-z0-9_]*)/i);\n    if (endMatch) {\n      return { kind: \"END\", name: endMatch[1] };\n    }\n\n    return null;\n  }\n\n  function extractStructFieldName(segment) {\n    const text = String(segment || \"\").trim();\n    if (!text) {\n      return \"\";\n    }\n\n    const match = text.match(/^([A-Za-z_][A-Za-z0-9_]*)/);\n    if (!match) {\n      return \"\";\n    }\n\n    const candidate = match[1] || \"\";\n    const upper = candidate.toUpperCase();\n    if ([\"BEGIN\", \"END\", \"INCLUDE\"].includes(upper)) {\n      return \"\";\n    }\n\n    return normalizeIdentifierCandidate(candidate) || \"\";\n  }\n\n  function resolveStructDefByContext(typeUpper, context, typeStructDefsByScope) {\n    if (!typeUpper || !typeStructDefsByScope) {\n      return null;\n    }\n\n    const procMap = context && context.procId ? typeStructDefsByScope.get(context.procId) : null;\n    if (procMap && procMap.has(typeUpper)) {\n      return procMap.get(typeUpper);\n    }\n\n    const classMap = context && context.classDefId ? typeStructDefsByScope.get(context.classDefId) : null;\n    if (classMap && classMap.has(typeUpper)) {\n      return classMap.get(typeUpper);\n    }\n\n    const globalMap = typeStructDefsByScope.get(0);\n    if (globalMap && globalMap.has(typeUpper)) {\n      return globalMap.get(typeUpper);\n    }\n\n    return null;\n  }\n\n  function getStructTypeCandidateFromDeclObject(obj) {\n    if (!obj) {\n      return \"\";\n    }\n\n    const type = getFirstValue(obj.values, \"type\");\n    const like = getFirstValue(obj.values, \"like\");\n    const structure = getFirstValue(obj.values, \"structure\");\n\n    const candidate = type || like || structure;\n    const normalized = normalizeIdentifierCandidate(candidate);\n    return normalized || \"\";\n  }\n\n  function patchDeclComment(declByScope, scopeId, nameUpper, comment) {\n    const trimmed = String(comment || \"\").trim();\n    if (!declByScope || !declByScope.has(scopeId)) {\n      return;\n    }\n\n    const scopeMap = declByScope.get(scopeId);\n    if (!scopeMap || !scopeMap.has(nameUpper)) {\n      return;\n    }\n\n    const decl = scopeMap.get(nameUpper);\n    if (decl && String(decl.comment || \"\").trim() !== trimmed) {\n      decl.comment = trimmed;\n    }\n  }\n\n  function attachStructFieldDecls({\n    allObjects,\n    idToObject,\n    declByScope,\n    scopeInfoById,\n    procedureBlocks,\n    classBlocks,\n    classInfo,\n    fileName,\n    structDefs\n  }) {\n    const dataByScope = structDefs && structDefs.dataByScope ? structDefs.dataByScope : new Map();\n    const typeByScope = structDefs && structDefs.typeByScope ? structDefs.typeByScope : new Map();\n\n    // 1) DATA inline structs: create `${var}-${field}` decls with per-field comments.\n    for (const [scopeId, defsByName] of dataByScope.entries()) {\n      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);\n\n      for (const def of defsByName.values()) {\n        if (!def || !def.name || !def.nameUpper) {\n          continue;\n        }\n\n        patchDeclComment(declByScope, scopeId, def.nameUpper, def.comment || \"\");\n\n        for (const field of def.fields.values()) {\n          const fullName = `${def.name}-${field.path}`;\n          addDecl(declByScope, scopeId, fullName, {\n            id: null,\n            objectType: \"STRUCT_FIELD\",\n            name: fullName,\n            file: fileName || \"\",\n            lineStart: field.lineStart || null,\n            raw: field.raw || \"\",\n            comment: field.comment || \"\",\n            scopeId,\n            scopeLabel: scopeInfo.scopeLabel,\n            scopeType: scopeInfo.scopeType,\n            scopeName: scopeInfo.scopeName,\n            structName: def.name,\n            fieldPath: field.path,\n            structObjectType: def.kind || \"DATA\",\n            structLineStart: def.lineStart || null,\n            structRaw: def.rawStart || \"\",\n            structComment: def.comment || \"\"\n          });\n        }\n      }\n    }\n\n    // 2) Typed declarations: `DATA ls_s TYPE ty_s.` -> create `ls_s-field` from `TYPES ... BEGIN OF ty_s`.\n    for (const obj of allObjects || []) {\n      if (!obj || !obj.objectType || !obj.values) {\n        continue;\n      }\n\n      const structMeta = obj.extras && typeof obj.extras === \"object\" ? obj.extras.structDef : null;\n      if (structMeta && structMeta.isDecl === false) {\n        continue;\n      }\n\n      const declName = getFirstValue(obj.values, \"name\");\n      const normalizedDeclName = normalizeIdentifierCandidate(declName);\n      if (!normalizedDeclName) {\n        continue;\n      }\n\n      const scopeId = getDeclarationScopeId(obj, idToObject, procedureBlocks, classBlocks);\n      const scopeInfo = scopeInfoById.get(scopeId) || buildFallbackScopeInfo(scopeId);\n\n      // Skip if already an inline DATA struct in the same scope (DATA wins; addDecl also protects).\n      const dataScopeMap = dataByScope.get(scopeId);\n      if (dataScopeMap && dataScopeMap.has(normalizedDeclName.toUpperCase())) {\n        continue;\n      }\n\n      const typeName = getStructTypeCandidateFromDeclObject(obj);\n      if (!typeName) {\n        continue;\n      }\n\n      const typeUpper = typeName.toUpperCase();\n      const context = buildResolveContext(obj, idToObject, declByScope, classInfo);\n      const typeDef = resolveStructDefByContext(typeUpper, context, typeByScope);\n      if (!typeDef) {\n        continue;\n      }\n\n      patchDeclComment(declByScope, typeDef.scopeId || scopeId, typeUpper, typeDef.comment || \"\");\n\n      for (const field of typeDef.fields.values()) {\n        const fullName = `${normalizedDeclName}-${field.path}`;\n        addDecl(declByScope, scopeId, fullName, {\n          id: null,\n          objectType: \"STRUCT_FIELD\",\n          name: fullName,\n          file: fileName || \"\",\n          lineStart: field.lineStart || null,\n          raw: field.raw || \"\",\n          comment: field.comment || \"\",\n          scopeId,\n          scopeLabel: scopeInfo.scopeLabel,\n          scopeType: scopeInfo.scopeType,\n          scopeName: scopeInfo.scopeName,\n          structName: normalizedDeclName,\n          fieldPath: field.path,\n          structObjectType: obj.objectType || \"DATA\",\n          structId: obj.id || null,\n          structLineStart: obj.lineStart || null,\n          structRaw: obj.raw || \"\",\n          structComment: obj.comment || \"\",\n          structTypeName: typeDef.name || typeName,\n          structTypeLineStart: typeDef.lineStart || null,\n          structTypeRaw: typeDef.rawStart || \"\",\n          structTypeComment: typeDef.comment || \"\"\n        });\n      }\n    }\n  }\n\n  function collectAllObjects(roots) {\n    const list = [];\n    for (const root of roots || []) {\n      walkObject(root, list);\n    }\n    return list;\n  }\n\n  function walkObject(node, list) {\n    if (!node) {\n      return;\n    }\n\n    list.push(node);\n    if (Array.isArray(node.children)) {\n      for (const child of node.children) {\n        walkObject(child, list);\n      }\n    }\n  }\n\n  function buildClassInfo(allObjects) {\n    const byName = new Map();\n    for (const obj of allObjects) {\n      if (!obj || obj.objectType !== \"CLASS\") {\n        continue;\n      }\n      const className = getFirstValue(obj.values, \"name\");\n      if (!className) {\n        continue;\n      }\n      const classNameUpper = className.toUpperCase();\n      const kind = classifyClassBlock(obj.raw || \"\");\n      if (!byName.has(classNameUpper)) {\n        byName.set(classNameUpper, { definition: null, implementation: null });\n      }\n      const entry = byName.get(classNameUpper);\n      if (kind === \"DEFINITION\") {\n        entry.definition = obj;\n      } else if (kind === \"IMPLEMENTATION\") {\n        entry.implementation = obj;\n      }\n    }\n\n    const methodParamsByClassAndName = new Map();\n    for (const [classNameUpper, entry] of byName.entries()) {\n      const classDef = entry.definition;\n      if (!classDef || !Array.isArray(classDef.children)) {\n        continue;\n      }\n\n      for (const child of classDef.children) {\n        if (!child || ![\"METHODS\", \"CLASS-METHODS\"].includes(child.objectType)) {\n          continue;\n        }\n\n        const methodName = getFirstValue(child.values, \"name\");\n        if (!methodName) {\n          continue;\n        }\n\n        const signature = child.extras && child.extras.methodSignature ? child.extras.methodSignature : null;\n        const params = signature && Array.isArray(signature.params) ? signature.params : [];\n        const paramsByNameUpper = new Map();\n\n        for (const param of params) {\n          if (!param || !param.name) {\n            continue;\n          }\n          paramsByNameUpper.set(param.name.toUpperCase(), {\n            id: child.id,\n            objectType: \"METHOD_PARAM\",\n            name: param.name,\n            file: child.file || \"\",\n            lineStart: child.lineStart || null,\n            raw: child.raw || \"\",\n            comment: \"\",\n            scopeId: child.id,\n            scopeLabel: `METHODSIG:${classNameUpper}=>${methodName.toUpperCase()}`,\n            scopeType: \"METHODSIG\",\n            scopeName: methodName\n          });\n        }\n\n        methodParamsByClassAndName.set(`${classNameUpper}:${methodName.toUpperCase()}`, {\n          classNameUpper,\n          methodNameUpper: methodName.toUpperCase(),\n          paramsByNameUpper,\n          signatureId: child.id\n        });\n      }\n    }\n\n    return {\n      byName,\n      methodParamsByClassAndName\n    };\n  }\n\n  function classifyClassBlock(raw) {\n    const upper = String(raw || \"\").toUpperCase();\n    if (upper.includes(\" DEFINITION\")) {\n      return \"DEFINITION\";\n    }\n    if (upper.includes(\" IMPLEMENTATION\")) {\n      return \"IMPLEMENTATION\";\n    }\n    return \"\";\n  }\n\n  function getFirstValue(values, name) {\n    if (!values) {\n      return \"\";\n    }\n\n    if (Array.isArray(values)) {\n      for (const entry of values) {\n        if (entry && entry.name === name) {\n          return entry.value || \"\";\n        }\n      }\n      return \"\";\n    }\n\n    if (typeof values !== \"object\") {\n      return \"\";\n    }\n\n    const entryOrList = values[name];\n    if (!entryOrList) {\n      return \"\";\n    }\n\n    const entry = Array.isArray(entryOrList) ? entryOrList[0] : entryOrList;\n    return entry && entry.value ? entry.value || \"\" : \"\";\n  }\n\n  function ensureScopeMap(declByScope, scopeId) {\n    if (!declByScope.has(scopeId)) {\n      declByScope.set(scopeId, new Map());\n    }\n  }\n\n  function addDecl(declByScope, scopeId, name, declInfo) {\n    const normalized = normalizeIdentifierCandidate(name);\n    if (!normalized) {\n      return;\n    }\n    const upper = normalized.toUpperCase();\n    ensureScopeMap(declByScope, scopeId);\n    const map = declByScope.get(scopeId);\n    if (!map.has(upper)) {\n      map.set(upper, declInfo);\n    }\n  }\n\n  function getDeclarationScopeId(obj, idToObject, procedureBlocks, classBlocks) {\n    if (!obj) {\n      return 0;\n    }\n    const procId = getProcedureScopeId(obj, idToObject);\n    if (procId) {\n      return procId;\n    }\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ../shared/abap-parser/05-extras.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/05-extras.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    const line = obj.lineStart || 0;\n    return getStatementScopeId(line, [], classBlocks);\n  }\n\n  function getProcedureScopeId(obj, idToObject) {\n    let current = obj;\n    while (current) {\n      if (current.objectType === \"FORM\" || current.objectType === \"METHOD\") {\n        return current.id || 0;\n      }\n      current = current.parent ? idToObject.get(current.parent) : null;\n    }\n    return 0;\n  }\n\n  function getStatementScopeId(lineStart, procedureBlocks, classBlocks) {\n    const proc = findInnermostBlock(lineStart, procedureBlocks);\n    if (proc) {\n      return proc.id || 0;\n    }\n    const cls = findInnermostBlock(lineStart, classBlocks);\n    if (cls) {\n      return cls.id || 0;\n    }\n    return 0;\n  }\n\n  function findInnermostBlock(line, blocks) {\n    let best = null;\n    let bestSize = Infinity;\n    const currentLine = Number(line || 0);\n\n    for (const block of blocks || []) {\n      const start = Number(block.lineStart || 0);\n      const end = Number(block.block && block.block.lineEnd ? block.block.lineEnd : 0);\n      if (!start || !end) {\n        continue;\n      }\n      if (currentLine < start || currentLine > end) {\n        continue;\n      }\n      const size = end - start;\n      if (size < bestSize) {\n        best = block;\n        bestSize = size;\n      }\n    }\n\n    return best;\n  }\n\n  function getDeclaredNamesFromObject(obj) {\n    if (!obj || !obj.objectType) {\n      return [];\n    }\n\n    const structMeta = obj.extras && typeof obj.extras === \"object\" ? obj.extras.structDef : null;\n    if (structMeta && structMeta.isDecl === false) {\n      return [];\n    }\n\n    const type = obj.objectType;\n    if ([\"DATA\", \"CONSTANTS\", \"PARAMETERS\", \"SELECT-OPTIONS\", \"TYPES\", \"RANGES\", \"STATICS\", \"CLASS-DATA\", \"FIELD-SYMBOLS\"].includes(type)) {\n      const name = getFirstValue(obj.values, \"name\");\n      return name ? [name] : [];\n    }\n\n    return [];\n  }\n\n  function buildDeclInfoFromObject(obj, name, scopeInfo) {\n    const scope = scopeInfo || buildFallbackScopeInfo(0);\n    return {\n      id: obj.id || null,\n      objectType: obj.objectType || \"\",\n      name: normalizeIdentifierCandidate(name) || name || \"\",\n      file: obj.file || \"\",\n      lineStart: obj.lineStart || null,\n      raw: obj.raw || \"\",\n      comment: obj.comment || \"\",\n      scopeId: scope.scopeId,\n      scopeLabel: scope.scopeLabel,\n      scopeType: scope.scopeType,\n      scopeName: scope.scopeName\n    };\n  }\n\n  function buildFallbackScopeInfo(scopeId) {\n    const id = Number(scopeId || 0) || 0;\n    if (!id) {\n      return { scopeId: 0, scopeType: \"GLOBAL\", scopeLabel: \"GLOBAL\", scopeName: \"\" };\n    }\n    return { scopeId: id, scopeType: \"SCOPE\", scopeLabel: `SCOPE:${id}`, scopeName: \"\" };\n  }\n\n  function buildScopeInfoById({ idToObject }) {\n    const map = new Map();\n    map.set(0, buildFallbackScopeInfo(0));\n\n    for (const [id, obj] of idToObject.entries()) {\n      if (!obj || !obj.objectType) {\n        continue;\n      }\n\n      const type = obj.objectType;\n      if (![\"FORM\", \"METHOD\", \"CLASS\", \"METHODS\", \"CLASS-METHODS\"].includes(type)) {\n        continue;\n      }\n\n      if (type === \"FORM\") {\n        const formName = getFirstValue(obj.values, \"name\") || \"\";\n        const upper = formName ? formName.toUpperCase() : \"\";\n        map.set(id, {\n          scopeId: id,\n          scopeType: \"FORM\",\n          scopeLabel: upper ? `FORM:${upper}` : `FORM:${id}`,\n          scopeName: formName\n        });\n        continue;\n      }\n\n      if (type === \"METHOD\") {\n        const methodName = getFirstValue(obj.values, \"name\") || \"\";\n        const methodUpper = methodName ? methodName.toUpperCase() : \"\";\n        const classUpper = findAncestorNameUpper(obj, idToObject, \"CLASS\");\n        const label = classUpper && methodUpper\n          ? `METHOD:${classUpper}=>${methodUpper}`\n          : methodUpper\n              ? `METHOD:${methodUpper}`\n              : `METHOD:${id}`;\n\n        map.set(id, {\n          scopeId: id,\n          scopeType: \"METHOD\",\n          scopeLabel: label,\n          scopeName: methodName\n        });\n        continue;\n      }\n\n      if (type === \"CLASS\") {\n        const className = getFirstValue(obj.values, \"name\") || \"\";\n        const classUpper = className ? className.toUpperCase() : \"\";\n        map.set(id, {\n          scopeId: id,\n          scopeType: \"CLASS\",\n          scopeLabel: classUpper ? `CLASS:${classUpper}` : `CLASS:${id}`,\n          scopeName: className\n        });\n        continue;\n      }\n\n      if (type === \"METHODS\" || type === \"CLASS-METHODS\") {\n        const methodName = getFirstValue(obj.values, \"name\") || \"\";\n        const methodUpper = methodName ? methodName.toUpperCase() : \"\";\n        const classUpper = findAncestorNameUpper(obj, idToObject, \"CLASS\");\n        const label = classUpper && methodUpper\n          ? `METHODSIG:${classUpper}=>${methodUpper}`\n          : methodUpper\n              ? `METHODSIG:${methodUpper}`\n              : `METHODSIG:${id}`;\n\n        map.set(id, {\n          scopeId: id,\n          scopeType: \"METHODSIG\",\n          scopeLabel: label,\n          scopeName: methodName\n        });\n      }\n    }\n\n    return map;\n  }\n\n  function findAncestorNameUpper(obj, idToObject, objectType) {\n    let current = obj;\n    while (current) {\n      if (current.objectType === objectType) {\n        const name = getFirstValue(current.values, \"name\") || \"\";\n        return name ? name.toUpperCase() : \"\";\n      }\n      current = current.parent ? idToObject.get(current.parent) : null;\n    }\n    return \"\";\n  }\n\n  function buildFormsByNameUpper(allObjects) {\n    const map = new Map();\n    for (const obj of allObjects || []) {\n      if (!obj || obj.objectType !== \"FORM\") {\n        continue;\n      }\n\n      const name = getFirstValue(obj.values, \"name\") || (obj.extras && obj.extras.form ? obj.extras.form.name : \"\");\n      if (!name) {\n        continue;\n      }\n\n      const upper = String(name).toUpperCase();\n      if (!map.has(upper)) {\n        map.set(upper, obj);\n      }\n    }\n    return map;\n  }\n\n  function declIdentityKey(decl) {\n    if (!decl) {\n      return \"\";\n    }\n    const objectType = decl.objectType || \"\";\n    const scopeLabel = decl.scopeLabel || \"\";\n    const name = decl.name || \"\";\n    const file = decl.file || \"\";\n    const line = decl.lineStart || \"\";\n    return `${objectType}|${scopeLabel}|${name}|${file}|${line}`;\n  }\n\n  function attachPerformOriginDecls({ allObjects, formsByNameUpper }) {\n    const formParamSections = new Set([\"USING\", \"CHANGING\", \"TABLES\"]);\n\n    const forms = Array.from(formsByNameUpper.values())\n      .filter((obj) => obj && obj.id && obj.extras && obj.extras.form && Array.isArray(obj.extras.form.params));\n\n    const formParamsByFormId = new Map();\n    const originsByFormIdAndParamUpper = new Map();\n\n    for (const form of forms) {\n      const params = form.extras.form.params.filter((param) => param && formParamSections.has(param.section));\n      const byNameUpper = new Map(params.map((param) => [param.name.toUpperCase(), param]));\n      const bySection = { USING: [], CHANGING: [], TABLES: [] };\n      for (const param of params) {\n        bySection[param.section].push(param);\n      }\n\n      formParamsByFormId.set(form.id, { form, byNameUpper, bySection });\n\n      const originByParam = new Map();\n      for (const param of params) {\n        originByParam.set(param.name.toUpperCase(), new Map());\n      }\n      originsByFormIdAndParamUpper.set(form.id, originByParam);\n    }\n\n    const performCalls = (allObjects || []).filter(\n      (obj) => obj && obj.objectType === \"PERFORM\" && obj.extras && obj.extras.performCall\n    );\n\n    function getOriginsForFormParamDecl(decl) {\n      if (!decl || decl.objectType !== \"FORM_PARAM\" || !decl.id || !decl.name) {\n        return new Map();\n      }\n      const byParam = originsByFormIdAndParamUpper.get(decl.id);\n      if (!byParam) {\n        return new Map();\n      }\n      return byParam.get(decl.name.toUpperCase()) || new Map();\n    }\n\n    function originsFromValueDecl(valueDecl) {\n      if (!valueDecl) {\n        return new Map();\n      }\n      if (valueDecl.objectType === \"FORM_PARAM\") {\n        return new Map(getOriginsForFormParamDecl(valueDecl));\n      }\n      const key = declIdentityKey(valueDecl);\n      return key ? new Map([[key, valueDecl]]) : new Map();\n    }\n\n    function unionInto(target, source) {\n      if (!target || !source) {\n        return false;\n      }\n      let changed = false;\n      for (const [key, decl] of source.entries()) {\n        if (!target.has(key)) {\n          target.set(key, decl);\n          changed = true;\n        }\n      }\n      return changed;\n    }\n\n    const maxIterations = 50;\n    for (let iter = 0; iter < maxIterations; iter += 1) {\n      let changed = false;\n\n      for (const callObj of performCalls) {\n        const call = callObj.extras.performCall;\n        const formNameUpper = String(call.form || \"\").toUpperCase();\n        if (!formNameUpper) {\n          continue;\n        }\n\n        const calleeForm = formsByNameUpper.get(formNameUpper);\n        if (!calleeForm || !calleeForm.id) {\n          continue;\n        }\n\n        const calleeInfo = formParamsByFormId.get(calleeForm.id);\n        if (!calleeInfo) {\n          continue;\n        }\n\n        const calleeOrigins = originsByFormIdAndParamUpper.get(calleeForm.id);\n        if (!calleeOrigins) {\n          continue;\n        }\n\n        for (const section of [\"USING\", \"CHANGING\", \"TABLES\"]) {\n          const formalParams = calleeInfo.bySection[section] || [];\n          const actualArgs = Array.isArray(call[section.toLowerCase()]) ? call[section.toLowerCase()] : [];\n          const max = Math.min(formalParams.length, actualArgs.length);\n\n          for (let index = 0; index < max; index += 1) {\n            const formal = formalParams[index];\n            const actual = actualArgs[index];\n            if (!formal || !formal.name || !actual) {\n              continue;\n            }\n\n            const target = calleeOrigins.get(formal.name.toUpperCase());\n            if (!target) {\n              continue;\n            }\n\n            const sourceOrigins = originsFromValueDecl(actual.valueDecl);\n            if (unionInto(target, sourceOrigins)) {\n              changed = true;\n            }\n          }\n        }\n      }\n\n      if (!changed) {\n        break;\n      }\n    }\n\n    for (const form of forms) {\n      const originByParam = originsByFormIdAndParamUpper.get(form.id);\n      if (!originByParam) {\n        continue;\n      }\n\n      for (const param of form.extras.form.params) {\n        if (!param || !param.name || !formParamSections.has(param.section)) {\n          continue;\n        }\n        const originMap = originByParam.get(param.name.toUpperCase());\n        param.originDecls = originMap ? Array.from(originMap.values()) : [];\n      }\n    }\n\n    for (const callObj of performCalls) {\n      const call = callObj.extras.performCall;\n      for (const sectionName of [\"using\", \"changing\", \"tables\"]) {\n        const list = Array.isArray(call[sectionName]) ? call[sectionName] : [];\n        for (const entry of list) {\n          entry.originDecls = Array.from(originsFromValueDecl(entry.valueDecl).values());\n        }\n      }\n    }\n\n    for (const obj of allObjects || []) {\n      if (!obj || !obj.extras) {\n        continue;\n      }\n\n      if (obj.extras.callFunction) {\n        for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"tables\", \"exceptions\"]) {\n          const list = Array.isArray(obj.extras.callFunction[sectionName]) ? obj.extras.callFunction[sectionName] : [];\n          for (const entry of list) {\n            entry.originDecls = Array.from(originsFromValueDecl(entry.valueDecl).values());\n          }\n        }\n      }\n\n      if (obj.extras.callMethod) {\n        for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"receiving\", \"exceptions\"]) {\n          const list = Array.isArray(obj.extras.callMethod[sectionName]) ? obj.extras.callMethod[sectionName] : [];\n          for (const entry of list) {\n            entry.originDecls = Array.from(originsFromValueDecl(entry.valueDecl).values());\n          }\n        }\n      }\n    }\n  }\n\n  function extractInlineDeclarations(raw) {\n    const text = String(raw || \"\");\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ../shared/abap-parser/06-conditions.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/06-conditions.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    const results = [];\n\n    [\n      /@?DATA\\s*\\(\\s*([^)]+)\\s*\\)/gi,\n      /@?FINAL\\s*\\(\\s*([^)]+)\\s*\\)/gi,\n      /FIELD-SYMBOL\\s*\\(\\s*(<[^>]+>)\\s*\\)/gi\n    ].forEach((regex) => {\n      let match = null;\n      while ((match = regex.exec(text))) {\n        const candidate = normalizeIdentifierCandidate(match[1]);\n        if (candidate) {\n          results.push(candidate);\n        }\n      }\n    });\n\n    return Array.from(new Set(results));\n  }\n\n  function normalizeIdentifierCandidate(raw) {\n    const trimmed = String(raw || \"\").trim();\n    if (!trimmed) {\n      return \"\";\n    }\n    if (/^<[^>]+>$/.test(trimmed)) {\n      return trimmed;\n    }\n    if (/^SY-[A-Za-z_][A-Za-z0-9_]*$/i.test(trimmed)) {\n      return trimmed.toUpperCase();\n    }\n    if (/^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(-[A-Za-z_][A-Za-z0-9_]*)+$/i.test(trimmed)) {\n      return trimmed;\n    }\n    if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(trimmed)) {\n      return trimmed;\n    }\n    return \"\";\n  }\n\n  function buildResolveContext(obj, idToObject, declByScope, classInfo) {\n    const procId = getProcedureScopeId(obj, idToObject);\n    const methodBlock = findAncestor(obj, idToObject, \"METHOD\");\n    const classBlock = findAncestor(obj, idToObject, \"CLASS\");\n\n    const classNameUpper = classBlock ? getFirstValue(classBlock.values, \"name\").toUpperCase() : \"\";\n    const methodNameUpper = methodBlock ? getFirstValue(methodBlock.values, \"name\").toUpperCase() : \"\";\n    const classDef = classNameUpper && classInfo.byName.get(classNameUpper)\n      ? classInfo.byName.get(classNameUpper).definition\n      : null;\n\n    const methodParamsEntry = classNameUpper && methodNameUpper\n      ? classInfo.methodParamsByClassAndName.get(`${classNameUpper}:${methodNameUpper}`)\n      : null;\n\n    return {\n      obj,\n      procId,\n      classNameUpper,\n      methodNameUpper,\n      classDefId: classDef ? classDef.id : 0,\n      declByScope,\n      methodParamsByNameUpper: methodParamsEntry ? methodParamsEntry.paramsByNameUpper : null\n    };\n  }\n\n  function findAncestor(obj, idToObject, objectType) {\n    let current = obj;\n    while (current) {\n      if (current.objectType === objectType) {\n        return current;\n      }\n      current = current.parent ? idToObject.get(current.parent) : null;\n    }\n    return null;\n  }\n\n  function annotateValuesWithDecls(values, context) {\n    const annotateEntry = (entry) => {\n      if (!entry || !entry.value) {\n        return;\n      }\n      const ref = extractFirstIdentifierFromExpression(entry.value);\n      if (!ref) {\n        return;\n      }\n      const decl = resolveDecl(ref, context);\n      if (!decl) {\n        return;\n      }\n      entry.declRef = ref;\n      entry.decl = decl;\n    };\n\n    if (Array.isArray(values)) {\n      for (const entry of values) {\n        annotateEntry(entry);\n      }\n      return;\n    }\n\n    if (!values || typeof values !== \"object\") {\n      return;\n    }\n\n    for (const key of Object.keys(values)) {\n      const entryOrList = values[key];\n      if (Array.isArray(entryOrList)) {\n        for (const entry of entryOrList) {\n          annotateEntry(entry);\n        }\n        continue;\n      }\n      annotateEntry(entryOrList);\n    }\n  }\n\n  function annotateExtrasWithDecls(extras, context) {\n    if (!extras || typeof extras !== \"object\") {\n      return;\n    }\n\n    if (extras.callFunction) {\n      annotateCallFunctionExtras(extras.callFunction, context);\n    }\n\n    if (extras.callMethod) {\n      annotateCallMethodExtras(extras.callMethod, context);\n    }\n\n    if (extras.performCall) {\n      annotatePerformCallExtras(extras.performCall, context);\n    }\n\n    if (extras.ifCondition) {\n      annotateIfConditionExtras(extras.ifCondition, context);\n    }\n\n    if (extras.select) {\n      annotateSelectExtras(extras.select, context);\n    }\n\n    if (extras.readTable) {\n      annotateReadTableExtras(extras.readTable, context);\n    }\n\n    if (extras.loopAtItab) {\n      annotateLoopAtItabExtras(extras.loopAtItab, context);\n    }\n\n    if (extras.modifyItab) {\n      annotateModifyItabExtras(extras.modifyItab, context);\n    }\n\n    if (extras.deleteItab) {\n      annotateDeleteItabExtras(extras.deleteItab, context);\n    }\n  }\n\n  function annotateCallFunctionExtras(callFunction, context) {\n    for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"tables\", \"exceptions\"]) {\n      const list = callFunction && Array.isArray(callFunction[sectionName]) ? callFunction[sectionName] : [];\n      for (const entry of list) {\n        if (!entry || !entry.value) {\n          continue;\n        }\n        const ref = extractFirstIdentifierFromExpression(entry.value);\n        if (!ref) {\n          continue;\n        }\n        entry.valueRef = ref;\n        entry.valueDecl = resolveDecl(ref, context);\n      }\n    }\n  }\n\n  function annotateCallMethodExtras(callMethod, context) {\n    for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"receiving\", \"exceptions\"]) {\n      const list = callMethod && Array.isArray(callMethod[sectionName]) ? callMethod[sectionName] : [];\n      for (const entry of list) {\n        if (!entry || !entry.value) {\n          continue;\n        }\n        const ref = extractFirstIdentifierFromExpression(entry.value);\n        if (!ref) {\n          continue;\n        }\n        entry.valueRef = ref;\n        entry.valueDecl = resolveDecl(ref, context);\n      }\n    }\n  }\n\n  function annotatePerformCallExtras(performCall, context) {\n    for (const sectionName of [\"using\", \"changing\", \"tables\"]) {\n      const list = performCall && Array.isArray(performCall[sectionName]) ? performCall[sectionName] : [];\n      for (const entry of list) {\n        if (!entry || !entry.value) {\n          continue;\n        }\n        const ref = extractFirstIdentifierFromExpression(entry.value);\n        if (!ref) {\n          continue;\n        }\n        entry.valueRef = ref;\n        entry.valueDecl = resolveDecl(ref, context);\n      }\n    }\n\n    annotateConditionClausesWithDecls(performCall ? performCall.ifConditions : null, context);\n  }\n\n  function annotateIfConditionExtras(ifCondition, context) {\n    if (!ifCondition || typeof ifCondition !== \"object\") {\n      return;\n    }\n    annotateConditionClausesWithDecls(ifCondition.conditions, context);\n  }\n\n  function annotateSelectExtras(selectExtras, context) {\n    if (!selectExtras || typeof selectExtras !== \"object\") {\n      return;\n    }\n    annotateConditionClausesWithDecls(selectExtras.whereConditions, context);\n    annotateConditionClausesWithDecls(selectExtras.havingConditions, context);\n  }\n\n  function annotateConditionClausesWithDecls(conditions, context) {\n    const list = Array.isArray(conditions) ? conditions : [];\n    for (const clause of list) {\n      if (!clause || typeof clause !== \"object\") {\n        continue;\n      }\n\n      const leftRef = extractFirstIdentifierFromExpression(clause.leftOperand);\n      if (leftRef) {\n        clause.leftOperandRef = leftRef;\n        clause.leftOperandDecl = resolveDecl(leftRef, context) || buildSyntheticConditionOperandDeclInfo(clause.leftOperand, leftRef);\n      } else {\n        clause.leftOperandDecl = buildSyntheticConditionOperandDeclInfo(clause.leftOperand, \"\");\n      }\n\n      const operatorUpper = String(clause.comparisonOperator || \"\").toUpperCase();\n      const skipRightAnnotation = operatorUpper === \"IS\" && isUnaryIsPredicate(clause.rightOperand);\n      const rightRef = skipRightAnnotation ? \"\" : extractFirstIdentifierFromExpression(clause.rightOperand);\n      if (rightRef) {\n        clause.rightOperandRef = rightRef;\n        clause.rightOperandDecl = resolveDecl(rightRef, context) || buildSyntheticConditionOperandDeclInfo(clause.rightOperand, rightRef);\n      } else if (skipRightAnnotation) {\n        clause.rightOperandDecl = buildUnaryIsPredicateDeclInfo(clause.rightOperand);\n      } else {\n        clause.rightOperandDecl = buildSyntheticConditionOperandDeclInfo(clause.rightOperand, \"\");\n      }\n    }\n  }\n\n  function isUnaryIsPredicate(value) {\n    const text = String(value || \"\").trim();\n    if (!text) {\n      return false;\n    }\n    return /^(?:NOT\\s+)?(?:INITIAL|ASSIGNED|BOUND|SUPPLIED|REQUESTED)$/i.test(text);\n  }\n\n  function buildUnaryIsPredicateDeclInfo(value) {\n    const text = String(value || \"\").trim().toUpperCase().replace(/\\s+/g, \" \");\n    if (!text) {\n      return null;\n    }\n    return {\n      id: null,\n      objectType: \"SYSTEM\",\n      name: text,\n      file: \"\",\n      lineStart: null,\n      raw: \"\",\n      comment: \"\",\n      scopeId: 0,\n      scopeLabel: \"SYSTEM\",\n      scopeType: \"SYSTEM\",\n      scopeName: \"\"\n    };\n  }\n\n  function buildSyntheticConditionOperandDeclInfo(rawValue, preferredName) {\n    const rawText = String(rawValue || \"\").trim();\n    const preferredText = String(preferredName || \"\").trim();\n    const name = preferredText || rawText;\n    if (!name) {\n      return null;\n    }\n    return {\n      id: null,\n      objectType: \"CONDITION_VALUE\",\n      name,\n      file: \"\",\n      lineStart: null,\n      raw: rawText,\n      comment: \"\",\n      scopeId: 0,\n      scopeLabel: \"CONDITION\",\n      scopeType: \"SYSTEM\",\n      scopeName: \"\"\n    };\n  }\n\n  function annotateReadTableExtras(readTable, context) {\n    if (!readTable || typeof readTable !== \"object\") {\n      return;\n    }\n    annotateConditionClausesWithDecls(readTable.conditions, context);\n  }\n\n  function annotateLoopAtItabExtras(loopAtItab, context) {\n    if (!loopAtItab || typeof loopAtItab !== \"object\") {\n      return;\n    }\n    annotateConditionClausesWithDecls(loopAtItab.conditions, context);\n  }\n\n  function annotateModifyItabExtras(modifyItab, context) {\n    if (!modifyItab || typeof modifyItab !== \"object\") {\n      return;\n    }\n    annotateConditionClausesWithDecls(modifyItab.conditions, context);\n  }\n\n  function annotateDeleteItabExtras(deleteItab, context) {\n    if (!deleteItab || typeof deleteItab !== \"object\") {\n      return;\n    }\n    annotateConditionClausesWithDecls(deleteItab.conditions, context);\n  }\n\n  function resolveDecl(identifier, context) {\n    const normalized = normalizeIdentifierCandidate(identifier);\n    if (!normalized) {\n      return null;\n    }\n    const upper = normalized.toUpperCase();\n\n    const procMap = context.procId ? context.declByScope.get(context.procId) : null;\n    if (procMap && procMap.has(upper)) {\n      return procMap.get(upper);\n    }\n\n    const methodParams = context.methodParamsByNameUpper;\n    if (methodParams && methodParams.has(upper)) {\n      return methodParams.get(upper);\n    }\n\n    const classMap = context.classDefId ? context.declByScope.get(context.classDefId) : null;\n    if (classMap && classMap.has(upper)) {\n      return classMap.get(upper);\n    }\n\n    const globalMap = context.declByScope.get(0);\n    if (globalMap && globalMap.has(upper)) {\n      return globalMap.get(upper);\n    }\n\n    const systemDecl = buildSystemDeclInfo(normalized);\n    if (systemDecl) {\n      return systemDecl;\n    }\n\n    return null;\n  }\n\n  function buildSystemDeclInfo(identifier) {\n    const upper = String(identifier || \"\").trim().toUpperCase();\n    if (!upper) {\n      return null;\n    }\n\n    const known = new Set([\n      \"ABAP_TRUE\",\n      \"ABAP_FALSE\",\n      \"ABAP_UNDEFINED\",\n      \"SPACE\",\n      \"SY-SUBRC\",\n      \"SY-TABIX\",\n      \"SY-UNAME\",\n      \"SY-REPID\"\n    ]);\n\n    if (!upper.startsWith(\"SY-\") && !known.has(upper)) {\n      return null;\n    }\n\n    return {\n      id: null,\n      objectType: \"SYSTEM\",\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ../shared/abap-parser/07-declarations.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/07-declarations.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "      name: upper,\n      file: \"\",\n      lineStart: null,\n      raw: \"\",\n      comment: \"\",\n      scopeId: 0,\n      scopeLabel: \"SYSTEM\",\n      scopeType: \"SYSTEM\",\n      scopeName: \"\"\n    };\n  }\n\n  function extractFirstIdentifierFromExpression(expression) {\n    const text = String(expression || \"\").trim();\n    if (!text) {\n      return \"\";\n    }\n    if (text.startsWith(\"'\") || text.startsWith(\"|\")) {\n      return \"\";\n    }\n    if (/^[+-]?\\d/.test(text)) {\n      return \"\";\n    }\n\n    const sysMatch = text.match(/^SY-[A-Za-z_][A-Za-z0-9_]*/i);\n    if (sysMatch) {\n      return sysMatch[0].toUpperCase();\n    }\n\n    const fieldPath = extractFirstFieldPathFromExpression(text);\n    if (fieldPath) {\n      return fieldPath;\n    }\n\n    const inline = extractFirstInlineDeclaration(text);\n    if (inline) {\n      return inline;\n    }\n\n    const matches = text.matchAll(/<[^>]+>|[A-Za-z_][A-Za-z0-9_]*/g);\n    for (const match of matches) {\n      const candidate = normalizeIdentifierCandidate(match[0]);\n      if (candidate) {\n        return candidate;\n      }\n    }\n\n    return \"\";\n  }\n\n  function extractFirstFieldPathFromExpression(text) {\n    const match = String(text || \"\").match(/^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(?:-[A-Za-z_][A-Za-z0-9_]*)+/);\n    if (!match) {\n      return \"\";\n    }\n    const candidate = normalizeIdentifierCandidate(match[0]);\n    return candidate || \"\";\n  }\n\n  function extractFirstInlineDeclaration(text) {\n    const patterns = [\n      { regex: /@?DATA\\s*\\(\\s*([^)]+)\\s*\\)/i, group: 1 },\n      { regex: /@?FINAL\\s*\\(\\s*([^)]+)\\s*\\)/i, group: 1 },\n      { regex: /FIELD-SYMBOL\\s*\\(\\s*(<[^>]+>)\\s*\\)/i, group: 1 }\n    ];\n\n    let best = null;\n    for (const pattern of patterns) {\n      const match = pattern.regex.exec(text);\n      if (!match) {\n        continue;\n      }\n      const candidate = normalizeIdentifierCandidate(match[pattern.group]);\n      if (!candidate) {\n        continue;\n      }\n      if (!best || match.index < best.index) {\n        best = { index: match.index, name: candidate };\n      }\n    }\n\n    return best ? best.name : \"\";\n  }\n\n  const CONDITION_OPERATORS = new Set([\n    \"=\",\n    \"<>\",\n    \"<\",\n    \">\",\n    \"<=\",\n    \">=\",\n    \"EQ\",\n    \"NE\",\n    \"LT\",\n    \"GT\",\n    \"LE\",\n    \"GE\",\n    \"CO\",\n    \"CN\",\n    \"CA\",\n    \"NA\",\n    \"CS\",\n    \"NS\",\n    \"CP\",\n    \"NP\",\n    \"IN\",\n    \"IS\",\n    \"BT\",\n    \"NB\"\n  ]);\n\n  const CONDITION_CONNECTORS = new Set([\"AND\", \"OR\"]);\n\n  function isConditionOperator(tokenUpper) {\n    return CONDITION_OPERATORS.has(String(tokenUpper || \"\").toUpperCase());\n  }\n\n  function isConditionConnector(tokenUpper) {\n    return CONDITION_CONNECTORS.has(String(tokenUpper || \"\").toUpperCase());\n  }\n\n  function normalizeReadTableKeyConditionSource(segmentRaw) {\n    const raw = String(segmentRaw || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const match = raw.match(/^(?:[A-Za-z_][A-Za-z0-9_]*\\s+)?COMPONENTS\\s+(.+)$/i);\n    if (!match) {\n      return raw;\n    }\n    return String(match[1] || \"\").trim();\n  }\n\n  function parseConditionClauses(segmentRaw, options) {\n    const raw = String(segmentRaw || \"\").trim();\n    if (!raw) {\n      return [];\n    }\n\n    const allowImplicitAnd = !options || options.allowImplicitAnd !== false;\n    const tokens = tokenize(`${raw}.`);\n    if (!tokens.length) {\n      return [];\n    }\n\n    const clauses = [];\n    let index = 0;\n\n    while (index < tokens.length) {\n      while (index < tokens.length && isConditionConnector(tokens[index].upper)) {\n        index += 1;\n      }\n      if (index >= tokens.length) {\n        break;\n      }\n\n      let opIndex = -1;\n      for (let i = index; i < tokens.length; i += 1) {\n        if (isConditionConnector(tokens[i].upper)) {\n          break;\n        }\n        if (isConditionOperator(tokens[i].upper)) {\n          opIndex = i;\n          break;\n        }\n      }\n      if (opIndex <= index) {\n        break;\n      }\n\n      const leftTokens = tokens.slice(index, opIndex);\n      if (!leftTokens.length) {\n        index = opIndex + 1;\n        continue;\n      }\n\n      const rightStart = opIndex + 1;\n      if (rightStart >= tokens.length) {\n        break;\n      }\n\n      let rightEnd = tokens.length - 1;\n      let explicitConnectorIndex = -1;\n      let implicitNextClauseIndex = -1;\n      const operatorUpper = String(tokens[opIndex].upper || \"\").toUpperCase();\n      const expectsRangeBounds = operatorUpper === \"BT\" || operatorUpper === \"NB\";\n      let rangeConnectorConsumed = false;\n\n      for (let i = rightStart; i < tokens.length; i += 1) {\n        if (isConditionConnector(tokens[i].upper)) {\n          if (expectsRangeBounds && !rangeConnectorConsumed && String(tokens[i].upper || \"\").toUpperCase() === \"AND\") {\n            rangeConnectorConsumed = true;\n            continue;\n          }\n          explicitConnectorIndex = i;\n          rightEnd = i - 1;\n          break;\n        }\n\n        const next = tokens[i + 1];\n        if (allowImplicitAnd && i > rightStart && next && isConditionOperator(next.upper)) {\n          implicitNextClauseIndex = i;\n          rightEnd = i - 1;\n          break;\n        }\n      }\n\n      const rightTokens = tokens.slice(rightStart, rightEnd + 1);\n      if (!rightTokens.length) {\n        if (explicitConnectorIndex >= 0) {\n          index = explicitConnectorIndex + 1;\n          continue;\n        }\n        break;\n      }\n\n      const leftOperand = leftTokens.map((token) => token.raw).join(\" \").trim();\n      const rightOperand = rightTokens.map((token) => token.raw).join(\" \").trim();\n      const comparisonOperator = String(tokens[opIndex].raw || \"\").trim();\n      if (!leftOperand || !rightOperand || !comparisonOperator) {\n        break;\n      }\n\n      let logicalConnector = \"\";\n      if (explicitConnectorIndex >= 0) {\n        logicalConnector = String(tokens[explicitConnectorIndex].upper || \"\").trim();\n      } else if (implicitNextClauseIndex >= 0) {\n        logicalConnector = \"AND\";\n      }\n\n      clauses.push({\n        leftOperand,\n        rightOperand,\n        comparisonOperator,\n        logicalConnector\n      });\n\n      if (explicitConnectorIndex >= 0) {\n        index = explicitConnectorIndex + 1;\n      } else if (implicitNextClauseIndex >= 0) {\n        index = implicitNextClauseIndex;\n      } else {\n        break;\n      }\n    }\n\n    return clauses;\n  }\n\n  function parseArgumentTokens(segmentRaw) {\n    const trimmed = String(segmentRaw || \"\").trim();\n    if (!trimmed) {\n      return [];\n    }\n\n    const tokens = tokenize(`${trimmed}.`);\n    return tokens.map((token) => token.raw).filter(Boolean);\n  }\n\n  function parseAssignments(segmentRaw) {\n    const trimmed = String(segmentRaw || \"\").trim();\n    if (!trimmed) {\n      return [];\n    }\n\n    const tokens = tokenize(`${trimmed}.`).map((token) => token.raw).filter(Boolean);\n    const assignments = [];\n\n    function findNextAssignmentStart(startIndex) {\n      for (let index = startIndex; index < tokens.length; index += 1) {\n        const token = tokens[index];\n        if (token === \"=\") {\n          continue;\n        }\n\n        if (tokens[index + 1] === \"=\" && normalizeFormParamName(token)) {\n          return index;\n        }\n\n        const equalIndex = token.indexOf(\"=\");\n        if (equalIndex > 0) {\n          const left = token.slice(0, equalIndex).trim();\n          if (normalizeFormParamName(left)) {\n            return index;\n          }\n        }\n      }\n      return tokens.length;\n    }\n\n    for (let index = 0; index < tokens.length;) {\n      const token = tokens[index];\n      let name = \"\";\n      let valueStartIndex = -1;\n      let inlineFirstValue = \"\";\n\n      if (token !== \"=\") {\n        const equalIndex = token.indexOf(\"=\");\n        if (equalIndex > 0) {\n          const left = token.slice(0, equalIndex).trim();\n          const rightInline = token.slice(equalIndex + 1).trim();\n          const parsedName = normalizeFormParamName(left);\n          if (parsedName) {\n            name = parsedName;\n            inlineFirstValue = rightInline;\n            valueStartIndex = index + 1;\n            index += 1;\n          }\n        } else if (tokens[index + 1] === \"=\") {\n          const parsedName = normalizeFormParamName(token);\n          if (parsedName) {\n            name = parsedName;\n            valueStartIndex = index + 2;\n            index += 2;\n          }\n        }\n      }\n\n      if (!name) {\n        index += 1;\n        continue;\n      }\n\n      const nextAssignmentIndex = findNextAssignmentStart(valueStartIndex);\n      const valueParts = [];\n      if (inlineFirstValue) {\n        valueParts.push(inlineFirstValue);\n      }\n      for (let valueIndex = valueStartIndex; valueIndex < nextAssignmentIndex; valueIndex += 1) {\n        valueParts.push(tokens[valueIndex]);\n      }\n\n      assignments.push({ name, value: valueParts.join(\" \").trim() });\n      index = nextAssignmentIndex;\n    }\n\n    return assignments;\n  }\n\n  function valuesToFirstValueMap(values) {\n    const map = {};\n\n    if (Array.isArray(values)) {\n      for (const entry of values) {\n        if (!entry || !entry.name) {\n          continue;\n        }\n        if (map[entry.name] === undefined) {\n          map[entry.name] = entry.value || \"\";\n        }\n      }\n      return map;\n    }\n\n    if (!values || typeof values !== \"object\") {\n      return map;\n    }\n\n    for (const [name, entryOrList] of Object.entries(values)) {\n      const entry = Array.isArray(entryOrList) ? entryOrList[0] : entryOrList;\n      if (!entry) {\n        continue;\n      }\n      map[name] = entry.value || \"\";\n    }\n\n    return map;\n  }\n\n  function groupEntriesByKey(entries, key) {\n    const map = {};\n    for (const entry of entries || []) {\n      if (!entry || entry[key] === undefined || entry[key] === null) {\n        continue;\n      }\n\n      const name = String(entry[key]).trim();\n      if (!name) {\n        continue;\n      }\n\n      const current = map[name];\n      if (current === undefined) {\n        map[name] = entry;\n        continue;\n      }\n\n      if (Array.isArray(current)) {\n        current.push(entry);\n        continue;\n      }\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ../shared/abap-parser/08-helpers.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/08-helpers.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\n      map[name] = [current, entry];\n    }\n    return map;\n  }\n\n  function parseFormSignature(valueMap) {\n    const usingParams = parseFormParamDefs(\"USING\", valueMap.usingRaw || \"\");\n    const changingParams = parseFormParamDefs(\"CHANGING\", valueMap.changingRaw || \"\");\n    const tablesParams = parseFormParamDefs(\"TABLES\", valueMap.tablesRaw || \"\");\n    const exceptions = parseFormExceptions(valueMap.raisingRaw || \"\");\n\n    const params = [...usingParams, ...changingParams, ...tablesParams];\n    const namesUpper = new Set(params.map((param) => param.name.toUpperCase()));\n\n    return {\n      params,\n      exceptions,\n      namesUpper\n    };\n  }\n\n  function parseFormParamDefs(section, segmentRaw) {\n    const trimmed = String(segmentRaw || \"\").trim();\n    if (!trimmed) {\n      return [];\n    }\n\n    const tokens = tokenize(`${trimmed}.`);\n    const params = [];\n    const seen = new Set();\n\n    for (let index = 0; index < tokens.length; index += 1) {\n      const tokenUpper = tokens[index].upper;\n      if (![\"TYPE\", \"LIKE\", \"STRUCTURE\"].includes(tokenUpper)) {\n        continue;\n      }\n\n      const nameToken = tokens[index - 1];\n      if (!nameToken) {\n        continue;\n      }\n\n      const name = normalizeFormParamName(nameToken.raw);\n      if (!name) {\n        continue;\n      }\n\n      const key = `${section}:${name.toUpperCase()}`;\n      if (seen.has(key)) {\n        continue;\n      }\n\n      const typing = readTyping(tokens, index);\n      params.push({\n        section,\n        name,\n        typing\n      });\n\n      seen.add(key);\n    }\n\n    if (params.length) {\n      return params;\n    }\n\n    for (const token of tokens) {\n      const name = normalizeFormParamName(token.raw);\n      if (!name) {\n        continue;\n      }\n      const key = `${section}:${name.toUpperCase()}`;\n      if (seen.has(key)) {\n        continue;\n      }\n      params.push({\n        section,\n        name,\n        typing: null\n      });\n      seen.add(key);\n    }\n\n    return params;\n  }\n\n  function readTyping(tokens, keywordIndex) {\n    const kind = tokens[keywordIndex].upper;\n    const next = tokens[keywordIndex + 1];\n    const next2 = tokens[keywordIndex + 2];\n    const next3 = tokens[keywordIndex + 3];\n\n    if ((kind === \"TYPE\" || kind === \"LIKE\") && next && next.upper === \"REF\" && next2 && next2.upper === \"TO\" && next3) {\n      return { kind: `${kind} REF TO`, value: next3.raw };\n    }\n\n    if (next) {\n      return { kind, value: next.raw };\n    }\n\n    return { kind, value: \"\" };\n  }\n\n  function parseFormExceptions(segmentRaw) {\n    const trimmed = String(segmentRaw || \"\").trim();\n    if (!trimmed) {\n      return [];\n    }\n\n    const tokens = tokenize(`${trimmed}.`);\n    return tokens\n      .map((token) => token.raw)\n      .filter(Boolean)\n      .map((name) => ({ name }));\n  }\n\n  function normalizeFormParamName(raw) {\n    const trimmed = String(raw || \"\").trim();\n    if (!trimmed) {\n      return \"\";\n    }\n\n    const valueMatch = trimmed.match(/^VALUE\\(([^)]+)\\)$/i);\n    const candidate = valueMatch ? valueMatch[1] : trimmed;\n    const cleaned = candidate.replace(/^[([{]+/, \"\").replace(/[)\\]}]+$/, \"\").trim();\n\n    if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(cleaned)) {\n      return \"\";\n    }\n\n    return cleaned;\n  }\n\n  function parseFormDocComment(commentLines) {\n    const params = [];\n    let formName = \"\";\n\n    for (const line of commentLines || []) {\n      const text = String(line || \"\").trim();\n      if (!text) {\n        continue;\n      }\n\n      if (!formName) {\n        const match = text.match(/\\bForm\\s+([A-Za-z_][A-Za-z0-9_]*)\\b/i);\n        if (match) {\n          formName = match[1];\n        }\n      }\n\n      const paramMatch = text.match(/^(-->|<--|<->)\\s+([A-Za-z_][A-Za-z0-9_]*)\\s*(.*)$/);\n      if (!paramMatch) {\n        continue;\n      }\n\n      const direction = decodeArrowDirection(paramMatch[1]);\n      const name = paramMatch[2];\n      const desc = String(paramMatch[3] || \"\").trim();\n\n      params.push({\n        direction,\n        name,\n        text: desc\n      });\n    }\n\n    return {\n      formName,\n      params\n    };\n  }\n\n  function decodeArrowDirection(symbol) {\n    if (symbol === \"-->\") {\n      return \"in\";\n    }\n    if (symbol === \"<--\") {\n      return \"out\";\n    }\n    return \"inout\";\n  }\n\n  function isChainedStatementStart(raw, startKeyword) {\n    if (!startKeyword) {\n      return false;\n    }\n\n    const pattern = new RegExp(`^\\\\s*${escapeRegExp(startKeyword)}\\\\s*:`, \"i\");\n    return pattern.test(raw);\n  }\n\n  function splitChainedStatementWithMeta(statement, startKeyword) {\n    const raw = statement && typeof statement.raw === \"string\" ? statement.raw : \"\";\n    const baseLineStart = statement && statement.lineStart ? Number(statement.lineStart) || null : null;\n    const lineEntries = statement && Array.isArray(statement.lineEntries) ? statement.lineEntries : [];\n\n    if (!lineEntries.length) {\n      const parts = splitChainedStatement(raw, startKeyword);\n      return parts.map((partRaw) => ({\n        raw: partRaw,\n        lineStart: baseLineStart,\n        comment: statement && typeof statement.comment === \"string\" ? statement.comment : \"\",\n        commentLines: statement && Array.isArray(statement.commentLines) ? statement.commentLines.slice() : []\n      }));\n    }\n\n    const prefixPattern = new RegExp(`^\\\\s*${escapeRegExp(startKeyword)}\\\\s*:\\\\s*`, \"i\");\n    const segments = [];\n\n    let current = \"\";\n    let currentStartLine = null;\n    let inSingleQuote = false;\n    let inPipe = false;\n\n    const pushSegment = ({ comment, endLine }) => {\n      const text = current.replace(/\\s+/g, \" \").trim();\n      if (!text) {\n        current = \"\";\n        currentStartLine = null;\n        return;\n      }\n\n      const commentText = String(comment || \"\").trim();\n      segments.push({\n        raw: `${startKeyword} ${text}.`,\n        lineStart: currentStartLine || endLine || baseLineStart,\n        comment: commentText,\n        commentLines: commentText ? [commentText] : []\n      });\n      current = \"\";\n      currentStartLine = null;\n    };\n\n    for (const entry of lineEntries) {\n      const lineNumber = entry && entry.line ? Number(entry.line || 0) || null : null;\n      const lineComment = entry && entry.comment ? String(entry.comment || \"\").trim() : \"\";\n      let code = entry && entry.code ? String(entry.code || \"\") : \"\";\n      code = code.trim();\n      if (!code) {\n        continue;\n      }\n      code = code.replace(prefixPattern, \"\").trim();\n      if (!code) {\n        continue;\n      }\n\n      if (current.trim()) {\n        current += \" \";\n      }\n\n      for (let index = 0; index < code.length; index += 1) {\n        const char = code[index];\n        const next = index + 1 < code.length ? code[index + 1] : \"\";\n\n        if (char === \"'\" && !inPipe) {\n          if (inSingleQuote && next === \"'\") {\n            if (!currentStartLine && current.trim().length === 0) {\n              currentStartLine = lineNumber || baseLineStart;\n            }\n            current += \"''\";\n            index += 1;\n            continue;\n          }\n          inSingleQuote = !inSingleQuote;\n          if (!currentStartLine && current.trim().length === 0 && char.trim()) {\n            currentStartLine = lineNumber || baseLineStart;\n          }\n          current += char;\n          continue;\n        }\n\n        if (char === \"|\" && !inSingleQuote) {\n          if (inPipe && next === \"|\") {\n            if (!currentStartLine && current.trim().length === 0) {\n              currentStartLine = lineNumber || baseLineStart;\n            }\n            current += \"||\";\n            index += 1;\n            continue;\n          }\n          inPipe = !inPipe;\n          if (!currentStartLine && current.trim().length === 0 && char.trim()) {\n            currentStartLine = lineNumber || baseLineStart;\n          }\n          current += char;\n          continue;\n        }\n\n        if (char === \",\" && !inSingleQuote && !inPipe) {\n          const rest = code.slice(index + 1).trim();\n          const commentForSegment = rest ? \"\" : lineComment;\n          pushSegment({ comment: commentForSegment, endLine: lineNumber });\n          continue;\n        }\n\n        if (char === \".\" && !inSingleQuote && !inPipe) {\n          const rest = code.slice(index + 1).trim();\n          if (!rest) {\n            pushSegment({ comment: lineComment, endLine: lineNumber });\n            break;\n          }\n        }\n\n        if (!currentStartLine && current.trim().length === 0 && char.trim()) {\n          currentStartLine = lineNumber || baseLineStart;\n        }\n        current += char;\n      }\n    }\n\n    if (current.trim()) {\n      pushSegment({ comment: \"\", endLine: null });\n    }\n\n    if (!segments.length) {\n      return splitChainedStatement(raw, startKeyword).map((partRaw) => ({\n        raw: partRaw,\n        lineStart: baseLineStart,\n        comment: \"\",\n        commentLines: []\n      }));\n    }\n\n    return segments;\n  }\n\n  function splitChainedStatement(raw, startKeyword) {\n    const pattern = new RegExp(`^\\\\s*${escapeRegExp(startKeyword)}\\\\s*:\\\\s*`, \"i\");\n    const match = raw.match(pattern);\n    if (!match) {\n      return [raw];\n    }\n\n    let body = raw.slice(match[0].length).trim();\n    body = body.replace(/\\.$/, \"\").trim();\n    if (!body) {\n      return [];\n    }\n\n    const parts = splitByCommaOutsideQuotes(body)\n      .map((part) => part.trim())\n      .filter(Boolean);\n\n    return parts.map((part) => `${startKeyword} ${part}.`);\n  }\n\n  function splitByCommaOutsideQuotes(text) {\n    const parts = [];\n    let current = \"\";\n    let inSingleQuote = false;\n    let inPipe = false;\n\n    for (let index = 0; index < text.length; index += 1) {\n      const char = text[index];\n      const next = index + 1 < text.length ? text[index + 1] : \"\";\n\n      if (char === \"'\" && !inPipe) {\n        if (inSingleQuote && next === \"'\") {\n          current += \"''\";\n          index += 1;\n          continue;\n        }\n        inSingleQuote = !inSingleQuote;\n        current += char;\n        continue;\n      }\n\n      if (char === \"|\" && !inSingleQuote) {\n        if (inPipe && next === \"|\") {\n          current += \"||\";\n          index += 1;\n          continue;\n        }\n        inPipe = !inPipe;\n        current += char;\n        continue;\n      }\n\n      if (char === \",\" && !inSingleQuote && !inPipe) {\n        parts.push(current.trim());\n        current = \"\";\n        continue;\n      }\n\n      current += char;\n    }\n\n    if (current.trim()) {\n      parts.push(current.trim());\n    }\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ../shared/abap-parser/09-public-api.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const partKey = "shared/abap-parser/09-public-api.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    return parts;\n  }\n\n  function escapeRegExp(text) {\n    return String(text).replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  }\n\n  function tokenize(statementRaw) {\n    const trimmed = statementRaw.trim();\n    if (!trimmed) {\n      return [];\n    }\n\n    const withoutDot = trimmed.replace(/\\.$/, \"\").trim();\n    const tokens = [];\n    let index = 0;\n\n    while (index < withoutDot.length) {\n      const char = withoutDot[index];\n\n      if (/\\s/.test(char)) {\n        index += 1;\n        continue;\n      }\n\n      if (char === \"'\" || char === \"|\") {\n        const quoteChar = char;\n        let end = index + 1;\n        while (end < withoutDot.length) {\n          const current = withoutDot[end];\n          const next = end + 1 < withoutDot.length ? withoutDot[end + 1] : \"\";\n          if (current === quoteChar) {\n            if ((quoteChar === \"'\" || quoteChar === \"|\") && next === quoteChar) {\n              end += 2;\n              continue;\n            }\n            end += 1;\n            break;\n          }\n          end += 1;\n        }\n        const token = withoutDot.slice(index, end);\n        tokens.push(token);\n        index = end;\n        continue;\n      }\n\n      let end = index + 1;\n      while (end < withoutDot.length && !/\\s/.test(withoutDot[end])) {\n        end += 1;\n      }\n      const token = withoutDot.slice(index, end);\n      tokens.push(token);\n      index = end;\n    }\n\n    return tokens\n      .map((token) => token.replace(/[,:\\u00A0]+$/, \"\"))\n      .filter(Boolean)\n      .map((token) => ({\n        raw: token,\n        upper: token.toUpperCase()\n      }));\n  }\n\n  function detectKeywords(tokens, config) {\n    const keywords = [];\n    const phraseEntries = buildPhraseEntries(config.keywordPhrases);\n\n    for (let i = 0; i < tokens.length; i += 1) {\n      const match = matchPhraseAt(tokens, i, phraseEntries);\n      if (match) {\n        const phraseText = tokens\n          .slice(i, i + match.length)\n          .map((token) => token.raw)\n          .join(\" \");\n\n        keywords.push({ text: phraseText, label: match.label });\n        i += match.length - 1;\n        continue;\n      }\n\n      const label = config.keywordLabels[tokens[i].upper];\n      if (label) {\n        keywords.push({ text: tokens[i].raw, label });\n      }\n    }\n\n    return keywords;\n  }\n\n  function buildPhraseEntries(phraseMap) {\n    return Object.entries(phraseMap || {})\n      .map(([phrase, label]) => ({\n        phrase,\n        label,\n        tokens: phrase.split(/\\s+/)\n      }))\n      .sort((a, b) => b.tokens.length - a.tokens.length);\n  }\n\n  function matchPhraseAt(tokens, index, phraseEntries) {\n    for (const entry of phraseEntries) {\n      if (index + entry.tokens.length > tokens.length) {\n        continue;\n      }\n\n      let matches = true;\n      for (let offset = 0; offset < entry.tokens.length; offset += 1) {\n        if (tokens[index + offset].upper !== entry.tokens[offset]) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (matches) {\n        return {\n          phrase: entry.phrase,\n          label: entry.label,\n          length: entry.tokens.length\n        };\n      }\n    }\n\n    return null;\n  }\n\n  function captureValues(tokens, config, commentText) {\n    const values = [];\n    const descMap = config.valueDescriptions || {};\n    const rules = (config.captureRules || []).filter(\n      (rule) => rule.afterTokens && rule.afterTokens.length\n    );\n    const statementDesc = commentText || \"\";\n\n    for (let index = 0; index < tokens.length; index += 1) {\n      let bestRule = null;\n\n      for (const rule of rules) {\n        if (!matchesTokens(tokens, index, rule.afterTokens)) {\n          continue;\n        }\n\n        if (!bestRule || rule.afterTokens.length > bestRule.afterTokens.length) {\n          bestRule = rule;\n        }\n      }\n\n      if (!bestRule) {\n        continue;\n      }\n\n      const valueIndex = index + bestRule.afterTokens.length;\n      if (valueIndex < tokens.length) {\n        const captured = captureValue(tokens, valueIndex, bestRule);\n        const userDesc = resolveUserDesc(descMap, bestRule.descKey, captured.upper);\n\n        values.push({\n          name: bestRule.name,\n          value: captured.raw,\n          label: bestRule.label || bestRule.name,\n          userDesc: userDesc || \"\",\n          codeDesc: statementDesc\n        });\n      }\n\n      index += bestRule.afterTokens.length - 1;\n    }\n\n    return values;\n  }\n\n  function captureAssignmentValues(tokens, commentText) {\n    if (!Array.isArray(tokens) || tokens.length < 3) {\n      return [];\n    }\n\n    const statementDesc = commentText || \"\";\n    const target = tokens[0] ? tokens[0].raw : \"\";\n    const op = tokens[1] ? tokens[1].raw : \"\";\n    const expr = tokens\n      .slice(2)\n      .map((t) => t.raw)\n      .join(\" \")\n      .trim();\n\n    return [\n      { name: \"target\", value: target, label: \"target\", userDesc: \"\", codeDesc: statementDesc },\n      { name: \"op\", value: op, label: \"op\", userDesc: \"\", codeDesc: statementDesc },\n      { name: \"expr\", value: expr, label: \"expr\", userDesc: \"\", codeDesc: statementDesc }\n    ];\n  }\n\n  function captureMethodCallExpressionValues(raw, commentText) {\n    const parsed = parseMethodCallExpressionFromRaw(raw);\n    if (!parsed) {\n      return [];\n    }\n\n    const statementDesc = commentText || \"\";\n    const values = [];\n    const addEntry = (name, value, label) => {\n      const text = String(value || \"\").trim();\n      if (!text) {\n        return;\n      }\n      values.push({\n        name,\n        value: text,\n        label: label || name,\n        userDesc: \"\",\n        codeDesc: statementDesc\n      });\n    };\n\n    addEntry(\"target\", parsed.callTarget, \"target\");\n\n    if (parsed.receivingTarget && !parsed.sectionRawByName.receivingRaw) {\n      addEntry(\"receivingRaw\", `result = ${parsed.receivingTarget}`, \"receiving\");\n    }\n\n    for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"receiving\", \"exceptions\"]) {\n      const rawKey = `${sectionName}Raw`;\n      addEntry(rawKey, parsed.sectionRawByName[rawKey], sectionName);\n    }\n\n    return values;\n  }\n\n  function parseMethodCallExpressionFromRaw(raw) {\n    const textRaw = String(raw || \"\").trim();\n    if (!textRaw) {\n      return null;\n    }\n\n    const text = textRaw.endsWith(\".\")\n      ? textRaw.slice(0, -1).trim()\n      : textRaw;\n\n    if (!text || /^CALL\\s+METHOD\\b/i.test(text)) {\n      return null;\n    }\n\n    let receivingTarget = \"\";\n    let callExpr = text;\n\n    const assignmentMatch = text.match(\n      /^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*(?:-[A-Za-z_][A-Za-z0-9_]*)*)\\s*=\\s*(.+)$/i\n    );\n    if (assignmentMatch) {\n      receivingTarget = assignmentMatch[1].trim();\n      callExpr = assignmentMatch[2].trim();\n    }\n\n    const targetMatch = callExpr.match(\n      /^((?:<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(?:->|=>)(?:[A-Za-z_][A-Za-z0-9_]*~)?[A-Za-z_][A-Za-z0-9_]*)\\s*\\(/i\n    );\n    if (!targetMatch) {\n      return null;\n    }\n\n    const callTarget = targetMatch[1].trim();\n    const openIndex = callExpr.indexOf(\"(\");\n    const closeIndex = callExpr.lastIndexOf(\")\");\n    if (openIndex < 0 || closeIndex <= openIndex || closeIndex !== callExpr.length - 1) {\n      return null;\n    }\n    const argsRaw = callExpr.slice(openIndex + 1, closeIndex).trim();\n\n    return {\n      receivingTarget,\n      callExpr,\n      callTarget,\n      argsRaw,\n      sectionRawByName: parseMethodCallExpressionSectionRaw(argsRaw)\n    };\n  }\n\n  function parseMethodCallExpressionSectionRaw(argsRaw) {\n    const output = {\n      exportingRaw: \"\",\n      importingRaw: \"\",\n      changingRaw: \"\",\n      receivingRaw: \"\",\n      exceptionsRaw: \"\"\n    };\n\n    const trimmed = String(argsRaw || \"\").trim();\n    if (!trimmed) {\n      return output;\n    }\n\n    const tokens = tokenize(`${trimmed}.`);\n    if (!tokens.length) {\n      return output;\n    }\n\n    const sectionByUpper = {\n      EXPORTING: \"exportingRaw\",\n      IMPORTING: \"importingRaw\",\n      CHANGING: \"changingRaw\",\n      RECEIVING: \"receivingRaw\",\n      EXCEPTIONS: \"exceptionsRaw\"\n    };\n    const sectionSet = new Set(Object.keys(sectionByUpper));\n    const markers = [];\n    for (let index = 0; index < tokens.length; index += 1) {\n      if (sectionSet.has(tokens[index].upper)) {\n        markers.push({ sectionUpper: tokens[index].upper, startIndex: index });\n      }\n    }\n\n    if (!markers.length) {\n      output.exportingRaw = trimmed;\n      return output;\n    }\n\n    for (let index = 0; index < markers.length; index += 1) {\n      const marker = markers[index];\n      const next = markers[index + 1];\n      const segmentStart = marker.startIndex + 1;\n      const segmentEnd = next ? next.startIndex : tokens.length;\n      const segmentRaw = tokens\n        .slice(segmentStart, segmentEnd)\n        .map((token) => token.raw)\n        .join(\" \")\n        .trim();\n      const key = sectionByUpper[marker.sectionUpper];\n      if (!key || !segmentRaw) {\n        continue;\n      }\n      output[key] = output[key]\n        ? `${output[key]} ${segmentRaw}`\n        : segmentRaw;\n    }\n\n    return output;\n  }\n\n  function captureValue(tokens, startIndex, rule) {\n    if (rule.capture === \"rest\") {\n      const stopTokens = rule.stopTokensUpper || [];\n      const parts = [];\n      for (let i = startIndex; i < tokens.length; i += 1) {\n        if (stopTokens.length && stopTokens.includes(tokens[i].upper)) {\n          break;\n        }\n        parts.push(tokens[i].raw);\n      }\n      const raw = parts.join(\" \").trim();\n      return { raw, upper: raw.toUpperCase() };\n    }\n\n    const token = tokens[startIndex];\n    return token ? { raw: token.raw, upper: token.upper } : { raw: \"\", upper: \"\" };\n  }\n\n  function matchesTokens(tokens, startIndex, expectedTokens) {\n    if (startIndex + expectedTokens.length > tokens.length) {\n      return false;\n    }\n\n    for (let offset = 0; offset < expectedTokens.length; offset += 1) {\n      if (tokens[startIndex + offset].upper !== expectedTokens[offset]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function resolveUserDesc(descMap, descKey, valueUpper) {\n    if (!descKey) {\n      return \"\";\n    }\n\n    const map = descMap[descKey];\n    if (!map) {\n      return \"\";\n    }\n\n    return map[valueUpper] || \"\";\n  }\n\n  return {\n    AbapObject,\n    normalizeConfig,\n    registerConfig,\n    getConfigs,\n    parseAbapText\n  };\n});\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ../shared/abap-parser.js
"use strict";

(function (root, factory) {
  if (typeof module === "object" && module.exports) {
    module.exports = factory(root, true);
    return;
  }

  root.AbapParser = factory(root, false);
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this), function (root, isNode) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);

  if (isNode && typeof require === "function") {
    const requireParts = [
        "./abap-parser/01-context.js",
        "./abap-parser/02-config.js",
        "./abap-parser/03-statements.js",
        "./abap-parser/04-parse-core.js",
        "./abap-parser/05-extras.js",
        "./abap-parser/06-conditions.js",
        "./abap-parser/07-declarations.js",
        "./abap-parser/08-helpers.js",
        "./abap-parser/09-public-api.js"
    ];
    for (const relPath of requireParts) {
      require(relPath);
    }
  }

  const registry = globalRoot.__AbapSourceParts || {};
  const targetKey = "shared/abap-parser.js";
  const bucket = registry[targetKey] || {};
  const orderedParts = [
      "shared/abap-parser/01-context.js",
      "shared/abap-parser/02-config.js",
      "shared/abap-parser/03-statements.js",
      "shared/abap-parser/04-parse-core.js",
      "shared/abap-parser/05-extras.js",
      "shared/abap-parser/06-conditions.js",
      "shared/abap-parser/07-declarations.js",
      "shared/abap-parser/08-helpers.js",
      "shared/abap-parser/09-public-api.js"
  ];

  const missing = orderedParts.filter((part) => typeof bucket[part] !== "string");
  if (missing.length) {
    throw new Error(`Parser source parts missing for ${targetKey}: ${missing.join(", ")}`);
  }

  const source = orderedParts.map((part) => bucket[part]).join("\n");
  (0, eval)(source);

  const api = globalRoot.AbapParser;
  if (!api || typeof api.parseAbapText !== "function") {
    throw new Error("Failed to initialize AbapParser from split parts.");
  }
  return api;
});
</script>
  <!-- abap-parser-configs:start -->
  <script>
// inlined from: ./configs.generated/append.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: append.json");
    return;
  }

  const config = {
    "_sourceFile": "append.json",
    "object": "APPEND",
    "match": {
      "startKeyword": "APPEND"
    },
    "keywordLabels": {
      "APPEND": "stmt",
      "TO": "to",
      "LINES": "lines",
      "OF": "of",
      "INITIAL": "initial",
      "LINE": "line",
      "ASSIGNING": "assigning",
      "REFERENCE": "reference",
      "INTO": "into"
    },
    "keywordPhrases": {
      "LINES OF": "lines-of",
      "INITIAL LINE": "initial-line",
      "REFERENCE INTO": "reference-into"
    },
    "captureRules": [
      {
        "after": "APPEND",
        "name": "what",
        "label": "what"
      },
      {
        "after": "APPEND LINES OF",
        "name": "source",
        "label": "source-itab"
      },
      {
        "after": "TO",
        "name": "to",
        "label": "to-itab"
      },
      {
        "after": "ASSIGNING",
        "name": "assigning",
        "label": "assigning"
      },
      {
        "after": "REFERENCE INTO",
        "name": "refInto",
        "label": "reference-into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/assignment.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: assignment.json");
    return;
  }

  const config = {
    "_sourceFile": "assignment.json",
    "object": "ASSIGNMENT",
    "match": {
      "type": "assignment"
    },
    "keywordLabels": {
      "=": "assign",
      "+=": "add-assign",
      "-=": "sub-assign",
      "*=": "mul-assign",
      "/=": "div-assign",
      "?=": "cast"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/call-function.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: call-function.json");
    return;
  }

  const config = {
    "_sourceFile": "call-function.json",
    "object": "CALL_FUNCTION",
    "match": {
      "startPhrase": "CALL FUNCTION"
    },
    "extras": {
      "type": "callFunction"
    },
    "keywordLabels": {
      "CALL": "stmt",
      "FUNCTION": "function",
      "DESTINATION": "destination",
      "IN": "in",
      "BACKGROUND": "background",
      "TASK": "task",
      "EXPORTING": "exporting",
      "IMPORTING": "importing",
      "CHANGING": "changing",
      "TABLES": "tables",
      "EXCEPTIONS": "exceptions"
    },
    "keywordPhrases": {
      "CALL FUNCTION": "call-function",
      "IN BACKGROUND TASK": "in-background-task"
    },
    "captureRules": [
      {
        "after": "CALL FUNCTION",
        "name": "name",
        "label": "function-name",
        "descKey": "name"
      },
      {
        "after": "DESTINATION",
        "name": "destination",
        "label": "destination"
      },
      {
        "after": "EXPORTING",
        "name": "exportingRaw",
        "label": "exporting",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "CHANGING",
          "TABLES",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "IMPORTING",
        "name": "importingRaw",
        "label": "importing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "CHANGING",
          "TABLES",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "TABLES",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "TABLES",
        "name": "tablesRaw",
        "label": "tables",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "CHANGING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "EXCEPTIONS",
        "name": "exceptionsRaw",
        "label": "exceptions",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/call-method-expression.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: call-method-expression.json");
    return;
  }

  const config = {
    "_sourceFile": "call-method-expression.json",
    "object": "CALL_METHOD",
    "match": {
      "type": "methodCallExpr"
    },
    "extras": {
      "type": "callMethodExpr"
    },
    "keywordLabels": {
      "EXPORTING": "exporting",
      "IMPORTING": "importing",
      "CHANGING": "changing",
      "RECEIVING": "receiving",
      "EXCEPTIONS": "exceptions"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/call-method.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: call-method.json");
    return;
  }

  const config = {
    "_sourceFile": "call-method.json",
    "object": "CALL_METHOD",
    "match": {
      "startPhrase": "CALL METHOD"
    },
    "extras": {
      "type": "callMethod"
    },
    "keywordLabels": {
      "CALL": "stmt",
      "METHOD": "method",
      "EXPORTING": "exporting",
      "IMPORTING": "importing",
      "CHANGING": "changing",
      "RECEIVING": "receiving",
      "EXCEPTIONS": "exceptions"
    },
    "keywordPhrases": {
      "CALL METHOD": "call-method"
    },
    "captureRules": [
      {
        "after": "CALL METHOD",
        "name": "target",
        "label": "target",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "CHANGING",
          "RECEIVING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "EXPORTING",
        "name": "exportingRaw",
        "label": "exporting",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "CHANGING",
          "RECEIVING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "IMPORTING",
        "name": "importingRaw",
        "label": "importing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "CHANGING",
          "RECEIVING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "RECEIVING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "RECEIVING",
        "name": "receivingRaw",
        "label": "receiving",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "IMPORTING",
          "CHANGING",
          "EXCEPTIONS"
        ]
      },
      {
        "after": "EXCEPTIONS",
        "name": "exceptionsRaw",
        "label": "exceptions",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/call-transaction.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: call-transaction.json");
    return;
  }

  const config = {
    "_sourceFile": "call-transaction.json",
    "object": "CALL_TRANSACTION",
    "match": {
      "startPhrase": "CALL TRANSACTION"
    },
    "keywordLabels": {
      "CALL": "stmt",
      "TRANSACTION": "transaction",
      "USING": "using",
      "SKIP": "skip",
      "FIRST": "first",
      "SCREEN": "screen",
      "AND": "and",
      "RETURN": "return",
      "MODE": "mode",
      "UPDATE": "update",
      "MESSAGES": "messages",
      "INTO": "into"
    },
    "keywordPhrases": {
      "CALL TRANSACTION": "call-transaction",
      "SKIP FIRST SCREEN": "skip-first-screen",
      "AND RETURN": "and-return",
      "MESSAGES INTO": "messages-into"
    },
    "captureRules": [
      {
        "after": "CALL TRANSACTION",
        "name": "tcode",
        "label": "tcode",
        "descKey": "tcode"
      },
      {
        "after": "USING",
        "name": "using",
        "label": "using"
      },
      {
        "after": "MODE",
        "name": "mode",
        "label": "mode"
      },
      {
        "after": "UPDATE",
        "name": "update",
        "label": "update"
      },
      {
        "after": "MESSAGES INTO",
        "name": "messagesInto",
        "label": "messages-into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/case.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: case.json");
    return;
  }

  const config = {
    "_sourceFile": "case.json",
    "object": "CASE",
    "match": {
      "startKeyword": "CASE"
    },
    "block": {
      "endKeyword": "ENDCASE"
    },
    "keywordLabels": {
      "CASE": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "CASE",
        "name": "expr",
        "label": "expression",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/catch.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: catch.json");
    return;
  }

  const config = {
    "_sourceFile": "catch.json",
    "object": "CATCH",
    "match": {
      "startKeyword": "CATCH"
    },
    "keywordLabels": {
      "CATCH": "stmt",
      "INTO": "into"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "CATCH",
        "name": "exception",
        "label": "exception",
        "capture": "rest",
        "stopTokens": [
          "INTO"
        ]
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/class-data.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: class-data.json");
    return;
  }

  const config = {
    "_sourceFile": "class-data.json",
    "object": "CLASS-DATA",
    "match": {
      "startKeyword": "CLASS-DATA"
    },
    "keywordLabels": {
      "CLASS-DATA": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to",
      "VALUE": "value",
      "LENGTH": "length",
      "DECIMALS": "decimals",
      "READ-ONLY": "read-only"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "CLASS-DATA",
        "name": "name",
        "label": "attr-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like-name",
        "descKey": "like"
      },
      {
        "after": "VALUE",
        "name": "value",
        "label": "value",
        "descKey": "value"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/class-methods.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: class-methods.json");
    return;
  }

  const config = {
    "_sourceFile": "class-methods.json",
    "object": "CLASS-METHODS",
    "match": {
      "startKeyword": "CLASS-METHODS"
    },
    "extras": {
      "type": "methodSignature"
    },
    "keywordLabels": {
      "CLASS-METHODS": "stmt",
      "IMPORTING": "importing",
      "EXPORTING": "exporting",
      "CHANGING": "changing",
      "RETURNING": "returning",
      "RAISING": "raising"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "CLASS-METHODS",
        "name": "name",
        "label": "method-name",
        "descKey": "name"
      },
      {
        "after": "IMPORTING",
        "name": "importingRaw",
        "label": "importing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "CHANGING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "EXPORTING",
        "name": "exportingRaw",
        "label": "exporting",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "CHANGING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "EXPORTING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "RETURNING",
        "name": "returningRaw",
        "label": "returning",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "EXPORTING",
          "CHANGING",
          "RAISING"
        ]
      },
      {
        "after": "RAISING",
        "name": "raisingRaw",
        "label": "raising",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/class.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: class.json");
    return;
  }

  const config = {
    "_sourceFile": "class.json",
    "object": "CLASS",
    "match": {
      "startKeyword": "CLASS"
    },
    "block": {
      "endKeyword": "ENDCLASS"
    },
    "keywordLabels": {
      "CLASS": "stmt",
      "DEFINITION": "definition",
      "IMPLEMENTATION": "implementation",
      "PUBLIC": "public",
      "PROTECTED": "protected",
      "PRIVATE": "private",
      "SECTION": "section",
      "CREATE": "create"
    },
    "keywordPhrases": {
      "PUBLIC SECTION": "public-section",
      "PROTECTED SECTION": "protected-section",
      "PRIVATE SECTION": "private-section",
      "CREATE PUBLIC": "create-public"
    },
    "captureRules": [
      {
        "after": "CLASS",
        "name": "name",
        "label": "class-name",
        "descKey": "name"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/cleanup.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: cleanup.json");
    return;
  }

  const config = {
    "_sourceFile": "cleanup.json",
    "object": "CLEANUP",
    "match": {
      "startKeyword": "CLEANUP"
    },
    "keywordLabels": {
      "CLEANUP": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/clear.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: clear.json");
    return;
  }

  const config = {
    "_sourceFile": "clear.json",
    "object": "CLEAR",
    "match": {
      "startKeyword": "CLEAR"
    },
    "keywordLabels": {
      "CLEAR": "stmt",
      "WITH": "with"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "CLEAR",
        "name": "target",
        "label": "target"
      },
      {
        "after": "WITH",
        "name": "with",
        "label": "with"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/constants.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: constants.json");
    return;
  }

  const config = {
    "_sourceFile": "constants.json",
    "object": "CONSTANTS",
    "match": {
      "startKeyword": "CONSTANTS"
    },
    "keywordLabels": {
      "CONSTANTS": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to",
      "VALUE": "value",
      "LENGTH": "length",
      "DECIMALS": "decimals"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "CONSTANTS",
        "name": "name",
        "label": "const-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like-name",
        "descKey": "like"
      },
      {
        "after": "VALUE",
        "name": "value",
        "label": "value",
        "descKey": "value"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/data.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: data.json");
    return;
  }

  const config = {
    "_sourceFile": "data.json",
    "object": "DATA",
    "match": {
      "startKeyword": "DATA"
    },
    "keywordLabels": {
      "DATA": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "BEGIN": "begin",
      "OF": "of",
      "END": "end",
      "REF": "ref",
      "TO": "to",
      "VALUE": "value",
      "LENGTH": "length",
      "DECIMALS": "decimals",
      "READ-ONLY": "read-only"
    },
    "keywordPhrases": {
      "BEGIN OF": "begin-of",
      "END OF": "end-of",
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "DATA BEGIN OF",
        "name": "name",
        "label": "struct-name",
        "descKey": "name"
      },
      {
        "after": "DATA END OF",
        "name": "name",
        "label": "struct-name",
        "descKey": "name"
      },
      {
        "after": "DATA",
        "name": "name",
        "label": "var-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like-name",
        "descKey": "like"
      },
      {
        "after": "VALUE",
        "name": "value",
        "label": "value",
        "descKey": "value"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/delete-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: delete-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "delete-itab.json",
    "object": "DELETE_ITAB",
    "match": {
      "startKeyword": "DELETE"
    },
    "extras": {
      "type": "deleteItab"
    },
    "keywordLabels": {
      "DELETE": "stmt",
      "FROM": "from",
      "INDEX": "index",
      "WHERE": "where",
      "ADJACENT": "adjacent",
      "DUPLICATES": "duplicates",
      "COMPARING": "comparing"
    },
    "keywordPhrases": {
      "ADJACENT DUPLICATES": "adjacent-duplicates",
      "DELETE ADJACENT DUPLICATES": "delete-adjacent-duplicates"
    },
    "captureRules": [
      {
        "after": "DELETE",
        "name": "target",
        "label": "target"
      },
      {
        "after": "FROM",
        "name": "from",
        "label": "from"
      },
      {
        "after": "INDEX",
        "name": "index",
        "label": "index"
      },
      {
        "after": "WHERE",
        "name": "where",
        "label": "where",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/do.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: do.json");
    return;
  }

  const config = {
    "_sourceFile": "do.json",
    "object": "DO",
    "match": {
      "startKeyword": "DO"
    },
    "block": {
      "endKeyword": "ENDDO"
    },
    "keywordLabels": {
      "DO": "stmt",
      "TIMES": "times"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "DO",
        "name": "times",
        "label": "times"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/else.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: else.json");
    return;
  }

  const config = {
    "_sourceFile": "else.json",
    "object": "ELSE",
    "match": {
      "startKeyword": "ELSE"
    },
    "keywordLabels": {
      "ELSE": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/elseif.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: elseif.json");
    return;
  }

  const config = {
    "_sourceFile": "elseif.json",
    "object": "ELSEIF",
    "match": {
      "startKeyword": "ELSEIF"
    },
    "extras": {
      "type": "ifCondition"
    },
    "keywordLabels": {
      "ELSEIF": "stmt",
      "AND": "and",
      "OR": "or",
      "NOT": "not",
      "IS": "is",
      "INITIAL": "initial"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "ELSEIF",
        "name": "condition",
        "label": "condition",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/field-symbols.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: field-symbols.json");
    return;
  }

  const config = {
    "_sourceFile": "field-symbols.json",
    "object": "FIELD-SYMBOLS",
    "match": {
      "startKeyword": "FIELD-SYMBOLS"
    },
    "keywordLabels": {
      "FIELD-SYMBOLS": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to",
      "STRUCTURE": "structure"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "FIELD-SYMBOLS",
        "name": "name",
        "label": "fs-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like",
        "descKey": "like"
      },
      {
        "after": "STRUCTURE",
        "name": "structure",
        "label": "structure",
        "descKey": "structure"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/form.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: form.json");
    return;
  }

  const config = {
    "_sourceFile": "form.json",
    "object": "FORM",
    "match": {
      "startKeyword": "FORM"
    },
    "block": {
      "endKeyword": "ENDFORM"
    },
    "extras": {
      "type": "form"
    },
    "keywordLabels": {
      "FORM": "stmt",
      "USING": "using",
      "CHANGING": "changing",
      "TABLES": "tables",
      "RAISING": "raising"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "FORM",
        "name": "name",
        "label": "form-name",
        "descKey": "name"
      },
      {
        "after": "USING",
        "name": "usingRaw",
        "label": "using",
        "capture": "rest",
        "stopTokens": [
          "CHANGING",
          "TABLES",
          "RAISING"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "USING",
          "TABLES",
          "RAISING"
        ]
      },
      {
        "after": "TABLES",
        "name": "tablesRaw",
        "label": "tables",
        "capture": "rest",
        "stopTokens": [
          "USING",
          "CHANGING",
          "RAISING"
        ]
      },
      {
        "after": "RAISING",
        "name": "raisingRaw",
        "label": "raising",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/if.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: if.json");
    return;
  }

  const config = {
    "_sourceFile": "if.json",
    "object": "IF",
    "match": {
      "startKeyword": "IF"
    },
    "extras": {
      "type": "ifCondition"
    },
    "block": {
      "endKeyword": "ENDIF"
    },
    "keywordLabels": {
      "IF": "stmt",
      "AND": "and",
      "OR": "or",
      "NOT": "not",
      "IS": "is",
      "INITIAL": "initial"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "IF",
        "name": "condition",
        "label": "condition",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/insert-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: insert-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "insert-itab.json",
    "object": "INSERT_ITAB",
    "match": {
      "startKeyword": "INSERT"
    },
    "keywordLabels": {
      "INSERT": "stmt",
      "INTO": "into",
      "TABLE": "table",
      "LINES": "lines",
      "OF": "of",
      "INDEX": "index",
      "ASSIGNING": "assigning",
      "REFERENCE": "reference"
    },
    "keywordPhrases": {
      "INTO TABLE": "into-table",
      "LINES OF": "lines-of",
      "REFERENCE INTO": "reference-into"
    },
    "captureRules": [
      {
        "after": "INSERT",
        "name": "what",
        "label": "what"
      },
      {
        "after": "INSERT LINES OF",
        "name": "source",
        "label": "source-itab"
      },
      {
        "after": "INTO TABLE",
        "name": "intoTable",
        "label": "into-table"
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      },
      {
        "after": "INDEX",
        "name": "index",
        "label": "index"
      },
      {
        "after": "ASSIGNING",
        "name": "assigning",
        "label": "assigning"
      },
      {
        "after": "REFERENCE INTO",
        "name": "refInto",
        "label": "reference-into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/loop-at-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: loop-at-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "loop-at-itab.json",
    "object": "LOOP_AT_ITAB",
    "match": {
      "startPhrase": "LOOP AT"
    },
    "extras": {
      "type": "loopAtItab"
    },
    "block": {
      "endKeyword": "ENDLOOP"
    },
    "keywordLabels": {
      "LOOP": "stmt",
      "AT": "at",
      "INTO": "into",
      "ASSIGNING": "assigning",
      "REFERENCE": "reference",
      "WHERE": "where",
      "FROM": "from",
      "TO": "to"
    },
    "keywordPhrases": {
      "LOOP AT": "loop-at",
      "REFERENCE INTO": "reference-into"
    },
    "captureRules": [
      {
        "after": "LOOP AT",
        "name": "itab",
        "label": "itab",
        "descKey": "itab"
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      },
      {
        "after": "ASSIGNING",
        "name": "assigning",
        "label": "assigning"
      },
      {
        "after": "REFERENCE INTO",
        "name": "refInto",
        "label": "reference-into"
      },
      {
        "after": "FROM",
        "name": "from",
        "label": "from"
      },
      {
        "after": "TO",
        "name": "to",
        "label": "to"
      },
      {
        "after": "WHERE",
        "name": "where",
        "label": "where",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/method.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: method.json");
    return;
  }

  const config = {
    "_sourceFile": "method.json",
    "object": "METHOD",
    "match": {
      "startKeyword": "METHOD"
    },
    "block": {
      "endKeyword": "ENDMETHOD"
    },
    "keywordLabels": {
      "METHOD": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "METHOD",
        "name": "name",
        "label": "method-name",
        "descKey": "name"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/methods.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: methods.json");
    return;
  }

  const config = {
    "_sourceFile": "methods.json",
    "object": "METHODS",
    "match": {
      "startKeyword": "METHODS"
    },
    "extras": {
      "type": "methodSignature"
    },
    "keywordLabels": {
      "METHODS": "stmt",
      "IMPORTING": "importing",
      "EXPORTING": "exporting",
      "CHANGING": "changing",
      "RETURNING": "returning",
      "RAISING": "raising"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "METHODS",
        "name": "name",
        "label": "method-name",
        "descKey": "name"
      },
      {
        "after": "IMPORTING",
        "name": "importingRaw",
        "label": "importing",
        "capture": "rest",
        "stopTokens": [
          "EXPORTING",
          "CHANGING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "EXPORTING",
        "name": "exportingRaw",
        "label": "exporting",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "CHANGING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "EXPORTING",
          "RETURNING",
          "RAISING"
        ]
      },
      {
        "after": "RETURNING",
        "name": "returningRaw",
        "label": "returning",
        "capture": "rest",
        "stopTokens": [
          "IMPORTING",
          "EXPORTING",
          "CHANGING",
          "RAISING"
        ]
      },
      {
        "after": "RAISING",
        "name": "raisingRaw",
        "label": "raising",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/modify-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: modify-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "modify-itab.json",
    "object": "MODIFY_ITAB",
    "match": {
      "startKeyword": "MODIFY"
    },
    "extras": {
      "type": "modifyItab"
    },
    "keywordLabels": {
      "MODIFY": "stmt",
      "TABLE": "table",
      "FROM": "from",
      "INDEX": "index",
      "TRANSPORTING": "transporting",
      "WHERE": "where"
    },
    "keywordPhrases": {
      "MODIFY TABLE": "modify-table"
    },
    "captureRules": [
      {
        "after": "MODIFY TABLE",
        "name": "itab",
        "label": "itab"
      },
      {
        "after": "MODIFY",
        "name": "itabOrDbtab",
        "label": "target"
      },
      {
        "after": "FROM",
        "name": "from",
        "label": "from"
      },
      {
        "after": "INDEX",
        "name": "index",
        "label": "index"
      },
      {
        "after": "TRANSPORTING",
        "name": "transporting",
        "label": "transporting",
        "capture": "rest",
        "stopTokens": [
          "WHERE"
        ]
      },
      {
        "after": "WHERE",
        "name": "where",
        "label": "where",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/move-corresponding.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: move-corresponding.json");
    return;
  }

  const config = {
    "_sourceFile": "move-corresponding.json",
    "object": "MOVE-CORRESPONDING",
    "match": {
      "startKeyword": "MOVE-CORRESPONDING"
    },
    "keywordLabels": {
      "MOVE-CORRESPONDING": "stmt",
      "TO": "to",
      "EXPANDING": "expanding",
      "NESTED": "nested",
      "TABLES": "tables",
      "KEEPING": "keeping",
      "TARGET": "target",
      "LINES": "lines"
    },
    "keywordPhrases": {
      "EXPANDING NESTED TABLES": "expanding-nested-tables",
      "KEEPING TARGET LINES": "keeping-target-lines"
    },
    "captureRules": [
      {
        "after": "MOVE-CORRESPONDING",
        "name": "source",
        "label": "source"
      },
      {
        "after": "TO",
        "name": "target",
        "label": "target"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/move.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: move.json");
    return;
  }

  const config = {
    "_sourceFile": "move.json",
    "object": "MOVE",
    "match": {
      "startKeyword": "MOVE"
    },
    "keywordLabels": {
      "MOVE": "stmt",
      "TO": "to"
    },
    "keywordPhrases": {},
    "captureRules": [
      {
        "after": "MOVE",
        "name": "source",
        "label": "source",
        "capture": "rest",
        "stopTokens": [
          "TO"
        ]
      },
      {
        "after": "TO",
        "name": "target",
        "label": "target",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/parameters.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: parameters.json");
    return;
  }

  const config = {
    "_sourceFile": "parameters.json",
    "object": "PARAMETERS",
    "match": {
      "startKeyword": "PARAMETERS"
    },
    "keywordLabels": {
      "PARAMETERS": "stmt",
      "TYPE": "type",
      "DEFAULT": "default",
      "OBLIGATORY": "obligatory",
      "AS": "as",
      "CHECKBOX": "checkbox",
      "RADIOBUTTON": "radiobutton",
      "LISTBOX": "listbox",
      "VISIBLE": "visible",
      "LENGTH": "length",
      "NO-DISPLAY": "no-display",
      "LOWER": "lower",
      "CASE": "case",
      "MEMORY": "memory",
      "ID": "id",
      "MODIF": "modif",
      "GROUP": "group",
      "DECIMALS": "decimals",
      "NO-EXTENSION": "no-extension"
    },
    "keywordPhrases": {
      "LOWER CASE": "lower-case",
      "NO-DISPLAY": "no-display",
      "AS CHECKBOX": "as-checkbox",
      "AS RADIOBUTTON": "as-radiobutton",
      "AS LISTBOX": "as-listbox",
      "MEMORY ID": "memory-id",
      "MODIF ID": "modif-id",
      "NO-EXTENSION": "no-extension"
    },
    "captureRules": [
      {
        "after": "PARAMETERS",
        "name": "name",
        "label": "param-name",
        "descKey": "name"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "DEFAULT",
        "name": "default",
        "label": "default-value",
        "descKey": "default"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      },
      {
        "after": "GROUP",
        "name": "group",
        "label": "group-name"
      },
      {
        "after": "MEMORY ID",
        "name": "memoryId",
        "label": "memory-id"
      },
      {
        "after": "MODIF ID",
        "name": "modifId",
        "label": "modif-id"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/perform.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: perform.json");
    return;
  }

  const config = {
    "_sourceFile": "perform.json",
    "object": "PERFORM",
    "match": {
      "startKeyword": "PERFORM"
    },
    "extras": {
      "type": "performCall"
    },
    "keywordLabels": {
      "PERFORM": "stmt",
      "IN": "in",
      "PROGRAM": "program",
      "USING": "using",
      "CHANGING": "changing",
      "TABLES": "tables",
      "IF": "if"
    },
    "keywordPhrases": {
      "IN PROGRAM": "in-program"
    },
    "captureRules": [
      {
        "after": "PERFORM",
        "name": "form",
        "label": "form-name",
        "descKey": "form"
      },
      {
        "after": "IN PROGRAM",
        "name": "program",
        "label": "program"
      },
      {
        "after": "USING",
        "name": "usingRaw",
        "label": "using",
        "capture": "rest",
        "stopTokens": [
          "CHANGING",
          "TABLES",
          "IF"
        ]
      },
      {
        "after": "CHANGING",
        "name": "changingRaw",
        "label": "changing",
        "capture": "rest",
        "stopTokens": [
          "USING",
          "TABLES",
          "IF"
        ]
      },
      {
        "after": "TABLES",
        "name": "tablesRaw",
        "label": "tables",
        "capture": "rest",
        "stopTokens": [
          "USING",
          "CHANGING",
          "IF"
        ]
      },
      {
        "after": "IF",
        "name": "ifCondition",
        "label": "if",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/ranges.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: ranges.json");
    return;
  }

  const config = {
    "_sourceFile": "ranges.json",
    "object": "RANGES",
    "match": {
      "startKeyword": "RANGES"
    },
    "keywordLabels": {
      "RANGES": "stmt",
      "FOR": "for",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "RANGES",
        "name": "name",
        "label": "range-name",
        "descKey": "name"
      },
      {
        "after": "FOR",
        "name": "for",
        "label": "for",
        "descKey": "for"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like",
        "descKey": "like"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/read-table.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: read-table.json");
    return;
  }

  const config = {
    "_sourceFile": "read-table.json",
    "object": "READ_TABLE",
    "match": {
      "startPhrase": "READ TABLE"
    },
    "extras": {
      "type": "readTable"
    },
    "keywordLabels": {
      "READ": "stmt",
      "TABLE": "table",
      "WITH": "with",
      "KEY": "key",
      "INDEX": "index",
      "INTO": "into",
      "ASSIGNING": "assigning",
      "REFERENCE": "reference",
      "TRANSPORTING": "transporting",
      "NO": "no",
      "FIELDS": "fields",
      "BINARY": "binary",
      "SEARCH": "search"
    },
    "keywordPhrases": {
      "READ TABLE": "read-table",
      "WITH TABLE KEY": "with-table-key",
      "WITH KEY": "with-key",
      "TRANSPORTING NO FIELDS": "transporting-no-fields",
      "BINARY SEARCH": "binary-search",
      "REFERENCE INTO": "reference-into"
    },
    "captureRules": [
      {
        "after": "READ TABLE",
        "name": "itab",
        "label": "itab"
      },
      {
        "after": "INDEX",
        "name": "index",
        "label": "index"
      },
      {
        "after": "WITH TABLE KEY",
        "name": "withTableKey",
        "label": "with-table-key",
        "capture": "rest",
        "stopTokens": [
          "INTO",
          "ASSIGNING",
          "REFERENCE",
          "TRANSPORTING",
          "BINARY"
        ]
      },
      {
        "after": "WITH KEY",
        "name": "withKey",
        "label": "with-key",
        "capture": "rest",
        "stopTokens": [
          "INTO",
          "ASSIGNING",
          "REFERENCE",
          "TRANSPORTING",
          "BINARY"
        ]
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      },
      {
        "after": "ASSIGNING",
        "name": "assigning",
        "label": "assigning"
      },
      {
        "after": "REFERENCE INTO",
        "name": "refInto",
        "label": "reference-into"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/select-options.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: select-options.json");
    return;
  }

  const config = {
    "_sourceFile": "select-options.json",
    "object": "SELECT-OPTIONS",
    "match": {
      "startKeyword": "SELECT-OPTIONS"
    },
    "keywordLabels": {
      "SELECT-OPTIONS": "stmt",
      "FOR": "for",
      "DEFAULT": "default",
      "OBLIGATORY": "obligatory",
      "NO-EXTENSION": "no-extension",
      "NO": "no",
      "INTERVALS": "intervals",
      "LOWER": "lower",
      "CASE": "case",
      "MEMORY": "memory",
      "ID": "id",
      "MODIF": "modif",
      "VISIBLE": "visible",
      "LENGTH": "length"
    },
    "keywordPhrases": {
      "LOWER CASE": "lower-case",
      "NO-EXTENSION": "no-extension",
      "NO INTERVALS": "no-intervals",
      "MEMORY ID": "memory-id",
      "MODIF ID": "modif-id"
    },
    "captureRules": [
      {
        "after": "SELECT-OPTIONS",
        "name": "name",
        "label": "selopt-name",
        "descKey": "name"
      },
      {
        "after": "FOR",
        "name": "for",
        "label": "for"
      },
      {
        "after": "DEFAULT",
        "name": "default",
        "label": "default"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "MEMORY ID",
        "name": "memoryId",
        "label": "memory-id"
      },
      {
        "after": "MODIF ID",
        "name": "modifId",
        "label": "modif-id"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/select.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: select.json");
    return;
  }

  const config = {
    "_sourceFile": "select.json",
    "object": "SELECT",
    "match": {
      "startKeyword": "SELECT"
    },
    "extras": {
      "type": "selectStatement"
    },
    "keywordLabels": {
      "SELECT": "stmt",
      "SINGLE": "single",
      "DISTINCT": "distinct",
      "FROM": "from",
      "INTO": "into",
      "APPENDING": "appending",
      "TABLE": "table",
      "WHERE": "where",
      "ORDER": "order",
      "BY": "by",
      "GROUP": "group",
      "HAVING": "having",
      "UP": "up",
      "TO": "to",
      "ROWS": "rows"
    },
    "keywordPhrases": {
      "INTO TABLE": "into-table",
      "APPENDING TABLE": "appending-table",
      "ORDER BY": "order-by",
      "GROUP BY": "group-by",
      "UP TO": "up-to"
    },
    "captureRules": [
      {
        "after": "SELECT",
        "name": "fields",
        "label": "fields",
        "capture": "rest",
        "stopTokens": [
          "FROM"
        ]
      },
      {
        "after": "FROM",
        "name": "from",
        "label": "from"
      },
      {
        "after": "INTO TABLE",
        "name": "intoTable",
        "label": "into-table"
      },
      {
        "after": "APPENDING TABLE",
        "name": "appendingTable",
        "label": "appending-table"
      },
      {
        "after": "INTO",
        "name": "into",
        "label": "into"
      },
      {
        "after": "WHERE",
        "name": "where",
        "label": "where",
        "capture": "rest",
        "stopTokens": [
          "ORDER",
          "GROUP",
          "HAVING",
          "UP"
        ]
      },
      {
        "after": "HAVING",
        "name": "having",
        "label": "having",
        "capture": "rest",
        "stopTokens": [
          "ORDER",
          "UP"
        ]
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/sort-itab.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: sort-itab.json");
    return;
  }

  const config = {
    "_sourceFile": "sort-itab.json",
    "object": "SORT_ITAB",
    "match": {
      "startKeyword": "SORT"
    },
    "keywordLabels": {
      "SORT": "stmt",
      "BY": "by",
      "ASCENDING": "ascending",
      "DESCENDING": "descending",
      "AS": "as",
      "TEXT": "text",
      "USING": "using",
      "KEY": "key"
    },
    "keywordPhrases": {
      "USING KEY": "using-key",
      "AS TEXT": "as-text"
    },
    "captureRules": [
      {
        "after": "SORT",
        "name": "itab",
        "label": "itab"
      },
      {
        "after": "BY",
        "name": "by",
        "label": "by",
        "capture": "rest",
        "stopTokens": [
          "ASCENDING",
          "DESCENDING",
          "USING"
        ]
      },
      {
        "after": "USING KEY",
        "name": "usingKey",
        "label": "using-key"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/statics.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: statics.json");
    return;
  }

  const config = {
    "_sourceFile": "statics.json",
    "object": "STATICS",
    "match": {
      "startKeyword": "STATICS"
    },
    "keywordLabels": {
      "STATICS": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "REF": "ref",
      "TO": "to",
      "VALUE": "value",
      "LENGTH": "length",
      "DECIMALS": "decimals"
    },
    "keywordPhrases": {
      "REF TO": "ref-to"
    },
    "captureRules": [
      {
        "after": "STATICS",
        "name": "name",
        "label": "var-name",
        "descKey": "name"
      },
      {
        "after": "TYPE REF TO",
        "name": "refTo",
        "label": "ref-to",
        "descKey": "refTo"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type-name",
        "descKey": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like-name",
        "descKey": "like"
      },
      {
        "after": "VALUE",
        "name": "value",
        "label": "value",
        "descKey": "value"
      },
      {
        "after": "LENGTH",
        "name": "length",
        "label": "length"
      },
      {
        "after": "DECIMALS",
        "name": "decimals",
        "label": "decimals"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/try.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: try.json");
    return;
  }

  const config = {
    "_sourceFile": "try.json",
    "object": "TRY",
    "match": {
      "startKeyword": "TRY"
    },
    "block": {
      "endKeyword": "ENDTRY"
    },
    "keywordLabels": {
      "TRY": "stmt"
    },
    "keywordPhrases": {},
    "captureRules": []
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/types.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: types.json");
    return;
  }

  const config = {
    "_sourceFile": "types.json",
    "object": "TYPES",
    "match": {
      "startKeyword": "TYPES"
    },
    "keywordLabels": {
      "TYPES": "stmt",
      "TYPE": "type",
      "LIKE": "like",
      "BEGIN": "begin",
      "OF": "of",
      "END": "end"
    },
    "keywordPhrases": {
      "BEGIN OF": "begin-of",
      "END OF": "end-of"
    },
    "captureRules": [
      {
        "after": "TYPES BEGIN OF",
        "name": "name",
        "label": "type-name"
      },
      {
        "after": "TYPES END OF",
        "name": "name",
        "label": "type-name"
      },
      {
        "after": "TYPES",
        "name": "name",
        "label": "type-name"
      },
      {
        "after": "TYPE",
        "name": "type",
        "label": "type"
      },
      {
        "after": "LIKE",
        "name": "like",
        "label": "like"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <script>
// inlined from: ./configs.generated/when.js
/* eslint-disable */
/*
  AUTO-GENERATED FILE

  Source: /configs/*.json
  Generator: /scripts/build-viewer-configs.js

  Do not edit this file directly. Regenerate instead.
*/

(function () {
  "use strict";

  if (!window.AbapParser || typeof window.AbapParser.registerConfig !== "function") {
    console.warn("AbapParser not loaded; config not registered: when.json");
    return;
  }

  const config = {
    "_sourceFile": "when.json",
    "object": "WHEN",
    "match": {
      "startKeyword": "WHEN"
    },
    "keywordLabels": {
      "WHEN": "stmt",
      "OTHERS": "others"
    },
    "keywordPhrases": {
      "WHEN OTHERS": "when-others"
    },
    "captureRules": [
      {
        "after": "WHEN",
        "name": "branch",
        "label": "branch",
        "capture": "rest"
      }
    ]
  };
  window.AbapParser.registerConfig(config);
})();
</script>
  <!-- abap-parser-configs:end -->
  <script>
// inlined from: ./variable-descriptions.js
(function () {
  "use strict";

  // Variable/system descriptions registry
  // - Mô tả dùng để hiển thị ở cột `declDesc` (nguồn khai báo).
  // - Không ảnh hưởng parse đúng/sai.
  //
  // Priority (cao -> thấp):
  // 1) Override từ UI (localStorage)  ✅ (bạn edit trực tiếp trong viewer)
  // 2) customByScope / customGlobal  ✅ (file này)
  // 3) comment trên dòng khai báo     ✅ (VD: DATA lv_a TYPE i. "desc)
  //
  // Key gợi ý:
  // - System: "SY-UNAME", "SY-REPID", "SY-SUBRC", "ABAP_TRUE", ...
  // - Custom theo scope: `${scopeLabel}:${NAME}` (đều UPPERCASE)
  //   VD: "GLOBAL:GV_USER"
  //       "FORM:MAIN:LV_B"
  //       "FORM:STEP_B:CV_OUT"

  window.AbapVarDescriptions = {
    system: {
      "SY-UNAME": "Current user name",
      "SY-REPID": "Current program name",
      "SY-SUBRC": "Return code of last ABAP statement",
      "SY-TABIX": "Current table index",

      ABAP_TRUE: "Boolean true",
      ABAP_FALSE: "Boolean false",
      ABAP_UNDEFINED: "Boolean undefined",
      SPACE: "Single space character"
    },

    // Fallback theo name (mọi scope). Key phải là UPPERCASE.
    customGlobal: {
      // "GT_LOG": "Global log table",
    },

    // Ưu tiên theo scopeLabel (phân biệt theo scope). Key + name đều UPPERCASE.
    customByScope: {
      // GLOBAL: {
      //   GV_USER: "User name (source for iv_user)"
      // },
      // "FORM:MAIN": {
      //   LV_B: "Output buffer"
      // }
    }
  };
})();
</script>
  <script>
// inlined from: ./app/core/01-runtime-state.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/01-core.js";
  const partKey = "viewer/app/core/01-runtime-state.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\"use strict\";\n\nwindow.AbapViewerModules = window.AbapViewerModules || {};\nwindow.AbapViewerModules.parts = window.AbapViewerModules.parts || {};\nwindow.AbapViewerRuntime = window.AbapViewerRuntime || {};\nwindow.AbapViewerRuntime.api = window.AbapViewerRuntime.api || {};\n\n  const els = {\n    fileInput: document.getElementById(\"fileInput\"),\n    parseBtn: document.getElementById(\"parseBtn\"),\n    searchInput: document.getElementById(\"searchInput\"),\n    typeFilter: document.getElementById(\"typeFilter\"),\n    showRaw: document.getElementById(\"showRaw\"),\n    showKeywords: document.getElementById(\"showKeywords\"),\n    showValues: document.getElementById(\"showValues\"),\n    showExtras: document.getElementById(\"showExtras\"),\n    themeToggle: document.getElementById(\"themeToggle\"),\n    expandAllBtn: document.getElementById(\"expandAllBtn\"),\n    collapseAllBtn: document.getElementById(\"collapseAllBtn\"),\n    clearFiltersBtn: document.getElementById(\"clearFiltersBtn\"),\n    descBtn: document.getElementById(\"descBtn\"),\n    settingsBtn: document.getElementById(\"settingsBtn\"),\n    exportXmlBtn: document.getElementById(\"exportXmlBtn\"),\n    inputText: document.getElementById(\"inputText\"),\n    inputGutter: document.getElementById(\"inputGutter\"),\n    inputGutterContent: document.getElementById(\"inputGutterContent\"),\n    mainLayout: document.getElementById(\"mainLayout\"),\n    panelSplitter: document.getElementById(\"panelSplitter\"),\n    output: document.getElementById(\"output\"),\n    buildInfo: document.getElementById(\"buildInfo\"),\n    rightPanelTitle: document.getElementById(\"rightPanelTitle\"),\n    rightTabOutputBtn: document.getElementById(\"rightTabOutputBtn\"),\n    rightTabTemplateBtn: document.getElementById(\"rightTabTemplateBtn\"),\n    rightTabDescBtn: document.getElementById(\"rightTabDescBtn\"),\n    templatePreviewPanel: document.getElementById(\"templatePreviewPanel\"),\n    templateKeyMode: document.getElementById(\"templateKeyMode\"),\n    templateCopyTableOnly: document.getElementById(\"templateCopyTableOnly\"),\n    templateCopyAllBtn: document.getElementById(\"templateCopyAllBtn\"),\n    templateResetBtn: document.getElementById(\"templateResetBtn\"),\n    templateExportBtn: document.getElementById(\"templateExportBtn\"),\n    templateImportBtn: document.getElementById(\"templateImportBtn\"),\n    templateApplyBtn: document.getElementById(\"templateApplyBtn\"),\n    templateImportInput: document.getElementById(\"templateImportInput\"),\n    templateConfigError: document.getElementById(\"templateConfigError\"),\n    templateConfigJson: document.getElementById(\"templateConfigJson\"),\n    templatePreviewOutput: document.getElementById(\"templatePreviewOutput\"),\n    declDescJsonBtn: document.getElementById(\"declDescJsonBtn\"),\n    declDescPanel: document.getElementById(\"declDescPanel\"),\n    error: document.getElementById(\"error\"),\n    jsonModal: document.getElementById(\"jsonModal\"),\n    jsonTitle: document.getElementById(\"jsonTitle\"),\n    jsonPre: document.getElementById(\"jsonPre\"),\n    jsonCopyBtn: document.getElementById(\"jsonCopyBtn\"),\n    jsonCloseBtn: document.getElementById(\"jsonCloseBtn\"),\n    declDescSearch: document.getElementById(\"declDescSearch\"),\n    declDescMissingOnly: document.getElementById(\"declDescMissingOnly\"),\n    declDescTypes: document.getElementById(\"declDescTypes\"),\n    declDescSummary: document.getElementById(\"declDescSummary\"),\n    declDescTable: document.getElementById(\"declDescTable\"),\n    editModal: document.getElementById(\"editModal\"),\n    editLabel: document.getElementById(\"editLabel\"),\n    editHint: document.getElementById(\"editHint\"),\n    editSingleWrap: document.getElementById(\"editSingleWrap\"),\n    editDesc: document.getElementById(\"editDesc\"),\n    editStructWrap: document.getElementById(\"editStructWrap\"),\n    editStructDesc: document.getElementById(\"editStructDesc\"),\n    editItemDesc: document.getElementById(\"editItemDesc\"),\n    editSkipNormalize: document.getElementById(\"editSkipNormalize\"),\n    editSaveBtn: document.getElementById(\"editSaveBtn\"),\n    editClearBtn: document.getElementById(\"editClearBtn\"),\n    editCancelBtn: document.getElementById(\"editCancelBtn\"),\n    rulesBtn: document.getElementById(\"rulesBtn\"),\n    rulesModal: document.getElementById(\"rulesModal\"),\n    rulesSelect: document.getElementById(\"rulesSelect\"),\n    rulesTemplate: document.getElementById(\"rulesTemplate\"),\n    rulesError: document.getElementById(\"rulesError\"),\n    rulesJson: document.getElementById(\"rulesJson\"),\n    rulesNewBtn: document.getElementById(\"rulesNewBtn\"),\n    rulesSaveBtn: document.getElementById(\"rulesSaveBtn\"),\n    rulesDeleteBtn: document.getElementById(\"rulesDeleteBtn\"),\n    rulesDownloadBtn: document.getElementById(\"rulesDownloadBtn\"),\n    rulesCloseBtn: document.getElementById(\"rulesCloseBtn\"),\n    settingsModal: document.getElementById(\"settingsModal\"),\n    settingsNormalizeDesc: document.getElementById(\"settingsNormalizeDesc\"),\n    settingsDeclTypes: document.getElementById(\"settingsDeclTypes\"),\n    settingsStructTemplate: document.getElementById(\"settingsStructTemplate\"),\n    settingsNameTemplates: document.getElementById(\"settingsNameTemplates\"),\n    settingsSaveBtn: document.getElementById(\"settingsSaveBtn\"),\n    settingsResetBtn: document.getElementById(\"settingsResetBtn\"),\n    settingsCloseBtn: document.getElementById(\"settingsCloseBtn\")\n  };\n\n  const state = {\n    data: null,\n    renderObjects: [],\n    inputMode: \"abap\",\n    inputLineCount: 0,\n    inputGutterButtonsByLine: new Map(),\n    inputGutterTargetsByLine: new Map(),\n    theme: \"dark\",\n    query: \"\",\n    type: \"\",\n    showRaw: true,\n    showKeywords: true,\n    showValues: true,\n    showExtras: false,\n    rightTab: \"template\",\n    templateConfig: null,\n    templateConfigDraft: \"\",\n    templatePreviewCache: null,\n    collapsedIds: new Set(),\n    selectedId: \"\",\n    selectedTemplateIndex: \"\",\n    selectedDeclKey: \"\",\n    descOverrides: {},\n    descOverridesLegacy: {},\n    activeEdit: null,\n    haystackById: new Map(),\n    inputLineOffsets: [],\n    customRules: [],\n    activeRuleId: \"\",\n    settings: null,\n    layoutLeftPane: 48\n  };\n\n  const DESC_STORAGE_KEY_V2 = \"abap-parser-viewer.declDescOverrides.v2\";\n  const DESC_STORAGE_KEY_LEGACY_V1 = \"abap-parser-viewer.descOverrides.v1\";\n  const RULES_STORAGE_KEY_V1 = \"abap-parser-viewer.customConfigs.v1\";\n  const SETTINGS_STORAGE_KEY_V1 = \"abap-parser-viewer.settings.v1\";\n  const TEMPLATE_CONFIG_STORAGE_KEY_V1 = \"abap-parser-viewer.templateConfig.v1\";\n  const THEME_STORAGE_KEY_V1 = \"abap-parser-viewer.theme.v1\";\n  const LAYOUT_SPLIT_STORAGE_KEY_V1 = \"abap-parser-viewer.layoutSplit.v1\";\n  const LAYOUT_SPLIT_DEFAULT = 48;\n  const LAYOUT_SPLIT_MIN = 28;\n  const LAYOUT_SPLIT_MAX = 72;\n  const MOBILE_LAYOUT_QUERY = \"(max-width: 980px)\";\n  const RENDER_TREE_OPTIONS = Object.freeze({\n    expandPerformForms: true,\n    hideFormRoots: true,\n    maxExpandDepth: Number.POSITIVE_INFINITY\n  });\n\n  const DECL_TYPE_OPTIONS = [\n    \"DATA\",\n    \"TYPES\",\n    \"PARAMETERS\",\n    \"SELECT-OPTIONS\",\n    \"CONSTANTS\",\n    \"RANGES\",\n    \"STATICS\",\n    \"CLASS-DATA\",\n    \"FIELD-SYMBOLS\"\n  ];\n\n  const NAME_CODE_OPTIONS = [\n    { code: \"CN\", label: \"HẰNG\" },\n    { code: \"DS\", label: \"STRUCT\" },\n    { code: \"DT\", label: \"TABLE\" },\n    { code: \"DR\", label: \"RANGETABLE\" },\n    { code: \"DF\", label: \"BIẾN\" },\n    { code: \"FL\", label: \"CỜ\" },\n    { code: \"FS\", label: \"FIELDSYMBOL\" }\n  ];\n\n  const DEFAULT_SETTINGS = {\n    normalizeDeclDesc: true,\n    declFilterTypes: [\"DATA\", \"TYPES\", \"PARAMETERS\"],\n    structDescTemplate: \"{{struct}}-{{item}}\",\n    nameTemplatesByCode: {\n      CN: \"HẰNG:{{desc}}\",\n      DS: \"STRUCT:{{desc}}\",\n      DT: \"TABLE:{{desc}}\",\n      DR: \"RANGETABLE:{{desc}}\",\n      DF: \"BIẾN:{{desc}}\",\n      FL: \"CỜ:{{desc}}\",\n      FS: \"FIELDSYMBOL:{{desc}}\"\n    }\n  };\n\n  const SAMPLE_ABAP = [\n    \"* ABAP Parser Viewer - richer offline demo\",\n    \"REPORT zabap_parser_demo.\",\n    \"\",\n    \"* Comment parsing checks\",\n    \"* ---- decorative separator (should behave like blank)\",\n    \"\\\" ---- decorative quote-comment separator\",\n    \"* Single leading comment should map to next statement\",\n    \"DATA lv_comment_demo TYPE string. \\\"Inline comment for comment test\",\n    \"lv_comment_demo = 'CHECK'. \\\"Inline assignment comment\",\n    \"\",\n    \"* Selection screen\",\n    \"PARAMETERS p_user TYPE syuname DEFAULT sy-uname OBLIGATORY. \\\"User name input\",\n    \"PARAMETERS p_flag TYPE abap_bool DEFAULT abap_true AS CHECKBOX. \\\"Enable branch\",\n    \"SELECT-OPTIONS s_bukrs FOR t001-bukrs.\",\n    \"\",\n    \"* Types + declarations\",\n    \"TYPES: BEGIN OF ty_row,\",\n    \"         bukrs TYPE t001-bukrs,\",\n    \"         butxt TYPE t001-butxt,\",\n    \"       END OF ty_row.\",\n    \"TYPES: BEGIN OF ty_user,\",\n    \"         uname TYPE syuname,\",\n    \"         active TYPE abap_bool,\",\n    \"         role TYPE string,\",\n    \"       END OF ty_user.\",\n    \"TYPES: BEGIN OF ty_pair,\",\n    \"         a TYPE string,\",\n    \"         b TYPE string,\",\n    \"       END OF ty_pair.\",\n    \"TYPES ty_rows TYPE STANDARD TABLE OF ty_row.\",\n    \"TYPES ty_users TYPE STANDARD TABLE OF ty_user.\",\n    \"\",\n    \"DATA: gt_rows TYPE ty_rows,\",\n    \"      gs_row  TYPE ty_row,\",\n    \"      lt_users TYPE ty_users,\",\n    \"      ls_user TYPE ty_user,\",\n    \"      LDS_pair TYPE ty_pair,\",\n    \"      gv_total TYPE i VALUE 0,\",\n    \"      lv_active TYPE abap_bool VALUE abap_true,\",\n    \"      lv_role TYPE string VALUE 'ADMIN',\",\n    \"      lv_text TYPE string,\",\n    \"      lo_demo TYPE REF TO lcl_demo.\",\n    \"CONSTANTS gc_default_bukrs TYPE t001-bukrs VALUE '1000'.\",\n    \"FIELD-SYMBOLS <fs_row> TYPE ty_row.\",\n    \"\",\n    \"* Open SQL + table ops\",\n    \"SELECT bukrs butxt FROM t001 INTO TABLE gt_rows WHERE bukrs IN s_bukrs.\",\n    \"READ TABLE gt_rows WITH KEY bukrs = gc_default_bukrs INTO gs_row.\",\n    \"READ TABLE gt_rows WITH TABLE KEY primary_key COMPONENTS bukrs = gc_default_bukrs INTO gs_row.\",\n    \"READ TABLE lt_users WITH KEY uname = p_user active = lv_active INTO ls_user.\",\n    \"READ TABLE lt_users WITH KEY uname = p_user active = lv_active role = lv_role INTO ls_user.\",\n    \"MODIFY gt_rows FROM gs_row TRANSPORTING butxt WHERE bukrs = gc_default_bukrs.\",\n    \"DELETE gt_rows WHERE bukrs = gc_default_bukrs.\",\n    \"\",\n    \"LOOP AT gt_rows ASSIGNING <fs_row> WHERE bukrs = gc_default_bukrs.\",\n    \"  gv_total = gv_total + 1.\",\n    \"ENDLOOP.\",\n    \"LOOP AT lt_users INTO ls_user\",\n    \"  WHERE uname = p_user\",\n    \"    AND active = lv_active\",\n    \"    AND role = lv_role.\",\n    \"  gv_total = gv_total + 1.\",\n    \"ENDLOOP.\",\n    \"\",\n    \"* Conditions\",\n    \"IF gv_total > 0 AND p_flag = abap_true.\",\n    \"  lv_text = p_user.\",\n    \"ELSEIF gv_total IS INITIAL.\",\n    \"  lv_text = 'EMPTY'.\",\n    \"ELSE.\",\n    \"  lv_text = 'OTHER'.\",\n    \"ENDIF.\",\n    \"\",\n    \"* Classic calls\",\n    \"CALL FUNCTION 'Z_DEMO_FM'\",\n    \"  EXPORTING\",\n    \"    iv_user = p_user\",\n    \"  IMPORTING\",\n    \"    ev_text = lv_text\",\n    \"  CHANGING\",\n    \"    cv_cnt = gv_total\",\n    \"  TABLES\",\n    \"    et_rows = gt_rows\",\n    \"  EXCEPTIONS\",\n    \"    text_error = 2\",\n    \"    error_message = 3\",\n    \"    OTHERS = 1.\",\n    \"\",\n    \"* Struct field normalization check (a-b)\",\n    \"* Expectation for normalized desc: STRUCT:a-b (NOT STRUCT:a-STRUCT:b)\",\n    \"LDS_pair-a = p_user. \\\"Struct field a source\",\n    \"LDS_pair-b = lv_role. \\\"Struct field b source\",\n    \"lv_text = LDS_pair-a. \\\"Struct field readback\",\n    \"\",\n    \"CALL METHOD lo_demo->do_something\",\n    \"  EXPORTING\",\n    \"    iv_user = p_user\",\n    \"  IMPORTING\",\n    \"    ev_text = lv_text.\",\n    \"\",\n    \"* New method-call expressions (=> and ->)\",\n    \"lv_text = lcl_demo=>get_default( ).\",\n    \"lo_demo->do_something( EXPORTING iv_user = p_user IMPORTING ev_text = lv_text ).\",\n    \"\",\n    \"* MESSAGE demo (class/number/type/display like/with/into)\",\n    \"MESSAGE ID '00' TYPE 'S' NUMBER '001' WITH p_user lv_role gv_total lv_text DISPLAY LIKE 'I' INTO lv_text.\",\n    \"\",\n    \"* PERFORM + FORM\",\n    \"PERFORM main USING p_user p_flag CHANGING lv_text IF p_flag = abap_true.\",\n    \"PERFORM main IN PROGRAM sy-repid USING p_user p_flag CHANGING lv_text IF p_flag = abap_true.\",\n    \"\",\n    \"FORM main\",\n    \"  USING iv_user TYPE syuname\",\n    \"        iv_flag TYPE abap_bool\",\n    \"  CHANGING cv_text TYPE string.\",\n    \"  cv_text = iv_user.\",\n    \"ENDFORM.\",\n    \"\",\n    \"* Local class\",\n    \"CLASS lcl_demo DEFINITION.\",\n    \"  PUBLIC SECTION.\",\n    \"    METHODS do_something IMPORTING iv_user TYPE syuname EXPORTING ev_text TYPE string.\",\n    \"    CLASS-METHODS get_default RETURNING VALUE(rv_text) TYPE string.\",\n    \"ENDCLASS.\",\n    \"\",\n    \"CLASS lcl_demo IMPLEMENTATION.\",\n    \"  METHOD do_something.\",\n    \"    ev_text = iv_user.\",\n    \"  ENDMETHOD.\",\n    \"\",\n    \"  METHOD get_default.\",\n    \"    rv_text = 'DEFAULT'.\",\n    \"  ENDMETHOD.\",\n    \"ENDCLASS.\"\n  ].join(\"\\n\");\n\n  function createTemplateBaseStyle(background) {\n    return {\n      background: background || \"default\",\n      border: \"outside-thin\",\n      font: \"MS PGothic\",\n      \"font color\": \"#111111\",\n      \"font size\": 10,\n      \"font family\": \"default\",\n      bold: false,\n      italic: false,\n      underline: false,\n      merge: false,\n      align: \"left\",\n      valign: \"top\",\n      wrap: false\n    };\n  }\n\n  const TEMPLATE_PREVIEW_DEFAULT_OPTIONS = {\n    hideEmptyRows: true,\n    hideRowsWithoutValues: true,\n    expandMultilineRows: true,\n    squareCells: true,\n    squareCellSize: 18\n  };\n\n  function createGenericStatementTemplate(templateKey) {\n    const keyText = String(templateKey || \"\").trim();\n    return {\n      _options: { ...TEMPLATE_PREVIEW_DEFAULT_OPTIONS },\n      \"A1:G1\": createTemplateBaseStyle(\"#dbeef4\"),\n      A1: {\n        text: \"Câu lệnh\"\n      },\n      \"H1:AY1\": createTemplateBaseStyle(\"default\"),\n      H1: {\n        text: \"{keywords.stmt.text}{objectType}\"\n      },\n      \"A2:G2\": createTemplateBaseStyle(\"#dbeef4\"),\n      A2: {\n        text: \"Đối tượng\"\n      },\n      \"H2:AY2\": createTemplateBaseStyle(\"default\"),\n      H2: {\n        text: \"{values.name.finalDesc}{values.target.finalDesc}{values.form.finalDesc}{values.itab.finalDesc}{values.itabOrDbtab.finalDesc}\"\n      },\n      \"A3:G3\": createTemplateBaseStyle(\"#dbeef4\"),\n      A3: {\n        text: \"Nguồn / Đích\"\n      },\n      \"H3:AY3\": createTemplateBaseStyle(\"default\"),\n      H3: {\n        text: \"{values.into.finalDesc}{values.from.finalDesc}{values.index.value}\"\n      },\n      \"A4:G4\": createTemplateBaseStyle(\"#dbeef4\"),\n      A4: {\n        text: \"Điều kiện\"\n      },\n      \"H4:AY4\": createTemplateBaseStyle(\"default\"),\n      H4: {\n        text: \"{values.condition.finalDesc}{values.where.finalDesc}{values.withKey.finalDesc}{values.withTableKey.finalDesc}\"\n      },\n      \"A5:G5\": createTemplateBaseStyle(\"#dbeef4\"),\n      A5: {\n        text: \"Chi tiết\"\n      },\n      \"H5:AY5\": createTemplateBaseStyle(\"default\"),\n      H5: {\n        text: \"{extras}\"\n      },\n      \"A6:G6\": createTemplateBaseStyle(\"#dbeef4\"),\n      A6: {\n        text: \"Template key\"\n      },\n      \"H6:AY6\": createTemplateBaseStyle(\"default\"),\n      H6: {\n        text: keyText\n      }\n    };\n  }\n\n  const TEMPLATE_DEFAULT_CONFIG_V1 = {\n    version: 1,\n    templates: {\n      DEFAULT: {\n        _options: {\n          hideEmptyRows: true,\n          hideRowsWithoutValues: true,\n          expandMultilineRows: false\n        },\n        \"A1:F1\": {\n          background: \"mau xanh nhat\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A1: {\n          text: \"{keywords.stmt.text}\"\n        },\n        \"G1:W1\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        G1: {\n          text: \"{values.name.finalDesc}\"\n        }\n      },\n      ASSIGNMENT: {\n        \"A1:F1\": {\n          background: \"mau xanh nhat\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/core/02-build-info.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/01-core.js";
  const partKey = "viewer/app/core/02-build-info.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A1: {\n          text: \"Đích\"\n        },\n        \"A2:F2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A2: {\n          text: \"{values.target.decl.finalDesc}\"\n        },\n        \"G1:W1\": {\n          background: \"mau xanh nhat\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        G1: {\n          text: \"Nguồn\"\n        },\n        \"G2:W2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        G2: {\n          text: \"{values.expr.decl.finalDesc}\"\n        }\n      },\n      CALL_FUNCTION: {\n        _options: {\n          hideEmptyRows: true,\n          hideRowsWithoutValues: true,\n          expandMultilineRows: true\n        },\n        \"A1:H1\": createTemplateBaseStyle(\"#dbeef4\"),\n        A1: {\n          text: \"Function Module\"\n        },\n        \"I1:BG1\": createTemplateBaseStyle(\"#ffffff\"),\n        I1: {\n          text: \"{values.name.finalDesc}\"\n        },\n        \"A2:H2\": createTemplateBaseStyle(\"#dbeef4\"),\n        A2: {\n          text: \"Exporting\"\n        },\n        \"I2:P2\": createTemplateBaseStyle(\"#ffffff\"),\n        I2: {\n          text: \"{extras.callFunction.exporting.name}\"\n        },\n        \"Q2:X2\": createTemplateBaseStyle(\"#ffffff\"),\n        Q2: {\n          text: \"=\"\n        },\n        \"Y2:BG2\": createTemplateBaseStyle(\"#ffffff\"),\n        Y2: {\n          text: \"{extras.callFunction.exporting.valueDecl.finalDesc}\"\n        },\n        \"A3:H3\": createTemplateBaseStyle(\"#dbeef4\"),\n        A3: {\n          text: \"Importing\"\n        },\n        \"I3:P3\": createTemplateBaseStyle(\"#ffffff\"),\n        I3: {\n          text: \"{extras.callFunction.importing.name}\"\n        },\n        \"Q3:X3\": createTemplateBaseStyle(\"#ffffff\"),\n        Q3: {\n          text: \"=\"\n        },\n        \"Y3:BG3\": createTemplateBaseStyle(\"#ffffff\"),\n        Y3: {\n          text: \"{extras.callFunction.importing.valueDecl.finalDesc}\"\n        },\n        \"A4:H4\": createTemplateBaseStyle(\"#dbeef4\"),\n        A4: {\n          text: \"Tables\"\n        },\n        \"I4:P4\": createTemplateBaseStyle(\"#ffffff\"),\n        I4: {\n          text: \"{extras.callFunction.tables.name}\"\n        },\n        \"Q4:X4\": createTemplateBaseStyle(\"#ffffff\"),\n        Q4: {\n          text: \"=\"\n        },\n        \"Y4:BG4\": createTemplateBaseStyle(\"#ffffff\"),\n        Y4: {\n          text: \"{extras.callFunction.tables.valueDecl.finalDesc}\"\n        },\n        \"A5:H5\": createTemplateBaseStyle(\"#dbeef4\"),\n        A5: {\n          text: \"Changing\"\n        },\n        \"I5:P5\": createTemplateBaseStyle(\"#ffffff\"),\n        I5: {\n          text: \"{extras.callFunction.changing.name}\"\n        },\n        \"Q5:X5\": createTemplateBaseStyle(\"#ffffff\"),\n        Q5: {\n          text: \"=\"\n        },\n        \"Y5:BG5\": createTemplateBaseStyle(\"#ffffff\"),\n        Y5: {\n          text: \"{extras.callFunction.changing.valueDecl.finalDesc}\"\n        },\n        \"A6:H6\": createTemplateBaseStyle(\"#dbeef4\"),\n        A6: {\n          text: \"Exceptions\"\n        },\n        \"I6:P6\": createTemplateBaseStyle(\"#ffffff\"),\n        I6: {\n          text: \"{extras.callFunction.exceptions.name}\"\n        },\n        \"Q6:X6\": createTemplateBaseStyle(\"#ffffff\"),\n        Q6: {\n          text: \"=\"\n        },\n        \"Y6:BG6\": createTemplateBaseStyle(\"#ffffff\"),\n        Y6: {\n          text: \"{extras.callFunction.exceptions.valueDecl.finalDesc}\"\n        }\n      },\n      APPEND: {\n        \"A1:G1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A1: {\n          text: \"Append\"\n        },\n        \"H1:Y1\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        H1: {\n          text: \"{values.what.decl.finalDesc}\"\n        },\n        \"Z1:AD1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        Z1: {\n          text: \"To\"\n        },\n        \"AE1:AY1\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        AE1: {\n          text: \"{values.to.decl.finalDesc}\"\n        },\n        \"A2:G2\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A2: {\n          text: \"{labels.sortedBy}\"\n        },\n        \"H2:AB2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        H2: {\n          text: \"{extras}\"\n        }\n      },\n      READ_TABLE: {\n        _options: {\n          hideEmptyRows: true,\n          hideRowsWithoutValues: true,\n          expandMultilineRows: true\n        },\n        \"A1:G1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A1: {\n          text: \"ReadTable\"\n        },\n        \"H1:AB1\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        H1: {\n          text: \"{values.itab.decl.finalDesc}\"\n        },\n        \"A2:G2\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A2: {\n          text: \"To\"\n        },\n        \"H2:AB2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        H2: {\n          text: \"{values.into.decl.finalDesc}\"\n        },\n        \"A3:G3\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A3: {\n          text: \"Điều kiện\"\n        },\n        \"H3:T3\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        H3: {\n          text: \"{extras.readTable.conditions.leftOperand}\"\n        },\n        \"U3:W3\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        U3: {\n          text: \"{extras.readTable.conditions.comparisonOperator}\"\n        },\n        \"X3:AR3\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        X3: {\n          text: \"{extras.readTable.conditions.rightOperandDecl.finalDesc}\"\n        },\n        \"A4:U4\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A4: {\n          text: \"{keywords.binary-search.text}\"\n        }\n      },\n      MODIFY_ITAB: {\n        _options: {\n          hideEmptyRows: true,\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/core/03-storage.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/01-core.js";
  const partKey = "viewer/app/core/03-storage.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "          hideRowsWithoutValues: true,\n          expandMultilineRows: true\n        },\n        \"A1:G1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A1: {\n          text: \"Modify Table\"\n        },\n        \"H1:AB1\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        H1: {\n          text: \"{values.itab.finalDesc}{values.itabOrDbtab.finalDesc}\"\n        },\n        \"A2:G2\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A2: {\n          text: \"From\"\n        },\n        \"H2:AB2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        H2: {\n          text: \"{values.from.finalDesc}\"\n        },\n        \"A3:G3\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A3: {\n          text: \"Transporting / Index\"\n        },\n        \"H3:AB3\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        H3: {\n          text: \"{extras.modifyItab.transporting}{values.index.value}\"\n        },\n        \"A4:T4\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A4: {\n          text: \"Điều kiện trái\"\n        },\n        \"U4:W4\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        U4: {\n          text: \"Điều kiện\"\n        },\n        \"X4:AD4\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        X4: {\n          text: \"Điều kiện phải\"\n        },\n        \"AE4:AY4\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        AE4: {\n          text: \"Logic connector\"\n        },\n        \"A5:T5\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A5: {\n          text: \"{extras.modifyItab.conditions.leftOperandDecl.finalDesc}\"\n        },\n        \"U5:W5\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        U5: {\n          text: \"{extras.modifyItab.conditions.comparisonOperator}\"\n        },\n        \"X5:AD5\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        X5: {\n          text: \"{extras.modifyItab.conditions.rightOperandDecl.finalDesc}\"\n        },\n        \"AE5:AY5\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        AE5: {\n          text: \"{extras.modifyItab.conditions.logicalConnector}\"\n        }\n      },\n      DELETE_ITAB: {\n        _options: {\n          hideEmptyRows: true,\n          hideRowsWithoutValues: true,\n          expandMultilineRows: true\n        },\n        \"A1:G1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A1: {\n          text: \"Delete Table\"\n        },\n        \"H1:AB1\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        H1: {\n          text: \"{values.target.finalDesc}\"\n        },\n        \"A2:G2\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A2: {\n          text: \"From / Index\"\n        },\n        \"H2:AB2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        H2: {\n          text: \"{values.from.finalDesc}{values.index.value}\"\n        },\n        \"A3:T3\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A3: {\n          text: \"Điều kiện trái\"\n        },\n        \"U3:W3\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        U3: {\n          text: \"Điều kiện\"\n        },\n        \"X3:AD3\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        X3: {\n          text: \"Điều kiện phải\"\n        },\n        \"AE3:AY3\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        AE3: {\n          text: \"Logic connector\"\n        },\n        \"A4:T4\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A4: {\n          text: \"{extras.deleteItab.conditions.leftOperandDecl.finalDesc}\"\n        },\n        \"U4:W4\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        U4: {\n          text: \"{extras.deleteItab.conditions.comparisonOperator}\"\n        },\n        \"X4:AD4\": {\n          background: \"#ffffff\",\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/core/04-template-config.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/01-core.js";
  const partKey = "viewer/app/core/04-template-config.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        X4: {\n          text: \"{extras.deleteItab.conditions.rightOperandDecl.finalDesc}\"\n        },\n        \"AE4:AY4\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        AE4: {\n          text: \"{extras.deleteItab.conditions.logicalConnector}\"\n        }\n      },\n      LOOP_AT_ITAB: {\n        _options: {\n          hideEmptyRows: true,\n          hideRowsWithoutValues: true,\n          expandMultilineRows: true\n        },\n        \"A1:X1\": createTemplateBaseStyle(\"#dbeef4\"),\n        A1: {\n          text: \"Loop At\"\n        },\n        \"Y1:BA1\": createTemplateBaseStyle(\"#dbeef4\"),\n        Y1: {\n          text: \"Into\"\n        },\n        \"BB1:BG1\": createTemplateBaseStyle(\"#dbeef4\"),\n        BB1: {\n          text: \"Connection\"\n        },\n        \"A2:H2\": createTemplateBaseStyle(\"#dbeef4\"),\n        A2: {\n          text: \"Điều kiện\"\n        },\n        \"I2:V2\": createTemplateBaseStyle(\"#ffffff\"),\n        I2: {\n          text: \"{extras.loopAtItab.conditions.leftOperandDecl.finalDesc}\"\n        },\n        \"W2:X2\": createTemplateBaseStyle(\"#dbeef4\"),\n        W2: {\n          text: \"{extras.loopAtItab.conditions.comparisonOperator}\"\n        },\n        \"Y2:BA2\": createTemplateBaseStyle(\"#ffffff\"),\n        Y2: {\n          text: \"{extras.loopAtItab.conditions.rightOperandDecl.finalDesc}\"\n        },\n        \"BB2:BG2\": createTemplateBaseStyle(\"#ffffff\"),\n        BB2: {\n          text: \"{extras.loopAtItab.conditions.logicalConnector}\"\n        }\n      },\n      IF: {\n        _options: {\n          hideEmptyRows: true,\n          hideRowsWithoutValues: true,\n          expandMultilineRows: true\n        },\n        \"A1:T1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A1: {\n          text: \"Điều kiện trái\"\n        },\n        \"U1:W1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        U1: {\n          text: \"Điều kiện\"\n        },\n        \"X1:AD1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        X1: {\n          text: \"Điều kiện phải\"\n        },\n        \"AE1:AY1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        AE1: {\n          text: \"Logic connector\"\n        },\n        \"A2:T2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A2: {\n          text: \"{extras.ifCondition.conditions.leftOperandDecl.finalDesc}\"\n        },\n        \"U2:W2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        U2: {\n          text: \"{extras.ifCondition.conditions.comparisonOperator}\"\n        },\n        \"X2:AD2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        X2: {\n          text: \"{extras.ifCondition.conditions.rightOperandDecl.finalDesc}\"\n        },\n        \"AE2:AY2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        AE2: {\n          text: \"{extras.ifCondition.conditions.logicalConnector}\"\n        }\n      },\n      ELSEIF: {\n        _options: {\n          hideEmptyRows: true,\n          hideRowsWithoutValues: true,\n          expandMultilineRows: true\n        },\n        \"A1:T1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A1: {\n          text: \"Điều kiện trái\"\n        },\n        \"U1:W1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        U1: {\n          text: \"Điều kiện\"\n        },\n        \"X1:AD1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        X1: {\n          text: \"Điều kiện phải\"\n        },\n        \"AE1:AY1\": {\n          background: \"#dbeef4\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        AE1: {\n          text: \"Logic connector\"\n        },\n        \"A2:T2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        A2: {\n          text: \"{extras.ifCondition.conditions.leftOperandDecl.finalDesc}\"\n        },\n        \"U2:W2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        U2: {\n          text: \"{extras.ifCondition.conditions.comparisonOperator}\"\n        },\n        \"X2:AD2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        X2: {\n          text: \"{extras.ifCondition.conditions.rightOperandDecl.finalDesc}\"\n        },\n        \"AE2:AY2\": {\n          background: \"#ffffff\",\n          border: \"outside-thin\",\n          font: \"MS PGothic\",\n          \"font color\": \"#111111\",\n          \"font size\": 10,\n          \"font family\": \"default\",\n          bold: false,\n          italic: false,\n          underline: false,\n          merge: false,\n          align: \"left\",\n          valign: \"top\",\n          wrap: false\n        },\n        AE2: {\n          text: \"{extras.ifCondition.conditions.logicalConnector}\"\n        }\n      },\n      PERFORM: {\n        _options: {\n          hideEmptyRows: true,\n          hideRowsWithoutValues: true,\n          expandMultilineRows: true\n        },\n        \"J1:X1\": createTemplateBaseStyle(\"#dbeef4\"),\n        J1: {\n          text: \"ID\"\n        },\n        \"Y1:BG1\": createTemplateBaseStyle(\"#dbeef4\"),\n        Y1: {\n          text: \"Text\"\n        },\n        \"A2:I2\": createTemplateBaseStyle(\"#dbeef4\"),\n        A2: {\n          text: \"Subroutine\"\n        },\n        \"J2:X2\": createTemplateBaseStyle(\"#ffffff\"),\n        J2: {\n          text: \"{values.form.decl.name}\"\n        },\n        \"Y2:BG2\": createTemplateBaseStyle(\"#ffffff\"),\n        Y2: {\n          text: \"{values.form.finalDesc}\"\n        },\n        \"A3:I3\": createTemplateBaseStyle(\"#dbeef4\"),\n        A3: {\n          text: \"Using\"\n        },\n        \"J3:X3\": createTemplateBaseStyle(\"#ffffff\"),\n        J3: {\n          text: \"{extras.performCall.using.valueDecl.name}\"\n        },\n        \"Y3:BG3\": createTemplateBaseStyle(\"#ffffff\"),\n        Y3: {\n          text: \"{extras.performCall.using.valueDecl.finalDesc}\"\n        },\n        \"A4:I4\": createTemplateBaseStyle(\"#dbeef4\"),\n        A4: {\n          text: \"Changing\"\n        },\n        \"J4:X4\": createTemplateBaseStyle(\"#ffffff\"),\n        J4: {\n          text: \"{extras.performCall.changing.valueDecl.name}\"\n        },\n        \"Y4:BG4\": createTemplateBaseStyle(\"#ffffff\"),\n        Y4: {\n          text: \"{extras.performCall.changing.valueDecl.finalDesc}\"\n        },\n        \"A5:I5\": createTemplateBaseStyle(\"#dbeef4\"),\n        A5: {\n          text: \"Tables\"\n        },\n        \"J5:X5\": createTemplateBaseStyle(\"#ffffff\"),\n        J5: {\n          text: \"{extras.performCall.tables.valueDecl.name}\"\n        },\n        \"Y5:BG5\": createTemplateBaseStyle(\"#ffffff\"),\n        Y5: {\n          text: \"{extras.performCall.tables.valueDecl.finalDesc}\"\n        },\n        \"A6:I6\": createTemplateBaseStyle(\"#dbeef4\"),\n        A6: {\n          text: \"Raising\"\n        },\n        \"J6:X6\": createTemplateBaseStyle(\"#ffffff\"),\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/core/05-theme-layout.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/01-core.js";
  const partKey = "viewer/app/core/05-theme-layout.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "        J6: {\n          text: \"{extras.performCall.raising.name}\"\n        },\n        \"Y6:BG6\": createTemplateBaseStyle(\"#ffffff\"),\n        Y6: {\n          text: \"{extras.performCall.raising.valueDecl.finalDesc}\"\n        },\n        \"A7:I7\": createTemplateBaseStyle(\"#dbeef4\"),\n        A7: {\n          text: \"In Program\"\n        },\n        \"J7:X7\": createTemplateBaseStyle(\"#ffffff\"),\n        J7: {\n          text: \"{values.program.decl.name}\"\n        },\n        \"Y7:BG7\": createTemplateBaseStyle(\"#ffffff\"),\n        Y7: {\n          text: \"{values.program.finalDesc}\"\n        }\n      },\n      MESSAGE: {\n        _options: {\n          hideEmptyRows: true,\n          hideRowsWithoutValues: true,\n          expandMultilineRows: true\n        },\n        \"A1:I1\": createTemplateBaseStyle(\"#dbeef4\"),\n        A1: {\n          text: \"Message Class\"\n        },\n        \"J1:V1\": createTemplateBaseStyle(\"#ffffff\"),\n        J1: {\n          text: \"{values.messageClass.finalDesc}\"\n        },\n        \"W1:AB1\": createTemplateBaseStyle(\"#dbeef4\"),\n        W1: {\n          text: \"Message Number\"\n        },\n        \"AC1:AJ1\": createTemplateBaseStyle(\"#ffffff\"),\n        AC1: {\n          text: \"{values.messageNumber.finalDesc}\"\n        },\n        \"AK1:AQ1\": createTemplateBaseStyle(\"#dbeef4\"),\n        AK1: {\n          text: \"Message Type\"\n        },\n        \"AR1:AX1\": createTemplateBaseStyle(\"#ffffff\"),\n        AR1: {\n          text: \"{values.messageType.finalDesc}\"\n        },\n        \"AY1:BG1\": createTemplateBaseStyle(\"#dbeef4\"),\n        AY1: {\n          text: \"Display Like\"\n        },\n        \"BH1:BZ1\": createTemplateBaseStyle(\"#ffffff\"),\n        BH1: {\n          text: \"{values.displayLike.finalDesc}\"\n        },\n        \"A2:I2\": createTemplateBaseStyle(\"#dbeef4\"),\n        A2: {\n          text: \"Message Text &1\"\n        },\n        \"J2:BZ2\": createTemplateBaseStyle(\"#ffffff\"),\n        J2: {\n          text: \"{values.messageText1.finalDesc}\"\n        },\n        \"A3:I3\": createTemplateBaseStyle(\"#dbeef4\"),\n        A3: {\n          text: \"Message Text &2\"\n        },\n        \"J3:BZ3\": createTemplateBaseStyle(\"#ffffff\"),\n        J3: {\n          text: \"{values.messageText2.finalDesc}\"\n        },\n        \"A4:I4\": createTemplateBaseStyle(\"#dbeef4\"),\n        A4: {\n          text: \"Message Text &3\"\n        },\n        \"J4:BZ4\": createTemplateBaseStyle(\"#ffffff\"),\n        J4: {\n          text: \"{values.messageText3.finalDesc}\"\n        },\n        \"A5:I5\": createTemplateBaseStyle(\"#dbeef4\"),\n        A5: {\n          text: \"Message Text &4\"\n        },\n        \"J5:BZ5\": createTemplateBaseStyle(\"#ffffff\"),\n        J5: {\n          text: \"{values.messageText4.finalDesc}\"\n        },\n        \"A6:I6\": createTemplateBaseStyle(\"#dbeef4\"),\n        A6: {\n          text: \"Message Display\"\n        },\n        \"J6:BZ6\": createTemplateBaseStyle(\"#ffffff\"),\n        J6: {\n          text: \"{values.messageDisplay.finalDesc}\"\n        },\n        \"A7:I7\": createTemplateBaseStyle(\"#dbeef4\"),\n        A7: {\n          text: \"Đích lưu\"\n        },\n        \"J7:BZ7\": createTemplateBaseStyle(\"#ffffff\"),\n        J7: {\n          text: \"{values.messageDestination.finalDesc}\"\n        }\n      }\n    }\n  };\n\n  const TEMPLATE_GENERIC_KEYS = [\n    \"CALL_FUNCTION\",\n    \"CALL_METHOD\",\n    \"CALL_TRANSACTION\",\n    \"CASE\",\n    \"CATCH\",\n    \"CLASS\",\n    \"CLASS-DATA\",\n    \"CLASS-METHODS\",\n    \"CLEANUP\",\n    \"CLEAR\",\n    \"CONSTANTS\",\n    \"DATA\",\n    \"DO\",\n    \"ELSE\",\n    \"FIELD-SYMBOLS\",\n    \"FORM\",\n    \"INSERT_ITAB\",\n    \"LOOP_AT_ITAB\",\n    \"METHOD\",\n    \"METHODS\",\n    \"MOVE\",\n    \"MOVE-CORRESPONDING\",\n    \"PARAMETERS\",\n    \"PERFORM\",\n    \"RANGES\",\n    \"SELECT\",\n    \"SELECT-OPTIONS\",\n    \"SORT_ITAB\",\n    \"STATICS\",\n    \"TRY\",\n    \"TYPES\",\n    \"WHEN\"\n  ];\n\n  for (const key of TEMPLATE_GENERIC_KEYS) {\n    if (!Object.prototype.hasOwnProperty.call(TEMPLATE_DEFAULT_CONFIG_V1.templates, key)) {\n      TEMPLATE_DEFAULT_CONFIG_V1.templates[key] = createGenericStatementTemplate(key);\n    }\n  }\n\n  for (const templateDef of Object.values(TEMPLATE_DEFAULT_CONFIG_V1.templates)) {\n    if (!templateDef || typeof templateDef !== \"object\" || Array.isArray(templateDef)) {\n      continue;\n    }\n    const currentOptions = templateDef._options && typeof templateDef._options === \"object\" && !Array.isArray(templateDef._options)\n      ? templateDef._options\n      : {};\n    templateDef._options = { ...TEMPLATE_PREVIEW_DEFAULT_OPTIONS, ...currentOptions };\n  }\n\n  function setError(message) {\n    els.error.textContent = message ? String(message) : \"\";\n  }\n\n  function setOutputMessage(message) {\n    els.output.classList.add(\"muted\");\n    els.output.replaceChildren();\n    els.output.textContent = message || \"\";\n  }\n\n  function parseDateCandidate(value) {\n    const raw = String(value || \"\").trim();\n    if (!raw) {\n      return null;\n    }\n    const date = new Date(raw);\n    return Number.isNaN(date.getTime()) ? null : date;\n  }\n\n  function formatDateTime(value) {\n    const date = value instanceof Date ? value : parseDateCandidate(value);\n    if (!date) {\n      return \"\";\n    }\n    try {\n      return new Intl.DateTimeFormat(undefined, {\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\",\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        second: \"2-digit\"\n      }).format(date);\n    } catch {\n      return date.toLocaleString();\n    }\n  }\n\n  function getMetaContent(name) {\n    try {\n      const el = document.querySelector(`meta[name=\"${name}\"]`);\n      if (!el) {\n        return \"\";\n      }\n      return String(el.getAttribute(\"content\") || \"\").trim();\n    } catch {\n      return \"\";\n    }\n  }\n\n  function renderBuildInfo() {\n    if (!els.buildInfo) {\n      return;\n    }\n\n    const manualVersion = getMetaContent(\"abap-viewer-version\");\n    const manualUpdatedAt = getMetaContent(\"abap-viewer-updated-at\");\n    const manualNote = getMetaContent(\"abap-viewer-updated-note\");\n    const parsedManualDate = parseDateCandidate(manualUpdatedAt);\n    const fallbackDate = parseDateCandidate(document.lastModified);\n    const versionPrefix = manualVersion ? `${manualVersion} | ` : \"\";\n\n    if (manualUpdatedAt || manualVersion) {\n      const display = parsedManualDate ? formatDateTime(parsedManualDate) : manualUpdatedAt;\n      const updatedText = display || \"manual timestamp not set\";\n      els.buildInfo.textContent = `Updated: ${versionPrefix}${updatedText} (manual)`;\n      els.buildInfo.title = manualNote || \"Manual timestamp from <meta name=\\\"abap-viewer-updated-at\\\">.\";\n      return;\n    }\n\n    if (fallbackDate) {\n      els.buildInfo.textContent = `Updated: ${formatDateTime(fallbackDate)} (from document.lastModified)`;\n      els.buildInfo.title = \"No manual timestamp found. Showing document.lastModified.\";\n      return;\n    }\n\n    els.buildInfo.textContent = \"Updated: unknown\";\n    els.buildInfo.title = \"No manual timestamp and no document.lastModified available.\";\n  }\n\n  function normalizeId(id) {\n    if (id === null || id === undefined) {\n      return \"\";\n    }\n    return String(id);\n  }\n\n  function flattenEntryMap(map) {\n    if (!map || typeof map !== \"object\") {\n      return [];\n    }\n\n    const out = [];\n    for (const key of Object.keys(map)) {\n      const entryOrList = map[key];\n      if (Array.isArray(entryOrList)) {\n        for (const entry of entryOrList) {\n          if (entry && typeof entry === \"object\") {\n            out.push(entry);\n          }\n        }\n        continue;\n      }\n      if (entryOrList && typeof entryOrList === \"object\") {\n        out.push(entryOrList);\n      }\n    }\n    return out;\n  }\n\n  function getKeywordEntries(obj) {\n    if (!obj) {\n      return [];\n    }\n    if (Array.isArray(obj.keywords)) {\n      return obj.keywords;\n    }\n    return flattenEntryMap(obj.keywords);\n  }\n\n  function getValueEntries(obj) {\n    if (!obj) {\n      return [];\n    }\n    if (Array.isArray(obj.values)) {\n      return obj.values;\n    }\n    return flattenEntryMap(obj.values);\n  }\n\n  function getFirstValueFromValues(values, key) {\n    if (!values) {\n      return \"\";\n    }\n\n    if (Array.isArray(values)) {\n      const match = values.find((v) => v && v.name === key && v.value);\n      return match ? String(match.value) : \"\";\n    }\n\n    if (typeof values !== \"object\") {\n      return \"\";\n    }\n\n    const entryOrList = values[key];\n    const entry = Array.isArray(entryOrList) ? entryOrList[0] : entryOrList;\n    return entry && entry.value ? String(entry.value) : \"\";\n  }\n\n  function loadStorageObject(key) {\n    try {\n      const raw = localStorage.getItem(key);\n      if (!raw) {\n        return {};\n      }\n      const parsed = JSON.parse(raw);\n      return parsed && typeof parsed === \"object\" ? parsed : {};\n    } catch {\n      return {};\n    }\n  }\n\n  function loadDescOverrides() {\n    return loadStorageObject(DESC_STORAGE_KEY_V2);\n  }\n\n  function loadLegacyDescOverrides() {\n    return loadStorageObject(DESC_STORAGE_KEY_LEGACY_V1);\n  }\n\n  function saveDescOverrides() {\n    try {\n      localStorage.setItem(DESC_STORAGE_KEY_V2, JSON.stringify(state.descOverrides || {}));\n    } catch {\n      // ignore\n    }\n  }\n\n  function loadStorageArray(key) {\n    try {\n      const raw = localStorage.getItem(key);\n      if (!raw) {\n        return [];\n      }\n      const parsed = JSON.parse(raw);\n      return Array.isArray(parsed) ? parsed : [];\n    } catch {\n      return [];\n    }\n  }\n\n  function normalizeSettings(value) {\n    const input = value && typeof value === \"object\" && !Array.isArray(value) ? value : {};\n\n    const normalizeDeclDesc = typeof input.normalizeDeclDesc === \"boolean\"\n      ? input.normalizeDeclDesc\n      : DEFAULT_SETTINGS.normalizeDeclDesc;\n\n    const declFilterTypes = Array.isArray(input.declFilterTypes)\n      ? input.declFilterTypes\n          .map((t) => String(t || \"\").trim().toUpperCase())\n          .filter((t) => t && DECL_TYPE_OPTIONS.includes(t))\n      : [];\n\n    const structDescTemplate = typeof input.structDescTemplate === \"string\" && input.structDescTemplate.trim()\n      ? input.structDescTemplate\n      : DEFAULT_SETTINGS.structDescTemplate;\n\n    const nameTemplatesByCode = {};\n    const inputNameTemplates = input.nameTemplatesByCode && typeof input.nameTemplatesByCode === \"object\"\n      ? input.nameTemplatesByCode\n      : {};\n\n    for (const opt of NAME_CODE_OPTIONS) {\n      const code = opt.code;\n      const rawTemplate = Object.prototype.hasOwnProperty.call(inputNameTemplates, code)\n        ? inputNameTemplates[code]\n        : DEFAULT_SETTINGS.nameTemplatesByCode[code];\n\n      const template = typeof rawTemplate === \"string\" && rawTemplate.trim()\n        ? rawTemplate\n        : DEFAULT_SETTINGS.nameTemplatesByCode[code];\n\n      nameTemplatesByCode[code] = template;\n    }\n\n    return {\n      normalizeDeclDesc,\n      declFilterTypes: declFilterTypes.length ? declFilterTypes : DEFAULT_SETTINGS.declFilterTypes.slice(),\n      structDescTemplate,\n      nameTemplatesByCode\n    };\n  }\n\n  function loadSettings() {\n    return normalizeSettings(loadStorageObject(SETTINGS_STORAGE_KEY_V1));\n  }\n\n  function saveSettings(settings) {\n    try {\n      localStorage.setItem(SETTINGS_STORAGE_KEY_V1, JSON.stringify(settings || {}));\n    } catch {\n      // ignore\n    }\n  }\n\n  function setTemplateConfigError(message) {\n    if (!els.templateConfigError) {\n      return;\n    }\n    els.templateConfigError.textContent = message ? String(message) : \"\";\n  }\n\n  function setTemplatePreviewMessage(message) {\n    if (!els.templatePreviewOutput) {\n      return;\n    }\n    els.templatePreviewOutput.classList.add(\"muted\");\n    els.templatePreviewOutput.replaceChildren();\n    els.templatePreviewOutput.textContent = message || \"\";\n  }\n\n  function cloneJsonValue(value) {\n    try {\n      return JSON.parse(JSON.stringify(value));\n    } catch {\n      return null;\n    }\n  }\n\n  function getDefaultTemplateConfig() {\n    const cloned = cloneJsonValue(TEMPLATE_DEFAULT_CONFIG_V1);\n    return cloned && typeof cloned === \"object\" ? cloned : { version: 1, templates: {} };\n  }\n\n  function normalizeTemplateAliasToken(value) {\n    return String(value || \"\")\n      .trim()\n      .toLowerCase()\n      .normalize(\"NFD\")\n      .replace(/[\\u0300-\\u036f]/g, \"\")\n      .replace(/\\s+/g, \" \");\n  }\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/core/06-rules.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/01-core.js";
  const partKey = "viewer/app/core/06-rules.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\n  function parseCellRef(cellRef) {\n    const raw = String(cellRef || \"\").trim().toUpperCase();\n    const match = /^([A-Z]+)([1-9][0-9]*)$/.exec(raw);\n    if (!match) {\n      throw new Error(`Invalid cell ref \"${cellRef}\". Expected format like A1.`);\n    }\n\n    const letters = match[1];\n    const row = Number(match[2]) || 0;\n    let col = 0;\n    for (let i = 0; i < letters.length; i += 1) {\n      col = (col * 26) + (letters.charCodeAt(i) - 64);\n    }\n\n    if (!row || !col) {\n      throw new Error(`Invalid cell ref \"${cellRef}\".`);\n    }\n\n    return { row, col, raw };\n  }\n\n  function parseRangeKey(rangeKey) {\n    const raw = String(rangeKey || \"\").trim().toUpperCase();\n    if (!raw) {\n      throw new Error(\"Range key is empty.\");\n    }\n\n    const parts = raw.split(\":\").map((item) => item.trim()).filter(Boolean);\n    if (!parts.length || parts.length > 2) {\n      throw new Error(`Invalid range \"${rangeKey}\". Expected A1 or A1:B2.`);\n    }\n\n    const start = parseCellRef(parts[0]);\n    const end = parseCellRef(parts.length > 1 ? parts[1] : parts[0]);\n\n    return {\n      key: raw,\n      r1: Math.min(start.row, end.row),\n      c1: Math.min(start.col, end.col),\n      r2: Math.max(start.row, end.row),\n      c2: Math.max(start.col, end.col)\n    };\n  }\n\n  function isTemplateOptionConfigKey(rawKey) {\n    const key = String(rawKey || \"\").trim().toLowerCase();\n    if (!key) {\n      return false;\n    }\n    return (\n      key === \"_options\"\n      || key === \"options\"\n      || key === \"ranges\"\n      || key === \"compact\"\n      || key === \"hideemptyrows\"\n      || key === \"hiderowswithoutvalues\"\n      || key === \"expandmultilinerows\"\n      || key === \"removeemptyrows\"\n      || key === \"removeemptyrowsadvanced\"\n      || key === \"removeemptyrowsadv\"\n      || key === \"expandarrayrows\"\n      || key === \"arraytorows\"\n    );\n  }\n\n  function validateTemplateConfig(config) {\n    const errors = [];\n    if (!config || typeof config !== \"object\" || Array.isArray(config)) {\n      return { valid: false, errors: [\"Config must be a JSON object.\"] };\n    }\n\n    const version = Number(config.version);\n    if (version !== 1) {\n      errors.push(\"Config.version must be 1.\");\n    }\n\n    const templates = config.templates;\n    if (!templates || typeof templates !== \"object\" || Array.isArray(templates)) {\n      errors.push(\"Config.templates must be an object.\");\n      return { valid: false, errors };\n    }\n\n    const templateKeys = Object.keys(templates);\n    if (!templateKeys.length) {\n      errors.push(\"Config.templates must contain at least one template key.\");\n      return { valid: false, errors };\n    }\n\n    for (const templateKey of templateKeys) {\n      const templateDef = templates[templateKey];\n      if (!templateDef || typeof templateDef !== \"object\" || Array.isArray(templateDef)) {\n        errors.push(`templates.${templateKey} must be an object of range -> style.`);\n        continue;\n      }\n\n      const hasRangesObject = Object.prototype.hasOwnProperty.call(templateDef, \"ranges\");\n      const ranges = hasRangesObject ? templateDef.ranges : templateDef;\n      if (!ranges || typeof ranges !== \"object\" || Array.isArray(ranges)) {\n        errors.push(`templates.${templateKey}.ranges must be an object of range -> style.`);\n        continue;\n      }\n\n      const optionCandidates = [\"_options\", \"options\"];\n      for (const optKey of optionCandidates) {\n        if (!Object.prototype.hasOwnProperty.call(templateDef, optKey)) {\n          continue;\n        }\n        const optValue = templateDef[optKey];\n        if (!optValue || typeof optValue !== \"object\" || Array.isArray(optValue)) {\n          errors.push(`templates.${templateKey}.${optKey} must be an object.`);\n        }\n      }\n\n      for (const rangeKey of Object.keys(ranges)) {\n        if (isTemplateOptionConfigKey(rangeKey)) {\n          continue;\n        }\n        try {\n          parseRangeKey(rangeKey);\n        } catch (err) {\n          errors.push(`templates.${templateKey}.${rangeKey}: ${err && err.message ? err.message : err}`);\n        }\n\n        const cellConfig = ranges[rangeKey];\n        if (!cellConfig || typeof cellConfig !== \"object\" || Array.isArray(cellConfig)) {\n          errors.push(`templates.${templateKey}.${rangeKey} must be an object.`);\n        }\n      }\n    }\n\n    return { valid: errors.length === 0, errors };\n  }\n\n  function loadTemplateConfig() {\n    try {\n      const raw = localStorage.getItem(TEMPLATE_CONFIG_STORAGE_KEY_V1);\n      if (!raw) {\n        return getDefaultTemplateConfig();\n      }\n      const parsed = JSON.parse(raw);\n      const check = validateTemplateConfig(parsed);\n      if (!check.valid) {\n        return getDefaultTemplateConfig();\n      }\n      return parsed;\n    } catch {\n      return getDefaultTemplateConfig();\n    }\n  }\n\n  function saveTemplateConfig(config) {\n    try {\n      localStorage.setItem(TEMPLATE_CONFIG_STORAGE_KEY_V1, JSON.stringify(config || {}));\n    } catch {\n      // ignore\n    }\n  }\n\n  function normalizeTheme(value) {\n    return value === \"light\" ? \"light\" : \"dark\";\n  }\n\n  function loadTheme() {\n    try {\n      return normalizeTheme(localStorage.getItem(THEME_STORAGE_KEY_V1) || \"\");\n    } catch {\n      return \"dark\";\n    }\n  }\n\n  function applyTheme(nextTheme, { save } = {}) {\n    const normalized = normalizeTheme(nextTheme);\n    state.theme = normalized;\n    document.documentElement.setAttribute(\"data-theme\", normalized);\n\n    if (els.themeToggle) {\n      els.themeToggle.checked = normalized === \"dark\";\n    }\n\n    if (save === false) {\n      return;\n    }\n\n    try {\n      localStorage.setItem(THEME_STORAGE_KEY_V1, normalized);\n    } catch {\n      // ignore\n    }\n  }\n\n  function clampNumber(value, min, max) {\n    return Math.min(max, Math.max(min, value));\n  }\n\n  function normalizeLayoutSplit(value) {\n    const numeric = Number(value);\n    if (!Number.isFinite(numeric)) {\n      return LAYOUT_SPLIT_DEFAULT;\n    }\n    return clampNumber(numeric, LAYOUT_SPLIT_MIN, LAYOUT_SPLIT_MAX);\n  }\n\n  function loadLayoutSplit() {\n    try {\n      return normalizeLayoutSplit(localStorage.getItem(LAYOUT_SPLIT_STORAGE_KEY_V1));\n    } catch {\n      return LAYOUT_SPLIT_DEFAULT;\n    }\n  }\n\n  function saveLayoutSplit(value) {\n    try {\n      localStorage.setItem(LAYOUT_SPLIT_STORAGE_KEY_V1, String(normalizeLayoutSplit(value)));\n    } catch {\n      // ignore\n    }\n  }\n\n  function updateSplitterAria(leftPercent) {\n    if (!els.panelSplitter) {\n      return;\n    }\n\n    const left = Math.round(leftPercent);\n    const right = Math.round(100 - leftPercent);\n    els.panelSplitter.setAttribute(\"aria-valuemin\", String(LAYOUT_SPLIT_MIN));\n    els.panelSplitter.setAttribute(\"aria-valuemax\", String(LAYOUT_SPLIT_MAX));\n    els.panelSplitter.setAttribute(\"aria-valuenow\", String(left));\n    els.panelSplitter.setAttribute(\"aria-valuetext\", `${left}% code, ${right}% output`);\n  }\n\n  function applyLayoutSplit(nextPercent, { save } = {}) {\n    const normalized = normalizeLayoutSplit(nextPercent);\n    state.layoutLeftPane = normalized;\n    document.documentElement.style.setProperty(\"--layout-left-pane\", `${normalized}%`);\n    updateSplitterAria(normalized);\n\n    if (save === false) {\n      return;\n    }\n\n    saveLayoutSplit(normalized);\n  }\n\n  function isCompactLayout() {\n    if (typeof window.matchMedia === \"function\") {\n      return window.matchMedia(MOBILE_LAYOUT_QUERY).matches;\n    }\n    return window.innerWidth <= 980;\n  }\n\n  function setLayoutResizing(active) {\n    if (!els.mainLayout) {\n      return;\n    }\n    els.mainLayout.classList.toggle(\"is-resizing\", Boolean(active));\n  }\n\n  function initLayoutSplitter() {\n    applyLayoutSplit(loadLayoutSplit(), { save: false });\n\n    if (!els.mainLayout || !els.panelSplitter) {\n      return;\n    }\n\n    let dragging = false;\n    let activePointerId = null;\n\n    function applySplitFromClientX(clientX) {\n      const layoutRect = els.mainLayout.getBoundingClientRect();\n      const splitterRect = els.panelSplitter.getBoundingClientRect();\n      const usableWidth = layoutRect.width - splitterRect.width;\n      if (usableWidth <= 0) {\n        return;\n      }\n\n      const leftWidth = clientX - layoutRect.left - (splitterRect.width / 2);\n      const leftPercent = (leftWidth / usableWidth) * 100;\n      applyLayoutSplit(leftPercent, { save: false });\n    }\n\n    function onPointerMove(ev) {\n      if (!dragging || isCompactLayout()) {\n        return;\n      }\n      applySplitFromClientX(ev.clientX);\n      ev.preventDefault();\n    }\n\n    function stopDragging() {\n      if (!dragging) {\n        return;\n      }\n      dragging = false;\n      setLayoutResizing(false);\n      if (activePointerId !== null && typeof els.panelSplitter.releasePointerCapture === \"function\") {\n        try {\n          els.panelSplitter.releasePointerCapture(activePointerId);\n        } catch {\n          // ignore\n        }\n      }\n      activePointerId = null;\n      saveLayoutSplit(state.layoutLeftPane);\n      window.removeEventListener(\"pointermove\", onPointerMove);\n      window.removeEventListener(\"pointerup\", stopDragging);\n      window.removeEventListener(\"pointercancel\", stopDragging);\n    }\n\n    els.panelSplitter.addEventListener(\"pointerdown\", (ev) => {\n      if (ev.button !== 0 || isCompactLayout()) {\n        return;\n      }\n\n      dragging = true;\n      activePointerId = ev.pointerId;\n      setLayoutResizing(true);\n\n      if (typeof els.panelSplitter.setPointerCapture === \"function\") {\n        try {\n          els.panelSplitter.setPointerCapture(ev.pointerId);\n        } catch {\n          // ignore\n        }\n      }\n\n      applySplitFromClientX(ev.clientX);\n      window.addEventListener(\"pointermove\", onPointerMove);\n      window.addEventListener(\"pointerup\", stopDragging);\n      window.addEventListener(\"pointercancel\", stopDragging);\n      ev.preventDefault();\n    });\n\n    els.panelSplitter.addEventListener(\"keydown\", (ev) => {\n      if (isCompactLayout()) {\n        return;\n      }\n      if (ev.key !== \"ArrowLeft\" && ev.key !== \"ArrowRight\") {\n        return;\n      }\n\n      const step = ev.shiftKey ? 5 : 2;\n      const delta = ev.key === \"ArrowRight\" ? step : -step;\n      applyLayoutSplit(state.layoutLeftPane + delta);\n      ev.preventDefault();\n    });\n\n    window.addEventListener(\"resize\", () => {\n      if (isCompactLayout()) {\n        setLayoutResizing(false);\n        return;\n      }\n      applyLayoutSplit(state.layoutLeftPane, { save: false });\n    });\n  }\n\n  function validateRuleConfig(config) {\n    if (!config || typeof config !== \"object\" || Array.isArray(config)) {\n      return \"Config must be a JSON object.\";\n    }\n\n    if (!config.object || typeof config.object !== \"string\") {\n      return \"Missing config.object (string).\";\n    }\n\n    if (!config.match || typeof config.match !== \"object\" || Array.isArray(config.match)) {\n      return \"Missing config.match (object).\";\n    }\n\n    const match = config.match;\n    const hasMatch =\n      (typeof match.startKeyword === \"string\" && match.startKeyword.trim()) ||\n      (typeof match.startPhrase === \"string\" && match.startPhrase.trim()) ||\n      (typeof match.type === \"string\" && match.type.trim());\n\n    if (!hasMatch) {\n      return \"match must include startKeyword, startPhrase, or type.\";\n    }\n\n    if (config.block !== undefined && config.block !== null) {\n      if (typeof config.block !== \"object\" || Array.isArray(config.block)) {\n        return \"block must be an object (or null).\";\n      }\n      if (typeof config.block.endKeyword !== \"string\" || !config.block.endKeyword.trim()) {\n        return \"block.endKeyword must be a non-empty string.\";\n      }\n    }\n\n    if (config.extras !== undefined && config.extras !== null) {\n      if (typeof config.extras !== \"object\" || Array.isArray(config.extras)) {\n        return \"extras must be an object (or null).\";\n      }\n      if (typeof config.extras.type !== \"string\" || !config.extras.type.trim()) {\n        return \"extras.type must be a non-empty string.\";\n      }\n    }\n\n    if (config.keywordLabels !== undefined && config.keywordLabels !== null) {\n      if (typeof config.keywordLabels !== \"object\" || Array.isArray(config.keywordLabels)) {\n        return \"keywordLabels must be an object.\";\n      }\n    }\n\n    if (config.keywordPhrases !== undefined && config.keywordPhrases !== null) {\n      if (typeof config.keywordPhrases !== \"object\" || Array.isArray(config.keywordPhrases)) {\n        return \"keywordPhrases must be an object.\";\n      }\n    }\n\n    if (config.captureRules !== undefined && config.captureRules !== null && !Array.isArray(config.captureRules)) {\n      return \"captureRules must be an array.\";\n    }\n\n    if (Array.isArray(config.captureRules)) {\n      for (const rule of config.captureRules) {\n        if (!rule || typeof rule !== \"object\" || Array.isArray(rule)) {\n          return \"Each captureRules[] item must be an object.\";\n        }\n        if (typeof rule.after !== \"string\" || !rule.after.trim()) {\n          return \"Each captureRules[] item must have after (string).\";\n        }\n        if (typeof rule.name !== \"string\" || !rule.name.trim()) {\n          return \"Each captureRules[] item must have name (string).\";\n        }\n      }\n    }\n\n    return \"\";\n  }\n\n  function generateRuleId() {\n    const time = Date.now();\n    const rand = Math.random().toString(16).slice(2, 10);\n    return `rule-${time}-${rand}`;\n  }\n\n  function normalizeCustomRules(list) {\n    const output = [];\n    const items = Array.isArray(list) ? list : [];\n\n    for (const item of items) {\n      if (!item || typeof item !== \"object\" || Array.isArray(item)) {\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/core/07-settings-modal.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/01-core.js";
  const partKey = "viewer/app/core/07-settings-modal.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "        continue;\n      }\n\n      if (item.config && typeof item.config === \"object\" && !Array.isArray(item.config)) {\n        const id = item.id ? String(item.id) : generateRuleId();\n        output.push({ id, config: item.config });\n        continue;\n      }\n\n      if (typeof item.object === \"string\") {\n        output.push({ id: generateRuleId(), config: item });\n      }\n    }\n\n    return output;\n  }\n\n  function loadCustomRules() {\n    return normalizeCustomRules(loadStorageArray(RULES_STORAGE_KEY_V1));\n  }\n\n  function saveCustomRules() {\n    try {\n      localStorage.setItem(RULES_STORAGE_KEY_V1, JSON.stringify(state.customRules || []));\n    } catch {\n      // ignore\n    }\n  }\n\n  function setRulesError(message) {\n    if (!els.rulesError) {\n      return;\n    }\n    els.rulesError.textContent = message ? String(message) : \"\";\n  }\n\n  function getCustomConfigs() {\n    const output = [];\n    for (const rule of state.customRules || []) {\n      if (!rule || !rule.config) {\n        continue;\n      }\n      const error = validateRuleConfig(rule.config);\n      if (!error) {\n        output.push(rule.config);\n      }\n    }\n    return output;\n  }\n\n  function describeRuleOption(rule) {\n    if (!rule || !rule.config) {\n      return \"(invalid rule)\";\n    }\n\n    const objectType = rule.config.object ? String(rule.config.object) : \"RULE\";\n    const match = rule.config.match && typeof rule.config.match === \"object\" ? rule.config.match : {};\n    const summary = match.startPhrase\n      ? `startPhrase=${String(match.startPhrase)}`\n      : match.startKeyword\n        ? `startKeyword=${String(match.startKeyword)}`\n        : match.type\n          ? `type=${String(match.type)}`\n          : \"match=?\";\n\n    return `${objectType} (${summary})`;\n  }\n\n  function renderRulesSelect() {\n    if (!els.rulesSelect) {\n      return;\n    }\n\n    els.rulesSelect.replaceChildren();\n    els.rulesSelect.appendChild(el(\"option\", { text: \"(New rule)\", attrs: { value: \"\" } }));\n\n    for (const rule of state.customRules || []) {\n      const id = rule && rule.id ? String(rule.id) : \"\";\n      if (!id) {\n        continue;\n      }\n      els.rulesSelect.appendChild(\n        el(\"option\", {\n          text: describeRuleOption(rule),\n          attrs: { value: id }\n        })\n      );\n    }\n\n    els.rulesSelect.value = state.activeRuleId || \"\";\n  }\n\n  function selectRule(ruleId) {\n    const id = ruleId ? String(ruleId) : \"\";\n    state.activeRuleId = id;\n    setRulesError(\"\");\n\n    if (!els.rulesJson) {\n      return;\n    }\n\n    if (!id) {\n      els.rulesJson.value = \"\";\n      return;\n    }\n\n    const rule = (state.customRules || []).find((r) => r && String(r.id) === id) || null;\n    if (!rule || !rule.config) {\n      els.rulesJson.value = \"\";\n      return;\n    }\n\n    try {\n      els.rulesJson.value = JSON.stringify(rule.config, null, 2);\n    } catch {\n      els.rulesJson.value = \"\";\n    }\n  }\n\n  function createRuleTemplate(kind) {\n    const type = String(kind || \"startKeyword\");\n\n    if (type === \"assignment\") {\n      return {\n        object: \"ASSIGNMENT\",\n        match: { type: \"assignment\" },\n        keywordLabels: {\n          \"=\": \"assign\",\n          \"+=\": \"add-assign\",\n          \"-=\": \"sub-assign\",\n          \"*=\": \"mul-assign\",\n          \"/=\": \"div-assign\",\n          \"?=\": \"cast\"\n        },\n        keywordPhrases: {},\n        captureRules: []\n      };\n    }\n\n    if (type === \"startPhrase\") {\n      return {\n        object: \"MY_OBJECT\",\n        match: { startPhrase: \"MY PHRASE\" },\n        keywordLabels: {\n          MY: \"stmt\"\n        },\n        keywordPhrases: {\n          \"MY PHRASE\": \"my-phrase\"\n        },\n        captureRules: [\n          { after: \"MY PHRASE\", name: \"name\", label: \"name\" }\n        ]\n      };\n    }\n\n    return {\n      object: \"MY_OBJECT\",\n      match: { startKeyword: \"MYKEYWORD\" },\n      keywordLabels: {\n        MYKEYWORD: \"stmt\"\n      },\n      keywordPhrases: {},\n      captureRules: [\n        { after: \"MYKEYWORD\", name: \"name\", label: \"name\" }\n      ]\n    };\n  }\n\n  function startNewRule() {\n    state.activeRuleId = \"\";\n    if (els.rulesSelect) {\n      els.rulesSelect.value = \"\";\n    }\n\n    const kind = els.rulesTemplate ? els.rulesTemplate.value : \"startKeyword\";\n    const template = createRuleTemplate(kind);\n\n    if (els.rulesJson) {\n      els.rulesJson.value = JSON.stringify(template, null, 2);\n      els.rulesJson.focus();\n    }\n\n    setRulesError(\"\");\n  }\n\n  function readRuleFromEditor() {\n    const text = els.rulesJson ? els.rulesJson.value || \"\" : \"\";\n    const trimmed = text.trim();\n    if (!trimmed) {\n      return { config: null, error: \"Rule JSON is empty.\" };\n    }\n\n    try {\n      const parsed = JSON.parse(trimmed);\n      const config = parsed;\n      const error = validateRuleConfig(config);\n      if (error) {\n        return { config: null, error };\n      }\n      return { config, error: \"\" };\n    } catch (err) {\n      return { config: null, error: `JSON parse error: ${err && err.message ? err.message : err}` };\n    }\n  }\n\n  function saveRuleFromEditor() {\n    const { config, error } = readRuleFromEditor();\n    if (error) {\n      setRulesError(error);\n      return;\n    }\n\n    setRulesError(\"\");\n\n    if (state.activeRuleId) {\n      const target = (state.customRules || []).find((r) => r && String(r.id) === state.activeRuleId) || null;\n      if (target) {\n        target.config = config;\n      } else {\n        state.customRules.push({ id: state.activeRuleId, config });\n      }\n    } else {\n      const id = generateRuleId();\n      state.customRules.push({ id, config });\n      state.activeRuleId = id;\n    }\n\n    saveCustomRules();\n    renderRulesSelect();\n    if (els.rulesSelect) {\n      els.rulesSelect.value = state.activeRuleId || \"\";\n    }\n  }\n\n  function deleteActiveRule() {\n    if (!state.activeRuleId) {\n      setRulesError(\"Select a saved rule to delete.\");\n      return;\n    }\n\n    state.customRules = (state.customRules || []).filter((r) => r && String(r.id) !== state.activeRuleId);\n    state.activeRuleId = \"\";\n    saveCustomRules();\n    renderRulesSelect();\n    if (els.rulesJson) {\n      els.rulesJson.value = \"\";\n    }\n    setRulesError(\"\");\n  }\n\n  function downloadRuleFromEditor() {\n    const { config, error } = readRuleFromEditor();\n    if (error) {\n      setRulesError(error);\n      return;\n    }\n\n    setRulesError(\"\");\n\n    const fileBase = config && config.object ? String(config.object).trim() : \"rule\";\n    const fileName = `${fileBase}.json`;\n    const content = JSON.stringify(config, null, 2);\n\n    try {\n      const blob = new Blob([content], { type: \"application/json\" });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = fileName;\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      setRulesError(`Download failed: ${err && err.message ? err.message : err}`);\n    }\n  }\n\n  function openRulesModal() {\n    if (!els.rulesModal) {\n      return;\n    }\n\n    if (!els.jsonModal.hidden) {\n      closeJsonModal();\n    }\n    if (!els.editModal.hidden) {\n      closeEditModal();\n    }\n\n    renderRulesSelect();\n    if (state.activeRuleId) {\n      selectRule(state.activeRuleId);\n    } else if (els.rulesJson && !els.rulesJson.value.trim()) {\n      startNewRule();\n    }\n\n    els.rulesModal.hidden = false;\n  }\n\n  function closeRulesModal() {\n    if (!els.rulesModal) {\n      return;\n    }\n\n    els.rulesModal.hidden = true;\n    setRulesError(\"\");\n  }\n\n  function renderSettingsModalUi() {\n    if (!els.settingsModal) {\n      return;\n    }\n\n    const settings = state.settings || loadSettings();\n    state.settings = settings;\n\n    if (els.settingsNormalizeDesc) {\n      els.settingsNormalizeDesc.checked = Boolean(settings.normalizeDeclDesc);\n    }\n\n    if (els.settingsDeclTypes) {\n      els.settingsDeclTypes.replaceChildren();\n      for (const type of DECL_TYPE_OPTIONS) {\n        const label = document.createElement(\"label\");\n        label.className = \"toggle\";\n\n        const input = document.createElement(\"input\");\n        input.type = \"checkbox\";\n        input.value = type;\n        input.checked = Array.isArray(settings.declFilterTypes) && settings.declFilterTypes.includes(type);\n\n        label.appendChild(input);\n        label.appendChild(document.createTextNode(type));\n        els.settingsDeclTypes.appendChild(label);\n      }\n    }\n\n    if (els.settingsStructTemplate) {\n      els.settingsStructTemplate.value = settings.structDescTemplate || DEFAULT_SETTINGS.structDescTemplate;\n    }\n\n    if (els.settingsNameTemplates) {\n      els.settingsNameTemplates.replaceChildren();\n\n      const table = document.createElement(\"table\");\n      const thead = document.createElement(\"thead\");\n      const headRow = document.createElement(\"tr\");\n      for (const title of [\"code\", \"label\", \"template\"]) {\n        const th = document.createElement(\"th\");\n        th.textContent = title;\n        headRow.appendChild(th);\n      }\n      thead.appendChild(headRow);\n      table.appendChild(thead);\n\n      const tbody = document.createElement(\"tbody\");\n      for (const opt of NAME_CODE_OPTIONS) {\n        const tr = document.createElement(\"tr\");\n\n        const codeCell = document.createElement(\"td\");\n        codeCell.textContent = opt.code;\n        tr.appendChild(codeCell);\n\n        const labelCell = document.createElement(\"td\");\n        labelCell.textContent = opt.label;\n        tr.appendChild(labelCell);\n\n        const tplCell = document.createElement(\"td\");\n        const input = document.createElement(\"input\");\n        input.type = \"text\";\n        input.style.width = \"100%\";\n        input.setAttribute(\"data-code\", opt.code);\n        input.value = (settings.nameTemplatesByCode && settings.nameTemplatesByCode[opt.code])\n          ? String(settings.nameTemplatesByCode[opt.code] || \"\")\n          : String(DEFAULT_SETTINGS.nameTemplatesByCode[opt.code] || \"\");\n\n        tplCell.appendChild(input);\n        tr.appendChild(tplCell);\n\n        tbody.appendChild(tr);\n      }\n      table.appendChild(tbody);\n\n      els.settingsNameTemplates.appendChild(table);\n    }\n  }\n\n  function openSettingsModal() {\n    if (!els.settingsModal) {\n      return;\n    }\n\n    if (!els.jsonModal.hidden) {\n      closeJsonModal();\n    }\n    if (!els.editModal.hidden) {\n      closeEditModal();\n    }\n    if (els.rulesModal && !els.rulesModal.hidden) {\n      closeRulesModal();\n    }\n\n    renderSettingsModalUi();\n    els.settingsModal.hidden = false;\n  }\n\n  function closeSettingsModal() {\n    if (!els.settingsModal) {\n      return;\n    }\n    els.settingsModal.hidden = true;\n  }\n\nwindow.AbapViewerModules.factories = window.AbapViewerModules.factories || {};\nwindow.AbapViewerModules.factories[\"01-core\"] = function registerCore(runtime) {\n  const targetRuntime = runtime || (window.AbapViewerRuntime = window.AbapViewerRuntime || {});\n  targetRuntime.api = targetRuntime.api || {};\n  targetRuntime.els = els;\n  targetRuntime.state = state;\n  targetRuntime.constants = {\n    DESC_STORAGE_KEY_V2,\n    DESC_STORAGE_KEY_LEGACY_V1,\n    RULES_STORAGE_KEY_V1,\n    SETTINGS_STORAGE_KEY_V1,\n    TEMPLATE_CONFIG_STORAGE_KEY_V1,\n    THEME_STORAGE_KEY_V1,\n    LAYOUT_SPLIT_STORAGE_KEY_V1,\n    LAYOUT_SPLIT_DEFAULT,\n    LAYOUT_SPLIT_MIN,\n    LAYOUT_SPLIT_MAX,\n    MOBILE_LAYOUT_QUERY,\n    RENDER_TREE_OPTIONS,\n    DECL_TYPE_OPTIONS,\n    NAME_CODE_OPTIONS,\n    DEFAULT_SETTINGS,\n    TEMPLATE_DEFAULT_CONFIG_V1,\n    SAMPLE_ABAP\n  };\n  window.AbapViewerModules.parts[\"01-core\"] = true;\n};\nwindow.AbapViewerModules.factories[\"01-core\"](window.AbapViewerRuntime);\n\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/01-core.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/01-core.js";
  const bucket = registry[targetKey] || {};
  const orderedParts = [
    "viewer/app/core/01-runtime-state.js",
    "viewer/app/core/02-build-info.js",
    "viewer/app/core/03-storage.js",
    "viewer/app/core/04-template-config.js",
    "viewer/app/core/05-theme-layout.js",
    "viewer/app/core/06-rules.js",
    "viewer/app/core/07-settings-modal.js"
  ];

  const missing = orderedParts.filter((part) => typeof bucket[part] !== "string");
  if (missing.length) {
    const message = `Source parts missing for ${targetKey}: ${missing.join(", ")}`;
    try {
      if (globalRoot.console && typeof globalRoot.console.error === "function") {
        globalRoot.console.error(message);
      }
    } catch {
      // ignore
    }
    return;
  }

  const source = orderedParts.map((part) => bucket[part]).join("\n");
  if (typeof document !== "undefined" && document.createElement) {
    const script = document.createElement("script");
    script.type = "text/javascript";
    script.setAttribute("data-abap-source-wrapper", targetKey);
    script.textContent = `${source}\n//# sourceURL=${targetKey}`;
    (document.head || document.documentElement || document.body).appendChild(script);
    script.remove();
  } else {
    (0, eval)(source);
  }
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/descriptions/01-normalize-and-desc.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/02-descriptions.js";
  const partKey = "viewer/app/descriptions/01-normalize-and-desc.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\"use strict\";\n\nwindow.AbapViewerModules = window.AbapViewerModules || {};\nwindow.AbapViewerModules.parts = window.AbapViewerModules.parts || {};\n\n  function collectConditionDeclsFromClauses(clauses, addDecl) {\n    const list = Array.isArray(clauses) ? clauses : [];\n    for (const clause of list) {\n      if (!clause || typeof clause !== \"object\") {\n        continue;\n      }\n      addDecl(clause.leftOperandDecl);\n      addDecl(clause.rightOperandDecl);\n    }\n  }\n\n  function collectConditionDeclsFromExtras(extras, addDecl) {\n    if (!extras || typeof extras !== \"object\" || typeof addDecl !== \"function\") {\n      return;\n    }\n\n    if (extras.ifCondition) {\n      collectConditionDeclsFromClauses(extras.ifCondition.conditions, addDecl);\n    }\n\n    if (extras.performCall) {\n      collectConditionDeclsFromClauses(extras.performCall.ifConditions, addDecl);\n    }\n\n    if (extras.select) {\n      collectConditionDeclsFromClauses(extras.select.whereConditions, addDecl);\n      collectConditionDeclsFromClauses(extras.select.havingConditions, addDecl);\n    }\n\n    for (const key of [\"readTable\", \"loopAtItab\", \"modifyItab\", \"deleteItab\"]) {\n      if (extras[key]) {\n        collectConditionDeclsFromClauses(extras[key].conditions, addDecl);\n      }\n    }\n  }\n\n  function getDeclsForDescriptionsModal() {\n    if (state.data && typeof state.data === \"object\" && Array.isArray(state.data.decls)) {\n      return state.data.decls;\n    }\n\n    const decls = [];\n    const seen = new Set();\n\n    const addDecl = (decl) => {\n      if (!decl || typeof decl !== \"object\") {\n        return;\n      }\n      const key = getDeclOverrideStorageKey(decl) || stringifyDecl(decl);\n      if (!key || seen.has(key)) {\n        return;\n      }\n      seen.add(key);\n      decls.push(decl);\n    };\n\n    walkObjects(state.data && Array.isArray(state.data.objects) ? state.data.objects : [], (obj) => {\n      for (const value of getValueEntries(obj)) {\n        addDecl(value && value.decl);\n      }\n\n      const extras = obj && obj.extras && typeof obj.extras === \"object\" ? obj.extras : null;\n      if (!extras) {\n        return;\n      }\n\n      const collectFromAssignmentSections = (container, sections) => {\n        for (const sectionName of sections) {\n          const list = container && Array.isArray(container[sectionName]) ? container[sectionName] : [];\n          for (const entry of list) {\n            const origin = entry && Array.isArray(entry.originDecls) ? entry.originDecls : [];\n            for (const originDecl of origin) {\n              addDecl(originDecl);\n            }\n            addDecl(entry && entry.valueDecl);\n          }\n        }\n      };\n\n      if (extras.callFunction) {\n        collectFromAssignmentSections(extras.callFunction, [\"exporting\", \"importing\", \"changing\", \"tables\", \"exceptions\"]);\n      }\n\n      if (extras.callMethod) {\n        collectFromAssignmentSections(extras.callMethod, [\"exporting\", \"importing\", \"changing\", \"receiving\", \"exceptions\"]);\n      }\n\n      if (extras.performCall) {\n        for (const sectionName of [\"using\", \"changing\", \"tables\"]) {\n          const list = Array.isArray(extras.performCall[sectionName]) ? extras.performCall[sectionName] : [];\n          for (const entry of list) {\n            const origin = entry && Array.isArray(entry.originDecls) ? entry.originDecls : [];\n            for (const originDecl of origin) {\n              addDecl(originDecl);\n            }\n            addDecl(entry && entry.valueDecl);\n          }\n        }\n      }\n\n      if (extras.form && Array.isArray(extras.form.params)) {\n        for (const param of extras.form.params) {\n          const origin = param && Array.isArray(param.originDecls) ? param.originDecls : [];\n          for (const originDecl of origin) {\n            addDecl(originDecl);\n          }\n        }\n      }\n\n      collectConditionDeclsFromExtras(extras, addDecl);\n    });\n\n    return decls;\n  }\n\n  function getDeclCodeDesc(decl) {\n    const source = getSourceDeclDesc(decl);\n    if (source) {\n      return source;\n    }\n    return getBaseDeclDesc(decl);\n  }\n\n  function renderDeclDescCellLines({ structText, itemText }) {\n    const wrap = document.createElement(\"div\");\n    const structLine = document.createElement(\"div\");\n    const structLabel = document.createElement(\"span\");\n    structLabel.className = \"muted\";\n    structLabel.textContent = \"Struct: \";\n    structLine.appendChild(structLabel);\n    structLine.appendChild(document.createTextNode(structText || \"\"));\n    wrap.appendChild(structLine);\n\n    const itemLine = document.createElement(\"div\");\n    const itemLabel = document.createElement(\"span\");\n    itemLabel.className = \"muted\";\n    itemLabel.textContent = \"Item: \";\n    itemLine.appendChild(itemLabel);\n    itemLine.appendChild(document.createTextNode(itemText || \"\"));\n    wrap.appendChild(itemLine);\n\n    return wrap;\n  }\n\n  function renderDeclDescPanelUi() {\n    if (!els.declDescPanel) {\n      return;\n    }\n\n    const settings = state.settings || loadSettings();\n    state.settings = settings;\n\n    if (els.declDescTypes) {\n      els.declDescTypes.replaceChildren();\n      for (const type of DECL_TYPE_OPTIONS) {\n        const label = document.createElement(\"label\");\n        label.className = \"toggle\";\n\n        const input = document.createElement(\"input\");\n        input.type = \"checkbox\";\n        input.value = type;\n        input.checked = Array.isArray(settings.declFilterTypes) && settings.declFilterTypes.includes(type);\n        input.addEventListener(\"change\", () => {\n          const selected = [];\n          const inputs = els.declDescTypes ? els.declDescTypes.querySelectorAll(\"input[type=checkbox]\") : [];\n          for (const checkbox of Array.from(inputs)) {\n            if (checkbox.checked) {\n              selected.push(String(checkbox.value || \"\").trim().toUpperCase());\n            }\n          }\n          state.settings = normalizeSettings({ ...settings, declFilterTypes: selected });\n          saveSettings(state.settings);\n          renderDeclDescPanelUi();\n        });\n\n        label.appendChild(input);\n        label.appendChild(document.createTextNode(type));\n        els.declDescTypes.appendChild(label);\n      }\n    }\n\n    const decls = getDeclsForDescriptionsModal();\n    const types = new Set((state.settings && Array.isArray(state.settings.declFilterTypes))\n      ? state.settings.declFilterTypes\n      : DEFAULT_SETTINGS.declFilterTypes);\n\n    const query = els.declDescSearch ? String(els.declDescSearch.value || \"\").trim().toLowerCase() : \"\";\n    const missingOnly = Boolean(els.declDescMissingOnly && els.declDescMissingOnly.checked);\n\n    const rows = [];\n    let totalRows = 0;\n    let missingRows = 0;\n\n    for (const decl of decls) {\n      if (!decl || typeof decl !== \"object\" || !decl.objectType || !decl.name) {\n        continue;\n      }\n\n      const objectType = String(decl.objectType || \"\").trim().toUpperCase();\n      if (objectType === \"STRUCT_FIELD\") {\n        const structType = String(decl.structObjectType || \"\").trim().toUpperCase();\n        if (structType && !types.has(structType)) {\n          continue;\n        }\n      } else if (!types.has(objectType)) {\n        continue;\n      }\n\n      totalRows += 1;\n\n      const techName = getDeclTechName(decl);\n      const scopeLabel = String(decl.scopeLabel || \"\");\n\n      const isStructField = isStructFieldDecl(decl);\n      if (!isStructField) {\n        const codeDescRaw = String(getDeclCodeDesc(decl) || \"\");\n        const userEntry = getDeclOverrideEntry(decl);\n        const userDescRaw = userEntry.text ? String(userEntry.text) : \"\";\n\n        const codeDesc = settings.normalizeDeclDesc ? normalizeDeclDescText(decl, codeDescRaw) : codeDescRaw;\n        const userDesc = (!settings.normalizeDeclDesc || userEntry.noNormalize)\n          ? userDescRaw\n          : normalizeDeclDescText(decl, userDescRaw);\n\n        const missing = !codeDescRaw.trim() && !userDescRaw.trim();\n        if (missing) {\n          missingRows += 1;\n        }\n        if (missingOnly && !missing) {\n          continue;\n        }\n\n        const haystack = [\n          objectType,\n          scopeLabel,\n          techName,\n          codeDescRaw,\n          userDescRaw,\n          codeDesc,\n          userDesc\n        ]\n          .filter(Boolean)\n          .join(\"\\n\")\n          .toLowerCase();\n\n        if (query && !haystack.includes(query)) {\n          continue;\n        }\n\n        rows.push({\n          decl,\n          objectType,\n          scopeLabel,\n          techName,\n          missing,\n          codeDesc,\n          userDesc\n        });\n        continue;\n      }\n\n      const structDecl = buildStructDeclFromFieldDecl(decl);\n      const structCodeRaw = structDecl ? String(getDeclCodeDesc(structDecl) || \"\") : \"\";\n      const structUserRaw = structDecl ? String(getDeclOverrideDesc(structDecl) || \"\") : \"\";\n      const itemCodeRaw = String(getDeclCodeDesc(decl) || \"\");\n      const itemEntry = getDeclOverrideEntry(decl);\n      const itemUserRaw = itemEntry.text ? String(itemEntry.text) : \"\";\n\n      const structCode = structDecl && settings.normalizeDeclDesc ? normalizeDeclDescText(structDecl, structCodeRaw) : structCodeRaw;\n      const structUser = structDecl && settings.normalizeDeclDesc ? normalizeDeclDescText(structDecl, structUserRaw) : structUserRaw;\n      const itemCode = settings.normalizeDeclDesc ? normalizeDeclDescText(decl, itemCodeRaw) : itemCodeRaw;\n      const itemUser = (!settings.normalizeDeclDesc || itemEntry.noNormalize)\n        ? itemUserRaw\n        : normalizeDeclDescText(decl, itemUserRaw);\n\n      const structMissing = !structCodeRaw.trim() && !structUserRaw.trim();\n      const itemMissing = !itemCodeRaw.trim() && !itemUserRaw.trim();\n      const missing = structMissing || itemMissing;\n      if (missing) {\n        missingRows += 1;\n      }\n      if (missingOnly && !missing) {\n        continue;\n      }\n\n      const haystack = [\n        objectType,\n        scopeLabel,\n        techName,\n        structCodeRaw,\n        structUserRaw,\n        itemCodeRaw,\n        itemUserRaw,\n        structCode,\n        structUser,\n        itemCode,\n        itemUser\n      ]\n        .filter(Boolean)\n        .join(\"\\n\")\n        .toLowerCase();\n\n      if (query && !haystack.includes(query)) {\n        continue;\n      }\n\n      rows.push({\n        decl,\n        objectType,\n        scopeLabel,\n        techName,\n        missing,\n        structMissing,\n        itemMissing,\n        structCode,\n        structUser,\n        itemCode,\n        itemUser\n      });\n    }\n\n    rows.sort((a, b) => {\n      const scopeCmp = String(a.scopeLabel || \"\").localeCompare(String(b.scopeLabel || \"\"));\n      if (scopeCmp) {\n        return scopeCmp;\n      }\n      const typeCmp = String(a.objectType || \"\").localeCompare(String(b.objectType || \"\"));\n      if (typeCmp) {\n        return typeCmp;\n      }\n      return String(a.techName || \"\").localeCompare(String(b.techName || \"\"));\n    });\n\n    if (els.declDescSummary) {\n      const shown = rows.length;\n      els.declDescSummary.textContent = `Showing ${shown} of ${totalRows} decls • Missing: ${missingRows}`;\n    }\n\n    if (!els.declDescTable) {\n      refreshInputGutterTargets();\n      return;\n    }\n\n    if (!state.data || !Array.isArray(state.data.objects)) {\n      els.declDescTable.replaceChildren(el(\"div\", { className: \"muted\", text: \"No data loaded. Click Render first.\" }));\n      refreshInputGutterTargets();\n      return;\n    }\n\n    const table = document.createElement(\"table\");\n    const thead = document.createElement(\"thead\");\n    const headRow = document.createElement(\"tr\");\n    for (const title of [\"type\", \"scope\", \"technical id\", \"code desc\", \"user desc\", \"\"]) {\n      const th = document.createElement(\"th\");\n      th.textContent = title;\n      headRow.appendChild(th);\n    }\n    thead.appendChild(headRow);\n    table.appendChild(thead);\n\n    const tbody = document.createElement(\"tbody\");\n    for (const row of rows) {\n      const tr = document.createElement(\"tr\");\n      const declKey = getDeclOverrideStorageKey(row.decl);\n      if (declKey) {\n        tr.setAttribute(\"data-decl-key\", declKey);\n        if (declKey === state.selectedDeclKey) {\n          tr.classList.add(\"desc-selected\");\n        }\n      }\n      if (row.decl && row.decl.lineStart) {\n        tr.setAttribute(\"data-line-start\", String(row.decl.lineStart));\n      }\n\n      const typeCell = document.createElement(\"td\");\n      typeCell.textContent = row.objectType || \"\";\n      tr.appendChild(typeCell);\n\n      const scopeCell = document.createElement(\"td\");\n      scopeCell.textContent = row.scopeLabel || \"\";\n      tr.appendChild(scopeCell);\n\n      const idCell = document.createElement(\"td\");\n      const idWrap = document.createElement(\"div\");\n      const idLine = document.createElement(\"div\");\n      idLine.textContent = row.techName || \"\";\n      const title = buildDeclTitle(row.decl);\n      if (title) {\n        idLine.title = title;\n      }\n      if (row.decl && row.decl.lineStart) {\n        idLine.style.cursor = \"pointer\";\n        idLine.addEventListener(\"click\", (ev) => {\n          ev.stopPropagation();\n          selectCodeLines(row.decl.lineStart, row.decl.lineStart);\n          if (row.decl.id) {\n            setSelectedCard(row.decl.id);\n          }\n        });\n      }\n      idWrap.appendChild(idLine);\n\n      if (row.objectType === \"STRUCT_FIELD\") {\n        const pills = document.createElement(\"div\");\n        if (row.structMissing) {\n          pills.appendChild(el(\"span\", { className: \"pill\", text: \"struct missing\" }));\n        }\n        if (row.itemMissing) {\n          pills.appendChild(el(\"span\", { className: \"pill\", text: \"item missing\" }));\n        }\n        if (pills.childNodes.length) {\n          idWrap.appendChild(pills);\n        }\n      } else if (row.missing) {\n        idWrap.appendChild(el(\"span\", { className: \"pill\", text: \"missing\" }));\n      }\n\n      idCell.appendChild(idWrap);\n      tr.appendChild(idCell);\n\n      const codeCell = document.createElement(\"td\");\n      if (row.objectType === \"STRUCT_FIELD\") {\n        codeCell.appendChild(renderDeclDescCellLines({ structText: row.structCode || \"\", itemText: row.itemCode || \"\" }));\n      } else {\n        codeCell.textContent = row.codeDesc || \"\";\n      }\n      tr.appendChild(codeCell);\n\n      const userCell = document.createElement(\"td\");\n      if (row.objectType === \"STRUCT_FIELD\") {\n        userCell.appendChild(renderDeclDescCellLines({ structText: row.structUser || \"\", itemText: row.itemUser || \"\" }));\n      } else {\n        userCell.textContent = row.userDesc || \"\";\n      }\n      tr.appendChild(userCell);\n\n      const actionCell = document.createElement(\"td\");\n      const btn = el(\"button\", {\n        className: \"icon-btn\",\n        text: \"✎\",\n        attrs: { type: \"button\", title: \"Edit description\", \"aria-label\": \"Edit description\" }\n      });\n      btn.addEventListener(\"click\", (ev) => {\n        ev.stopPropagation();\n        editDeclDesc(row.decl);\n      });\n      actionCell.appendChild(btn);\n      tr.appendChild(actionCell);\n\n      tbody.appendChild(tr);\n    }\n    table.appendChild(tbody);\n\n    els.declDescTable.replaceChildren(table);\n    refreshInputGutterTargets();\n  }\n\n  function setRightTab(nextTab) {\n    const tab = nextTab === \"descriptions\"\n      ? \"descriptions\"\n      : (nextTab === \"template\" ? \"template\" : \"output\");\n    state.rightTab = tab;\n\n    const showDescriptions = tab === \"descriptions\";\n    const showTemplate = tab === \"template\";\n    const showOutput = tab === \"output\";\n    if (els.output) {\n      els.output.hidden = !showOutput;\n    }\n    if (els.templatePreviewPanel) {\n      els.templatePreviewPanel.hidden = !showTemplate;\n    }\n    if (els.declDescPanel) {\n      els.declDescPanel.hidden = !showDescriptions;\n    }\n\n    if (els.rightPanelTitle) {\n      els.rightPanelTitle.textContent = showDescriptions\n        ? \"Descriptions\"\n        : (showTemplate ? \"Template Preview\" : \"Output\");\n    }\n\n    if (els.rightTabOutputBtn) {\n      els.rightTabOutputBtn.classList.toggle(\"active\", showOutput);\n      els.rightTabOutputBtn.setAttribute(\"aria-selected\", String(showOutput));\n    }\n    if (els.rightTabTemplateBtn) {\n      els.rightTabTemplateBtn.classList.toggle(\"active\", showTemplate);\n      els.rightTabTemplateBtn.setAttribute(\"aria-selected\", String(showTemplate));\n    }\n    if (els.rightTabDescBtn) {\n      els.rightTabDescBtn.classList.toggle(\"active\", showDescriptions);\n      els.rightTabDescBtn.setAttribute(\"aria-selected\", String(showDescriptions));\n    }\n    if (els.declDescJsonBtn) {\n      els.declDescJsonBtn.hidden = !showDescriptions;\n    }\n\n    if (showDescriptions) {\n      renderDeclDescPanelUi();\n      setTimeout(() => {\n        if (els.declDescSearch) {\n          els.declDescSearch.focus();\n        }\n      }, 0);\n    } else if (showTemplate) {\n      renderTemplatePreview();\n    }\n\n    refreshInputGutterTargets();\n  }\n\n  function applySettingsFromModal() {\n    if (!els.settingsModal) {\n      return;\n    }\n\n    const next = {\n      normalizeDeclDesc: Boolean(els.settingsNormalizeDesc && els.settingsNormalizeDesc.checked),\n      declFilterTypes: [],\n      structDescTemplate: (els.settingsStructTemplate && els.settingsStructTemplate.value)\n        ? String(els.settingsStructTemplate.value || \"\")\n        : DEFAULT_SETTINGS.structDescTemplate,\n      nameTemplatesByCode: {}\n    };\n\n    if (els.settingsDeclTypes) {\n      const inputs = els.settingsDeclTypes.querySelectorAll(\"input[type=checkbox]\");\n      for (const input of Array.from(inputs)) {\n        if (input.checked) {\n          next.declFilterTypes.push(String(input.value || \"\").trim().toUpperCase());\n        }\n      }\n    }\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/descriptions/02-overrides-and-edit.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/02-descriptions.js";
  const partKey = "viewer/app/descriptions/02-overrides-and-edit.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    const nameInputs = els.settingsNameTemplates\n      ? els.settingsNameTemplates.querySelectorAll(\"input[data-code]\")\n      : [];\n\n    for (const input of Array.from(nameInputs)) {\n      const code = String(input.getAttribute(\"data-code\") || \"\").trim().toUpperCase();\n      if (!code) {\n        continue;\n      }\n      next.nameTemplatesByCode[code] = String(input.value || \"\");\n    }\n\n    state.settings = normalizeSettings(next);\n    saveSettings(state.settings);\n    state.haystackById = buildSearchIndex(state.renderObjects);\n    renderOutput();\n  }\n\n  function resetSettingsToDefault() {\n    state.settings = normalizeSettings(DEFAULT_SETTINGS);\n    saveSettings(state.settings);\n    renderSettingsModalUi();\n    state.haystackById = buildSearchIndex(state.renderObjects);\n    renderOutput();\n  }\n\n  function normalizeKeyToken(value) {\n    return String(value || \"\").trim().toUpperCase();\n  }\n\n  function getDeclFallbackKey(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const name = normalizeKeyToken(decl.name);\n    if (!name) {\n      return \"\";\n    }\n\n    const objectType = normalizeKeyToken(decl.objectType);\n    const file = String(decl.file || \"\").trim();\n    const line = decl.lineStart ? String(decl.lineStart) : \"\";\n    return `FALLBACK:${objectType}|${name}|${file}|${line}`;\n  }\n\n  function getDeclKey(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const scope = normalizeKeyToken(decl.scopeLabel);\n    const name = normalizeKeyToken(decl.name);\n\n    if (!scope || !name) {\n      return \"\";\n    }\n\n    return `${scope}:${name}`;\n  }\n\n  function getLegacyDeclKey(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const type = normalizeKeyToken(decl.objectType);\n    const name = normalizeKeyToken(decl.name);\n\n    if (!type || !name) {\n      return \"\";\n    }\n\n    return `${type}:NAME:${name}`;\n  }\n\n  function getDeclOverrideLookupKeys(decl) {\n    const keys = [];\n    const pushKey = (value) => {\n      const key = String(value || \"\").trim();\n      if (!key || keys.includes(key)) {\n        return;\n      }\n      keys.push(key);\n    };\n\n    pushKey(getDeclKey(decl));\n    pushKey(getLegacyDeclKey(decl));\n    pushKey(getDeclFallbackKey(decl));\n    return keys;\n  }\n\n  function getDeclOverrideStorageKey(decl) {\n    const keys = getDeclOverrideLookupKeys(decl);\n    return keys.length ? keys[0] : \"\";\n  }\n\n  function normalizeDescOverrideEntry(value) {\n    if (typeof value === \"string\") {\n      return { text: String(value || \"\"), noNormalize: false };\n    }\n    if (!value || typeof value !== \"object\" || Array.isArray(value)) {\n      return { text: \"\", noNormalize: false };\n    }\n\n    const text = typeof value.text === \"string\"\n      ? value.text\n      : typeof value.desc === \"string\"\n        ? value.desc\n        : typeof value.value === \"string\"\n          ? value.value\n          : \"\";\n\n    const noNormalize = Boolean(value.noNormalize || value.skipNormalize || value.disableNormalize || value.no_normalize);\n    return { text: String(text || \"\"), noNormalize };\n  }\n\n  function getDeclOverrideEntry(decl) {\n    const keys = getDeclOverrideLookupKeys(decl);\n    for (const key of keys) {\n      if (key && Object.prototype.hasOwnProperty.call(state.descOverrides || {}, key)) {\n        return normalizeDescOverrideEntry(state.descOverrides[key]);\n      }\n    }\n\n    const legacyKey = getLegacyDeclKey(decl);\n    if (legacyKey && Object.prototype.hasOwnProperty.call(state.descOverridesLegacy || {}, legacyKey)) {\n      return { text: String(state.descOverridesLegacy[legacyKey] || \"\"), noNormalize: false };\n    }\n\n    return { text: \"\", noNormalize: false };\n  }\n\n  function getDeclOverrideDesc(decl) {\n    return getDeclOverrideEntry(decl).text;\n  }\n\n  function getDeclOverrideNoNormalize(decl) {\n    return Boolean(getDeclOverrideEntry(decl).noNormalize);\n  }\n\n  function getBaseDeclDesc(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const objectType = normalizeKeyToken(decl.objectType);\n    const scopeType = normalizeKeyToken(decl.scopeType);\n    if (objectType === \"PATH_DECL\" || scopeType === \"PATH\") {\n      return \"\";\n    }\n\n    const registry = window.AbapVarDescriptions && typeof window.AbapVarDescriptions === \"object\"\n      ? window.AbapVarDescriptions\n      : null;\n    if (!registry) {\n      return \"\";\n    }\n\n    const nameUpper = normalizeKeyToken(decl.name);\n    if (!nameUpper) {\n      return \"\";\n    }\n\n    const scopeLabel = normalizeKeyToken(decl.scopeLabel);\n\n    if (objectType === \"SYSTEM\" || scopeLabel === \"SYSTEM\") {\n      const systemMap = registry.system && typeof registry.system === \"object\" ? registry.system : null;\n      if (systemMap && Object.prototype.hasOwnProperty.call(systemMap, nameUpper)) {\n        return String(systemMap[nameUpper] || \"\");\n      }\n    }\n\n    const byScope = registry.customByScope && typeof registry.customByScope === \"object\" ? registry.customByScope : null;\n    if (byScope && scopeLabel && Object.prototype.hasOwnProperty.call(byScope, scopeLabel)) {\n      const scopeMap = byScope[scopeLabel];\n      if (scopeMap && typeof scopeMap === \"object\" && Object.prototype.hasOwnProperty.call(scopeMap, nameUpper)) {\n        return String(scopeMap[nameUpper] || \"\");\n      }\n    }\n\n    const globalMap = registry.customGlobal && typeof registry.customGlobal === \"object\" ? registry.customGlobal : null;\n    if (globalMap && Object.prototype.hasOwnProperty.call(globalMap, nameUpper)) {\n      return String(globalMap[nameUpper] || \"\");\n    }\n\n    return \"\";\n  }\n\n  function getSourceDeclDesc(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n    return decl.comment ? String(decl.comment) : \"\";\n  }\n\n  function normalizeDeclDescText(decl, text) {\n    const settings = state.settings || DEFAULT_SETTINGS;\n    if (!settings.normalizeDeclDesc) {\n      return String(text || \"\").trim();\n    }\n    return normalizeDeclDescByTemplate(decl, text);\n  }\n\n  function stripDeclTemplateAffixes(text, template) {\n    const raw = String(text || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const tpl = String(template || \"\");\n    const marker = \"{{desc}}\";\n    const markerIndex = tpl.indexOf(marker);\n    if (markerIndex === -1) {\n      return raw;\n    }\n\n    const prefix = tpl.slice(0, markerIndex).trim();\n    const suffix = tpl.slice(markerIndex + marker.length).trim();\n\n    let next = raw;\n    if (prefix && next.toLowerCase().startsWith(prefix.toLowerCase())) {\n      next = next.slice(prefix.length).trim();\n    }\n    if (\n      suffix &&\n      next.length >= suffix.length &&\n      next.toLowerCase().endsWith(suffix.toLowerCase())\n    ) {\n      next = next.slice(0, next.length - suffix.length).trim();\n    }\n\n    return next || raw;\n  }\n\n  function normalizeDeclDescByTemplate(decl, text) {\n    const descTrimmed = String(text || \"\").trim();\n    if (!descTrimmed) {\n      return \"\";\n    }\n\n    const techName = getDeclTechName(decl);\n    const bare = stripAngleBrackets(techName);\n    if (bare.length < 3) {\n      return descTrimmed;\n    }\n\n    const code = bare.slice(1, 3).toUpperCase();\n    const settings = state.settings || DEFAULT_SETTINGS;\n    const templates = settings.nameTemplatesByCode || DEFAULT_SETTINGS.nameTemplatesByCode;\n    const template = templates && Object.prototype.hasOwnProperty.call(templates, code) ? String(templates[code] || \"\") : \"\";\n    if (!template.trim()) {\n      return descTrimmed;\n    }\n\n    const strippedKnownPrefix = stripDeclCategoryPrefix(descTrimmed);\n    const normalizedDesc = stripDeclTemplateAffixes(strippedKnownPrefix, template);\n    const normalized = template.replace(/\\{\\{desc\\}\\}/g, normalizedDesc).trim();\n    return normalized || descTrimmed;\n  }\n\n  function getEffectiveDeclAtomicDesc(decl) {\n    const override = getDeclOverrideDesc(decl);\n    if (override) {\n      return override;\n    }\n\n    const source = getSourceDeclDesc(decl);\n    if (source) {\n      return source;\n    }\n\n    return getBaseDeclDesc(decl);\n  }\n\n  function getEffectiveDeclAtomicDescNormalized(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const settings = state.settings || DEFAULT_SETTINGS;\n    const normalizeEnabled = Boolean(settings.normalizeDeclDesc);\n\n    const overrideEntry = getDeclOverrideEntry(decl);\n    const overrideText = overrideEntry.text ? String(overrideEntry.text) : \"\";\n    if (overrideText) {\n      if (!normalizeEnabled || overrideEntry.noNormalize) {\n        return overrideText;\n      }\n      return normalizeDeclDescText(decl, overrideText);\n    }\n\n    const source = getSourceDeclDesc(decl);\n    if (source) {\n      return normalizeEnabled ? normalizeDeclDescText(decl, source) : source;\n    }\n\n    const base = getBaseDeclDesc(decl);\n    if (base) {\n      return normalizeEnabled ? normalizeDeclDescText(decl, base) : base;\n    }\n\n    return String(getDeclTechName(decl) || \"\").trim();\n  }\n\n  function getFinalDeclAtomicDescNormalized(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const overrideEntry = getDeclOverrideEntry(decl);\n    const overrideText = overrideEntry.text ? String(overrideEntry.text) : \"\";\n    if (overrideText) {\n      return normalizeDeclDescByTemplate(decl, overrideText);\n    }\n\n    const codeDesc = getDeclCodeDesc(decl);\n    if (codeDesc) {\n      return normalizeDeclDescByTemplate(decl, codeDesc);\n    }\n\n    const techId = String(getDeclTechName(decl) || \"\").trim();\n    if (!techId) {\n      return \"\";\n    }\n\n    return normalizeDeclDescByTemplate(decl, techId);\n  }\n\n  function buildStructDeclFromFieldDecl(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return null;\n    }\n\n    if (!decl.scopeLabel || !decl.structName) {\n      return null;\n    }\n\n    return {\n      id: decl.structId || null,\n      objectType: decl.structObjectType || decl.objectType || \"STRUCT\",\n      name: String(decl.structName || \"\"),\n      file: decl.file || \"\",\n      lineStart: decl.structLineStart || null,\n      raw: decl.structRaw || \"\",\n      comment: decl.structComment || decl.structTypeComment || \"\",\n      scopeId: decl.scopeId || 0,\n      scopeLabel: decl.scopeLabel || \"\",\n      scopeType: decl.scopeType || \"\",\n      scopeName: decl.scopeName || \"\"\n    };\n  }\n\n  function stripStructNamePrefixFromItemText(itemText, structName) {\n    const raw = String(itemText || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const struct = String(structName || \"\").trim();\n    if (!struct) {\n      return raw;\n    }\n\n    const prefix = `${struct.toUpperCase()}-`;\n    if (raw.toUpperCase().startsWith(prefix)) {\n      return raw.slice(struct.length + 1).trim();\n    }\n\n    return raw;\n  }\n\n  function hasStructCompositeMeta(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return false;\n    }\n    const structName = String(decl.structName || \"\").trim();\n    const fieldPath = String(decl.fieldPath || \"\").trim();\n    return Boolean(structName && fieldPath);\n  }\n\n  function stripDeclCategoryPrefixDeep(text) {\n    let current = String(text || \"\").trim();\n    while (current) {\n      const next = stripDeclCategoryPrefix(current);\n      if (!next || next === current) {\n        break;\n      }\n      current = next;\n    }\n    return current;\n  }\n\n  function sanitizeStructCompositeText(text, decl) {\n    const raw = String(text || \"\").replace(/\\u00A0/g, \" \").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const parts = raw.split(\"-\");\n    if (parts.length < 2) {\n      return stripDeclCategoryPrefixDeep(raw);\n    }\n\n    const structPart = stripDeclCategoryPrefixDeep(parts.shift());\n    let itemPart = stripDeclCategoryPrefixDeep(parts.join(\"-\"));\n    itemPart = stripStructNamePrefixFromItemText(itemPart, String(decl && decl.structName ? decl.structName : \"\").trim());\n\n    if (!structPart) {\n      return itemPart;\n    }\n    if (!itemPart) {\n      return structPart;\n    }\n    return `${structPart}-${itemPart}`;\n  }\n\n  function getDeclTechNameSafe(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n    return String(getDeclTechName(decl) || decl.name || \"\").trim();\n  }\n\n  function isTechnicalFallbackDesc(decl, text) {\n    const candidate = String(text || \"\").trim();\n    if (!candidate) {\n      return false;\n    }\n    const tech = getDeclTechNameSafe(decl);\n    if (!tech) {\n      return false;\n    }\n    return candidate.toUpperCase() === tech.toUpperCase();\n  }\n\n  function formatStructFieldDesc(decl) {\n    if (!isStructFieldDecl(decl)) {\n      return getEffectiveDeclAtomicDesc(decl);\n    }\n\n    const settings = state.settings || DEFAULT_SETTINGS;\n    const template = settings.structDescTemplate || DEFAULT_SETTINGS.structDescTemplate;\n\n    const structTech = String(decl.structName || \"\").trim() || getDeclTechName(decl);\n    const itemTech = String(decl.fieldPath || \"\").trim() || (() => {\n      const tech = getDeclTechName(decl);\n      const structPrefix = String(decl.structName || \"\").trim();\n      if (structPrefix && tech.toUpperCase().startsWith(`${structPrefix.toUpperCase()}-`)) {\n        return tech.slice(structPrefix.length + 1);\n      }\n      return tech;\n    })();\n\n    const structDecl = buildStructDeclFromFieldDecl(decl);\n    const structDescRaw = structDecl ? getEffectiveDeclAtomicDescNormalized(structDecl) : \"\";\n    const itemDescRaw = getEffectiveDeclAtomicDescNormalized(decl);\n\n    const structText = stripDeclCategoryPrefix(String(structDescRaw || \"\").trim()) || structTech;\n    const itemTextRaw = stripDeclCategoryPrefix(String(itemDescRaw || \"\").trim()) || itemTech;\n    const itemText = stripStructNamePrefixFromItemText(itemTextRaw, String(decl.structName || \"\").trim() || structTech);\n\n    return String(template || DEFAULT_SETTINGS.structDescTemplate)\n      .replace(/\\{\\{struct\\}\\}/g, structText)\n      .replace(/\\{\\{item\\}\\}/g, itemText);\n  }\n\n  function getEffectiveDeclDesc(decl) {\n    if (!isStructFieldDecl(decl)) {\n      return getEffectiveDeclAtomicDescNormalized(decl);\n    }\n\n    const composed = sanitizeStructCompositeText(formatStructFieldDesc(decl), decl);\n    if (!hasStructCompositeMeta(decl)) {\n      const normalized = normalizeDeclDescByTemplate(decl, composed);\n      return normalized || composed;\n    }\n    return composed;\n  }\n\n  function formatStructFieldFinalDesc(decl) {\n    if (!isStructFieldDecl(decl)) {\n      return getFinalDeclAtomicDescNormalized(decl);\n    }\n\n    const structDecl = buildStructDeclFromFieldDecl(decl);\n    const structTextRaw = structDecl ? String(getFinalDeclAtomicDescNormalized(structDecl) || \"\").trim() : \"\";\n    const itemTextRaw = String(getFinalDeclAtomicDescNormalized(decl) || \"\").trim();\n    const structText = stripDeclCategoryPrefix(structTextRaw);\n    const itemTextNormalized = stripDeclCategoryPrefix(itemTextRaw);\n    const itemText = stripStructNamePrefixFromItemText(itemTextNormalized, String(decl.structName || \"\").trim());\n\n    if (!structText && !itemText) {\n      return \"\";\n    }\n    if (!structText) {\n      return itemText;\n    }\n    if (!itemText) {\n      return structText;\n    }\n\n    const settings = state.settings || DEFAULT_SETTINGS;\n    const template = settings.structDescTemplate || DEFAULT_SETTINGS.structDescTemplate;\n    return String(template || DEFAULT_SETTINGS.structDescTemplate)\n      .replace(/\\{\\{struct\\}\\}/g, structText)\n      .replace(/\\{\\{item\\}\\}/g, itemText);\n  }\n\n  function getFinalDeclDesc(decl) {\n    if (!isStructFieldDecl(decl)) {\n      return getFinalDeclAtomicDescNormalized(decl);\n    }\n\n    const composed = sanitizeStructCompositeText(formatStructFieldFinalDesc(decl), decl);\n    if (!composed) {\n      return \"\";\n    }\n\n    if (isTechnicalFallbackDesc(decl, composed)) {\n      return composed;\n    }\n\n    const normalized = normalizeDeclDescByTemplate(decl, composed);\n    return normalized || composed;\n  }\n\n  function openEditModal({ mode, key, structKey, itemKey, label, hint, initialValue, structValue, itemValue, skipNormalize }) {\n    const editMode = mode === \"structField\" ? \"structField\" : \"single\";\n\n    if (editMode === \"single\" && !key) {\n      return;\n    }\n\n    if (editMode === \"structField\" && (!structKey || !itemKey)) {\n      return;\n    }\n\n    if (!els.jsonModal.hidden) {\n      closeJsonModal();\n    }\n\n    state.activeEdit = editMode === \"structField\"\n      ? { mode: \"structField\", structKey, itemKey }\n      : { mode: \"single\", key };\n    els.editLabel.textContent = label ? String(label) : \"\";\n\n    const hintText = hint ? String(hint) : \"\";\n    els.editHint.textContent = hintText;\n    els.editHint.style.display = hintText ? \"block\" : \"none\";\n\n    if (els.editSingleWrap) {\n      els.editSingleWrap.hidden = editMode !== \"single\";\n    }\n    if (els.editStructWrap) {\n      els.editStructWrap.hidden = editMode !== \"structField\";\n    }\n\n    els.editDesc.value = \"\";\n    if (els.editStructDesc) {\n      els.editStructDesc.value = \"\";\n    }\n    if (els.editItemDesc) {\n      els.editItemDesc.value = \"\";\n    }\n    if (els.editSkipNormalize) {\n      els.editSkipNormalize.checked = Boolean(skipNormalize);\n    }\n\n    if (editMode === \"single\") {\n      els.editDesc.value = initialValue ? String(initialValue) : \"\";\n    } else {\n      if (els.editStructDesc) {\n        els.editStructDesc.value = structValue ? String(structValue) : \"\";\n      }\n      if (els.editItemDesc) {\n        els.editItemDesc.value = itemValue ? String(itemValue) : \"\";\n      }\n    }\n\n    els.editModal.hidden = false;\n    setTimeout(() => {\n      const target = editMode === \"structField\" && els.editStructDesc ? els.editStructDesc : els.editDesc;\n      target.focus();\n    }, 0);\n  }\n\n  function closeEditModal() {\n    els.editModal.hidden = true;\n    els.editDesc.value = \"\";\n    if (els.editStructDesc) {\n      els.editStructDesc.value = \"\";\n    }\n    if (els.editItemDesc) {\n      els.editItemDesc.value = \"\";\n    }\n    if (els.editSkipNormalize) {\n      els.editSkipNormalize.checked = false;\n    }\n    state.activeEdit = null;\n  }\n\n  function applyEditModal(action) {\n    if (!state.activeEdit) {\n      return;\n    }\n\n    const mode = state.activeEdit.mode === \"structField\" ? \"structField\" : \"single\";\n    const skipNormalize = Boolean(els.editSkipNormalize && els.editSkipNormalize.checked);\n\n    if (mode === \"single\") {\n      const key = state.activeEdit.key;\n      if (!key) {\n        return;\n      }\n\n      const value = action === \"clear\" ? \"\" : String(els.editDesc.value || \"\");\n      const trimmed = value.trim();\n      const stored = skipNormalize ? trimmed : stripDeclCategoryPrefix(trimmed);\n\n      if (!stored) {\n        delete state.descOverrides[key];\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/descriptions/03-value-finaldesc.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/02-descriptions.js";
  const partKey = "viewer/app/descriptions/03-value-finaldesc.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "      } else {\n        state.descOverrides[key] = skipNormalize ? { text: stored, noNormalize: true } : stored;\n      }\n    } else {\n      const structKey = state.activeEdit.structKey;\n      const itemKey = state.activeEdit.itemKey;\n      if (!structKey || !itemKey) {\n        return;\n      }\n\n      const structValue = action === \"clear\" ? \"\" : String((els.editStructDesc && els.editStructDesc.value) || \"\");\n      const itemValue = action === \"clear\" ? \"\" : String((els.editItemDesc && els.editItemDesc.value) || \"\");\n      const structTrimmed = structValue.trim();\n      const itemTrimmed = itemValue.trim();\n      const structStored = stripDeclCategoryPrefix(structTrimmed);\n      const itemStored = skipNormalize ? itemTrimmed : stripDeclCategoryPrefix(itemTrimmed);\n\n      if (!structStored) {\n        delete state.descOverrides[structKey];\n      } else {\n        state.descOverrides[structKey] = structStored;\n      }\n\n      if (!itemStored) {\n        delete state.descOverrides[itemKey];\n      } else {\n        state.descOverrides[itemKey] = skipNormalize ? { text: itemStored, noNormalize: true } : itemStored;\n      }\n    }\n\n    saveDescOverrides();\n    state.haystackById = buildSearchIndex(state.renderObjects);\n    renderOutput();\n    if (state.rightTab === \"descriptions\") {\n      renderDeclDescPanelUi();\n    }\n  }\n\n  function editDeclDesc(decl) {\n    if (!decl || !decl.name) {\n      return;\n    }\n\n    const isStructField = isStructFieldDecl(decl);\n\n    const key = getDeclOverrideStorageKey(decl);\n    if (!key) {\n      return;\n    }\n\n    const settings = state.settings || DEFAULT_SETTINGS;\n    const normalizeEnabled = Boolean(settings.normalizeDeclDesc);\n\n    const currentEntry = getDeclOverrideEntry(decl);\n    const current = currentEntry.text ? String(currentEntry.text) : \"\";\n    const effective = getEffectiveDeclDesc(decl);\n    const currentDisplay = current\n      ? (normalizeEnabled && !currentEntry.noNormalize ? normalizeDeclDescText(decl, current) : current)\n      : \"\";\n    const hintParts = [];\n    hintParts.push(`Key: ${key}`);\n    if (decl.scopeLabel) {\n      hintParts.push(`Scope: ${decl.scopeLabel}`);\n    }\n    if (decl.objectType) {\n      hintParts.push(`Type: ${decl.objectType}`);\n    }\n    if (decl.lineStart) {\n      hintParts.push(`Line: ${decl.lineStart}`);\n    }\n    const base = getBaseDeclDesc(decl);\n    const source = getSourceDeclDesc(decl);\n    if (base) {\n      hintParts.push(`Registry: ${base}`);\n    }\n    if (source) {\n      hintParts.push(`Comment: ${source}`);\n    }\n    if (decl.raw) {\n      hintParts.push(decl.raw);\n    }\n\n    if (!isStructField) {\n      openEditModal({\n        mode: \"single\",\n        key,\n        label: `${decl.objectType || \"DECL\"} ${getDeclTechName(decl)}`,\n        hint: hintParts.join(\" • \"),\n        initialValue: currentDisplay || effective,\n        skipNormalize: Boolean(currentEntry.noNormalize)\n      });\n      return;\n    }\n\n    const structDecl = buildStructDeclFromFieldDecl(decl);\n    const structKey = structDecl ? getDeclOverrideStorageKey(structDecl) : \"\";\n    if (!structKey) {\n      return;\n    }\n\n    const structCurrentEntry = structDecl ? getDeclOverrideEntry(structDecl) : { text: \"\", noNormalize: false };\n    const structCurrent = structCurrentEntry.text ? String(structCurrentEntry.text) : \"\";\n    const structEffective = structDecl ? getEffectiveDeclDesc(structDecl) : \"\";\n    const structCurrentDisplay = structDecl && structCurrent && normalizeEnabled\n      ? normalizeDeclDescText(structDecl, structCurrent)\n      : structCurrent;\n\n    hintParts.push(`StructKey: ${structKey}`);\n    hintParts.push(`ItemKey: ${key}`);\n\n    openEditModal({\n      mode: \"structField\",\n      structKey,\n      itemKey: key,\n      label: `${decl.objectType || \"DECL\"} ${getDeclTechName(decl)}`,\n      hint: hintParts.join(\" • \"),\n      structValue: structCurrentDisplay || structEffective,\n      itemValue: currentDisplay || getEffectiveDeclAtomicDescNormalized(decl),\n      skipNormalize: Boolean(currentEntry.noNormalize)\n    });\n  }\n\n  function escapeSelectorValue(value) {\n    const text = String(value || \"\");\n    if (window.CSS && typeof window.CSS.escape === \"function\") {\n      return window.CSS.escape(text);\n    }\n    return text.replace(/\"/g, '\\\\\"');\n  }\n\n  function safeJson(value, pretty) {\n    try {\n      return JSON.stringify(value, null, pretty ? 2 : 0);\n    } catch {\n      return \"\";\n    }\n  }\n\n  function sanitizeXmlText(value) {\n    const text = String(value ?? \"\");\n    // Keep: TAB (0x9), LF (0xA), CR (0xD)\n    return text.replace(/[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F\\u007F]/g, \"\");\n  }\n\n  function escapeXmlText(value) {\n    return sanitizeXmlText(value)\n      .replace(/&/g, \"&amp;\")\n      .replace(/</g, \"&lt;\")\n      .replace(/>/g, \"&gt;\")\n      .replace(/\"/g, \"&quot;\")\n      .replace(/'/g, \"&apos;\");\n  }\n\n  function toXmlTagName(key) {\n    const raw = String(key || \"\").trim();\n    if (!raw) {\n      return \"value\";\n    }\n\n    const normalized = raw.replace(/[^A-Za-z0-9_:-]/g, \"_\");\n    if (!/^[A-Za-z_]/.test(normalized)) {\n      return `_${normalized}`;\n    }\n    return normalized;\n  }\n\n  function getArrayItemTagName(keyHint) {\n    const key = String(keyHint || \"\").trim().toLowerCase();\n    if (key === \"objects\" || key === \"children\") {\n      return \"object\";\n    }\n    return \"item\";\n  }\n\n  function isPlainObjectRecord(value) {\n    return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n  }\n\n  function isAbapStatementObject(value) {\n    if (!isPlainObjectRecord(value)) {\n      return false;\n    }\n    const hasNodeShape = Object.prototype.hasOwnProperty.call(value, \"values\")\n      || Object.prototype.hasOwnProperty.call(value, \"extras\")\n      || Object.prototype.hasOwnProperty.call(value, \"children\");\n    if (!hasNodeShape) {\n      return false;\n    }\n    return (\n      Object.prototype.hasOwnProperty.call(value, \"objectType\")\n      && Object.prototype.hasOwnProperty.call(value, \"raw\")\n      && Object.prototype.hasOwnProperty.call(value, \"lineStart\")\n    );\n  }\n\n  function extractIdentifierCandidate(text) {\n    const raw = String(text || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n    if (raw.startsWith(\"'\") || raw.startsWith(\"|\")) {\n      return \"\";\n    }\n    if (/^[+-]?\\d/.test(raw)) {\n      return \"\";\n    }\n\n    const sysMatch = raw.match(/^SY-[A-Za-z_][A-Za-z0-9_]*/i);\n    if (sysMatch) {\n      return sysMatch[0].toUpperCase();\n    }\n\n    const fieldPathMatch = raw.match(\n      /^(<[^>]+>|[A-Za-z_][A-Za-z0-9_]*)(?:(?:->|=>|~|-)[A-Za-z_][A-Za-z0-9_]*)+/\n    );\n    if (fieldPathMatch) {\n      return String(fieldPathMatch[0] || \"\").trim();\n    }\n\n    const inlinePatterns = [\n      /@?DATA\\s*\\(\\s*([^)]+)\\s*\\)/i,\n      /@?FINAL\\s*\\(\\s*([^)]+)\\s*\\)/i,\n      /FIELD-SYMBOL\\s*\\(\\s*(<[^>]+>)\\s*\\)/i\n    ];\n    for (const regex of inlinePatterns) {\n      const match = regex.exec(raw);\n      if (!match || !match[1]) {\n        continue;\n      }\n      const candidate = String(match[1] || \"\").trim();\n      if (candidate) {\n        return candidate;\n      }\n    }\n\n    const genericMatch = raw.match(\n      /<[^>]+>|[A-Za-z_][A-Za-z0-9_]*(?:(?:->|=>|~|-)[A-Za-z_][A-Za-z0-9_]*)*/\n    );\n    return genericMatch ? String(genericMatch[0] || \"\").trim() : \"\";\n  }\n\n  function resolveFallbackFieldId(entry) {\n    if (!isPlainObjectRecord(entry)) {\n      return \"\";\n    }\n\n    const fromDeclRef = String(entry.declRef || \"\").trim();\n    if (fromDeclRef) {\n      return fromDeclRef;\n    }\n\n    const valueText = String(entry.value || \"\").trim();\n    const identifier = extractIdentifierCandidate(valueText);\n    if (identifier) {\n      return identifier;\n    }\n\n    if (valueText) {\n      return valueText;\n    }\n\n    const fromName = String(entry.name || \"\").trim();\n    if (fromName) {\n      return fromName;\n    }\n\n    return \"\";\n  }\n\n  function buildPathKeyFromParts(parts) {\n    const tokens = Array.isArray(parts) ? parts : [];\n    const cleaned = [];\n    for (const part of tokens) {\n      const token = String(part || \"\").trim();\n      if (token) {\n        cleaned.push(token);\n      }\n    }\n    return cleaned.join(\"/\");\n  }\n\n  function normalizeSyntheticPathKey(pathKey) {\n    const text = String(pathKey || \"\").trim();\n    if (!text) {\n      return \"ROOT\";\n    }\n    const normalized = text\n      .replace(/\\s+/g, \"_\")\n      .replace(/[^A-Za-z0-9_:\\-./[\\]#]/g, \"_\")\n      .toUpperCase();\n    return normalized || \"ROOT\";\n  }\n\n  function buildSyntheticDeclForPath({ pathKey, fieldId, file, lineStart, raw, role }) {\n    const name = String(fieldId || \"\").trim();\n    if (!name) {\n      return null;\n    }\n\n    const numericLine = lineStart === null || lineStart === undefined || lineStart === \"\"\n      ? null\n      : (Number(lineStart) || null);\n\n    const normalizedPath = normalizeSyntheticPathKey(pathKey);\n    return {\n      id: null,\n      objectType: \"PATH_DECL\",\n      name,\n      file: String(file || \"\"),\n      lineStart: numericLine,\n      raw: String(raw || \"\"),\n      comment: \"\",\n      scopeId: 0,\n      scopeLabel: `PATH:${normalizedPath}`,\n      scopeType: \"PATH\",\n      scopeName: String(role || \"\")\n    };\n  }\n\n  function getDeclSourceContextFromObject(obj) {\n    if (!isPlainObjectRecord(obj)) {\n      return { file: \"\", lineStart: null, raw: \"\" };\n    }\n    return {\n      file: String(obj.file || \"\"),\n      lineStart: obj.lineStart === null || obj.lineStart === undefined\n        ? null\n        : (Number(obj.lineStart) || null),\n      raw: String(obj.raw || \"\")\n    };\n  }\n\n  function buildObjectPathBase(obj) {\n    const id = normalizeId(obj && obj.id);\n    if (id) {\n      return `OBJECT:${id}`;\n    }\n    const type = String(obj && obj.objectType ? obj.objectType : \"OBJECT\").trim() || \"OBJECT\";\n    const file = String(obj && obj.file ? obj.file : \"\").trim() || \"NO_FILE\";\n    const line = obj && obj.lineStart ? String(obj.lineStart) : \"0\";\n    return `OBJECT:${type}:${file}:${line}`;\n  }\n\n  function hasAnyDecls(list) {\n    if (!Array.isArray(list)) {\n      return false;\n    }\n    return list.some((item) => item && typeof item === \"object\");\n  }\n\n  function ensureEntryDeclWithSynthetic(entry, options) {\n    if (!isPlainObjectRecord(entry)) {\n      return entry;\n    }\n    if (isDeclLikeObject(entry.decl)) {\n      return entry;\n    }\n\n    const fieldId = resolveFallbackFieldId(entry);\n    const pathKey = buildPathKeyFromParts([options && options.pathKey ? options.pathKey : \"\", \"decl\"]);\n    const syntheticDecl = buildSyntheticDeclForPath({\n      pathKey,\n      fieldId,\n      file: options && options.file ? options.file : \"\",\n      lineStart: options ? options.lineStart : null,\n      raw: options && options.raw ? options.raw : \"\",\n      role: options && options.role ? options.role : \"value\"\n    });\n    if (!syntheticDecl) {\n      return entry;\n    }\n\n    const next = { ...entry, decl: syntheticDecl };\n    if (!String(next.declRef || \"\").trim()) {\n      next.declRef = fieldId;\n    }\n    return next;\n  }\n\n  function ensureValueDeclWithSynthetic(entry, options) {\n    if (!isPlainObjectRecord(entry)) {\n      return entry;\n    }\n    if (isDeclLikeObject(entry.valueDecl) || hasAnyDecls(entry.originDecls)) {\n      return entry;\n    }\n\n    const sourceForId = {\n      declRef: String(entry.valueRef || entry.declRef || \"\").trim(),\n      value: entry.value,\n      name: entry.name || (options && options.nameHint ? options.nameHint : \"\")\n    };\n    const fieldId = resolveFallbackFieldId(sourceForId);\n    const pathKey = buildPathKeyFromParts([options && options.pathKey ? options.pathKey : \"\", \"valueDecl\"]);\n    const syntheticDecl = buildSyntheticDeclForPath({\n      pathKey,\n      fieldId,\n      file: options && options.file ? options.file : \"\",\n      lineStart: options ? options.lineStart : null,\n      raw: options && options.raw ? options.raw : \"\",\n      role: options && options.role ? options.role : \"value\"\n    });\n    if (!syntheticDecl) {\n      return entry;\n    }\n\n    return {\n      ...entry,\n      valueDecl: syntheticDecl\n    };\n  }\n\n  function ensureConditionClauseDeclsWithSynthetic(clause, options) {\n    if (!isPlainObjectRecord(clause)) {\n      return clause;\n    }\n\n    let next = clause;\n    const file = options && options.file ? options.file : \"\";\n    const lineStart = options ? options.lineStart : null;\n    const raw = options && options.raw ? options.raw : \"\";\n    const basePath = options && options.pathKey ? options.pathKey : \"\";\n\n    if (!isDeclLikeObject(clause.leftOperandDecl)) {\n      const leftFieldId = resolveFallbackFieldId({\n        declRef: clause.leftOperandRef,\n        value: clause.leftOperand,\n        name: \"leftOperand\"\n      });\n      const leftDecl = buildSyntheticDeclForPath({\n        pathKey: buildPathKeyFromParts([basePath, \"leftOperandDecl\"]),\n        fieldId: leftFieldId,\n        file,\n        lineStart,\n        raw,\n        role: \"leftOperand\"\n      });\n      if (leftDecl) {\n        if (next === clause) {\n          next = { ...clause };\n        }\n        next.leftOperandDecl = leftDecl;\n        if (!String(next.leftOperandRef || \"\").trim()) {\n          next.leftOperandRef = leftFieldId;\n        }\n      }\n    }\n\n    if (!isDeclLikeObject(clause.rightOperandDecl)) {\n      const rightFieldId = resolveFallbackFieldId({\n        declRef: clause.rightOperandRef,\n        value: clause.rightOperand,\n        name: \"rightOperand\"\n      });\n      const rightDecl = buildSyntheticDeclForPath({\n        pathKey: buildPathKeyFromParts([basePath, \"rightOperandDecl\"]),\n        fieldId: rightFieldId,\n        file,\n        lineStart,\n        raw,\n        role: \"rightOperand\"\n      });\n      if (rightDecl) {\n        if (next === clause) {\n          next = { ...clause };\n        }\n        next.rightOperandDecl = rightDecl;\n        if (!String(next.rightOperandRef || \"\").trim()) {\n          next.rightOperandRef = rightFieldId;\n        }\n      }\n    }\n\n    return next;\n  }\n\n  function normalizeXmlObjectId(value) {\n    if (value === null || value === undefined) {\n      return \"\";\n    }\n    return String(value);\n  }\n\n  function getFormNameFromNode(node) {\n    if (!node || typeof node !== \"object\") {\n      return \"\";\n    }\n    const valueName = getFirstValueFromValues(node.values, \"name\");\n    const extrasName = node.extras && node.extras.form && node.extras.form.name\n      ? String(node.extras.form.name)\n      : \"\";\n    return String(valueName || extrasName || \"\").trim();\n  }\n\n  function getPerformFormNameFromNode(node) {\n    if (!node || typeof node !== \"object\") {\n      return \"\";\n    }\n    const extrasName = node.extras && node.extras.performCall && node.extras.performCall.form\n      ? String(node.extras.performCall.form)\n      : \"\";\n    const valueName = getFirstValueFromValues(node.values, \"form\");\n    return String(extrasName || valueName || \"\").trim();\n  }\n\n  function getPerformProgramFromNode(node) {\n    if (!node || typeof node !== \"object\") {\n      return \"\";\n    }\n    const extrasProgram = node.extras && node.extras.performCall && node.extras.performCall.program\n      ? String(node.extras.performCall.program)\n      : \"\";\n    const valueProgram = getFirstValueFromValues(node.values, \"program\");\n    return String(extrasProgram || valueProgram || \"\").trim();\n  }\n\n  function buildFormsByNameUpperFromRoots(rawRoots) {\n    const map = new Map();\n    walkObjects(rawRoots, (obj) => {\n      if (!obj || obj.objectType !== \"FORM\") {\n        return;\n      }\n      const name = getFormNameFromNode(obj);\n      if (!name) {\n        return;\n      }\n      const upper = name.toUpperCase();\n      if (!map.has(upper)) {\n        map.set(upper, obj);\n      }\n    });\n    return map;\n  }\n\n  function buildRenderableObjects(rawRoots, options) {\n    const roots = Array.isArray(rawRoots) ? rawRoots : [];\n    if (!roots.length) {\n      return [];\n    }\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/descriptions/04-panel-render.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/02-descriptions.js";
  const partKey = "viewer/app/descriptions/04-panel-render.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    const opts = {\n      expandPerformForms: true,\n      hideFormRoots: true,\n      maxExpandDepth: Number.POSITIVE_INFINITY,\n      ...(options && typeof options === \"object\" ? options : {})\n    };\n    const maxExpandDepth = Math.max(0, Number(opts.maxExpandDepth) || 0);\n    const formsByNameUpper = opts.expandPerformForms ? buildFormsByNameUpperFromRoots(roots) : new Map();\n    var PERFORM_TRACE_META_KEY_DESC = \"__abapPerformTraceBinding\";\n\n    const getDeclIdentityKey = (decl) => {\n      if (!decl || typeof decl !== \"object\") {\n        return \"\";\n      }\n      return [\n        decl.objectType || \"\",\n        decl.scopeLabel || \"\",\n        decl.name || \"\",\n        decl.file || \"\",\n        decl.lineStart || \"\"\n      ].join(\"|\");\n    };\n\n    const dedupeDeclList = (list) => {\n      const out = [];\n      const seen = new Set();\n      for (const decl of Array.isArray(list) ? list : []) {\n        if (!decl || typeof decl !== \"object\") {\n          continue;\n        }\n        const key = getDeclIdentityKey(decl);\n        if (!key || seen.has(key)) {\n          continue;\n        }\n        seen.add(key);\n        out.push(decl);\n      }\n      return out;\n    };\n\n    const resolveActualTraceDecls = (actualEntry, currentBindingContext) => {\n      if (!actualEntry || typeof actualEntry !== \"object\") {\n        return [];\n      }\n\n      const out = [];\n      const pushDecl = (decl) => {\n        if (decl && typeof decl === \"object\") {\n          out.push(decl);\n        }\n      };\n      const pushList = (decls) => {\n        for (const decl of Array.isArray(decls) ? decls : []) {\n          pushDecl(decl);\n        }\n      };\n\n      const valueDecl = actualEntry.valueDecl && typeof actualEntry.valueDecl === \"object\"\n        ? actualEntry.valueDecl\n        : null;\n      if (!valueDecl) {\n        pushList(actualEntry.originDecls);\n        return dedupeDeclList(out);\n      }\n\n      pushDecl(valueDecl);\n\n      const valueDeclType = String(valueDecl.objectType || \"\").toUpperCase();\n      if (valueDeclType === \"FORM_PARAM\") {\n        const paramUpper = String(valueDecl.name || \"\").trim().toUpperCase();\n        const byParamUpper = currentBindingContext && currentBindingContext.byParamUpper instanceof Map\n          ? currentBindingContext.byParamUpper\n          : null;\n        const externalDecls = byParamUpper && paramUpper ? byParamUpper.get(paramUpper) : null;\n        if (Array.isArray(externalDecls) && externalDecls.length) {\n          pushList(externalDecls);\n        } else {\n          pushList(actualEntry.originDecls);\n        }\n      } else {\n        pushList(actualEntry.originDecls);\n      }\n\n      return dedupeDeclList(out);\n    };\n\n    const buildPerformBindingContext = (performNode, resolvedForm, currentBindingContext) => {\n      if (!performNode || !resolvedForm) {\n        return null;\n      }\n\n      const call = performNode.extras && performNode.extras.performCall && typeof performNode.extras.performCall === \"object\"\n        ? performNode.extras.performCall\n        : null;\n      const formExtras = resolvedForm.extras && resolvedForm.extras.form && typeof resolvedForm.extras.form === \"object\"\n        ? resolvedForm.extras.form\n        : null;\n      const params = formExtras && Array.isArray(formExtras.params) ? formExtras.params : [];\n      if (!call || !params.length) {\n        return null;\n      }\n\n      const bySection = {\n        USING: [],\n        CHANGING: [],\n        TABLES: []\n      };\n      for (const param of params) {\n        if (!param || !param.name) {\n          continue;\n        }\n        const section = String(param.section || \"\").trim().toUpperCase();\n        if (!Object.prototype.hasOwnProperty.call(bySection, section)) {\n          continue;\n        }\n        bySection[section].push(param);\n      }\n\n      const byParamUpper = new Map();\n      for (const section of [\"USING\", \"CHANGING\", \"TABLES\"]) {\n        const formalParams = bySection[section] || [];\n        const actualArgs = Array.isArray(call[section.toLowerCase()]) ? call[section.toLowerCase()] : [];\n        const max = Math.min(formalParams.length, actualArgs.length);\n        for (let index = 0; index < max; index += 1) {\n          const formalParam = formalParams[index];\n          const actualArg = actualArgs[index];\n          if (!formalParam || !formalParam.name || !actualArg) {\n            continue;\n          }\n          const paramUpper = String(formalParam.name || \"\").trim().toUpperCase();\n          if (!paramUpper) {\n            continue;\n          }\n          const traceDecls = resolveActualTraceDecls(actualArg, currentBindingContext);\n          if (!traceDecls.length) {\n            continue;\n          }\n          byParamUpper.set(paramUpper, traceDecls);\n        }\n      }\n\n      if (!byParamUpper.size) {\n        return null;\n      }\n\n      return {\n        byParamUpper\n      };\n    };\n\n    const attachPerformBindingMetadata = (node, bindingContext) => {\n      if (!node || typeof node !== \"object\" || !bindingContext || !bindingContext.byParamUpper) {\n        return;\n      }\n      try {\n        Object.defineProperty(node, PERFORM_TRACE_META_KEY_DESC, {\n          value: bindingContext,\n          enumerable: false,\n          configurable: true\n        });\n      } catch {\n        // ignore metadata errors; rendering should keep working without trace metadata.\n      }\n    };\n\n    const cloneNode = (sourceNode, parentId, expandDepth, pathToken, forceSyntheticId, formCallStack, bindingContext) => {\n      if (!sourceNode || typeof sourceNode !== \"object\") {\n        return null;\n      }\n\n      if (opts.hideFormRoots && sourceNode.objectType === \"FORM\" && !forceSyntheticId) {\n        return null;\n      }\n\n      const out = {};\n      for (const key of Object.keys(sourceNode)) {\n        if (key === \"children\") {\n          continue;\n        }\n        out[key] = sourceNode[key];\n      }\n\n      if (forceSyntheticId) {\n        out.id = `PERFORM_EXPANDED:${pathToken}`;\n      }\n\n      if (parentId !== undefined) {\n        out.parent = parentId;\n      }\n      attachPerformBindingMetadata(out, bindingContext);\n\n      const ownId = out.id !== null && out.id !== undefined && String(out.id).trim() ? out.id : undefined;\n      const outChildren = [];\n\n      const sourceChildren = Array.isArray(sourceNode.children) ? sourceNode.children : [];\n      for (let index = 0; index < sourceChildren.length; index += 1) {\n        const child = sourceChildren[index];\n        const childPath = `${pathToken}.C${index}`;\n        const clonedChild = cloneNode(child, ownId, expandDepth, childPath, forceSyntheticId, formCallStack, bindingContext);\n        if (clonedChild) {\n          outChildren.push(clonedChild);\n        }\n      }\n\n      if (\n        opts.expandPerformForms &&\n        sourceNode.objectType === \"PERFORM\" &&\n        expandDepth < maxExpandDepth\n      ) {\n        const formName = getPerformFormNameFromNode(sourceNode);\n        const programName = getPerformProgramFromNode(sourceNode);\n        const formNameUpper = formName ? formName.toUpperCase() : \"\";\n        const resolvedForm = !programName && formNameUpper ? formsByNameUpper.get(formNameUpper) : null;\n        const isRecursiveCall = Boolean(formNameUpper) && Array.isArray(formCallStack) && formCallStack.includes(formNameUpper);\n\n        if (resolvedForm && !isRecursiveCall) {\n          const nextBindingContext = buildPerformBindingContext(sourceNode, resolvedForm, bindingContext);\n          const nextFormCallStack = formNameUpper\n            ? [...(Array.isArray(formCallStack) ? formCallStack : []), formNameUpper]\n            : (Array.isArray(formCallStack) ? formCallStack.slice() : []);\n          const formChildren = Array.isArray(resolvedForm.children) ? resolvedForm.children : [];\n          for (let index = 0; index < formChildren.length; index += 1) {\n            const formChild = formChildren[index];\n            const expandedPath = `${pathToken}.FORM:${formNameUpper}.C${index}`;\n            const clonedExpandedChild = cloneNode(\n              formChild,\n              ownId,\n              expandDepth + 1,\n              expandedPath,\n              true,\n              nextFormCallStack,\n              nextBindingContext\n            );\n            if (clonedExpandedChild) {\n              outChildren.push(clonedExpandedChild);\n            }\n          }\n        }\n      }\n\n      if (outChildren.length) {\n        out.children = outChildren;\n      } else if (Array.isArray(sourceNode.children)) {\n        out.children = [];\n      }\n\n      return out;\n    };\n\n    const output = [];\n    for (let index = 0; index < roots.length; index += 1) {\n      const root = roots[index];\n      const clonedRoot = cloneNode(root, null, 0, `ROOT${index}`, false, [], null);\n      if (clonedRoot) {\n        output.push(clonedRoot);\n      }\n    }\n\n    return output;\n  }\n\n  function buildXmlExportRoots(objects) {\n    const input = Array.isArray(objects) ? objects : [];\n    if (!input.length) {\n      return [];\n    }\n\n    const nodeById = new Map();\n    const idOrder = [];\n    const childIdsByParentId = new Map();\n    const topLevelNoIdNodes = [];\n\n    const pushChildId = (parentId, childId) => {\n      if (!parentId || !childId) {\n        return;\n      }\n      if (!childIdsByParentId.has(parentId)) {\n        childIdsByParentId.set(parentId, []);\n      }\n      const list = childIdsByParentId.get(parentId);\n      if (!list.includes(childId)) {\n        list.push(childId);\n      }\n    };\n\n    const stack = input\n      .filter((node) => node && typeof node === \"object\")\n      .map((node) => ({ node, isTopLevel: true }));\n\n    while (stack.length) {\n      const item = stack.pop();\n      const node = item && item.node;\n      if (!node || typeof node !== \"object\") {\n        continue;\n      }\n\n      const nodeId = normalizeXmlObjectId(node.id);\n      if (!nodeId) {\n        if (item.isTopLevel) {\n          topLevelNoIdNodes.push(node);\n        }\n      } else if (!nodeById.has(nodeId)) {\n        nodeById.set(nodeId, node);\n        idOrder.push(nodeId);\n      }\n\n      const parentId = normalizeXmlObjectId(node.parent);\n      if (nodeId && parentId) {\n        pushChildId(parentId, nodeId);\n      }\n\n      const children = Array.isArray(node.children) ? node.children : [];\n      for (let index = children.length - 1; index >= 0; index -= 1) {\n        const child = children[index];\n        if (!child || typeof child !== \"object\") {\n          continue;\n        }\n        const childId = normalizeXmlObjectId(child.id);\n        if (nodeId && childId) {\n          pushChildId(nodeId, childId);\n        }\n        stack.push({ node: child, isTopLevel: false });\n      }\n    }\n\n    if (!nodeById.size) {\n      return input.slice();\n    }\n\n    const cloneNodeNoId = (node, seenNoId) => {\n      if (!node || typeof node !== \"object\") {\n        return node;\n      }\n      if (seenNoId.has(node)) {\n        return null;\n      }\n\n      const nextSeenNoId = new Set(seenNoId);\n      nextSeenNoId.add(node);\n\n      const out = {};\n      for (const key of Object.keys(node)) {\n        if (key === \"children\") {\n          continue;\n        }\n        out[key] = node[key];\n      }\n\n      const children = Array.isArray(node.children) ? node.children : [];\n      const outChildren = [];\n      for (const child of children) {\n        if (!child || typeof child !== \"object\") {\n          continue;\n        }\n        const childId = normalizeXmlObjectId(child.id);\n        if (childId) {\n          // ID-based children are wired later from parent map.\n          continue;\n        }\n        const cloned = cloneNodeNoId(child, nextSeenNoId);\n        if (cloned) {\n          outChildren.push(cloned);\n        }\n      }\n\n      if (outChildren.length) {\n        out.children = outChildren;\n      } else if (Array.isArray(node.children) && node.children.length === 0) {\n        out.children = [];\n      }\n\n      return out;\n    };\n\n    const cloneNodeById = (nodeId, ancestorIds, emittedIds) => {\n      if (!nodeId || !nodeById.has(nodeId)) {\n        return null;\n      }\n      if (ancestorIds.has(nodeId)) {\n        return null;\n      }\n      if (emittedIds && emittedIds.has(nodeId)) {\n        return null;\n      }\n\n      const node = nodeById.get(nodeId);\n      const nextAncestors = new Set(ancestorIds);\n      nextAncestors.add(nodeId);\n      if (emittedIds) {\n        emittedIds.add(nodeId);\n      }\n\n      const out = {};\n      for (const key of Object.keys(node)) {\n        if (key === \"children\") {\n          continue;\n        }\n        out[key] = node[key];\n      }\n\n      const outChildren = [];\n\n      const explicitChildren = Array.isArray(node.children) ? node.children : [];\n      for (const child of explicitChildren) {\n        if (!child || typeof child !== \"object\") {\n          continue;\n        }\n        const childId = normalizeXmlObjectId(child.id);\n        if (childId) {\n          continue;\n        }\n        const clonedNoId = cloneNodeNoId(child, new Set());\n        if (clonedNoId) {\n          outChildren.push(clonedNoId);\n        }\n      }\n\n      const childIds = childIdsByParentId.get(nodeId) || [];\n      for (const childId of childIds) {\n        const cloned = cloneNodeById(childId, nextAncestors, emittedIds);\n        if (cloned) {\n          outChildren.push(cloned);\n        }\n      }\n\n      if (outChildren.length) {\n        out.children = outChildren;\n      } else if (Array.isArray(node.children) && node.children.length === 0) {\n        out.children = [];\n      }\n\n      return out;\n    };\n\n    const isRootId = (nodeId) => {\n      const node = nodeById.get(nodeId);\n      if (!node) {\n        return false;\n      }\n      const parentId = normalizeXmlObjectId(node.parent);\n      return !parentId || !nodeById.has(parentId);\n    };\n\n    const rootIds = [];\n    const addedRootIds = new Set();\n    const addRootId = (nodeId) => {\n      if (!nodeId || addedRootIds.has(nodeId) || !nodeById.has(nodeId)) {\n        return;\n      }\n      addedRootIds.add(nodeId);\n      rootIds.push(nodeId);\n    };\n\n    for (const topNode of input) {\n      const topId = normalizeXmlObjectId(topNode && topNode.id);\n      if (topId && isRootId(topId)) {\n        addRootId(topId);\n      }\n    }\n\n    for (const nodeId of idOrder) {\n      if (isRootId(nodeId)) {\n        addRootId(nodeId);\n      }\n    }\n\n    const reachableIds = new Set();\n    const markReachable = (nodeId) => {\n      if (!nodeId || reachableIds.has(nodeId) || !nodeById.has(nodeId)) {\n        return;\n      }\n      reachableIds.add(nodeId);\n      const childIds = childIdsByParentId.get(nodeId) || [];\n      for (const childId of childIds) {\n        markReachable(childId);\n      }\n    };\n\n    for (const rootId of rootIds) {\n      markReachable(rootId);\n    }\n\n    for (const nodeId of idOrder) {\n      if (!reachableIds.has(nodeId)) {\n        addRootId(nodeId);\n        markReachable(nodeId);\n      }\n    }\n\n    const roots = [];\n    const emittedIds = new Set();\n    for (const node of topLevelNoIdNodes) {\n      const cloned = cloneNodeNoId(node, new Set());\n      if (cloned) {\n        roots.push(cloned);\n      }\n    }\n    for (const rootId of rootIds) {\n      const cloned = cloneNodeById(rootId, new Set(), emittedIds);\n      if (cloned) {\n        roots.push(cloned);\n      }\n    }\n\n    return roots;\n  }\n\n  function isDeclLikeObject(value) {\n    if (!value || typeof value !== \"object\") {\n      return false;\n    }\n    return (\n      typeof value.objectType === \"string\" &&\n      typeof value.name === \"string\" &&\n      typeof value.scopeLabel === \"string\"\n    );\n  }\n\n  function isDeclHintKey(keyHint) {\n    const key = String(keyHint || \"\").trim();\n    if (!key) {\n      return false;\n    }\n    return /decl$/i.test(key);\n  }\n\n  function isDeclObjectForXml(keyHint, value) {\n    if (isDeclLikeObject(value)) {\n      return true;\n    }\n    if (!isDeclHintKey(keyHint) || !value || typeof value !== \"object\" || Array.isArray(value)) {\n      return false;\n    }\n    return (\n      typeof value.name === \"string\" ||\n      typeof value.objectType === \"string\" ||\n      typeof value.scopeLabel === \"string\" ||\n      typeof value.comment === \"string\"\n    );\n  }\n\n  function hasValueLevelDescFields(value) {\n    if (!value || typeof value !== \"object\" || Array.isArray(value)) {\n      return false;\n    }\n    return (\n      Object.prototype.hasOwnProperty.call(value, \"userDesc\") ||\n      Object.prototype.hasOwnProperty.call(value, \"codeDesc\")\n    );\n  }\n\n  function resolveValueLevelTechId(value) {\n    if (!value || typeof value !== \"object\") {\n      return \"\";\n    }\n\n    if (isDeclLikeObject(value.decl)) {\n      const declTech = String(getDeclTechName(value.decl) || \"\").trim();\n      if (declTech) {\n        return declTech;\n      }\n    }\n\n    const declRef = String(value.declRef || \"\").trim();\n    if (declRef) {\n      return declRef;\n    }\n\n    const identifier = extractIdentifierCandidate(value.value);\n    if (identifier) {\n      return identifier;\n    }\n\n    const rawValue = String(value.value || \"\").trim();\n    if (rawValue) {\n      return rawValue;\n    }\n\n    const fallbackName = String(value.name || \"\").trim();\n    return fallbackName;\n  }\n\n  const VALUE_LEVEL_IDENTIFIER_REGEX =\n    /<[^>]+>(?:(?:->|=>|~|-)[A-Za-z_][A-Za-z0-9_]*)*|SY-[A-Za-z_][A-Za-z0-9_]*|[A-Za-z_][A-Za-z0-9_]*(?:(?:->|=>|~|-)[A-Za-z_][A-Za-z0-9_]*)*/g;\n\n  function normalizeValueIdentifierKey(text) {\n    return String(text || \"\").trim().toUpperCase();\n  }\n\n  function buildValueLevelDeclReplacementMap(value, rawValueText) {\n    if (!value || typeof value !== \"object\" || !isDeclLikeObject(value.decl)) {\n      return null;\n    }\n\n    const replacement = String(getFinalDeclDesc(value.decl) || getDeclTechName(value.decl) || \"\").trim();\n    if (!replacement) {\n      return null;\n    }\n\n    const map = Object.create(null);\n    const register = (token) => {\n      const key = normalizeValueIdentifierKey(token);\n      if (!key) {\n        return;\n      }\n      map[key] = replacement;\n    };\n\n    register(value.declRef);\n    register(value.decl && value.decl.name);\n    register(extractIdentifierCandidate(rawValueText));\n\n    return Object.keys(map).length ? map : null;\n  }\n\n  function replaceIdentifiersOutsideLiterals(rawText, replacementMap) {\n    const text = String(rawText || \"\");\n    if (!text || !replacementMap || typeof replacementMap !== \"object\") {\n      return \"\";\n    }\n\n    let out = \"\";\n    let i = 0;\n    const length = text.length;\n\n    const replaceSegment = (segment) => segment.replace(VALUE_LEVEL_IDENTIFIER_REGEX, (token) => {\n      const key = normalizeValueIdentifierKey(token);\n      if (key && Object.prototype.hasOwnProperty.call(replacementMap, key)) {\n        return replacementMap[key];\n      }\n      return token;\n    });\n\n    while (i < length) {\n      const ch = text[i];\n\n      if (ch === \"'\" || ch === \"|\") {\n        const quote = ch;\n        const start = i;\n        i += 1;\n        while (i < length) {\n          if (text[i] !== quote) {\n            i += 1;\n            continue;\n          }\n          if (quote === \"'\" && i + 1 < length && text[i + 1] === \"'\") {\n            i += 2;\n            continue;\n          }\n          i += 1;\n          break;\n        }\n        out += text.slice(start, i);\n        continue;\n      }\n\n      const start = i;\n      while (i < length && text[i] !== \"'\" && text[i] !== \"|\") {\n        i += 1;\n      }\n      out += replaceSegment(text.slice(start, i));\n    }\n\n    return out;\n  }\n\n  function resolveValueLevelFinalDesc(value) {\n    if (!value || typeof value !== \"object\") {\n      return \"\";\n    }\n\n    const userDesc = String(value.userDesc || \"\").trim();\n    if (userDesc) {\n      const decl = value.decl;\n      if (decl && typeof decl === \"object\" && typeof normalizeDeclDescByTemplate === \"function\") {\n        const normalizedUserDesc = String(normalizeDeclDescByTemplate(decl, userDesc) || \"\").trim();\n        return normalizedUserDesc || userDesc;\n      }\n      return userDesc;\n    }\n\n    const codeDesc = String(value.codeDesc || \"\").trim();\n    if (codeDesc) {\n      return codeDesc;\n    }\n\n    const rawValueText = String(value.value || \"\");\n    if (rawValueText.trim()) {\n      const replacementMap = buildValueLevelDeclReplacementMap(value, rawValueText);\n      if (replacementMap) {\n        const replaced = replaceIdentifiersOutsideLiterals(rawValueText, replacementMap).trim();\n        if (replaced) {\n          return replaced;\n        }\n      }\n    }\n\n    return resolveValueLevelTechId(value);\n  }\n\nwindow.AbapViewerModules.factories = window.AbapViewerModules.factories || {};\nwindow.AbapViewerModules.factories[\"02-descriptions\"] = function registerDescriptions(runtime) {\n  const targetRuntime = runtime || (window.AbapViewerRuntime = window.AbapViewerRuntime || {});\n  targetRuntime.api = targetRuntime.api || {};\n  targetRuntime.api.renderDeclDescPanelUi = renderDeclDescPanelUi;\n  targetRuntime.api.getFinalDeclDesc = getFinalDeclDesc;\n  targetRuntime.api.getEffectiveDeclDesc = getEffectiveDeclDesc;\n  targetRuntime.api.resolveValueLevelFinalDesc = resolveValueLevelFinalDesc;\n  window.AbapViewerModules.parts[\"02-descriptions\"] = true;\n};\nwindow.AbapViewerModules.factories[\"02-descriptions\"](window.AbapViewerRuntime);\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/02-descriptions.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/02-descriptions.js";
  const bucket = registry[targetKey] || {};
  const orderedParts = [
    "viewer/app/descriptions/01-normalize-and-desc.js",
    "viewer/app/descriptions/02-overrides-and-edit.js",
    "viewer/app/descriptions/03-value-finaldesc.js",
    "viewer/app/descriptions/04-panel-render.js"
  ];

  const missing = orderedParts.filter((part) => typeof bucket[part] !== "string");
  if (missing.length) {
    const message = `Source parts missing for ${targetKey}: ${missing.join(", ")}`;
    try {
      if (globalRoot.console && typeof globalRoot.console.error === "function") {
        globalRoot.console.error(message);
      }
    } catch {
      // ignore
    }
    return;
  }

  const source = orderedParts.map((part) => bucket[part]).join("\n");
  if (typeof document !== "undefined" && document.createElement) {
    const script = document.createElement("script");
    script.type = "text/javascript";
    script.setAttribute("data-abap-source-wrapper", targetKey);
    script.textContent = `${source}\n//# sourceURL=${targetKey}`;
    (document.head || document.documentElement || document.body).appendChild(script);
    script.remove();
  } else {
    (0, eval)(source);
  }
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/template/01-path-resolver.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/03-template-preview.js";
  const partKey = "viewer/app/template/01-path-resolver.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\"use strict\";\n\nwindow.AbapViewerModules = window.AbapViewerModules || {};\nwindow.AbapViewerModules.parts = window.AbapViewerModules.parts || {};\n\n  var PERFORM_TRACE_META_KEY_TEMPLATE = \"__abapPerformTraceBinding\";\n\n  function toInlineCssText(styleMap) {\n    if (!styleMap || typeof styleMap !== \"object\") {\n      return \"\";\n    }\n    const entries = [];\n    for (const [key, value] of Object.entries(styleMap)) {\n      const cssKey = String(key || \"\").trim();\n      const cssValue = String(value || \"\").trim();\n      if (!cssKey || !cssValue) {\n        continue;\n      }\n      entries.push(`${cssKey}:${cssValue}`);\n    }\n    return entries.join(\";\");\n  }\n\n  function normalizeTemplateColorValue(value) {\n    const raw = String(value || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const alias = normalizeTemplateAliasToken(raw);\n    if (!alias || alias === \"default\") {\n      return \"\";\n    }\n    if (alias === \"mau xanh nhat\") {\n      return \"#dbeef4\";\n    }\n    if (alias === \"den\") {\n      return \"#000000\";\n    }\n    return raw;\n  }\n\n  function normalizeTemplateBorderValue(value) {\n    const raw = String(value || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const alias = normalizeTemplateAliasToken(raw);\n    if (!alias || alias === \"default\") {\n      return \"\";\n    }\n    if (alias === \"outside line mong\") {\n      return \"outside-thin\";\n    }\n    return raw;\n  }\n\n  function normalizeTemplateAlignValue(value) {\n    const alias = normalizeTemplateAliasToken(value);\n    if (!alias || alias === \"default\") {\n      return \"\";\n    }\n    if (alias === \"left\" || alias === \"center\" || alias === \"right\") {\n      return alias;\n    }\n    return \"\";\n  }\n\n  function normalizeTemplateVAlignValue(value) {\n    const alias = normalizeTemplateAliasToken(value);\n    if (!alias || alias === \"default\") {\n      return \"\";\n    }\n    if (alias === \"top\") {\n      return \"top\";\n    }\n    if (alias === \"middle\" || alias === \"center\") {\n      return \"middle\";\n    }\n    if (alias === \"bottom\") {\n      return \"bottom\";\n    }\n    return \"\";\n  }\n\n  function parseTemplatePathSegments(pathExpression) {\n    const raw = String(pathExpression || \"\").trim();\n    if (!raw) {\n      return [];\n    }\n\n    const segments = [];\n    let token = \"\";\n    let index = 0;\n\n    const pushToken = () => {\n      const trimmed = token.trim();\n      if (trimmed) {\n        segments.push(trimmed);\n      }\n      token = \"\";\n    };\n\n    while (index < raw.length) {\n      const ch = raw[index];\n      if (ch === \".\") {\n        pushToken();\n        index += 1;\n        continue;\n      }\n\n      if (ch === \"[\") {\n        pushToken();\n        const close = raw.indexOf(\"]\", index + 1);\n        if (close === -1) {\n          return null;\n        }\n        const inside = raw.slice(index + 1, close).trim();\n        if (!/^\\d+$/.test(inside)) {\n          return null;\n        }\n        segments.push(Number(inside));\n        index = close + 1;\n        continue;\n      }\n\n      token += ch;\n      index += 1;\n    }\n\n    pushToken();\n    return segments;\n  }\n\n  function isDeclLikePathSegment(segment) {\n    const key = String(segment || \"\").replace(/\\[\\d+\\]$/, \"\").trim();\n    if (!key) {\n      return false;\n    }\n    if (key.toLowerCase() === \"decl\") {\n      return true;\n    }\n    return /decl$/i.test(key);\n  }\n\n  function isTemplateDeclLikeValue(value) {\n    if (isDeclLikeObject(value)) {\n      return true;\n    }\n    return Boolean(\n      value\n      && typeof value === \"object\"\n      && typeof value.objectType === \"string\"\n      && typeof value.name === \"string\"\n    );\n  }\n\n  function resolveTemplatePathValue(root, pathExpression) {\n    const segments = parseTemplatePathSegments(pathExpression);\n    if (!segments) {\n      return undefined;\n    }\n\n    let current = root;\n    let parent = null;\n    let parentAccessKey = \"\";\n    for (const segment of segments) {\n      if (typeof segment === \"number\") {\n        if (!Array.isArray(current)) {\n          return undefined;\n        }\n        parent = current;\n        parentAccessKey = `[${segment}]`;\n        current = current[segment];\n        continue;\n      }\n\n      const key = String(segment || \"\").trim();\n      if (!key) {\n        continue;\n      }\n\n      if (Array.isArray(current)) {\n        const projected = [];\n        for (const item of current) {\n          if (!item || typeof item !== \"object\") {\n            continue;\n          }\n\n          const keyLower = key.toLowerCase();\n          if (keyLower === \"desc\" && isDeclLikeObject(item)) {\n            projected.push(getEffectiveDeclDesc(item));\n            continue;\n          }\n\n          if (keyLower === \"finaldesc\") {\n            if (isTemplateDeclLikeValue(item)) {\n              projected.push(getFinalDeclDesc(item));\n              continue;\n            }\n            if (hasValueLevelDescFields(item) || isDeclLikeObject(item.decl)) {\n              projected.push(resolveValueLevelFinalDesc(item));\n              continue;\n            }\n          }\n\n          if (Object.prototype.hasOwnProperty.call(item, key)) {\n            projected.push(item[key]);\n          }\n        }\n        if (!projected.length) {\n          return undefined;\n        }\n        parent = null;\n        parentAccessKey = \"\";\n        current = projected;\n        continue;\n      }\n\n      if (!current || typeof current !== \"object\") {\n        return undefined;\n      }\n\n      const keyLower = key.toLowerCase();\n      if (keyLower === \"desc\" && isDeclLikeObject(current)) {\n        return getEffectiveDeclDesc(current);\n      }\n\n      if (keyLower === \"finaldesc\") {\n        const parentLooksDecl = isDeclLikePathSegment(parentAccessKey);\n        if (isTemplateDeclLikeValue(current) || parentLooksDecl) {\n          return getFinalDeclDesc(current);\n        }\n        if (hasValueLevelDescFields(current) || isDeclLikeObject(current.decl)) {\n          return resolveValueLevelFinalDesc(current);\n        }\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(current, key)) {\n        return undefined;\n      }\n      parent = current;\n      parentAccessKey = key;\n      current = current[key];\n    }\n\n    return current;\n  }\n\n  function buildTemplatePathCandidates(tokenExpression) {\n    const raw = String(tokenExpression || \"\").trim();\n    if (!raw) {\n      return [];\n    }\n\n    const candidates = new Set();\n    candidates.add(raw);\n\n    if (/^keyword\\./i.test(raw)) {\n      candidates.add(`keywords.${raw.slice(\"keyword.\".length)}`);\n    }\n\n    return Array.from(candidates);\n  }\n\n  function getTemplateArrayItemTagName(keyHint) {\n    if (typeof getArrayItemTagName === \"function\") {\n      return getArrayItemTagName(keyHint);\n    }\n    const key = String(keyHint || \"\").trim().toLowerCase();\n    if (key === \"objects\" || key === \"children\") {\n      return \"object\";\n    }\n    return \"item\";\n  }\n\n  function normalizeTemplateEntryForPath(value, keyHint, pathParts, ownerContext) {\n    if (typeof normalizeEntryObjectForXml !== \"function\") {\n      return value;\n    }\n    try {\n      return normalizeEntryObjectForXml(value, keyHint, pathParts, ownerContext);\n    } catch {\n      return value;\n    }\n  }\n\n  function getTemplateDeclRenderKey(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n    return (\n      (typeof getDeclKey === \"function\" ? getDeclKey(decl) : \"\")\n      || [\n        decl.objectType || \"\",\n        decl.scopeLabel || \"\",\n        decl.name || \"\",\n        decl.file || \"\",\n        decl.lineStart || \"\"\n      ].join(\"|\")\n    );\n  }\n\n  function dedupeTemplateDecls(list) {\n    const out = [];\n    const seen = new Set();\n    for (const decl of Array.isArray(list) ? list : []) {\n      if (!decl || typeof decl !== \"object\") {\n        continue;\n      }\n      const key = getTemplateDeclRenderKey(decl);\n      if (!key || seen.has(key)) {\n        continue;\n      }\n      seen.add(key);\n      out.push(decl);\n    }\n    return out;\n  }\n\n  function getExpandedPerformBindingContextForTemplate(obj) {\n    if (!obj || typeof obj !== \"object\") {\n      return null;\n    }\n    const bindingContext = obj[PERFORM_TRACE_META_KEY_TEMPLATE];\n    if (!bindingContext || typeof bindingContext !== \"object\") {\n      return null;\n    }\n    if (!(bindingContext.byParamUpper instanceof Map)) {\n      return null;\n    }\n    return bindingContext;\n  }\n\n  function resolveExpandedPerformTemplateTraceDecls(ownerContext, decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return [];\n    }\n    if (String(decl.objectType || \"\").toUpperCase() !== \"FORM_PARAM\") {\n      return [];\n    }\n    const bindingContext = getExpandedPerformBindingContextForTemplate(ownerContext);\n    if (!bindingContext) {\n      return [];\n    }\n    const paramUpper = String(decl.name || \"\").trim().toUpperCase();\n    if (!paramUpper) {\n      return [];\n    }\n    const traceDecls = bindingContext.byParamUpper.get(paramUpper);\n    if (!Array.isArray(traceDecls) || !traceDecls.length) {\n      return [];\n    }\n    return dedupeTemplateDecls(traceDecls);\n  }\n\n  function isTemplateValueEntryLikeObject(value) {\n    if (!value || typeof value !== \"object\" || Array.isArray(value)) {\n      return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(value, \"decl\")) {\n      return false;\n    }\n    return (\n      Object.prototype.hasOwnProperty.call(value, \"value\")\n      || Object.prototype.hasOwnProperty.call(value, \"declRef\")\n      || Object.prototype.hasOwnProperty.call(value, \"name\")\n      || Object.prototype.hasOwnProperty.call(value, \"label\")\n      || hasValueLevelDescFields(value)\n    );\n  }\n\n  function remapTemplateDeclForExpandedPerform(value, ownerContext) {\n    if (!isTemplateValueEntryLikeObject(value)) {\n      return value;\n    }\n\n    const localDecl = value.decl;\n    if (!isDeclLikeObject(localDecl) || String(localDecl.objectType || \"\").toUpperCase() !== \"FORM_PARAM\") {\n      return value;\n    }\n\n    const externalTraceDecls = resolveExpandedPerformTemplateTraceDecls(ownerContext, localDecl);\n    if (!externalTraceDecls.length) {\n      return value;\n    }\n\n    const existingOrigins = Array.isArray(value.originDecls) ? value.originDecls : [];\n    const originDecls = dedupeTemplateDecls([localDecl, ...externalTraceDecls, ...existingOrigins]);\n    return {\n      ...value,\n      decl: externalTraceDecls[0],\n      originDecls\n    };\n  }\n\n  function buildTemplateContextObject(obj, objectIndexOneBased) {\n    const objectIndex = Number(objectIndexOneBased) || 1;\n    const basePathParts = [\"objects\", `object[${objectIndex}]`];\n\n    const cloneRecursive = (value, keyHint, pathParts, ownerContext) => {\n      if (value === null || value === undefined) {\n        return value;\n      }\n      if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n        return value;\n      }\n\n      if (Array.isArray(value)) {\n        const itemTag = getTemplateArrayItemTagName(keyHint);\n        return value.map((item, index) => cloneRecursive(\n          item,\n          itemTag,\n          pathParts.concat(`${itemTag}[${index + 1}]`),\n          ownerContext\n        ));\n      }\n\n      if (typeof value !== \"object\") {\n        return value;\n      }\n\n      const nextOwnerContext = (typeof isAbapStatementObject === \"function\" && isAbapStatementObject(value))\n        ? value\n        : ownerContext;\n      const normalized = normalizeTemplateEntryForPath(value, keyHint, pathParts, nextOwnerContext);\n      if (!normalized || typeof normalized !== \"object\") {\n        return normalized;\n      }\n      const remappedForTrace = remapTemplateDeclForExpandedPerform(normalized, nextOwnerContext);\n\n      const out = {};\n      for (const key of Object.keys(remappedForTrace)) {\n        out[key] = cloneRecursive(\n          remappedForTrace[key],\n          key,\n          pathParts.concat(key),\n          nextOwnerContext\n        );\n      }\n      return out;\n    };\n\n    return cloneRecursive(obj, \"object\", basePathParts, obj);\n  }\n\n  function stringifyTemplateResolvedValue(value) {\n    if (value === undefined || value === null) {\n      return \"\";\n    }\n    if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n      return String(value);\n    }\n    if (Array.isArray(value)) {\n      return value\n        .map((item) => stringifyTemplateResolvedValue(item))\n        .filter((text) => text !== \"\")\n        .join(\"\\n\");\n    }\n    if (isDeclLikeObject(value)) {\n      return getDeclDisplayName(value) || getDeclTechName(value);\n    }\n    if (typeof value === \"object\") {\n      if (hasValueLevelDescFields(value) || isDeclLikeObject(value.decl)) {\n        const finalDesc = resolveValueLevelFinalDesc(value);\n        if (finalDesc) {\n          return finalDesc;\n        }\n      }\n      return safeJson(value, false);\n    }\n    return String(value);\n  }\n\n  function collectTemplateDumpPaths(root) {\n    const out = new Set();\n\n    const walk = (value, path) => {\n      if (path) {\n        out.add(path);\n      }\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i += 1) {\n          const nextPath = path ? `${path}[${i}]` : `[${i}]`;\n          walk(value[i], nextPath);\n        }\n        return;\n      }\n\n      if (typeof value !== \"object\") {\n        return;\n      }\n\n      if (path && isDeclLikeObject(value)) {\n        out.add(`${path}.desc`);\n        out.add(`${path}.finalDesc`);\n      }\n      if (path && (hasValueLevelDescFields(value) || isDeclLikeObject(value.decl))) {\n        out.add(`${path}.finalDesc`);\n      }\n\n      for (const key of Object.keys(value)) {\n        const nextPath = path ? `${path}.${key}` : key;\n        walk(value[key], nextPath);\n      }\n    };\n\n    walk(root, \"\");\n    return Array.from(out).sort((a, b) => a.localeCompare(b));\n  }\n\n  function formatTemplateDumpValue(value) {\n    if (value === undefined || value === null) {\n      return \"\";\n    }\n    const text = String(value);\n    return text\n      .replace(/\\r\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\n\")\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/template/02-grid-and-style.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/03-template-preview.js";
  const partKey = "viewer/app/template/02-grid-and-style.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "      .replace(/\\n/g, \"\\\\n\");\n  }\n\n  function collectTemplateDumpPathValues(root) {\n    const out = new Map();\n\n    const addEntry = (path, value) => {\n      const key = String(path || \"\").trim();\n      if (!key || out.has(key)) {\n        return;\n      }\n      out.set(key, formatTemplateDumpValue(value));\n    };\n\n    const walk = (value, path) => {\n      const currentPath = String(path || \"\");\n      if (value === undefined) {\n        return;\n      }\n\n      if (value === null) {\n        if (currentPath) {\n          addEntry(currentPath, \"\");\n        }\n        return;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n        if (currentPath) {\n          addEntry(currentPath, value);\n        }\n        return;\n      }\n\n      if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i += 1) {\n          const nextPath = currentPath ? `${currentPath}[${i}]` : `[${i}]`;\n          walk(value[i], nextPath);\n        }\n        return;\n      }\n\n      if (typeof value !== \"object\") {\n        if (currentPath) {\n          addEntry(currentPath, String(value));\n        }\n        return;\n      }\n\n      if (currentPath && isDeclLikeObject(value)) {\n        addEntry(`${currentPath}.desc`, getEffectiveDeclDesc(value));\n        addEntry(`${currentPath}.finalDesc`, getFinalDeclDesc(value));\n      }\n      if (currentPath && (hasValueLevelDescFields(value) || isDeclLikeObject(value.decl))) {\n        addEntry(`${currentPath}.finalDesc`, resolveValueLevelFinalDesc(value));\n      }\n\n      const keys = Object.keys(value);\n      keys.sort((a, b) => a.localeCompare(b));\n      for (const key of keys) {\n        const nextPath = currentPath ? `${currentPath}.${key}` : key;\n        walk(value[key], nextPath);\n      }\n    };\n\n    walk(root, \"\");\n    return Array.from(out.entries()).map(([path, value]) => `${path} = ${value}`);\n  }\n\n  function openTemplatePathDump(contextObj, index, obj) {\n    const lines = collectTemplateDumpPathValues(contextObj);\n    const fallback = collectTemplateDumpPaths(contextObj).map((path) => `${path} =`);\n    const dumpText = (lines.length ? lines : fallback).join(\"\\n\");\n    const objectType = obj && obj.objectType ? String(obj.objectType) : \"OBJECT\";\n    const title = `Template Paths #${Number(index) + 1} ${objectType}`;\n\n    if (typeof openTextModal === \"function\") {\n      openTextModal(title, dumpText || \"[No paths]\");\n      return;\n    }\n\n    if (typeof setError === \"function\") {\n      setError(\"Path viewer is unavailable.\");\n    }\n  }\n\n  function resolveTemplatePlaceholderValue(obj, tokenExpression) {\n    const token = String(tokenExpression || \"\").trim();\n    if (!token) {\n      return \"\";\n    }\n\n    if (token === \"__DUMP__\") {\n      return collectTemplateDumpPaths(obj).join(\"\\n\");\n    }\n    if (token === \"__DUMP_VALUES__\" || token === \"__DUMP_WITH_VALUES__\") {\n      return collectTemplateDumpPathValues(obj).join(\"\\n\");\n    }\n\n    const candidates = buildTemplatePathCandidates(token);\n\n    for (const candidate of candidates) {\n      const value = resolveTemplatePathValue(obj, candidate);\n      if (value !== undefined) {\n        return value;\n      }\n    }\n\n    return \"\";\n  }\n\n  function resolveTemplateText(rawText, obj) {\n    const templateText = String(rawText === undefined || rawText === null ? \"\" : rawText);\n    if (!templateText.includes(\"{\")) {\n      return {\n        text: templateText,\n        hasPlaceholder: false,\n        hasTokenValue: false\n      };\n    }\n\n    let hasPlaceholder = false;\n    let hasTokenValue = false;\n    const text = templateText.replace(/\\{([^{}]+)\\}/g, (full, token) => {\n      hasPlaceholder = true;\n      const resolved = resolveTemplatePlaceholderValue(obj, token);\n      const resolvedText = stringifyTemplateResolvedValue(resolved);\n      if (resolvedText !== \"\") {\n        hasTokenValue = true;\n      }\n      return resolvedText;\n    });\n\n    return {\n      text,\n      hasPlaceholder,\n      hasTokenValue\n    };\n  }\n\n  function createTemplateCellModel() {\n    return {\n      text: \"\",\n      style: {},\n      hidden: false,\n      rowspan: 1,\n      colspan: 1,\n      hasPlaceholder: false,\n      hasTokenValue: false\n    };\n  }\n\n  function buildTemplateCellStyle(rangeConfig, position) {\n    const cfg = rangeConfig && typeof rangeConfig === \"object\" ? rangeConfig : {};\n    const style = {};\n\n    const background = normalizeTemplateColorValue(cfg.background);\n    if (background) {\n      style[\"background-color\"] = background;\n    }\n\n    const fontColor = normalizeTemplateColorValue(cfg[\"font color\"]);\n    if (fontColor) {\n      style.color = fontColor;\n    }\n\n    const fontSize = Number(cfg[\"font size\"]);\n    if (Number.isFinite(fontSize) && fontSize > 0) {\n      style[\"font-size\"] = `${fontSize}pt`;\n    }\n\n    const fontFamilyRaw = String(cfg[\"font family\"] || \"\").trim();\n    if (fontFamilyRaw && normalizeTemplateAliasToken(fontFamilyRaw) !== \"default\") {\n      style[\"font-family\"] = fontFamilyRaw;\n    }\n\n    if (cfg.bold === true) {\n      style[\"font-weight\"] = \"700\";\n    }\n    if (cfg.italic === true) {\n      style[\"font-style\"] = \"italic\";\n    }\n    if (cfg.underline === true) {\n      style[\"text-decoration\"] = \"underline\";\n    }\n\n    const align = normalizeTemplateAlignValue(cfg.align);\n    if (align) {\n      style[\"text-align\"] = align;\n    }\n\n    const valign = normalizeTemplateVAlignValue(cfg.valign);\n    if (valign) {\n      style[\"vertical-align\"] = valign;\n    }\n\n    if (cfg.wrap === true) {\n      style[\"white-space\"] = \"pre-wrap\";\n    } else if (cfg.wrap === false) {\n      style[\"white-space\"] = \"nowrap\";\n    }\n\n    const border = normalizeTemplateBorderValue(cfg.border);\n    if (border === \"outside-thin\") {\n      const borderLine = \"0.5pt solid #000000\";\n      if (position && position.isMergeAnchor) {\n        style.border = borderLine;\n      } else {\n        style[\"border-top\"] = position && position.isTop ? borderLine : \"none\";\n        style[\"border-right\"] = position && position.isRight ? borderLine : \"none\";\n        style[\"border-bottom\"] = position && position.isBottom ? borderLine : \"none\";\n        style[\"border-left\"] = position && position.isLeft ? borderLine : \"none\";\n      }\n    } else if (border) {\n      style.border = border;\n    }\n\n    return style;\n  }\n\n  function parseTemplateOptionBoolean(value, fallback) {\n    if (typeof value === \"boolean\") {\n      return value;\n    }\n    if (typeof value === \"number\") {\n      if (value === 1) {\n        return true;\n      }\n      if (value === 0) {\n        return false;\n      }\n      return fallback;\n    }\n    const token = String(value || \"\").trim().toLowerCase();\n    if (!token) {\n      return fallback;\n    }\n    if (token === \"1\" || token === \"true\" || token === \"yes\" || token === \"y\" || token === \"on\") {\n      return true;\n    }\n    if (token === \"0\" || token === \"false\" || token === \"no\" || token === \"n\" || token === \"off\") {\n      return false;\n    }\n    return fallback;\n  }\n\n  function parseTemplateOptionNumber(value, fallback, min, max) {\n    const fallbackValue = Number.isFinite(Number(fallback)) ? Number(fallback) : 0;\n    const minValue = Number.isFinite(Number(min)) ? Number(min) : fallbackValue;\n    const maxValue = Number.isFinite(Number(max)) ? Number(max) : fallbackValue;\n\n    let numeric = NaN;\n    if (typeof value === \"number\") {\n      numeric = value;\n    } else if (typeof value === \"string\") {\n      const token = value.trim();\n      if (token) {\n        numeric = Number(token);\n      }\n    }\n\n    if (!Number.isFinite(numeric)) {\n      return fallbackValue;\n    }\n\n    const normalized = Math.round(numeric);\n    return Math.max(minValue, Math.min(maxValue, normalized));\n  }\n\n  function getTemplateOptionByPath(source, path) {\n    if (!source || typeof source !== \"object\" || Array.isArray(source)) {\n      return undefined;\n    }\n    const parts = String(path || \"\").split(\".\").map((item) => String(item || \"\").trim()).filter(Boolean);\n    if (!parts.length) {\n      return undefined;\n    }\n\n    let current = source;\n    for (const part of parts) {\n      if (!current || typeof current !== \"object\" || Array.isArray(current)) {\n        return undefined;\n      }\n      if (!Object.prototype.hasOwnProperty.call(current, part)) {\n        return undefined;\n      }\n      current = current[part];\n    }\n    return current;\n  }\n\n  function readTemplateOptionValue(sources, paths) {\n    const sourceList = Array.isArray(sources) ? sources : [];\n    const pathList = Array.isArray(paths) ? paths : [];\n    for (const source of sourceList) {\n      for (const path of pathList) {\n        const value = getTemplateOptionByPath(source, path);\n        if (value !== undefined) {\n          return value;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  function normalizeTemplatePreviewOptions(optionSource, templateDef, rangeSource) {\n    const sources = [optionSource, templateDef, rangeSource];\n    const hideEmptyRows = parseTemplateOptionBoolean(readTemplateOptionValue(sources, [\n      \"hideEmptyRows\",\n      \"removeEmptyRows\",\n      \"compact.removeEmptyRows\"\n    ]), true);\n    const hideRowsWithoutValues = parseTemplateOptionBoolean(readTemplateOptionValue(sources, [\n      \"hideRowsWithoutValues\",\n      \"removeEmptyRowsAdvanced\",\n      \"removeEmptyRowsAdv\",\n      \"compact.removeEmptyRowsAdvanced\",\n      \"compact.removeEmptyRowsAdv\"\n    ]), true);\n    const expandMultilineRows = parseTemplateOptionBoolean(readTemplateOptionValue(sources, [\n      \"expandMultilineRows\",\n      \"expandArrayRows\",\n      \"arrayToRows\"\n    ]), false);\n    const squareCells = parseTemplateOptionBoolean(readTemplateOptionValue(sources, [\n      \"squareCells\",\n      \"squareCellsEnabled\",\n      \"fixedSquareCells\"\n    ]), true);\n    const squareCellSize = parseTemplateOptionNumber(readTemplateOptionValue(sources, [\n      \"squareCellSize\",\n      \"squareCellSizePx\",\n      \"cellSize\",\n      \"cellSizePx\"\n    ]), 18, 16, 240);\n\n    return {\n      hideEmptyRows,\n      hideRowsWithoutValues,\n      expandMultilineRows,\n      squareCells,\n      squareCellSize\n    };\n  }\n\n  function isTemplateRangeMetaKey(rawKey) {\n    const key = String(rawKey || \"\").trim().toLowerCase();\n    if (!key) {\n      return false;\n    }\n    return (\n      key === \"_options\"\n      || key === \"options\"\n      || key === \"ranges\"\n      || key === \"compact\"\n      || key === \"hideemptyrows\"\n      || key === \"hiderowswithoutvalues\"\n      || key === \"expandmultilinerows\"\n      || key === \"removeemptyrows\"\n      || key === \"removeemptyrowsadvanced\"\n      || key === \"removeemptyrowsadv\"\n      || key === \"expandarrayrows\"\n      || key === \"arraytorows\"\n      || key === \"squarecells\"\n      || key === \"squarecellsenabled\"\n      || key === \"fixedsquarecells\"\n      || key === \"squarecellsize\"\n      || key === \"squarecellsizepx\"\n      || key === \"cellsize\"\n      || key === \"cellsizepx\"\n    );\n  }\n\n  function resolveTemplateDefinitionForPreview(definition) {\n    if (!definition || typeof definition !== \"object\" || Array.isArray(definition)) {\n      return {\n        map: null,\n        options: normalizeTemplatePreviewOptions(null, null, null)\n      };\n    }\n\n    const hasRanges = definition.ranges && typeof definition.ranges === \"object\" && !Array.isArray(definition.ranges);\n    const rangeSource = hasRanges ? definition.ranges : definition;\n    const optionSource = (definition._options && typeof definition._options === \"object\" && !Array.isArray(definition._options))\n      ? definition._options\n      : ((definition.options && typeof definition.options === \"object\" && !Array.isArray(definition.options))\n        ? definition.options\n        : null);\n    const options = normalizeTemplatePreviewOptions(optionSource, definition, rangeSource);\n\n    const map = {};\n    for (const [key, value] of Object.entries(rangeSource)) {\n      if (isTemplateRangeMetaKey(key)) {\n        continue;\n      }\n      map[key] = value;\n    }\n\n    return { map, options };\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/template/03-preview-render.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/03-template-preview.js";
  const partKey = "viewer/app/template/03-preview-render.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "  }\n\n  function splitTemplateTextLines(text) {\n    const normalized = String(text === undefined || text === null ? \"\" : text)\n      .replace(/\\r\\n/g, \"\\n\")\n      .replace(/\\r/g, \"\\n\");\n    if (normalized === \"\") {\n      return [\"\"];\n    }\n    return normalized.split(\"\\n\");\n  }\n\n  function getTemplateTextLine(lines, index) {\n    const list = Array.isArray(lines) && lines.length ? lines : [\"\"];\n    const idx = Number(index) || 0;\n    if (idx < list.length) {\n      return String(list[idx] || \"\");\n    }\n    return String(list[list.length - 1] || \"\");\n  }\n\n  function cloneTemplateMatrixCell(cell) {\n    if (!cell || typeof cell !== \"object\") {\n      return createTemplateCellModel();\n    }\n    return {\n      text: String(cell.text || \"\"),\n      style: { ...(cell.style && typeof cell.style === \"object\" ? cell.style : {}) },\n      hidden: Boolean(cell.hidden),\n      rowspan: Number(cell.rowspan) || 1,\n      colspan: Number(cell.colspan) || 1,\n      hasPlaceholder: Boolean(cell.hasPlaceholder),\n      hasTokenValue: Boolean(cell.hasTokenValue)\n    };\n  }\n\n  function expandTemplateMatrixRows(matrix) {\n    const rows = Array.isArray(matrix)\n      ? matrix.map((row) => (Array.isArray(row) ? row.map((cell) => cloneTemplateMatrixCell(cell)) : []))\n      : [];\n    if (!rows.length) {\n      return rows;\n    }\n\n    for (let rowIndex = rows.length - 1; rowIndex >= 0; rowIndex -= 1) {\n      const row = rows[rowIndex];\n      if (!Array.isArray(row) || !row.length) {\n        continue;\n      }\n\n      const hasMergedCells = row.some((cell) => cell && (cell.hidden || cell.rowspan > 1 || cell.colspan > 1));\n      if (hasMergedCells) {\n        continue;\n      }\n\n      const lineByCol = new Map();\n      let maxLines = 1;\n      for (let colIndex = 0; colIndex < row.length; colIndex += 1) {\n        const cell = row[colIndex];\n        if (!cell || cell.hidden) {\n          continue;\n        }\n        const lines = splitTemplateTextLines(cell.text);\n        lineByCol.set(colIndex, lines);\n        maxLines = Math.max(maxLines, lines.length);\n      }\n\n      if (maxLines <= 1) {\n        continue;\n      }\n\n      for (let colIndex = 0; colIndex < row.length; colIndex += 1) {\n        const cell = row[colIndex];\n        if (!cell || cell.hidden) {\n          continue;\n        }\n        const lines = lineByCol.get(colIndex) || [String(cell.text || \"\")];\n        cell.text = getTemplateTextLine(lines, 0);\n      }\n\n      const extraRows = [];\n      for (let lineIndex = 1; lineIndex < maxLines; lineIndex += 1) {\n        const extraRow = row.map((cell) => cloneTemplateMatrixCell(cell));\n        for (let colIndex = 0; colIndex < extraRow.length; colIndex += 1) {\n          const cell = extraRow[colIndex];\n          if (!cell || cell.hidden) {\n            continue;\n          }\n          const lines = lineByCol.get(colIndex) || [String(cell.text || \"\")];\n          cell.text = getTemplateTextLine(lines, lineIndex);\n        }\n        extraRows.push(extraRow);\n      }\n\n      if (extraRows.length) {\n        rows.splice(rowIndex + 1, 0, ...extraRows);\n      }\n    }\n\n    return rows;\n  }\n\n  function isTemplateRowBlank(row) {\n    const list = Array.isArray(row) ? row : [];\n    for (const cell of list) {\n      if (!cell || cell.hidden) {\n        continue;\n      }\n      if (String(cell.text || \"\").trim() !== \"\") {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function getTemplateRowPlaceholderState(row) {\n    const list = Array.isArray(row) ? row : [];\n    let hasPlaceholder = false;\n    let hasTokenValue = false;\n    for (const cell of list) {\n      if (!cell || cell.hidden) {\n        continue;\n      }\n      if (cell.hasPlaceholder) {\n        hasPlaceholder = true;\n      }\n      if (cell.hasTokenValue) {\n        hasTokenValue = true;\n      }\n    }\n    return { hasPlaceholder, hasTokenValue };\n  }\n\n  function compactTemplateMatrixRows(matrix, options) {\n    const rows = Array.isArray(matrix) ? matrix : [];\n    if (!rows.length) {\n      return rows;\n    }\n\n    const removeAdvanced = options && options.hideRowsWithoutValues === true;\n    const removeEmpty = removeAdvanced || (options && options.hideEmptyRows === true);\n    if (!removeAdvanced && !removeEmpty) {\n      return rows;\n    }\n\n    const out = [];\n    for (const row of rows) {\n      const rowBlank = isTemplateRowBlank(row);\n      if (removeAdvanced) {\n        const stateRow = getTemplateRowPlaceholderState(row);\n        if (rowBlank || (stateRow.hasPlaceholder && !stateRow.hasTokenValue)) {\n          continue;\n        }\n        out.push(row);\n        continue;\n      }\n\n      if (removeEmpty && rowBlank) {\n        continue;\n      }\n      out.push(row);\n    }\n\n    return out;\n  }\n\n  function applyTemplatePreviewOptions(matrix, options) {\n    let next = Array.isArray(matrix) ? matrix : [];\n    if (!next.length) {\n      return next;\n    }\n    if (options && options.expandMultilineRows === true) {\n      next = expandTemplateMatrixRows(next);\n    }\n    return compactTemplateMatrixRows(next, options);\n  }\n\n  function buildTemplateGridModel(obj, templateMap, templateOptions) {\n    const map = templateMap && typeof templateMap === \"object\" ? templateMap : {};\n    const options = templateOptions && typeof templateOptions === \"object\"\n      ? templateOptions\n      : normalizeTemplatePreviewOptions(null, null, null);\n    const entries = [];\n    const errors = [];\n    let maxRow = 0;\n    let maxCol = 0;\n\n    for (const rangeKey of Object.keys(map)) {\n      if (isTemplateRangeMetaKey(rangeKey)) {\n        continue;\n      }\n      try {\n        const parsedRange = parseRangeKey(rangeKey);\n        entries.push({\n          rangeKey,\n          parsedRange,\n          config: map[rangeKey] && typeof map[rangeKey] === \"object\" ? map[rangeKey] : {}\n        });\n        maxRow = Math.max(maxRow, parsedRange.r2);\n        maxCol = Math.max(maxCol, parsedRange.c2);\n      } catch (err) {\n        errors.push(`${rangeKey}: ${err && err.message ? err.message : err}`);\n      }\n    }\n\n    if (!entries.length) {\n      return {\n        matrix: [],\n        maxRow: 0,\n        maxCol: 0,\n        errors\n      };\n    }\n\n    const matrix = Array.from({ length: maxRow }, () =>\n      Array.from({ length: maxCol }, () => createTemplateCellModel())\n    );\n\n    for (const entry of entries) {\n      const cfg = entry.config;\n      const range = entry.parsedRange;\n      const hasText = Object.prototype.hasOwnProperty.call(cfg, \"text\");\n      const textMeta = hasText ? resolveTemplateText(cfg.text, obj) : null;\n      const merge = cfg && cfg.merge === true;\n\n      if (merge) {\n        for (let row = range.r1; row <= range.r2; row += 1) {\n          for (let col = range.c1; col <= range.c2; col += 1) {\n            const cell = matrix[row - 1][col - 1];\n            if (!cell) {\n              continue;\n            }\n            const isAnchor = row === range.r1 && col === range.c1;\n            if (isAnchor) {\n              cell.hidden = false;\n              cell.rowspan = range.r2 - range.r1 + 1;\n              cell.colspan = range.c2 - range.c1 + 1;\n              if (hasText) {\n                cell.text = String(textMeta && textMeta.text ? textMeta.text : \"\");\n                cell.hasPlaceholder = cell.hasPlaceholder || Boolean(textMeta && textMeta.hasPlaceholder);\n                cell.hasTokenValue = cell.hasTokenValue || Boolean(textMeta && textMeta.hasTokenValue);\n              }\n              const cellStyle = buildTemplateCellStyle(cfg, {\n                isTop: true,\n                isRight: true,\n                isBottom: true,\n                isLeft: true,\n                isMergeAnchor: true\n              });\n              cell.style = { ...cell.style, ...cellStyle };\n            } else {\n              cell.hidden = true;\n              cell.rowspan = 1;\n              cell.colspan = 1;\n            }\n          }\n        }\n        continue;\n      }\n\n      for (let row = range.r1; row <= range.r2; row += 1) {\n        for (let col = range.c1; col <= range.c2; col += 1) {\n          const cell = matrix[row - 1][col - 1];\n          if (!cell) {\n            continue;\n          }\n          cell.hidden = false;\n          cell.rowspan = 1;\n          cell.colspan = 1;\n          if (hasText) {\n            cell.text = String(textMeta && textMeta.text ? textMeta.text : \"\");\n            cell.hasPlaceholder = cell.hasPlaceholder || Boolean(textMeta && textMeta.hasPlaceholder);\n            cell.hasTokenValue = cell.hasTokenValue || Boolean(textMeta && textMeta.hasTokenValue);\n          }\n          const cellStyle = buildTemplateCellStyle(cfg, {\n            isTop: row === range.r1,\n            isRight: col === range.c2,\n            isBottom: row === range.r2,\n            isLeft: col === range.c1,\n            isMergeAnchor: false\n          });\n          cell.style = { ...cell.style, ...cellStyle };\n        }\n      }\n    }\n\n    const compactedMatrix = applyTemplatePreviewOptions(matrix, options);\n    return {\n      matrix: compactedMatrix,\n      maxRow: compactedMatrix.length,\n      maxCol,\n      errors,\n      options\n    };\n  }\n\n  function renderTemplateTable(model) {\n    const matrix = model && Array.isArray(model.matrix) ? model.matrix : [];\n    if (!matrix.length) {\n      return null;\n    }\n    const options = model && model.options && typeof model.options === \"object\"\n      ? model.options\n      : normalizeTemplatePreviewOptions(null, null, null);\n    const squareCells = options.squareCells === true;\n    const squareCellSize = parseTemplateOptionNumber(options.squareCellSize, 18, 16, 240);\n\n    const table = el(\"table\", {\n      className: \"template-preview-table\",\n      attrs: {\n        style: \"border-collapse:collapse;table-layout:fixed;width:max-content;min-width:100%;\"\n      }\n    });\n    const tbody = el(\"tbody\");\n\n    for (let rowIndex = 0; rowIndex < matrix.length; rowIndex += 1) {\n      const row = matrix[rowIndex];\n      const tr = el(\"tr\");\n      for (let colIndex = 0; colIndex < row.length; colIndex += 1) {\n        const cell = row[colIndex];\n        if (!cell || cell.hidden) {\n          continue;\n        }\n\n        const td = document.createElement(\"td\");\n        if (cell.rowspan > 1) {\n          td.rowSpan = cell.rowspan;\n        }\n        if (cell.colspan > 1) {\n          td.colSpan = cell.colspan;\n        }\n\n        td.textContent = String(cell.text || \"\");\n        const colSpan = Math.max(1, Number(td.colSpan) || 1);\n        const rowSpan = Math.max(1, Number(td.rowSpan) || 1);\n        const baseMinWidth = squareCells ? `${squareCellSize}px` : \"56px\";\n        const baseMaxWidth = squareCells ? `${squareCellSize}px` : \"360px\";\n        const baseWidth = squareCells ? `${squareCellSize * colSpan}px` : \"\";\n        const baseMinHeight = squareCells ? `${squareCellSize}px` : \"\";\n        const baseHeight = squareCells ? `${squareCellSize * rowSpan}px` : \"\";\n        const baseTextOverflow = squareCells ? \"ellipsis\" : \"\";\n        const cssText = toInlineCssText({\n          \"min-width\": baseMinWidth,\n          \"max-width\": baseMaxWidth,\n          width: baseWidth,\n          \"min-height\": baseMinHeight,\n          height: baseHeight,\n          padding: \"4px 6px\",\n          border: \"none\",\n          \"vertical-align\": \"top\",\n          \"white-space\": \"pre-wrap\",\n          \"text-overflow\": baseTextOverflow,\n          \"box-sizing\": \"border-box\",\n          \"font-size\": \"10pt\",\n          \"font-family\": \"\\\"MS PGothic\\\", \\\"MS UI Gothic\\\", Meiryo, sans-serif\",\n          color: \"#111111\",\n          \"background-color\": \"#ffffff\",\n          ...cell.style\n        });\n        if (cssText) {\n          td.setAttribute(\"style\", cssText);\n        }\n\n        tr.appendChild(td);\n      }\n      tbody.appendChild(tr);\n    }\n\n    table.appendChild(tbody);\n    return table;\n  }\n\n  async function copyHtmlWithFallback(html, plainText) {\n    const safeHtml = String(html || \"\");\n    const safeText = String(plainText || \"\");\n\n    if (\n      safeHtml\n      && navigator.clipboard\n      && typeof navigator.clipboard.write === \"function\"\n      && typeof window.ClipboardItem === \"function\"\n    ) {\n      const item = new window.ClipboardItem({\n        \"text/html\": new Blob([safeHtml], { type: \"text/html\" }),\n        \"text/plain\": new Blob([safeText], { type: \"text/plain\" })\n      });\n      await navigator.clipboard.write([item]);\n      return;\n    }\n\n    if (navigator.clipboard && typeof navigator.clipboard.writeText === \"function\") {\n      await navigator.clipboard.writeText(safeText);\n      return;\n    }\n\n    const temp = document.createElement(\"div\");\n    temp.style.position = \"fixed\";\n    temp.style.left = \"-99999px\";\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/template/04-copy-import-export.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/03-template-preview.js";
  const partKey = "viewer/app/template/04-copy-import-export.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    temp.style.top = \"0\";\n    temp.setAttribute(\"contenteditable\", \"true\");\n    temp.innerHTML = safeHtml || safeText.replace(/\\n/g, \"<br>\");\n    document.body.appendChild(temp);\n\n    const selection = window.getSelection();\n    if (!selection) {\n      document.body.removeChild(temp);\n      throw new Error(\"Clipboard selection is unavailable.\");\n    }\n\n    selection.removeAllRanges();\n    const range = document.createRange();\n    range.selectNodeContents(temp);\n    selection.addRange(range);\n    const copied = document.execCommand(\"copy\");\n    selection.removeAllRanges();\n    document.body.removeChild(temp);\n\n    if (!copied) {\n      throw new Error(\"Copy failed in this browser.\");\n    }\n  }\n\n  async function copyHtmlWithFallback(html, plainText) {\n    const safeHtml = String(html || \"\");\n    const safeText = String(plainText || \"\");\n    const clipboard = typeof navigator !== \"undefined\" && navigator ? navigator.clipboard : null;\n    let lastClipboardError = null;\n\n    if (\n      safeHtml\n      && clipboard\n      && typeof clipboard.write === \"function\"\n      && typeof window.ClipboardItem === \"function\"\n    ) {\n      try {\n        const item = new window.ClipboardItem({\n          \"text/html\": new Blob([safeHtml], { type: \"text/html\" }),\n          \"text/plain\": new Blob([safeText], { type: \"text/plain\" })\n        });\n        await clipboard.write([item]);\n        return;\n      } catch (err) {\n        lastClipboardError = err;\n      }\n    }\n\n    if (clipboard && typeof clipboard.writeText === \"function\") {\n      try {\n        await clipboard.writeText(safeText);\n        return;\n      } catch (err) {\n        lastClipboardError = err;\n      }\n    }\n\n    const temp = document.createElement(\"div\");\n    temp.style.position = \"fixed\";\n    temp.style.left = \"-99999px\";\n    temp.style.top = \"0\";\n    temp.setAttribute(\"contenteditable\", \"true\");\n    temp.innerHTML = safeHtml || safeText.replace(/\\n/g, \"<br>\");\n    document.body.appendChild(temp);\n\n    const selection = window.getSelection();\n    if (!selection) {\n      document.body.removeChild(temp);\n      if (lastClipboardError) {\n        throw lastClipboardError;\n      }\n      throw new Error(\"Clipboard selection is unavailable.\");\n    }\n\n    selection.removeAllRanges();\n    const range = document.createRange();\n    range.selectNodeContents(temp);\n    selection.addRange(range);\n    const copied = document.execCommand(\"copy\");\n    selection.removeAllRanges();\n    document.body.removeChild(temp);\n\n    if (!copied) {\n      if (lastClipboardError) {\n        throw lastClipboardError;\n      }\n      throw new Error(\"Copy failed in this browser.\");\n    }\n  }\n\n  function resolveTemplateMapForObject(obj, config) {\n    const templates = config && typeof config === \"object\" && config.templates && typeof config.templates === \"object\"\n      ? config.templates\n      : {};\n    const objectType = obj && obj.objectType ? String(obj.objectType) : \"\";\n    if (objectType && Object.prototype.hasOwnProperty.call(templates, objectType)) {\n      const resolved = resolveTemplateDefinitionForPreview(templates[objectType]);\n      return { key: objectType, map: resolved.map, options: resolved.options };\n    }\n    if (Object.prototype.hasOwnProperty.call(templates, \"DEFAULT\")) {\n      const resolved = resolveTemplateDefinitionForPreview(templates.DEFAULT);\n      return { key: \"DEFAULT\", map: resolved.map, options: resolved.options };\n    }\n    const resolved = resolveTemplateDefinitionForPreview(null);\n    return { key: \"\", map: null, options: resolved.options };\n  }\n\n  function buildTemplatePlainTextFromBlock(block) {\n    if (!block) {\n      return \"\";\n    }\n    return String(block.innerText || block.textContent || \"\").trim();\n  }\n\n  function isTemplateCopyTableOnlyEnabled() {\n    return Boolean(els.templateCopyTableOnly && els.templateCopyTableOnly.checked);\n  }\n\n  function buildTemplateCopyPayloadFromBlock(block) {\n    if (!block || typeof block.cloneNode !== \"function\") {\n      return { node: null, text: \"\" };\n    }\n\n    const clone = block.cloneNode(true);\n    const actionButtons = clone.querySelectorAll(\"[data-template-action]\");\n    for (const actionBtn of Array.from(actionButtons)) {\n      actionBtn.remove();\n    }\n\n    if (isTemplateCopyTableOnlyEnabled()) {\n      const table = clone.querySelector(\".template-preview-table\");\n      if (table) {\n        return {\n          node: table.cloneNode(true),\n          text: buildTemplatePlainTextFromBlock(table)\n        };\n      }\n    }\n\n    return {\n      node: clone,\n      text: buildTemplatePlainTextFromBlock(clone)\n    };\n  }\n\n  function getRenderableObjectListForTemplate() {\n    const out = [];\n    const roots = Array.isArray(state.renderObjects) ? state.renderObjects : [];\n\n    const appendNode = (obj, depth) => {\n      if (!obj || typeof obj !== \"object\") {\n        return;\n      }\n      out.push({ obj, depth: Math.max(0, Number(depth) || 0) });\n\n      const children = Array.isArray(obj.children) ? obj.children : [];\n      for (const child of children) {\n        appendNode(child, (Number(depth) || 0) + 1);\n      }\n    };\n\n    for (const root of roots) {\n      appendNode(root, 0);\n    }\n\n    return out;\n  }\n\n  function renderTemplatePreview() {\n    if (!els.templatePreviewOutput) {\n      return;\n    }\n\n    if (!state.data || !Array.isArray(state.renderObjects)) {\n      setTemplatePreviewMessage(\"No data loaded.\");\n      return;\n    }\n\n    const config = state.templateConfig && typeof state.templateConfig === \"object\"\n      ? state.templateConfig\n      : getDefaultTemplateConfig();\n\n    const check = validateTemplateConfig(config);\n    if (!check.valid) {\n      setTemplatePreviewMessage(\"Template config is invalid.\");\n      setTemplateConfigError(check.errors.join(\"\\n\"));\n      return;\n    }\n\n    const items = getRenderableObjectListForTemplate();\n    if (!items.length) {\n      setTemplatePreviewMessage(\"No renderable objects.\");\n      return;\n    }\n\n    const fragment = document.createDocumentFragment();\n    for (let index = 0; index < items.length; index += 1) {\n      const item = items[index];\n      const obj = item.obj;\n      const depth = Math.max(0, Number(item.depth) || 0);\n      const templateContextObj = buildTemplateContextObject(obj, index + 1);\n      const resolved = resolveTemplateMapForObject(obj, config);\n\n      const blockAttrs = { \"data-template-index\": String(index), \"data-depth\": String(depth) };\n      const lineStart = Number(obj && obj.lineStart) || 0;\n      if (lineStart > 0) {\n        blockAttrs[\"data-line-start\"] = String(lineStart);\n      }\n      const block = el(\"div\", { className: \"template-block\", attrs: blockAttrs });\n      const indentPx = Math.min(120, depth * 12);\n      if (indentPx > 0) {\n        block.style.marginLeft = `${indentPx}px`;\n      } else {\n        block.style.marginLeft = \"\";\n      }\n      const header = el(\"div\", { className: \"template-block-header\" });\n\n      const left = el(\"div\");\n      const label = getObjectLabel(obj);\n      const titleText = `${index + 1}. ${String(obj.objectType || \"OBJECT\")}${label ? ` ${label}` : \"\"}`;\n      left.appendChild(el(\"h4\", { className: \"template-block-title\", text: titleText }));\n      const meta = renderMeta(obj);\n      const keyText = resolved.key ? `template=${resolved.key}` : \"template=missing\";\n      left.appendChild(el(\"div\", { className: \"template-block-meta\", text: [meta, keyText].filter(Boolean).join(\" • \") }));\n      header.appendChild(left);\n\n      const actions = el(\"div\", { className: \"template-block-actions\" });\n      const codeBtn = el(\"button\", {\n        className: \"secondary\",\n        text: \"Code\",\n        attrs: { type: \"button\", \"data-template-action\": \"code\" }\n      });\n      codeBtn.addEventListener(\"click\", () => {\n        const selectedIndex = String(index);\n        if (typeof setSelectedTemplateBlock === \"function\") {\n          setSelectedTemplateBlock(selectedIndex);\n        } else {\n          state.selectedTemplateIndex = selectedIndex;\n        }\n        if (lineStart > 0 && typeof selectCodeLines === \"function\") {\n          const lineEnd = Number(obj && obj.block && obj.block.lineEnd) || lineStart;\n          selectCodeLines(lineStart, lineEnd);\n        }\n      });\n      actions.appendChild(codeBtn);\n\n      const pathsBtn = el(\"button\", {\n        className: \"secondary\",\n        text: \"Paths\",\n        attrs: { type: \"button\", \"data-template-action\": \"paths\" }\n      });\n      pathsBtn.addEventListener(\"click\", (ev) => {\n        if (ev && typeof ev.stopPropagation === \"function\") {\n          ev.stopPropagation();\n        }\n        openTemplatePathDump(templateContextObj, index, obj);\n      });\n      actions.appendChild(pathsBtn);\n\n      const copyBtn = el(\"button\", {\n        className: \"secondary\",\n        text: \"Copy\",\n        attrs: { type: \"button\", \"data-template-action\": \"copy\" }\n      });\n      copyBtn.addEventListener(\"click\", async () => {\n        try {\n          const payload = buildTemplateCopyPayloadFromBlock(block);\n          if (!payload.node) {\n            setError(\"Nothing to copy.\");\n            return;\n          }\n          await copyHtmlWithFallback(payload.node.outerHTML, payload.text);\n          setError(\"\");\n        } catch (err) {\n          setError(`Copy failed: ${err && err.message ? err.message : err}`);\n        }\n      });\n      actions.appendChild(copyBtn);\n      header.appendChild(actions);\n      block.appendChild(header);\n      block.addEventListener(\"click\", () => {\n        const selectedIndex = String(index);\n        if (typeof setSelectedTemplateBlock === \"function\") {\n          setSelectedTemplateBlock(selectedIndex, { scroll: false });\n        } else {\n          state.selectedTemplateIndex = selectedIndex;\n        }\n      });\n\n      if (!resolved.map || typeof resolved.map !== \"object\") {\n        block.appendChild(el(\"div\", { className: \"template-empty\", text: \"[Missing template]\" }));\n        fragment.appendChild(block);\n        continue;\n      }\n\n      const model = buildTemplateGridModel(templateContextObj, resolved.map, resolved.options);\n      if (model.errors.length) {\n        block.appendChild(el(\"div\", { className: \"template-error\", text: model.errors.join(\"\\n\") }));\n      }\n\n      const table = renderTemplateTable(model);\n      if (table) {\n        block.appendChild(table);\n      } else {\n        block.appendChild(el(\"div\", { className: \"template-empty\", text: \"[Missing template]\" }));\n      }\n\n      fragment.appendChild(block);\n    }\n\n    els.templatePreviewOutput.classList.remove(\"muted\");\n    els.templatePreviewOutput.replaceChildren(fragment);\n    state.templatePreviewCache = { count: items.length };\n    if (state.selectedTemplateIndex !== \"\" && typeof setSelectedTemplateBlock === \"function\") {\n      setSelectedTemplateBlock(state.selectedTemplateIndex, { scroll: false });\n    }\n    if (typeof refreshInputGutterTargets === \"function\") {\n      refreshInputGutterTargets();\n    }\n  }\n\n  function syncTemplateEditorFromState() {\n    if (!els.templateConfigJson) {\n      return;\n    }\n    const pretty = safeJson(state.templateConfig || getDefaultTemplateConfig(), true);\n    state.templateConfigDraft = pretty;\n    els.templateConfigJson.value = pretty;\n  }\n\n  function applyTemplateConfigObject(config, options) {\n    const opts = options && typeof options === \"object\" ? options : {};\n    const check = validateTemplateConfig(config);\n    if (!check.valid) {\n      setTemplateConfigError(check.errors.join(\"\\n\"));\n      return false;\n    }\n\n    const next = cloneJsonValue(config);\n    if (!next || typeof next !== \"object\") {\n      setTemplateConfigError(\"Cannot clone template config.\");\n      return false;\n    }\n\n    state.templateConfig = next;\n    if (opts.save !== false) {\n      saveTemplateConfig(next);\n    }\n    setTemplateConfigError(\"\");\n    syncTemplateEditorFromState();\n    renderTemplatePreview();\n    return true;\n  }\n\n  function applyTemplateConfigFromEditor() {\n    const raw = els.templateConfigJson ? String(els.templateConfigJson.value || \"\").trim() : \"\";\n    if (!raw) {\n      setTemplateConfigError(\"Template config JSON is empty.\");\n      return;\n    }\n\n    let parsed = null;\n    try {\n      parsed = JSON.parse(raw);\n    } catch (err) {\n      setTemplateConfigError(`JSON parse error: ${err && err.message ? err.message : err}`);\n      return;\n    }\n\n    applyTemplateConfigObject(parsed, { save: true });\n  }\n\n  function resetTemplateConfig() {\n    applyTemplateConfigObject(getDefaultTemplateConfig(), { save: true });\n  }\n\n  function exportTemplateConfig() {\n    const config = state.templateConfig || getDefaultTemplateConfig();\n    const content = safeJson(config, true);\n    const fileName = \"abap-template-config.json\";\n\n    try {\n      const blob = new Blob([content], { type: \"application/json\" });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = fileName;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n      setError(\"\");\n    } catch (err) {\n      setError(`Export failed: ${err && err.message ? err.message : err}`);\n    }\n  }\n\n  async function importTemplateConfigFromFile(file) {\n    if (!file) {\n      return;\n    }\n\n    let text = \"\";\n    try {\n      text = await file.text();\n    } catch (err) {\n      setTemplateConfigError(`Import failed: ${err && err.message ? err.message : err}`);\n      return;\n    }\n\n    try {\n      const parsed = JSON.parse(text);\n      const applied = applyTemplateConfigObject(parsed, { save: true });\n      if (applied) {\n        setError(\"\");\n      }\n    } catch (err) {\n      setTemplateConfigError(`Import JSON parse error: ${err && err.message ? err.message : err}`);\n    }\n  }\n\n  async function copyAllTemplateBlocks() {\n    if (!els.templatePreviewOutput) {\n      return;\n    }\n    const blocks = Array.from(els.templatePreviewOutput.querySelectorAll(\".template-block\"));\n    if (!blocks.length) {\n      setError(\"Nothing to copy.\");\n      return;\n    }\n\n    const wrapper = document.createElement(\"div\");\n    const plainLines = [];\n    const tableOnly = isTemplateCopyTableOnlyEnabled();\n    for (const block of blocks) {\n      const payload = buildTemplateCopyPayloadFromBlock(block);\n      if (!payload.node) {\n        continue;\n      }\n      wrapper.appendChild(payload.node);\n      if (tableOnly) {\n        wrapper.appendChild(document.createElement(\"br\"));\n      }\n      plainLines.push(payload.text);\n    }\n\n    if (!wrapper.childNodes.length) {\n      setError(\"Nothing to copy.\");\n      return;\n    }\n\n    await copyHtmlWithFallback(wrapper.innerHTML, plainLines.filter(Boolean).join(\"\\n\\n\"));\n  }\n\nwindow.AbapViewerModules.factories = window.AbapViewerModules.factories || {};\nwindow.AbapViewerModules.factories[\"03-template-preview\"] = function registerTemplatePreview(runtime) {\n  const targetRuntime = runtime || (window.AbapViewerRuntime = window.AbapViewerRuntime || {});\n  targetRuntime.api = targetRuntime.api || {};\n  targetRuntime.api.renderTemplatePreview = renderTemplatePreview;\n  targetRuntime.api.applyTemplateConfigFromEditor = applyTemplateConfigFromEditor;\n  window.AbapViewerModules.parts[\"03-template-preview\"] = true;\n};\nwindow.AbapViewerModules.factories[\"03-template-preview\"](window.AbapViewerRuntime);\n\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/03-template-preview.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/03-template-preview.js";
  const bucket = registry[targetKey] || {};
  const orderedParts = [
    "viewer/app/template/01-path-resolver.js",
    "viewer/app/template/02-grid-and-style.js",
    "viewer/app/template/03-preview-render.js",
    "viewer/app/template/04-copy-import-export.js"
  ];

  const missing = orderedParts.filter((part) => typeof bucket[part] !== "string");
  if (missing.length) {
    const message = `Source parts missing for ${targetKey}: ${missing.join(", ")}`;
    try {
      if (globalRoot.console && typeof globalRoot.console.error === "function") {
        globalRoot.console.error(message);
      }
    } catch {
      // ignore
    }
    return;
  }

  const source = orderedParts.map((part) => bucket[part]).join("\n");
  if (typeof document !== "undefined" && document.createElement) {
    const script = document.createElement("script");
    script.type = "text/javascript";
    script.setAttribute("data-abap-source-wrapper", targetKey);
    script.textContent = `${source}\n//# sourceURL=${targetKey}`;
    (document.head || document.documentElement || document.body).appendChild(script);
    script.remove();
  } else {
    (0, eval)(source);
  }
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/output/01-xml-export.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/01-xml-export.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\"use strict\";\n\nwindow.AbapViewerModules = window.AbapViewerModules || {};\nwindow.AbapViewerModules.parts = window.AbapViewerModules.parts || {};\n\n  function isValueLikeEntryObject(value) {\n    if (!isPlainObjectRecord(value)) {\n      return false;\n    }\n    if (isDeclLikeObject(value) || isAbapStatementObject(value)) {\n      return false;\n    }\n    return (\n      hasValueLevelDescFields(value)\n      || Object.prototype.hasOwnProperty.call(value, \"declRef\")\n      || Object.prototype.hasOwnProperty.call(value, \"value\")\n      || Object.prototype.hasOwnProperty.call(value, \"name\")\n      || Object.prototype.hasOwnProperty.call(value, \"label\")\n    );\n  }\n\n  function isAssignmentLikeEntryObject(value) {\n    if (!isPlainObjectRecord(value)) {\n      return false;\n    }\n    if (isDeclLikeObject(value) || isAbapStatementObject(value)) {\n      return false;\n    }\n    const hasValueSignals = (\n      Object.prototype.hasOwnProperty.call(value, \"value\")\n      || Object.prototype.hasOwnProperty.call(value, \"valueRef\")\n      || Object.prototype.hasOwnProperty.call(value, \"valueDecl\")\n      || Object.prototype.hasOwnProperty.call(value, \"originDecls\")\n    );\n    if (!hasValueSignals) {\n      return false;\n    }\n    return (\n      Object.prototype.hasOwnProperty.call(value, \"name\")\n      || Object.prototype.hasOwnProperty.call(value, \"value\")\n      || Object.prototype.hasOwnProperty.call(value, \"valueRef\")\n    );\n  }\n\n  function isConditionClauseLikeObject(value) {\n    if (!isPlainObjectRecord(value)) {\n      return false;\n    }\n    return (\n      Object.prototype.hasOwnProperty.call(value, \"leftOperand\")\n      || Object.prototype.hasOwnProperty.call(value, \"rightOperand\")\n      || Object.prototype.hasOwnProperty.call(value, \"comparisonOperator\")\n    );\n  }\n\n  function normalizeEntryObjectForXml(value, keyHint, pathParts, ownerContext) {\n    if (!isPlainObjectRecord(value)) {\n      return value;\n    }\n    if (isDeclLikeObject(value) || isAbapStatementObject(value)) {\n      return value;\n    }\n\n    const pathKey = buildPathKeyFromParts(pathParts);\n    const pathLower = pathKey.toLowerCase();\n    const inValuesPath = pathLower.includes(\"/values/\");\n    const inExtrasPath = pathLower.includes(\"/extras/\");\n    const keyHintLower = String(keyHint || \"\").trim().toLowerCase();\n    const extrasItemLike = keyHintLower === \"item\";\n    const source = getDeclSourceContextFromObject(ownerContext);\n\n    let next = value;\n\n    if (inValuesPath && isValueLikeEntryObject(next)) {\n      next = ensureEntryDeclWithSynthetic(next, {\n        pathKey,\n        file: source.file,\n        lineStart: source.lineStart,\n        raw: source.raw,\n        role: \"xml:value\"\n      });\n    }\n\n    if (inExtrasPath && extrasItemLike) {\n      if (isConditionClauseLikeObject(next)) {\n        next = ensureConditionClauseDeclsWithSynthetic(next, {\n          pathKey,\n          file: source.file,\n          lineStart: source.lineStart,\n          raw: source.raw\n        });\n      }\n\n      if (isAssignmentLikeEntryObject(next)) {\n        next = ensureValueDeclWithSynthetic(next, {\n          pathKey,\n          file: source.file,\n          lineStart: source.lineStart,\n          raw: source.raw,\n          role: \"xml:extras:value\",\n          nameHint: String(keyHint || \"value\")\n        });\n      }\n\n      if (isValueLikeEntryObject(next)) {\n        next = ensureEntryDeclWithSynthetic(next, {\n          pathKey,\n          file: source.file,\n          lineStart: source.lineStart,\n          raw: source.raw,\n          role: \"xml:extras\"\n        });\n      }\n    }\n\n    return next;\n  }\n\n  function appendXmlValue(lines, keyHint, tagName, value, indent, pathParts, ownerContext) {\n    const pad = \" \".repeat(indent);\n    const currentPathParts = Array.isArray(pathParts) ? pathParts : [];\n    const currentOwnerContext = ownerContext && typeof ownerContext === \"object\" ? ownerContext : null;\n\n    if (value === undefined) {\n      return;\n    }\n\n    if (value === null) {\n      lines.push(`${pad}<${tagName}/>`);\n      return;\n    }\n\n    if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n      lines.push(`${pad}<${tagName}>${escapeXmlText(String(value))}</${tagName}>`);\n      return;\n    }\n\n    if (Array.isArray(value)) {\n      const itemTag = getArrayItemTagName(keyHint);\n      lines.push(`${pad}<${tagName}>`);\n      for (let index = 0; index < value.length; index += 1) {\n        const item = value[index];\n        const itemPathParts = currentPathParts.concat(`${itemTag}[${index + 1}]`);\n        appendXmlValue(lines, itemTag, itemTag, item, indent + 2, itemPathParts, currentOwnerContext);\n      }\n      lines.push(`${pad}</${tagName}>`);\n      return;\n    }\n\n    if (typeof value === \"object\") {\n      const nextOwnerContext = isAbapStatementObject(value) ? value : currentOwnerContext;\n      const normalizedValue = normalizeEntryObjectForXml(value, keyHint, currentPathParts, nextOwnerContext);\n      lines.push(`${pad}<${tagName}>`);\n\n      const valueIsDecl = isDeclObjectForXml(keyHint, normalizedValue);\n      let hasComputedFinalDesc = false;\n\n      if (valueIsDecl) {\n        const declDesc = getEffectiveDeclDesc(normalizedValue);\n        if (declDesc) {\n          lines.push(`${\" \".repeat(indent + 2)}<desc>${escapeXmlText(declDesc)}</desc>`);\n        } else {\n          lines.push(`${\" \".repeat(indent + 2)}<desc/>`);\n        }\n\n        const finalDeclDesc = getFinalDeclDesc(normalizedValue);\n        hasComputedFinalDesc = true;\n        if (finalDeclDesc) {\n          lines.push(`${\" \".repeat(indent + 2)}<finalDesc>${escapeXmlText(finalDeclDesc)}</finalDesc>`);\n        } else {\n          lines.push(`${\" \".repeat(indent + 2)}<finalDesc/>`);\n        }\n\n        const declName = getDeclDisplayName(normalizedValue) || getDeclTechName(normalizedValue);\n        lines.push(`${\" \".repeat(indent + 2)}<name>${escapeXmlText(declName)}</name>`);\n      }\n\n      if (!valueIsDecl) {\n        let shouldEmitFinalDesc = false;\n        let finalDesc = \"\";\n        if (hasValueLevelDescFields(normalizedValue)) {\n          shouldEmitFinalDesc = true;\n          finalDesc = resolveValueLevelFinalDesc(normalizedValue);\n        } else if (isDeclLikeObject(normalizedValue.decl)) {\n          shouldEmitFinalDesc = true;\n          finalDesc = getFinalDeclDesc(normalizedValue.decl);\n        }\n\n        if (shouldEmitFinalDesc) {\n          hasComputedFinalDesc = true;\n          if (finalDesc) {\n            lines.push(`${\" \".repeat(indent + 2)}<finalDesc>${escapeXmlText(finalDesc)}</finalDesc>`);\n          } else {\n            lines.push(`${\" \".repeat(indent + 2)}<finalDesc/>`);\n          }\n        }\n      }\n\n      const preferredOrder = [\n        \"id\",\n        \"parent\",\n        \"objectType\",\n        \"file\",\n        \"lineStart\",\n        \"comment\",\n        \"raw\",\n        \"keywords\",\n        \"values\",\n        \"extras\",\n        \"block\",\n        \"children\"\n      ];\n\n      const keys = Object.keys(normalizedValue);\n      keys.sort((a, b) => {\n        const ai = preferredOrder.indexOf(a);\n        const bi = preferredOrder.indexOf(b);\n        if (ai !== -1 || bi !== -1) {\n          return (ai === -1 ? 999 : ai) - (bi === -1 ? 999 : bi);\n        }\n        return a.localeCompare(b);\n      });\n\n      for (const key of keys) {\n        if (key === \"desc\" && valueIsDecl) {\n          // computed above\n          continue;\n        }\n        if (key === \"name\" && valueIsDecl) {\n          // computed above (normalized via settings)\n          continue;\n        }\n        if (key === \"finalDesc\" && hasComputedFinalDesc) {\n          continue;\n        }\n        const childTag = toXmlTagName(key);\n        appendXmlValue(\n          lines,\n          key,\n          childTag,\n          normalizedValue[key],\n          indent + 2,\n          currentPathParts.concat(key),\n          nextOwnerContext\n        );\n      }\n\n      lines.push(`${pad}</${tagName}>`);\n      return;\n    }\n\n    lines.push(`${pad}<${tagName}>${escapeXmlText(String(value))}</${tagName}>`);\n  }\n\n  function buildAbapFlowXml(data) {\n    const fileName = data && typeof data === \"object\" ? String(data.file || \"\") : \"\";\n    const objects = data && typeof data === \"object\" && Array.isArray(data.objects) ? data.objects : [];\n    const renderObjects = buildRenderableObjects(objects, RENDER_TREE_OPTIONS);\n    const exportRoots = buildXmlExportRoots(renderObjects);\n\n    const lines = ['<?xml version=\"1.0\" encoding=\"UTF-8\"?>', \"<abapflowObjects>\"];\n    if (fileName) {\n      lines.push(`  <file>${escapeXmlText(fileName)}</file>`);\n    }\n    lines.push(\"  <objects>\");\n    for (let index = 0; index < exportRoots.length; index += 1) {\n      const obj = exportRoots[index];\n      appendXmlValue(lines, \"object\", \"object\", obj, 4, [\"objects\", `object[${index + 1}]`], obj);\n    }\n    lines.push(\"  </objects>\");\n    lines.push(\"</abapflowObjects>\");\n\n    return lines.join(\"\\n\");\n  }\n\n  function walkObjects(roots, visit) {\n    const stack = Array.isArray(roots) ? roots.slice().reverse() : [];\n    while (stack.length) {\n      const node = stack.pop();\n      if (!node) {\n        continue;\n      }\n      visit(node);\n      const children = Array.isArray(node.children) ? node.children : [];\n      for (let i = children.length - 1; i >= 0; i -= 1) {\n        stack.push(children[i]);\n      }\n    }\n  }\n\n  function collectDeclSearchTextFromExtras(extras) {\n    if (!extras || typeof extras !== \"object\") {\n      return \"\";\n    }\n\n    const decls = [];\n    const addDecl = (decl) => {\n      if (decl && typeof decl === \"object\") {\n        decls.push(decl);\n      }\n    };\n    const addDeclList = (list) => {\n      if (!Array.isArray(list)) {\n        return;\n      }\n      for (const decl of list) {\n        addDecl(decl);\n      }\n    };\n\n    const collectFromAssignmentSections = (obj, sections) => {\n      for (const sectionName of sections) {\n        const list = obj && Array.isArray(obj[sectionName]) ? obj[sectionName] : [];\n        for (const entry of list) {\n          addDeclList(entry && entry.originDecls);\n          addDecl(entry && entry.valueDecl);\n        }\n      }\n    };\n\n    if (extras.callFunction) {\n      collectFromAssignmentSections(extras.callFunction, [\"exporting\", \"importing\", \"changing\", \"tables\", \"exceptions\"]);\n    }\n\n    if (extras.callMethod) {\n      collectFromAssignmentSections(extras.callMethod, [\"exporting\", \"importing\", \"changing\", \"receiving\", \"exceptions\"]);\n    }\n\n    if (extras.performCall) {\n      for (const sectionName of [\"using\", \"changing\", \"tables\"]) {\n        const list = Array.isArray(extras.performCall[sectionName]) ? extras.performCall[sectionName] : [];\n        for (const entry of list) {\n          addDeclList(entry && entry.originDecls);\n          addDecl(entry && entry.valueDecl);\n        }\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/output/02-search-index.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/02-search-index.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "      }\n    }\n\n    if (extras.form && Array.isArray(extras.form.params)) {\n      for (const param of extras.form.params) {\n        addDeclList(param && param.originDecls);\n      }\n    }\n\n    collectConditionDeclsFromExtras(extras, addDecl);\n\n    const seen = new Set();\n    const parts = [];\n    for (const decl of decls) {\n      const key = getDeclOverrideStorageKey(decl) || stringifyDecl(decl);\n      if (!key || seen.has(key)) {\n        continue;\n      }\n      seen.add(key);\n      parts.push(String(decl.name || \"\"));\n      const desc = getEffectiveDeclDesc(decl);\n      if (desc) {\n        parts.push(desc);\n      }\n    }\n\n    return parts.filter(Boolean).join(\"\\n\");\n  }\n\n  function buildSearchIndex(objects) {\n    const map = new Map();\n    walkObjects(objects, (obj) => {\n      const id = normalizeId(obj && obj.id);\n      if (!id) {\n        return;\n      }\n\n      const keywordEntries = getKeywordEntries(obj);\n      const keywordsText = keywordEntries.length\n        ? keywordEntries.map((k) => `${k.text || \"\"} ${k.label || \"\"}`.trim()).join(\"\\n\")\n        : \"\";\n\n      const valueEntries = getValueEntries(obj);\n      const valuesText = valueEntries.length\n        ? valueEntries\n            .map((v) => {\n              const declText = stringifyDecl(v && v.decl);\n              const declDesc = getEffectiveDeclDesc(v && v.decl);\n              return [\n                v && v.name ? String(v.name) : \"\",\n                v && v.value ? String(v.value) : \"\",\n                v && v.label ? String(v.label) : \"\",\n                v && v.codeDesc ? String(v.codeDesc) : \"\",\n                v && v.declRef ? String(v.declRef) : \"\",\n                declText,\n                declDesc\n              ]\n                .filter(Boolean)\n                .join(\" \");\n            })\n            .join(\"\\n\")\n        : \"\";\n\n      const extrasText = obj.extras && typeof obj.extras === \"object\" ? safeJson(obj.extras, false) : \"\";\n      const extrasDeclText = collectDeclSearchTextFromExtras(obj.extras);\n\n      const haystack = [\n        obj.objectType || \"\",\n        obj.raw || \"\",\n        obj.comment || \"\",\n        keywordsText,\n        valuesText,\n        extrasText,\n        extrasDeclText\n      ]\n        .filter(Boolean)\n        .join(\"\\n\")\n        .toLowerCase();\n\n      map.set(id, haystack);\n    });\n    return map;\n  }\n\n  function computeLineOffsets(text) {\n    const value = String(text || \"\");\n    const offsets = [0];\n    for (let i = 0; i < value.length; i += 1) {\n      if (value[i] === \"\\n\") {\n        offsets.push(i + 1);\n      }\n    }\n    return offsets;\n  }\n\n  function getSelectionRangeForLines(text, lineStart, lineEnd) {\n    const value = String(text || \"\");\n    const offsets = state.inputLineOffsets.length ? state.inputLineOffsets : computeLineOffsets(value);\n    const start = Math.max(1, Number(lineStart) || 1);\n    const end = Math.max(start, Number(lineEnd) || start);\n    const startLineIndex = start - 1;\n    const endLineIndex = end - 1;\n    const startOffset = offsets[startLineIndex] ?? 0;\n    const endOffset = offsets[endLineIndex + 1] ?? value.length;\n    return { start: startOffset, end: Math.max(startOffset, endOffset) };\n  }\n\n  function selectCodeLines(lineStart, lineEnd) {\n    const text = els.inputText.value || \"\";\n    state.inputLineOffsets = computeLineOffsets(text);\n    const range = getSelectionRangeForLines(text, lineStart, lineEnd);\n    els.inputText.focus();\n    els.inputText.setSelectionRange(range.start, range.end);\n    syncInputGutterScroll();\n  }\n\n  function scrollElementInContainer(container, element, options) {\n    if (!container || !element || typeof container.scrollTop !== \"number\") {\n      return;\n    }\n\n    const opts = options && typeof options === \"object\" ? options : {};\n    const mode = String(opts.mode || \"nearest\").toLowerCase();\n    const padTop = Math.max(0, Number(opts.padTop) || 0);\n    const padBottom = Math.max(0, Number(opts.padBottom) || 0);\n    const behavior = opts.behavior === \"smooth\" ? \"smooth\" : \"auto\";\n\n    const containerRect = container.getBoundingClientRect();\n    const elementRect = element.getBoundingClientRect();\n    if (!containerRect || !elementRect || !Number.isFinite(containerRect.top) || !Number.isFinite(elementRect.top)) {\n      return;\n    }\n\n    const currentTop = Number(container.scrollTop || 0) || 0;\n    let nextTop = currentTop;\n\n    if (mode === \"start\") {\n      nextTop = currentTop + (elementRect.top - containerRect.top) - padTop;\n    } else if (mode === \"center\") {\n      nextTop = currentTop\n        + (elementRect.top + (elementRect.height / 2))\n        - (containerRect.top + (containerRect.height / 2));\n    } else {\n      const topLimit = containerRect.top + padTop;\n      const bottomLimit = containerRect.bottom - padBottom;\n      if (elementRect.top < topLimit) {\n        nextTop = currentTop + (elementRect.top - topLimit);\n      } else if (elementRect.bottom > bottomLimit) {\n        nextTop = currentTop + (elementRect.bottom - bottomLimit);\n      } else {\n        return;\n      }\n    }\n\n    const maxTop = Math.max(0, Number(container.scrollHeight || 0) - Number(container.clientHeight || 0));\n    const clampedTop = Math.max(0, Math.min(maxTop, Math.round(nextTop)));\n    if (Math.abs(clampedTop - currentTop) < 1) {\n      return;\n    }\n\n    if (typeof container.scrollTo === \"function\") {\n      container.scrollTo({ top: clampedTop, behavior });\n    } else {\n      container.scrollTop = clampedTop;\n    }\n  }\n\n  function setSelectedCard(id, options) {\n    const normalized = normalizeId(id);\n    if (!normalized) {\n      return;\n    }\n    const opts = options && typeof options === \"object\" ? options : {};\n    const shouldScroll = opts.scroll !== false;\n    const scrollMode = String(opts.scrollMode || \"start\").toLowerCase();\n\n    if (state.selectedId) {\n      const prev = els.output.querySelector(`[data-id=\"${escapeSelectorValue(state.selectedId)}\"]`);\n      if (prev) {\n        prev.classList.remove(\"selected\");\n      }\n    }\n\n    state.selectedId = normalized;\n    const next = els.output.querySelector(`[data-id=\"${escapeSelectorValue(normalized)}\"]`);\n    if (next) {\n      next.classList.add(\"selected\");\n      if (shouldScroll) {\n        scrollElementInContainer(els.output, next, { mode: scrollMode, padTop: 10, padBottom: 10 });\n      }\n    }\n  }\n\n  function setSelectedTemplateBlock(index, options) {\n    if (!els.templatePreviewOutput) {\n      return;\n    }\n\n    const opts = options && typeof options === \"object\" ? options : {};\n    const shouldScroll = opts.scroll !== false;\n    const scrollMode = String(opts.scrollMode || \"start\").toLowerCase();\n    const normalized = String(index === undefined || index === null ? \"\" : index).trim();\n    if (!normalized) {\n      return;\n    }\n\n    if (state.selectedTemplateIndex !== \"\") {\n      const prev = els.templatePreviewOutput.querySelector(\n        `.template-block[data-template-index=\"${escapeSelectorValue(state.selectedTemplateIndex)}\"]`\n      );\n      if (prev) {\n        prev.classList.remove(\"selected\");\n      }\n    }\n\n    state.selectedTemplateIndex = normalized;\n    const next = els.templatePreviewOutput.querySelector(\n      `.template-block[data-template-index=\"${escapeSelectorValue(normalized)}\"]`\n    );\n    if (next) {\n      next.classList.add(\"selected\");\n      if (shouldScroll) {\n        scrollElementInContainer(els.templatePreviewOutput, next, { mode: scrollMode, padTop: 10, padBottom: 10 });\n      }\n    }\n  }\n\n  function setSelectedDeclRow(declKey) {\n    const key = String(declKey || \"\").trim();\n    if (!key || !els.declDescTable) {\n      return;\n    }\n\n    if (state.selectedDeclKey) {\n      const prev = els.declDescTable.querySelector(`tr[data-decl-key=\"${escapeSelectorValue(state.selectedDeclKey)}\"]`);\n      if (prev) {\n        prev.classList.remove(\"desc-selected\");\n      }\n    }\n\n    state.selectedDeclKey = key;\n    const next = els.declDescTable.querySelector(`tr[data-decl-key=\"${escapeSelectorValue(key)}\"]`);\n    if (next) {\n      next.classList.add(\"desc-selected\");\n      scrollElementInContainer(els.declDescPanel, next, { mode: \"nearest\", padTop: 8, padBottom: 8 });\n    }\n  }\n\n  function countInputLines(value) {\n    const text = String(value || \"\");\n    if (!text) {\n      return 1;\n    }\n    return text.split(\"\\n\").length;\n  }\n\n  function syncInputGutterScroll() {\n    if (!els.inputText || !els.inputGutterContent) {\n      return;\n    }\n\n    const scrollTop = Number(els.inputText.scrollTop || 0) || 0;\n    els.inputGutterContent.style.transform = `translateY(${-scrollTop}px)`;\n  }\n\n  function rebuildInputGutter() {\n    if (!els.inputText || !els.inputGutterContent) {\n      return;\n    }\n\n    const trimmed = String(els.inputText.value || \"\").trim();\n    const isJsonLike = (trimmed.startsWith(\"{\") || trimmed.startsWith(\"[\")) && trimmed.length > 1;\n    state.inputMode = isJsonLike ? \"json\" : \"abap\";\n\n    const lineCount = Math.max(1, countInputLines(els.inputText.value || \"\"));\n    if (lineCount === state.inputLineCount && state.inputGutterButtonsByLine.size) {\n      syncInputGutterScroll();\n      refreshInputGutterTargets();\n      return;\n    }\n\n    state.inputLineCount = lineCount;\n    state.inputGutterButtonsByLine = new Map();\n\n    const frag = document.createDocumentFragment();\n    for (let line = 1; line <= lineCount; line += 1) {\n      const row = document.createElement(\"div\");\n      row.className = \"gutter-line\";\n\n      const btn = document.createElement(\"button\");\n      btn.type = \"button\";\n      btn.className = \"gutter-jump\";\n      btn.textContent = \"↪\";\n      btn.hidden = true;\n      btn.setAttribute(\"data-line\", String(line));\n      row.appendChild(btn);\n\n      const num = document.createElement(\"span\");\n      num.className = \"gutter-num\";\n      num.textContent = String(line);\n      row.appendChild(num);\n\n      state.inputGutterButtonsByLine.set(line, btn);\n      frag.appendChild(row);\n    }\n\n    els.inputGutterContent.replaceChildren(frag);\n    syncInputGutterScroll();\n    refreshInputGutterTargets();\n  }\n\n  function computeInputGutterTargetsForOutput() {\n    const targets = new Map();\n    if (!els.output) {\n      return targets;\n    }\n\n    const cards = els.output.querySelectorAll(\".card[data-id][data-line-start]\");\n    for (const card of Array.from(cards)) {\n      const line = Number(card.getAttribute(\"data-line-start\")) || 0;\n      const id = String(card.getAttribute(\"data-id\") || \"\");\n      if (!line || !id || targets.has(line)) {\n        continue;\n      }\n      targets.set(line, { kind: \"output\", id });\n    }\n\n    return targets;\n  }\n\n  function computeInputGutterTargetsForDescriptions() {\n    const targets = new Map();\n    if (!els.declDescTable) {\n      return targets;\n    }\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/output/03-selection-gutter.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/03-selection-gutter.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "\n    const rows = els.declDescTable.querySelectorAll(\"tr[data-decl-key][data-line-start]\");\n    for (const row of Array.from(rows)) {\n      const line = Number(row.getAttribute(\"data-line-start\")) || 0;\n      const declKey = String(row.getAttribute(\"data-decl-key\") || \"\");\n      if (!line || !declKey || targets.has(line)) {\n        continue;\n      }\n      targets.set(line, { kind: \"descriptions\", declKey });\n    }\n\n    return targets;\n  }\n\n  function computeInputGutterTargetsForTemplate() {\n    const targets = new Map();\n    if (!els.templatePreviewOutput) {\n      return targets;\n    }\n\n    const blocks = els.templatePreviewOutput.querySelectorAll(\".template-block[data-template-index][data-line-start]\");\n    for (const block of Array.from(blocks)) {\n      const line = Number(block.getAttribute(\"data-line-start\")) || 0;\n      const index = String(block.getAttribute(\"data-template-index\") || \"\");\n      if (!line || !index || targets.has(line)) {\n        continue;\n      }\n      targets.set(line, { kind: \"template\", index });\n    }\n\n    return targets;\n  }\n\n  function refreshInputGutterTargets() {\n    if (!els.inputGutterContent || !state.inputGutterButtonsByLine.size) {\n      return;\n    }\n\n    if (state.inputMode !== \"abap\") {\n      state.inputGutterTargetsByLine = new Map();\n      for (const btn of state.inputGutterButtonsByLine.values()) {\n        btn.hidden = true;\n      }\n      return;\n    }\n\n    let targets = new Map();\n    if (state.rightTab === \"descriptions\") {\n      targets = computeInputGutterTargetsForDescriptions();\n    } else if (state.rightTab === \"output\") {\n      targets = computeInputGutterTargetsForOutput();\n    } else if (state.rightTab === \"template\") {\n      targets = computeInputGutterTargetsForTemplate();\n    }\n\n    state.inputGutterTargetsByLine = targets;\n    const title = state.rightTab === \"descriptions\"\n      ? \"Jump to Descriptions\"\n      : (state.rightTab === \"output\"\n        ? \"Jump to Output\"\n        : (state.rightTab === \"template\" ? \"Jump to Template\" : \"\"));\n    for (const [line, btn] of state.inputGutterButtonsByLine.entries()) {\n      const target = targets.get(line);\n      btn.hidden = !target;\n      if (target) {\n        btn.title = title;\n        btn.setAttribute(\"aria-label\", title);\n      }\n    }\n  }\n\n  function onInputGutterClick(ev) {\n    const target = ev && ev.target && typeof ev.target.closest === \"function\"\n      ? ev.target.closest(\"button.gutter-jump\")\n      : null;\n    if (!target) {\n      return;\n    }\n\n    const line = Number(target.getAttribute(\"data-line\")) || 0;\n    if (!line) {\n      return;\n    }\n\n    const jumpTarget = state.inputGutterTargetsByLine.get(line);\n    if (!jumpTarget) {\n      return;\n    }\n\n    if (state.rightTab === \"output\" && jumpTarget.kind === \"output\") {\n      setSelectedCard(jumpTarget.id, { scroll: true, scrollMode: \"start\" });\n      return;\n    }\n\n    if (state.rightTab === \"template\" && jumpTarget.kind === \"template\") {\n      setSelectedTemplateBlock(jumpTarget.index, { scroll: true, scrollMode: \"start\" });\n      return;\n    }\n\n    if (state.rightTab === \"descriptions\" && jumpTarget.kind === \"descriptions\") {\n      setSelectedDeclRow(jumpTarget.declKey);\n    }\n  }\n\n  function openJsonModal(value) {\n    openTextModal(\"Object JSON\", safeJson(value, true));\n  }\n\n  function openTextModal(title, text) {\n    if (!els.editModal.hidden) {\n      closeEditModal();\n    }\n\n    if (els.jsonTitle) {\n      els.jsonTitle.textContent = title ? String(title) : \"\";\n    }\n\n    els.jsonPre.textContent = text ? String(text) : \"\";\n    els.jsonModal.hidden = false;\n  }\n\n  function closeJsonModal() {\n    els.jsonModal.hidden = true;\n    if (els.jsonTitle) {\n      els.jsonTitle.textContent = \"Object JSON\";\n    }\n    els.jsonPre.textContent = \"\";\n  }\n\n  async function copyJsonToClipboard() {\n    const text = els.jsonPre.textContent || \"\";\n    if (!text) {\n      return;\n    }\n\n    if (navigator.clipboard && typeof navigator.clipboard.writeText === \"function\") {\n      await navigator.clipboard.writeText(text);\n      return;\n    }\n\n    const selection = window.getSelection();\n    if (!selection) {\n      return;\n    }\n    selection.removeAllRanges();\n    const range = document.createRange();\n    range.selectNodeContents(els.jsonPre);\n    selection.addRange(range);\n    document.execCommand(\"copy\");\n    selection.removeAllRanges();\n  }\n\n  function stringifyDecl(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const techName = getDeclTechName(decl);\n    const displayName = getDeclDisplayName(decl);\n\n    const parts = [];\n    if (decl.objectType) {\n      parts.push(String(decl.objectType));\n    }\n    if (decl.scopeLabel) {\n      parts.push(`[${String(decl.scopeLabel)}]`);\n    }\n    if (displayName) {\n      parts.push(displayName);\n    }\n    if (techName && displayName && techName !== displayName) {\n      parts.push(`(${techName})`);\n    }\n    if (decl.file) {\n      parts.push(String(decl.file));\n    }\n    if (decl.lineStart) {\n      parts.push(`#${decl.lineStart}`);\n    }\n    return parts.join(\" \");\n  }\n\n  function getDeclTechName(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n    return decl.name ? String(decl.name) : \"\";\n  }\n\n  function stripAngleBrackets(text) {\n    const trimmed = String(text || \"\").trim();\n    if (trimmed.startsWith(\"<\") && trimmed.endsWith(\">\") && trimmed.length > 2) {\n      return trimmed.slice(1, -1);\n    }\n    return trimmed;\n  }\n\n  function stripDeclCategoryPrefix(text) {\n    const raw = String(text || \"\").trim();\n    if (!raw) {\n      return \"\";\n    }\n\n    const match = raw.match(\n      /^\\s*(HẰNG|HANG|STRUCT|TABLE|RANGETABLE|BIẾN|BIEN|CỜ|CO|FIELDSYMBOL)\\b\\s*[:\\-\\[\\]]*\\s*/i\n    );\n    if (!match) {\n      return raw;\n    }\n\n    let rest = raw.slice(match[0].length).trim();\n    // If the prefix included an opening \"[\" (e.g. \"BIẾN:[\") then strip ONE trailing \"]\" (e.g. \"...]\")\n    // so \"BIẾN:[desc]\" -> \"desc\" instead of \"desc]\".\n    if (match[0].includes(\"[\") && rest.endsWith(\"]\")) {\n      rest = rest.slice(0, -1).trim();\n    }\n    return rest;\n  }\n\n  function isStructFieldDecl(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return false;\n    }\n    if (decl.objectType === \"STRUCT_FIELD\") {\n      return true;\n    }\n    return Boolean(decl.structName && decl.fieldPath);\n  }\n\n  function getDeclDisplayName(decl) {\n    const techName = getDeclTechName(decl);\n    if (!techName) {\n      return \"\";\n    }\n\n    if (isStructFieldDecl(decl)) {\n      return techName;\n    }\n\n    const desc = getEffectiveDeclDesc(decl);\n    const descTrimmed = String(desc || \"\").trim();\n    if (!descTrimmed) {\n      return techName;\n    }\n\n    const settings = state.settings || DEFAULT_SETTINGS;\n    if (settings.normalizeDeclDesc) {\n      return descTrimmed;\n    }\n\n    const bare = stripAngleBrackets(techName);\n    if (bare.length < 3) {\n      return techName;\n    }\n\n    const code = bare.slice(1, 3).toUpperCase();\n    const templates = settings.nameTemplatesByCode || DEFAULT_SETTINGS.nameTemplatesByCode;\n    const template = templates && Object.prototype.hasOwnProperty.call(templates, code) ? String(templates[code] || \"\") : \"\";\n    if (!template.trim()) {\n      return techName;\n    }\n\n    const strippedKnownPrefix = stripDeclCategoryPrefix(descTrimmed);\n    const normalizedDesc = stripDeclTemplateAffixes(strippedKnownPrefix, template);\n    const displayName = template.replace(/\\{\\{desc\\}\\}/g, normalizedDesc).trim();\n    return displayName || techName;\n  }\n\n  function buildDeclTitle(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const lines = [];\n    lines.push(stringifyDecl(decl));\n\n    const desc = getEffectiveDeclDesc(decl);\n    if (desc) {\n      lines.push(`Desc: ${desc}`);\n    }\n\n    if (decl.raw) {\n      lines.push(String(decl.raw));\n    }\n\n    return lines.filter(Boolean).join(\"\\n\");\n  }\n\n  function renderDeclNameCell(decl) {\n    const text = decl ? getDeclDisplayName(decl) : \"\";\n    const title = buildDeclTitle(decl);\n    const cell = el(\"td\", { text, attrs: title ? { title } : {} });\n\n    if (decl && decl.lineStart) {\n      cell.style.cursor = \"pointer\";\n      cell.addEventListener(\"click\", (ev) => {\n        ev.stopPropagation();\n        selectCodeLines(decl.lineStart, decl.lineStart);\n        if (decl.id) {\n          setSelectedCard(decl.id);\n        }\n      });\n    }\n\n    return cell;\n  }\n\n  function renderDeclDescCell(decl) {\n    const text = getEffectiveDeclDesc(decl);\n    const title = buildDeclTitle(decl);\n    const cell = el(\"td\", { attrs: title ? { title } : {} });\n\n    const wrap = el(\"div\", { className: \"decl-desc\" });\n    wrap.appendChild(el(\"div\", { className: \"decl-desc-text\", text: text || \"\" }));\n\n    if (getDeclOverrideStorageKey(decl)) {\n      const btn = el(\"button\", {\n        className: \"icon-btn\",\n        text: \"✎\",\n        attrs: {\n          type: \"button\",\n          title: \"Edit decl description\",\n          \"aria-label\": \"Edit decl description\"\n        }\n      });\n      btn.addEventListener(\"click\", (ev) => {\n        ev.stopPropagation();\n        editDeclDesc(decl);\n      });\n      wrap.appendChild(btn);\n    }\n\n    cell.appendChild(wrap);\n\n    return cell;\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/output/04-render-shared.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/04-render-shared.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "  }\n\n  var PERFORM_TRACE_META_KEY_OUTPUT = \"__abapPerformTraceBinding\";\n\n  function getDeclRenderKey(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n    return (\n      getDeclKey(decl) ||\n      [\n        decl.objectType || \"\",\n        decl.scopeLabel || \"\",\n        decl.name || \"\",\n        decl.file || \"\",\n        decl.lineStart || \"\"\n      ].join(\"|\")\n    );\n  }\n\n  function dedupeDecls(list) {\n    const output = [];\n    const seen = new Set();\n    for (const decl of list || []) {\n      if (!decl) {\n        continue;\n      }\n      const key = getDeclRenderKey(decl);\n      if (!key || seen.has(key)) {\n        continue;\n      }\n      seen.add(key);\n      output.push(decl);\n    }\n    return output;\n  }\n\n  function getExpandedPerformBindingContext(obj) {\n    if (!obj || typeof obj !== \"object\") {\n      return null;\n    }\n    const bindingContext = obj[PERFORM_TRACE_META_KEY_OUTPUT];\n    if (!bindingContext || typeof bindingContext !== \"object\") {\n      return null;\n    }\n    if (!(bindingContext.byParamUpper instanceof Map)) {\n      return null;\n    }\n    return bindingContext;\n  }\n\n  function resolveExpandedPerformTraceDecls(obj, decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return [];\n    }\n    if (String(decl.objectType || \"\").toUpperCase() !== \"FORM_PARAM\") {\n      return [];\n    }\n    const bindingContext = getExpandedPerformBindingContext(obj);\n    if (!bindingContext) {\n      return [];\n    }\n    const paramUpper = String(decl.name || \"\").trim().toUpperCase();\n    if (!paramUpper) {\n      return [];\n    }\n    const traceDecls = bindingContext.byParamUpper.get(paramUpper);\n    if (!Array.isArray(traceDecls) || !traceDecls.length) {\n      return [];\n    }\n    return dedupeDecls(traceDecls.filter((item) => item && typeof item === \"object\"));\n  }\n\n  function buildDeclTraceListForObject(obj, decl) {\n    const list = [];\n    if (decl && typeof decl === \"object\") {\n      list.push(decl);\n    }\n    const traceDecls = resolveExpandedPerformTraceDecls(obj, decl);\n    if (traceDecls.length) {\n      list.push(...traceDecls);\n    }\n    return dedupeDecls(list);\n  }\n\n  function getDeclListDisplayName(decl) {\n    if (!decl || typeof decl !== \"object\") {\n      return \"\";\n    }\n\n    const displayName = String(getDeclDisplayName(decl) || \"\").trim();\n    const descText = String(getEffectiveDeclDesc(decl) || \"\").trim();\n    if (\n      displayName &&\n      descText &&\n      displayName.localeCompare(descText, undefined, { sensitivity: \"accent\" }) === 0\n    ) {\n      const techName = String(getDeclTechName(decl) || \"\").trim();\n      if (techName) {\n        return techName;\n      }\n    }\n\n    return displayName || String(getDeclTechName(decl) || \"\").trim();\n  }\n\n  function renderDeclListCells(decls, fallbackDecl) {\n    const list = dedupeDecls(Array.isArray(decls) ? decls.filter(Boolean) : []);\n    const effectiveList = list.length ? list : dedupeDecls(fallbackDecl ? [fallbackDecl] : []);\n\n    const nameCell = el(\"td\");\n    const descCell = el(\"td\");\n\n    if (!effectiveList.length) {\n      return { nameCell, descCell };\n    }\n\n    const nameWrap = el(\"div\");\n    const descWrap = el(\"div\");\n\n    for (const decl of effectiveList) {\n      const nameLine = el(\"div\", { text: getDeclListDisplayName(decl) });\n      const title = buildDeclTitle(decl);\n      if (title) {\n        nameLine.title = title;\n      }\n\n      if (decl && decl.lineStart) {\n        nameLine.style.cursor = \"pointer\";\n        nameLine.addEventListener(\"click\", (ev) => {\n          ev.stopPropagation();\n          selectCodeLines(decl.lineStart, decl.lineStart);\n          if (decl.id) {\n            setSelectedCard(decl.id);\n          }\n        });\n      }\n\n      nameWrap.appendChild(nameLine);\n\n      const descLineWrap = el(\"div\", { className: \"decl-desc-line\" });\n      const descLineText = el(\"div\", { className: \"decl-desc-text\", text: getEffectiveDeclDesc(decl) || \"\" });\n      if (title) {\n        descLineText.title = title;\n      }\n      descLineWrap.appendChild(descLineText);\n\n      if (getDeclOverrideStorageKey(decl)) {\n        const btn = el(\"button\", {\n          className: \"icon-btn\",\n          text: \"✎\",\n          attrs: {\n            type: \"button\",\n            title: \"Edit decl description\",\n            \"aria-label\": \"Edit decl description\"\n          }\n        });\n        btn.addEventListener(\"click\", (ev) => {\n          ev.stopPropagation();\n          editDeclDesc(decl);\n        });\n        descLineWrap.appendChild(btn);\n      }\n\n      descWrap.appendChild(descLineWrap);\n    }\n\n    nameCell.appendChild(nameWrap);\n    descCell.appendChild(descWrap);\n    return { nameCell, descCell };\n  }\n\n  function matchesFilters(obj) {\n    const typeOk = !state.type || obj.objectType === state.type;\n    if (!typeOk) {\n      return false;\n    }\n\n    if (!state.query) {\n      return true;\n    }\n\n    const id = normalizeId(obj && obj.id);\n    const haystack = id ? state.haystackById.get(id) : \"\";\n    return haystack ? haystack.includes(state.query) : false;\n  }\n\n  function filterTree(obj) {\n    const children = Array.isArray(obj.children) ? obj.children : [];\n    const filteredChildren = [];\n    for (const child of children) {\n      const filtered = filterTree(child);\n      if (filtered) {\n        filteredChildren.push(filtered);\n      }\n    }\n\n    const selfMatches = matchesFilters(obj);\n    if (!selfMatches && !filteredChildren.length) {\n      return null;\n    }\n\n    return { obj, children: filteredChildren, selfMatches };\n  }\n\n  function el(tag, options) {\n    const node = document.createElement(tag);\n    if (options && options.className) {\n      node.className = options.className;\n    }\n    if (options && options.text !== undefined) {\n      node.textContent = options.text;\n    }\n    if (options && options.attrs) {\n      for (const [key, value] of Object.entries(options.attrs)) {\n        node.setAttribute(key, String(value));\n      }\n    }\n    return node;\n  }\n\n  function renderKeywords(obj) {\n    const keywords = getKeywordEntries(obj);\n    if (!keywords.length) {\n      return null;\n    }\n\n    const wrap = el(\"div\");\n    for (const keyword of keywords) {\n      wrap.appendChild(\n        el(\"span\", {\n          className: \"pill\",\n          text: keyword && keyword.text ? String(keyword.text) : \"\",\n          attrs: keyword && keyword.label ? { title: String(keyword.label) } : {}\n        })\n      );\n    }\n    return wrap;\n  }\n\n  function collectDeclsForValueEntry(obj, entry) {\n    const decls = [];\n    const addDecl = (decl) => {\n      if (decl && typeof decl === \"object\") {\n        decls.push(decl);\n      }\n    };\n    const addDeclWithTrace = (decl) => {\n      if (!decl || typeof decl !== \"object\") {\n        return;\n      }\n      const traceList = buildDeclTraceListForObject(obj, decl);\n      if (!traceList.length) {\n        addDecl(decl);\n        return;\n      }\n      for (const traceDecl of traceList) {\n        addDecl(traceDecl);\n      }\n    };\n\n    const normalizedEntry = ensureEntryDeclForOutput(obj, cloneValueEntryForOutput(entry));\n\n    addDeclWithTrace(normalizedEntry && normalizedEntry.decl);\n    addDeclWithTrace(normalizedEntry && normalizedEntry.valueDecl);\n    if (normalizedEntry && Array.isArray(normalizedEntry.originDecls)) {\n      for (const originDecl of normalizedEntry.originDecls) {\n        addDeclWithTrace(originDecl);\n      }\n    }\n\n    const extras = obj && obj.extras && typeof obj.extras === \"object\" ? obj.extras : null;\n    if (!extras) {\n      return dedupeDecls(decls);\n    }\n\n    const entryName = String(normalizedEntry && normalizedEntry.name ? normalizedEntry.name : \"\").trim().toLowerCase();\n    if (!entryName) {\n      return dedupeDecls(decls);\n    }\n\n    if (entryName === \"condition\" && extras.ifCondition) {\n      collectConditionDeclsFromClauses(extras.ifCondition.conditions, addDeclWithTrace);\n    } else if (entryName === \"ifcondition\" && extras.performCall) {\n      collectConditionDeclsFromClauses(extras.performCall.ifConditions, addDeclWithTrace);\n    } else if (entryName === \"where\") {\n      if (extras.select) {\n        collectConditionDeclsFromClauses(extras.select.whereConditions, addDeclWithTrace);\n      }\n      if (extras.loopAtItab) {\n        collectConditionDeclsFromClauses(extras.loopAtItab.conditions, addDeclWithTrace);\n      }\n      if (extras.modifyItab) {\n        collectConditionDeclsFromClauses(extras.modifyItab.conditions, addDeclWithTrace);\n      }\n      if (extras.deleteItab) {\n        collectConditionDeclsFromClauses(extras.deleteItab.conditions, addDeclWithTrace);\n      }\n    } else if (entryName === \"having\" && extras.select) {\n      collectConditionDeclsFromClauses(extras.select.havingConditions, addDeclWithTrace);\n    } else if ((entryName === \"withkey\" || entryName === \"withtablekey\") && extras.readTable) {\n      collectConditionDeclsFromClauses(extras.readTable.conditions, addDeclWithTrace);\n    }\n\n    return dedupeDecls(decls);\n  }\n\n  function isRawValueEntry(entry) {\n    const name = entry && entry.name ? String(entry.name).trim() : \"\";\n    return Boolean(name) && /raw$/i.test(name);\n  }\n\n  function makeSectionIndexName(sectionName, indexOneBased) {\n    return `${sectionName}[${indexOneBased}]`;\n  }\n\n  function makeParsedValueRow({\n    sectionName,\n    indexOneBased,\n    valueText,\n    baseEntry,\n    decl,\n    valueDecl,\n    originDecls,\n    valueRef\n  }) {\n    const row = {\n      name: makeSectionIndexName(sectionName, indexOneBased),\n      value: valueText ? String(valueText) : \"\",\n      label: baseEntry && baseEntry.label ? String(baseEntry.label) : sectionName,\n      userDesc: baseEntry && baseEntry.userDesc ? String(baseEntry.userDesc) : \"\",\n      codeDesc: baseEntry && baseEntry.codeDesc ? String(baseEntry.codeDesc) : \"\"\n    };\n\n    if (decl && typeof decl === \"object\") {\n      row.decl = decl;\n    }\n    if (valueDecl && typeof valueDecl === \"object\") {\n      row.valueDecl = valueDecl;\n    }\n    if (Array.isArray(originDecls) && originDecls.length) {\n      row.originDecls = originDecls.filter((item) => item && typeof item === \"object\");\n    }\n    if (valueRef) {\n      row.declRef = String(valueRef);\n    }\n\n    return row;\n  }\n\n  function buildParsedRowsFromPerformList(sectionName, list, baseEntry) {\n    const items = Array.isArray(list) ? list : [];\n    return items.map((item, index) => makeParsedValueRow({\n      sectionName,\n      indexOneBased: index + 1,\n      valueText: item && item.value ? String(item.value) : \"\",\n      baseEntry,\n      decl: item && item.valueDecl ? item.valueDecl : (baseEntry && baseEntry.decl ? baseEntry.decl : null),\n      valueDecl: item && item.valueDecl ? item.valueDecl : null,\n      originDecls: item && Array.isArray(item.originDecls) ? item.originDecls : [],\n      valueRef: item && item.valueRef ? String(item.valueRef) : \"\"\n    }));\n  }\n\n  function buildParsedRowsFromAssignments(sectionName, list, baseEntry) {\n    const items = Array.isArray(list) ? list : [];\n    return items.map((item, index) => {\n      const leftName = item && item.name ? String(item.name) : \"\";\n      const rightValue = item && item.value ? String(item.value) : \"\";\n      const valueText = leftName && rightValue\n        ? `${leftName} = ${rightValue}`\n        : (leftName || rightValue);\n      return makeParsedValueRow({\n        sectionName,\n        indexOneBased: index + 1,\n        valueText,\n        baseEntry,\n        decl: item && item.valueDecl ? item.valueDecl : (baseEntry && baseEntry.decl ? baseEntry.decl : null),\n        valueDecl: item && item.valueDecl ? item.valueDecl : null,\n        originDecls: item && Array.isArray(item.originDecls) ? item.originDecls : [],\n        valueRef: item && item.valueRef ? String(item.valueRef) : \"\"\n      });\n    });\n  }\n\n  function buildParsedRowsFromParams(sectionName, list, baseEntry) {\n    const items = Array.isArray(list) ? list : [];\n    return items.map((param, index) => {\n      const paramName = param && param.name ? String(param.name) : \"\";\n      const typingText = formatTyping(param && param.typing);\n      const valueText = [paramName, typingText].filter(Boolean).join(\" \").trim();\n      const origins = param && Array.isArray(param.originDecls) ? param.originDecls : [];\n      return makeParsedValueRow({\n        sectionName,\n        indexOneBased: index + 1,\n        valueText,\n        baseEntry,\n        decl: origins.length ? origins[0] : (baseEntry && baseEntry.decl ? baseEntry.decl : null),\n        valueDecl: null,\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/output/05-render-values.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/05-render-values.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "        originDecls: origins,\n        valueRef: \"\"\n      });\n    });\n  }\n\n  function buildParsedRowsFromExceptions(sectionName, list, baseEntry) {\n    const items = Array.isArray(list) ? list : [];\n    return items.map((item, index) => {\n      const name = item && item.name ? String(item.name) : \"\";\n      return makeParsedValueRow({\n        sectionName,\n        indexOneBased: index + 1,\n        valueText: name,\n        baseEntry,\n        decl: baseEntry && baseEntry.decl ? baseEntry.decl : null,\n        valueDecl: null,\n        originDecls: item && Array.isArray(item.originDecls) ? item.originDecls : [],\n        valueRef: \"\"\n      });\n    });\n  }\n\n  function buildParsedRowsForRawEntry(obj, baseEntry) {\n    if (!obj || !baseEntry) {\n      return [];\n    }\n\n    const extras = obj.extras && typeof obj.extras === \"object\" ? obj.extras : null;\n    if (!extras) {\n      return [];\n    }\n\n    const rawName = baseEntry.name ? String(baseEntry.name).trim().toLowerCase() : \"\";\n    if (!rawName) {\n      return [];\n    }\n\n    if (extras.performCall) {\n      const sectionMap = {\n        usingraw: \"using\",\n        changingraw: \"changing\",\n        tablesraw: \"tables\"\n      };\n      const sectionName = sectionMap[rawName];\n      if (sectionName) {\n        return buildParsedRowsFromPerformList(sectionName, extras.performCall[sectionName], baseEntry);\n      }\n    }\n\n    if (extras.callFunction) {\n      const sectionMap = {\n        exportingraw: \"exporting\",\n        importingraw: \"importing\",\n        changingraw: \"changing\",\n        tablesraw: \"tables\",\n        exceptionsraw: \"exceptions\"\n      };\n      const sectionName = sectionMap[rawName];\n      if (sectionName) {\n        return buildParsedRowsFromAssignments(sectionName, extras.callFunction[sectionName], baseEntry);\n      }\n    }\n\n    if (extras.callMethod) {\n      const sectionMap = {\n        exportingraw: \"exporting\",\n        importingraw: \"importing\",\n        changingraw: \"changing\",\n        receivingraw: \"receiving\",\n        exceptionsraw: \"exceptions\"\n      };\n      const sectionName = sectionMap[rawName];\n      if (sectionName) {\n        return buildParsedRowsFromAssignments(sectionName, extras.callMethod[sectionName], baseEntry);\n      }\n    }\n\n    if (extras.form) {\n      const paramsByRawName = {\n        usingraw: \"USING\",\n        changingraw: \"CHANGING\",\n        tablesraw: \"TABLES\"\n      };\n      if (Object.prototype.hasOwnProperty.call(paramsByRawName, rawName)) {\n        const sectionUpper = paramsByRawName[rawName];\n        const params = Array.isArray(extras.form.params)\n          ? extras.form.params.filter((param) => String(param && param.section ? param.section : \"\").toUpperCase() === sectionUpper)\n          : [];\n        return buildParsedRowsFromParams(sectionUpper.toLowerCase(), params, baseEntry);\n      }\n      if (rawName === \"raisingraw\") {\n        return buildParsedRowsFromExceptions(\"raising\", extras.form.exceptions, baseEntry);\n      }\n    }\n\n    if (extras.methodSignature) {\n      const paramsByRawName = {\n        importingraw: \"IMPORTING\",\n        exportingraw: \"EXPORTING\",\n        changingraw: \"CHANGING\",\n        returningraw: \"RETURNING\"\n      };\n      if (Object.prototype.hasOwnProperty.call(paramsByRawName, rawName)) {\n        const sectionUpper = paramsByRawName[rawName];\n        const params = Array.isArray(extras.methodSignature.params)\n          ? extras.methodSignature.params.filter((param) => String(param && param.section ? param.section : \"\").toUpperCase() === sectionUpper)\n          : [];\n        return buildParsedRowsFromParams(sectionUpper.toLowerCase(), params, baseEntry);\n      }\n      if (rawName === \"raisingraw\") {\n        return buildParsedRowsFromExceptions(\"raising\", extras.methodSignature.exceptions, baseEntry);\n      }\n    }\n\n    return [];\n  }\n\n  function cloneValueEntryForOutput(entry) {\n    if (!entry || typeof entry !== \"object\") {\n      return entry;\n    }\n    const out = { ...entry };\n    if (Array.isArray(entry.originDecls)) {\n      out.originDecls = entry.originDecls.slice();\n    }\n    return out;\n  }\n\n  function ensureEntryDeclForOutput(obj, entry) {\n    if (!entry || typeof entry !== \"object\") {\n      return entry;\n    }\n    const source = getDeclSourceContextFromObject(obj);\n    const entryName = String(entry.name || \"value\").trim() || \"value\";\n    return ensureEntryDeclWithSynthetic(entry, {\n      pathKey: buildPathKeyFromParts([buildObjectPathBase(obj), \"values\", entryName]),\n      file: source.file,\n      lineStart: source.lineStart,\n      raw: source.raw,\n      role: \"value\"\n    });\n  }\n\n  function buildRenderableValueEntries(obj) {\n    const values = getValueEntries(obj);\n    if (!values.length) {\n      return [];\n    }\n\n    const rows = [];\n    for (const entry of values) {\n      const rawRow = cloneValueEntryForOutput(entry);\n      if (!isRawValueEntry(entry)) {\n        rows.push(ensureEntryDeclForOutput(obj, rawRow));\n        continue;\n      }\n\n      const parsedRows = buildParsedRowsForRawEntry(obj, entry);\n      if (parsedRows.length) {\n        for (const parsedRow of parsedRows) {\n          rows.push(ensureEntryDeclForOutput(obj, cloneValueEntryForOutput(parsedRow)));\n        }\n      } else {\n        rows.push(ensureEntryDeclForOutput(obj, rawRow));\n      }\n    }\n\n    return rows;\n  }\n\n  function renderValues(obj) {\n    const values = buildRenderableValueEntries(obj);\n    if (!values.length) {\n      return null;\n    }\n\n    const table = el(\"table\");\n    const thead = el(\"thead\");\n    const headRow = el(\"tr\");\n    for (const name of [\"name\", \"value\", \"label\", \"codeDesc\", \"declName\", \"declDesc\"]) {\n      headRow.appendChild(el(\"th\", { text: name }));\n    }\n    thead.appendChild(headRow);\n    table.appendChild(thead);\n\n    const tbody = el(\"tbody\");\n    for (const entry of values) {\n      const row = el(\"tr\");\n      const relatedDecls = collectDeclsForValueEntry(obj, entry);\n      const declListCells = renderDeclListCells(\n        relatedDecls.length ? relatedDecls : null,\n        relatedDecls.length ? null : entry && entry.decl\n      );\n      row.appendChild(el(\"td\", { text: entry && entry.name ? String(entry.name) : \"\" }));\n      row.appendChild(el(\"td\", { text: entry && entry.value ? String(entry.value) : \"\" }));\n      row.appendChild(el(\"td\", { text: entry && entry.label ? String(entry.label) : \"\" }));\n      row.appendChild(el(\"td\", { text: entry && entry.codeDesc ? String(entry.codeDesc) : \"\" }));\n      row.appendChild(declListCells.nameCell);\n      row.appendChild(declListCells.descCell);\n      tbody.appendChild(row);\n    }\n    table.appendChild(tbody);\n    return table;\n  }\n\n  function buildExtrasEntryPathKey(obj, extrasScope, sectionName, indexOneBased, itemKind) {\n    return buildPathKeyFromParts([\n      buildObjectPathBase(obj),\n      \"extras\",\n      extrasScope || \"extras\",\n      sectionName || \"section\",\n      `${itemKind || \"item\"}[${indexOneBased}]`\n    ]);\n  }\n\n  function normalizeExtrasEntryForOutput(obj, extrasScope, sectionName, indexOneBased, entry) {\n    if (!entry || typeof entry !== \"object\") {\n      return entry;\n    }\n\n    const source = getDeclSourceContextFromObject(obj);\n    const basePath = buildExtrasEntryPathKey(obj, extrasScope, sectionName, indexOneBased, \"item\");\n    let next = cloneValueEntryForOutput(entry);\n    next = ensureEntryDeclWithSynthetic(next, {\n      pathKey: basePath,\n      file: source.file,\n      lineStart: source.lineStart,\n      raw: source.raw,\n      role: `${extrasScope || \"extras\"}:${sectionName || \"entry\"}`\n    });\n    next = ensureValueDeclWithSynthetic(next, {\n      pathKey: basePath,\n      file: source.file,\n      lineStart: source.lineStart,\n      raw: source.raw,\n      role: `${extrasScope || \"extras\"}:${sectionName || \"entry\"}:value`,\n      nameHint: sectionName || \"value\"\n    });\n    return next;\n  }\n\n  function renderAssignmentTable(title, list, context) {\n    const items = Array.isArray(list) ? list : [];\n    if (!items.length) {\n      return null;\n    }\n\n    const obj = context && context.obj ? context.obj : null;\n    const extrasScope = context && context.extrasScope ? String(context.extrasScope) : \"extras\";\n\n    const section = el(\"div\");\n    section.appendChild(el(\"div\", { className: \"muted\", text: title }));\n\n    const table = el(\"table\");\n    const thead = el(\"thead\");\n    const headRow = el(\"tr\");\n    for (const key of [\"name\", \"value\", \"ref\", \"declName\", \"declDesc\"]) {\n      headRow.appendChild(el(\"th\", { text: key }));\n    }\n    thead.appendChild(headRow);\n    table.appendChild(thead);\n\n    const tbody = el(\"tbody\");\n    for (let index = 0; index < items.length; index += 1) {\n      const entry = items[index];\n      const normalizedEntry = normalizeExtrasEntryForOutput(obj, extrasScope, title, index + 1, entry);\n      const row = el(\"tr\");\n      row.appendChild(el(\"td\", { text: normalizedEntry && normalizedEntry.name ? String(normalizedEntry.name) : \"\" }));\n      row.appendChild(el(\"td\", { text: normalizedEntry && normalizedEntry.value ? String(normalizedEntry.value) : \"\" }));\n      row.appendChild(el(\"td\", { text: normalizedEntry && normalizedEntry.valueRef ? String(normalizedEntry.valueRef) : \"\" }));\n      const { nameCell, descCell } = renderDeclListCells(\n        normalizedEntry && normalizedEntry.originDecls,\n        normalizedEntry && normalizedEntry.valueDecl\n      );\n      row.appendChild(nameCell);\n      row.appendChild(descCell);\n      tbody.appendChild(row);\n    }\n    table.appendChild(tbody);\n    section.appendChild(table);\n    return section;\n  }\n\n  function renderValueListTable(title, list, context) {\n    const items = Array.isArray(list) ? list : [];\n    if (!items.length) {\n      return null;\n    }\n\n    const obj = context && context.obj ? context.obj : null;\n    const extrasScope = context && context.extrasScope ? String(context.extrasScope) : \"extras\";\n\n    const section = el(\"div\");\n    section.appendChild(el(\"div\", { className: \"muted\", text: title }));\n\n    const table = el(\"table\");\n    const thead = el(\"thead\");\n    const headRow = el(\"tr\");\n    for (const key of [\"value\", \"ref\", \"declName\", \"declDesc\"]) {\n      headRow.appendChild(el(\"th\", { text: key }));\n    }\n    thead.appendChild(headRow);\n    table.appendChild(thead);\n\n    const tbody = el(\"tbody\");\n    for (let index = 0; index < items.length; index += 1) {\n      const entry = items[index];\n      const normalizedEntry = normalizeExtrasEntryForOutput(obj, extrasScope, title, index + 1, entry);\n      const row = el(\"tr\");\n      row.appendChild(el(\"td\", { text: normalizedEntry && normalizedEntry.value ? String(normalizedEntry.value) : \"\" }));\n      row.appendChild(el(\"td\", { text: normalizedEntry && normalizedEntry.valueRef ? String(normalizedEntry.valueRef) : \"\" }));\n      const { nameCell, descCell } = renderDeclListCells(\n        normalizedEntry && normalizedEntry.originDecls,\n        normalizedEntry && normalizedEntry.valueDecl\n      );\n      row.appendChild(nameCell);\n      row.appendChild(descCell);\n      tbody.appendChild(row);\n    }\n    table.appendChild(tbody);\n    section.appendChild(table);\n    return section;\n  }\n\n  function resolveConditionDeclForViewer(decl, refCandidate) {\n    if (decl && typeof decl === \"object\") {\n      return decl;\n    }\n\n    const ref = String(refCandidate || \"\").trim();\n    if (!ref) {\n      return null;\n    }\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/output/06-render-extras.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/06-render-extras.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "    const decls = state.data && typeof state.data === \"object\" && Array.isArray(state.data.decls)\n      ? state.data.decls\n      : [];\n    if (!decls.length) {\n      return null;\n    }\n\n    const upperRef = ref.toUpperCase();\n    let matched = null;\n    for (const candidate of decls) {\n      if (!candidate || typeof candidate !== \"object\") {\n        continue;\n      }\n      const nameUpper = String(candidate.name || \"\").trim().toUpperCase();\n      if (!nameUpper || nameUpper !== upperRef) {\n        continue;\n      }\n\n      if (!matched) {\n        matched = candidate;\n      }\n\n      const scopeUpper = String(candidate.scopeLabel || \"\").trim().toUpperCase();\n      if (scopeUpper === \"GLOBAL\") {\n        return candidate;\n      }\n    }\n\n    return matched;\n  }\n\n  function renderConditionTable(title, clauses, context) {\n    const items = Array.isArray(clauses) ? clauses : [];\n    if (!items.length) {\n      return null;\n    }\n\n    const obj = context && context.obj ? context.obj : null;\n    const extrasScope = context && context.extrasScope ? String(context.extrasScope) : \"extras\";\n    const source = getDeclSourceContextFromObject(obj);\n\n    const section = el(\"div\");\n    if (title) {\n      section.appendChild(el(\"div\", { className: \"muted\", text: title }));\n    }\n\n    const table = el(\"table\");\n    const thead = el(\"thead\");\n    const headRow = el(\"tr\");\n    for (const key of [\n      \"leftOperand\",\n      \"operator\",\n      \"rightOperand\",\n      \"connector\",\n      \"leftRef\",\n      \"leftDeclName\",\n      \"leftDeclDesc\",\n      \"rightRef\",\n      \"rightDeclName\",\n      \"rightDeclDesc\"\n    ]) {\n      headRow.appendChild(el(\"th\", { text: key }));\n    }\n    thead.appendChild(headRow);\n    table.appendChild(thead);\n\n    const tbody = el(\"tbody\");\n    for (let index = 0; index < items.length; index += 1) {\n      const clause = items[index];\n      const clausePath = buildExtrasEntryPathKey(obj, extrasScope, title || \"conditions\", index + 1, \"clause\");\n      let normalizedClause = clause;\n      let leftRef = clause && clause.leftOperandRef ? String(clause.leftOperandRef) : \"\";\n      let rightRef = clause && clause.rightOperandRef ? String(clause.rightOperandRef) : \"\";\n      const row = el(\"tr\");\n      const leftDecl = resolveConditionDeclForViewer(\n        clause && clause.leftOperandDecl ? clause.leftOperandDecl : null,\n        leftRef || (clause && clause.leftOperand ? clause.leftOperand : \"\")\n      );\n      const rightDecl = resolveConditionDeclForViewer(\n        clause && clause.rightOperandDecl ? clause.rightOperandDecl : null,\n        rightRef || (clause && clause.rightOperand ? clause.rightOperand : \"\")\n      );\n      let effectiveLeftDecl = leftDecl;\n      let effectiveRightDecl = rightDecl;\n\n      if (!effectiveLeftDecl || !effectiveRightDecl) {\n        normalizedClause = ensureConditionClauseDeclsWithSynthetic(clause, {\n          pathKey: clausePath,\n          file: source.file,\n          lineStart: source.lineStart,\n          raw: source.raw\n        });\n        leftRef = normalizedClause && normalizedClause.leftOperandRef ? String(normalizedClause.leftOperandRef) : leftRef;\n        rightRef = normalizedClause && normalizedClause.rightOperandRef ? String(normalizedClause.rightOperandRef) : rightRef;\n        if (!effectiveLeftDecl) {\n          effectiveLeftDecl = normalizedClause && normalizedClause.leftOperandDecl\n            ? normalizedClause.leftOperandDecl\n            : null;\n        }\n        if (!effectiveRightDecl) {\n          effectiveRightDecl = normalizedClause && normalizedClause.rightOperandDecl\n            ? normalizedClause.rightOperandDecl\n            : null;\n        }\n      }\n\n      row.appendChild(el(\"td\", { text: normalizedClause && normalizedClause.leftOperand ? String(normalizedClause.leftOperand) : \"\" }));\n      row.appendChild(el(\"td\", { text: normalizedClause && normalizedClause.comparisonOperator ? String(normalizedClause.comparisonOperator) : \"\" }));\n      row.appendChild(el(\"td\", { text: normalizedClause && normalizedClause.rightOperand ? String(normalizedClause.rightOperand) : \"\" }));\n      row.appendChild(el(\"td\", { text: normalizedClause && normalizedClause.logicalConnector ? String(normalizedClause.logicalConnector) : \"\" }));\n      row.appendChild(el(\"td\", { text: leftRef }));\n\n      const leftTraceDecls = buildDeclTraceListForObject(obj, effectiveLeftDecl);\n      const leftDeclCells = renderDeclListCells(leftTraceDecls, effectiveLeftDecl);\n      row.appendChild(leftDeclCells.nameCell);\n      row.appendChild(leftDeclCells.descCell);\n\n      row.appendChild(el(\"td\", { text: rightRef }));\n      const rightTraceDecls = buildDeclTraceListForObject(obj, effectiveRightDecl);\n      const rightDeclCells = renderDeclListCells(rightTraceDecls, effectiveRightDecl);\n      row.appendChild(rightDeclCells.nameCell);\n      row.appendChild(rightDeclCells.descCell);\n\n      tbody.appendChild(row);\n    }\n\n    table.appendChild(tbody);\n    section.appendChild(table);\n    return section;\n  }\n\n  function appendConditionSection(wrap, title, rawText, clauses, context) {\n    if (!wrap) {\n      return;\n    }\n\n    const raw = String(rawText || \"\").trim();\n    if (raw) {\n      wrap.appendChild(el(\"div\", { className: \"muted\", text: raw }));\n    }\n\n    const table = renderConditionTable(title, clauses, context);\n    if (table) {\n      wrap.appendChild(table);\n    }\n  }\n\n  function renderParamsTable(title, params) {\n    const items = Array.isArray(params) ? params : [];\n    if (!items.length) {\n      return null;\n    }\n\n    const section = el(\"div\");\n    section.appendChild(el(\"div\", { className: \"muted\", text: title }));\n\n    const table = el(\"table\");\n    const thead = el(\"thead\");\n    const headRow = el(\"tr\");\n    for (const key of [\"section\", \"name\", \"typing\", \"doc\", \"declName\", \"declDesc\"]) {\n      headRow.appendChild(el(\"th\", { text: key }));\n    }\n    thead.appendChild(headRow);\n    table.appendChild(thead);\n\n    const tbody = el(\"tbody\");\n    for (const param of items) {\n      const row = el(\"tr\");\n      row.appendChild(el(\"td\", { text: param && param.section ? String(param.section) : \"\" }));\n      row.appendChild(el(\"td\", { text: param && param.name ? String(param.name) : \"\" }));\n      const typingText = formatTyping(param && param.typing);\n      row.appendChild(el(\"td\", { text: typingText }));\n      const docText = param && param.doc\n        ? [param.doc.direction || \"\", param.doc.text || \"\"].filter(Boolean).join(\" \")\n        : \"\";\n      row.appendChild(el(\"td\", { text: docText }));\n      const { nameCell, descCell } = renderDeclListCells(param && param.originDecls);\n      row.appendChild(nameCell);\n      row.appendChild(descCell);\n      tbody.appendChild(row);\n    }\n    table.appendChild(tbody);\n    section.appendChild(table);\n    return section;\n  }\n\n  function formatTyping(typing) {\n    if (!typing) {\n      return \"\";\n    }\n    if (typeof typing === \"string\") {\n      return typing;\n    }\n    if (Array.isArray(typing)) {\n      return typing.map((item) => formatTyping(item)).filter(Boolean).join(\" \");\n    }\n    if (typeof typing === \"object\") {\n      const kind = typing.kind ? String(typing.kind) : \"\";\n      let value = \"\";\n\n      if (typeof typing.value === \"string\") {\n        value = typing.value;\n      } else if (typing.value && typeof typing.value === \"object\") {\n        if (typeof typing.value.value === \"string\") {\n          value = typing.value.value;\n        } else if (typeof typing.value.raw === \"string\") {\n          value = typing.value.raw;\n        } else if (typeof typing.value.name === \"string\") {\n          value = typing.value.name;\n        } else {\n          value = safeJson(typing.value, false);\n        }\n      } else if (typing.value !== undefined && typing.value !== null) {\n        value = String(typing.value);\n      }\n\n      return [kind, value].filter(Boolean).join(\" \").trim();\n    }\n    return String(typing);\n  }\n\n  function renderNameList(title, items) {\n    const list = Array.isArray(items) ? items : [];\n    if (!list.length) {\n      return null;\n    }\n\n    const section = el(\"div\");\n    section.appendChild(el(\"div\", { className: \"muted\", text: title }));\n\n    const wrap = el(\"div\");\n    for (const entry of list) {\n      wrap.appendChild(el(\"span\", { className: \"pill\", text: entry && entry.name ? String(entry.name) : \"\" }));\n    }\n    section.appendChild(wrap);\n    return section;\n  }\n\n  function renderExtras(obj) {\n    const extras = obj.extras;\n    if (!extras || typeof extras !== \"object\") {\n      return null;\n    }\n\n    const wrap = el(\"div\", { className: \"extras\" });\n    wrap.appendChild(el(\"div\", { className: \"muted\", text: \"Extras\" }));\n\n    if (extras.form) {\n      const form = extras.form;\n      const titleParts = [form.name ? `FORM ${form.name}` : \"\"].filter(Boolean);\n      if (form.nameFromComment && form.nameFromComment !== form.name) {\n        titleParts.push(`(comment: ${form.nameFromComment})`);\n      }\n      if (titleParts.length) {\n        wrap.appendChild(el(\"div\", { className: \"muted\", text: titleParts.join(\" \") }));\n      }\n\n      const paramsTable = renderParamsTable(\"params\", form.params);\n      if (paramsTable) {\n        wrap.appendChild(paramsTable);\n      }\n\n      const exceptions = renderNameList(\"exceptions\", form.exceptions);\n      if (exceptions) {\n        wrap.appendChild(exceptions);\n      }\n\n      return wrap;\n    }\n\n    if (extras.methodSignature) {\n      const signature = extras.methodSignature;\n      if (signature.name) {\n        wrap.appendChild(el(\"div\", { className: \"muted\", text: `METHOD ${signature.name}` }));\n      }\n\n      const paramsTable = renderParamsTable(\"params\", signature.params);\n      if (paramsTable) {\n        wrap.appendChild(paramsTable);\n      }\n\n      const exceptions = renderNameList(\"exceptions\", signature.exceptions);\n      if (exceptions) {\n        wrap.appendChild(exceptions);\n      }\n\n      return wrap;\n    }\n\n    if (extras.callFunction) {\n      const call = extras.callFunction;\n      wrap.appendChild(el(\"div\", { className: \"muted\", text: call.name ? `CALL FUNCTION ${call.name}` : \"CALL FUNCTION\" }));\n      if (call.destination) {\n        wrap.appendChild(el(\"div\", { className: \"muted\", text: `DESTINATION ${call.destination}` }));\n      }\n\n      for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"tables\", \"exceptions\"]) {\n        const table = renderAssignmentTable(sectionName, call[sectionName], { obj, extrasScope: \"callFunction\" });\n        if (table) {\n          wrap.appendChild(table);\n        }\n      }\n\n      return wrap;\n    }\n\n    if (extras.callMethod) {\n      const call = extras.callMethod;\n      wrap.appendChild(el(\"div\", { className: \"muted\", text: call.target ? `CALL METHOD ${call.target}` : \"CALL METHOD\" }));\n\n      for (const sectionName of [\"exporting\", \"importing\", \"changing\", \"receiving\", \"exceptions\"]) {\n        const table = renderAssignmentTable(sectionName, call[sectionName], { obj, extrasScope: \"callMethod\" });\n        if (table) {\n          wrap.appendChild(table);\n        }\n      }\n\n      return wrap;\n    }\n\n    if (extras.performCall) {\n      const call = extras.performCall;\n      wrap.appendChild(el(\"div\", { className: \"muted\", text: call.form ? `PERFORM ${call.form}` : \"PERFORM\" }));\n      if (call.program) {\n        wrap.appendChild(el(\"div\", { className: \"muted\", text: `IN PROGRAM ${call.program}` }));\n      }\n      appendConditionSection(\n        wrap,\n        \"ifConditions\",\n        call.ifCondition ? `IF ${call.ifCondition}` : \"\",\n        call.ifConditions,\n        { obj, extrasScope: \"performCall\" }\n      );\n\n      for (const sectionName of [\"using\", \"changing\", \"tables\"]) {\n        const table = renderValueListTable(sectionName, call[sectionName], { obj, extrasScope: \"performCall\" });\n        if (table) {\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/output/07-render-tree.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const partKey = "viewer/app/output/07-render-tree.js";
  const bucket = registry[targetKey] = registry[targetKey] || {};
  bucket[partKey] = "          wrap.appendChild(table);\n        }\n      }\n\n      return wrap;\n    }\n\n    if (extras.ifCondition) {\n      const info = extras.ifCondition;\n      appendConditionSection(\n        wrap,\n        \"conditions\",\n        info.conditionRaw ? `IF ${info.conditionRaw}` : \"\",\n        info.conditions,\n        { obj, extrasScope: \"ifCondition\" }\n      );\n      return wrap;\n    }\n\n    if (extras.select) {\n      const info = extras.select;\n      appendConditionSection(\n        wrap,\n        \"whereConditions\",\n        info.whereRaw ? `WHERE ${info.whereRaw}` : \"\",\n        info.whereConditions,\n        { obj, extrasScope: \"select.where\" }\n      );\n      appendConditionSection(\n        wrap,\n        \"havingConditions\",\n        info.havingRaw ? `HAVING ${info.havingRaw}` : \"\",\n        info.havingConditions,\n        { obj, extrasScope: \"select.having\" }\n      );\n      return wrap;\n    }\n\n    if (extras.readTable) {\n      const info = extras.readTable;\n      const raw = info.withTableKeyRaw\n        ? `WITH TABLE KEY ${info.withTableKeyRaw}`\n        : (info.withKeyRaw ? `WITH KEY ${info.withKeyRaw}` : \"\");\n      appendConditionSection(wrap, \"conditions\", raw, info.conditions, { obj, extrasScope: \"readTable\" });\n      return wrap;\n    }\n\n    if (extras.loopAtItab) {\n      const info = extras.loopAtItab;\n      appendConditionSection(\n        wrap,\n        \"conditions\",\n        info.whereRaw ? `WHERE ${info.whereRaw}` : \"\",\n        info.conditions,\n        { obj, extrasScope: \"loopAtItab\" }\n      );\n      return wrap;\n    }\n\n    if (extras.modifyItab) {\n      const info = extras.modifyItab;\n      appendConditionSection(\n        wrap,\n        \"conditions\",\n        info.whereRaw ? `WHERE ${info.whereRaw}` : \"\",\n        info.conditions,\n        { obj, extrasScope: \"modifyItab\" }\n      );\n      return wrap;\n    }\n\n    if (extras.deleteItab) {\n      const info = extras.deleteItab;\n      appendConditionSection(\n        wrap,\n        \"conditions\",\n        info.whereRaw ? `WHERE ${info.whereRaw}` : \"\",\n        info.conditions,\n        { obj, extrasScope: \"deleteItab\" }\n      );\n      return wrap;\n    }\n\n    wrap.appendChild(el(\"pre\", { text: safeJson(extras, true) }));\n    return wrap;\n  }\n\n  function renderMeta(obj) {\n    const parts = [];\n    if (obj.file) {\n      parts.push(String(obj.file));\n    }\n    if (obj.lineStart) {\n      parts.push(`line ${obj.lineStart}`);\n    }\n    if (obj.block && obj.block.lineEnd) {\n      parts.push(`end ${obj.block.lineEnd}`);\n    }\n    if (obj.id !== undefined && obj.id !== null) {\n      parts.push(`#${obj.id}`);\n    }\n    return parts.join(\" • \");\n  }\n\n  function getObjectLabel(obj) {\n    for (const key of [\"name\", \"target\", \"form\"]) {\n      const value = getFirstValueFromValues(obj.values, key);\n      if (value) {\n        return value;\n      }\n    }\n\n    if (obj.extras && obj.extras.callFunction && obj.extras.callFunction.name) {\n      return String(obj.extras.callFunction.name);\n    }\n    if (obj.extras && obj.extras.callMethod && obj.extras.callMethod.target) {\n      return String(obj.extras.callMethod.target);\n    }\n    if (obj.extras && obj.extras.performCall && obj.extras.performCall.form) {\n      return String(obj.extras.performCall.form);\n    }\n    if (obj.extras && obj.extras.form && obj.extras.form.name) {\n      return String(obj.extras.form.name);\n    }\n    if (obj.extras && obj.extras.methodSignature && obj.extras.methodSignature.name) {\n      return String(obj.extras.methodSignature.name);\n    }\n\n    return \"\";\n  }\n\n  function renderNode(nodeInfo) {\n    const obj = nodeInfo.obj;\n    const id = normalizeId(obj.id);\n    const children = nodeInfo.children || [];\n\n    const cardAttrs = {};\n    if (id) {\n      cardAttrs[\"data-id\"] = id;\n    }\n    if (obj && obj.lineStart) {\n      cardAttrs[\"data-line-start\"] = String(obj.lineStart);\n    }\n\n    const card = el(\"div\", {\n      className: `card${obj.block ? \" block\" : \"\"}${id && id === state.selectedId ? \" selected\" : \"\"}`,\n      attrs: Object.keys(cardAttrs).length ? cardAttrs : {}\n    });\n\n    const header = el(\"div\", { className: \"card-header\" });\n    const label = getObjectLabel(obj);\n    const titleText = `${String(obj.objectType || \"(unknown)\")}${label ? ` ${label}` : \"\"}`;\n    const title = el(\"h3\", { className: \"card-title\", text: titleText });\n\n    const meta = renderMeta(obj);\n    if (meta) {\n      title.appendChild(el(\"span\", { className: \"muted\", text: `  (${meta})` }));\n    }\n\n    header.appendChild(title);\n\n    const actions = el(\"div\", { className: \"card-actions\" });\n\n    const btnCode = el(\"button\", { className: \"btn-ghost\", text: \"Code\" });\n    btnCode.type = \"button\";\n    btnCode.addEventListener(\"click\", (ev) => {\n      ev.stopPropagation();\n      setSelectedCard(id);\n      const lineEnd = obj.block && obj.block.lineEnd ? obj.block.lineEnd : obj.lineStart;\n      selectCodeLines(obj.lineStart, lineEnd);\n    });\n    actions.appendChild(btnCode);\n\n    const btnJson = el(\"button\", { className: \"btn-ghost\", text: \"JSON\" });\n    btnJson.type = \"button\";\n    btnJson.addEventListener(\"click\", (ev) => {\n      ev.stopPropagation();\n      setSelectedCard(id);\n      openJsonModal(obj);\n    });\n    actions.appendChild(btnJson);\n\n    if (children.length) {\n      const isCollapsed = state.collapsedIds.has(id);\n      const btnCollapse = el(\"button\", { className: \"btn-ghost\", text: isCollapsed ? \"Expand\" : \"Collapse\" });\n      btnCollapse.type = \"button\";\n      btnCollapse.addEventListener(\"click\", (ev) => {\n        ev.stopPropagation();\n        if (state.collapsedIds.has(id)) {\n          state.collapsedIds.delete(id);\n        } else {\n          state.collapsedIds.add(id);\n        }\n        renderOutput();\n        setSelectedCard(id);\n      });\n      actions.appendChild(btnCollapse);\n    }\n\n    header.appendChild(actions);\n    card.appendChild(header);\n\n    if (obj.comment) {\n      card.appendChild(el(\"div\", { className: \"muted\", text: String(obj.comment) }));\n    }\n\n    if (state.showKeywords) {\n      const kw = renderKeywords(obj);\n      if (kw) {\n        card.appendChild(kw);\n      }\n    }\n\n    if (state.showValues) {\n      const valuesTable = renderValues(obj);\n      if (valuesTable) {\n        card.appendChild(valuesTable);\n      }\n    }\n\n    if (state.showRaw && obj.raw) {\n      card.appendChild(el(\"div\", { className: \"raw\", text: String(obj.raw) }));\n    }\n\n    if (state.showExtras) {\n      const extras = renderExtras(obj);\n      if (extras) {\n        card.appendChild(extras);\n      }\n    }\n\n    if (children.length && !state.collapsedIds.has(id)) {\n      const childWrap = el(\"div\", { className: \"children\" });\n      for (const child of children) {\n        childWrap.appendChild(renderNode(child));\n      }\n      card.appendChild(childWrap);\n    }\n\n    card.addEventListener(\"click\", () => setSelectedCard(id));\n    return card;\n  }\n\n  function populateTypeFilter(objects) {\n    const types = new Set();\n    walkObjects(objects, (obj) => {\n      if (obj && obj.objectType) {\n        types.add(String(obj.objectType));\n      }\n    });\n\n    const sorted = Array.from(types).sort((a, b) => a.localeCompare(b));\n    const current = els.typeFilter.value || \"\";\n\n    while (els.typeFilter.options.length > 1) {\n      els.typeFilter.remove(1);\n    }\n\n    for (const type of sorted) {\n      const opt = document.createElement(\"option\");\n      opt.value = type;\n      opt.textContent = type;\n      els.typeFilter.appendChild(opt);\n    }\n\n    els.typeFilter.value = sorted.includes(current) ? current : \"\";\n  }\n\n  function renderOutput() {\n    const scrollTop = els.output.scrollTop;\n    setError(\"\");\n\n    if (!state.data || !Array.isArray(state.renderObjects)) {\n      setOutputMessage(\"No data loaded.\");\n      refreshInputGutterTargets();\n      return;\n    }\n\n    state.query = (els.searchInput.value || \"\").trim().toLowerCase();\n    state.type = els.typeFilter.value || \"\";\n    state.showRaw = Boolean(els.showRaw && els.showRaw.checked);\n    state.showKeywords = Boolean(els.showKeywords && els.showKeywords.checked);\n    state.showValues = Boolean(els.showValues && els.showValues.checked);\n    state.showExtras = Boolean(els.showExtras && els.showExtras.checked);\n\n    const filteredRoots = (state.renderObjects || [])\n      .map((obj) => filterTree(obj))\n      .filter(Boolean);\n\n    if (!filteredRoots.length) {\n      setOutputMessage(\"No matches.\");\n      refreshInputGutterTargets();\n      return;\n    }\n\n    const frag = document.createDocumentFragment();\n    for (const root of filteredRoots) {\n      frag.appendChild(renderNode(root));\n    }\n\n    els.output.classList.remove(\"muted\");\n    els.output.replaceChildren(frag);\n    els.output.scrollTop = scrollTop;\n\n    if (state.selectedId) {\n      setSelectedCard(state.selectedId, { scroll: false });\n    }\n\n    refreshInputGutterTargets();\n  }\n\n  function normalizeParsedJson(json) {\n    if (Array.isArray(json)) {\n      return { file: \"\", objects: json, decls: [] };\n    }\n    if (json && typeof json === \"object\" && Array.isArray(json.objects)) {\n      return {\n        file: String(json.file || \"\"),\n        objects: json.objects,\n        decls: Array.isArray(json.decls) ? json.decls : []\n      };\n    }\n    return null;\n  }\n\nwindow.AbapViewerModules.factories = window.AbapViewerModules.factories || {};\nwindow.AbapViewerModules.factories[\"04-output-render\"] = function registerOutputRender(runtime) {\n  const targetRuntime = runtime || (window.AbapViewerRuntime = window.AbapViewerRuntime || {});\n  targetRuntime.api = targetRuntime.api || {};\n  targetRuntime.api.renderOutput = renderOutput;\n  targetRuntime.api.buildAbapFlowXml = buildAbapFlowXml;\n  targetRuntime.api.setRightTab = setRightTab;\n  window.AbapViewerModules.parts[\"04-output-render\"] = true;\n};\nwindow.AbapViewerModules.factories[\"04-output-render\"](window.AbapViewerRuntime);\n\n";
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/04-output-render.js
"use strict";

(function (root) {
  const globalRoot = root || (typeof globalThis !== "undefined" ? globalThis : this);
  const registry = globalRoot.__AbapSourceParts || {};
  const targetKey = "viewer/app/04-output-render.js";
  const bucket = registry[targetKey] || {};
  const orderedParts = [
    "viewer/app/output/01-xml-export.js",
    "viewer/app/output/02-search-index.js",
    "viewer/app/output/03-selection-gutter.js",
    "viewer/app/output/04-render-shared.js",
    "viewer/app/output/05-render-values.js",
    "viewer/app/output/06-render-extras.js",
    "viewer/app/output/07-render-tree.js"
  ];

  const missing = orderedParts.filter((part) => typeof bucket[part] !== "string");
  if (missing.length) {
    const message = `Source parts missing for ${targetKey}: ${missing.join(", ")}`;
    try {
      if (globalRoot.console && typeof globalRoot.console.error === "function") {
        globalRoot.console.error(message);
      }
    } catch {
      // ignore
    }
    return;
  }

  const source = orderedParts.map((part) => bucket[part]).join("\n");
  if (typeof document !== "undefined" && document.createElement) {
    const script = document.createElement("script");
    script.type = "text/javascript";
    script.setAttribute("data-abap-source-wrapper", targetKey);
    script.textContent = `${source}\n//# sourceURL=${targetKey}`;
    (document.head || document.documentElement || document.body).appendChild(script);
    script.remove();
  } else {
    (0, eval)(source);
  }
})(typeof globalThis !== "undefined" ? globalThis : (typeof self !== "undefined" ? self : this));
</script>
  <script>
// inlined from: ./app/05-main.js
"use strict";

window.AbapViewerModules = window.AbapViewerModules || {};
window.AbapViewerModules.parts = window.AbapViewerModules.parts || {};

  function parseFromTextarea(fileName) {
    const content = els.inputText.value || "";
    const trimmed = content.trim();
    const isJsonInput = (trimmed.startsWith("{") || trimmed.startsWith("[")) && trimmed.length > 1;
    state.inputMode = isJsonInput ? "json" : "abap";
    rebuildInputGutter();
    if (!trimmed) {
      setError("Input is empty.");
      setOutputMessage("No data loaded.");
      return;
    }

    state.inputLineOffsets = computeLineOffsets(content);

    if (isJsonInput) {
      try {
        const json = JSON.parse(trimmed);
        const parsed = normalizeParsedJson(json);
        if (!parsed) {
          throw new Error("JSON parsed, but shape is not { file, objects[] } or objects[].");
        }
        state.data = parsed;
      } catch (err) {
        setError(`JSON parse error: ${err && err.message ? err.message : err}`);
        setOutputMessage("No data loaded.");
        return;
      }
    } else {
      if (!window.AbapParser || typeof window.AbapParser.parseAbapText !== "function") {
        setError("AbapParser not loaded.");
        setOutputMessage("No data loaded.");
        return;
      }

      try {
        const builtInConfigs = typeof window.AbapParser.getConfigs === "function" ? window.AbapParser.getConfigs() : [];
        const customConfigs = getCustomConfigs();
        const configs = [...customConfigs, ...builtInConfigs];
        state.data = window.AbapParser.parseAbapText(content, configs, fileName || "");
      } catch (err) {
        setError(`Parse error: ${err && err.message ? err.message : err}`);
        setOutputMessage("No data loaded.");
        return;
      }
    }

    state.collapsedIds.clear();
    state.selectedId = "";
    state.selectedTemplateIndex = "";
    state.renderObjects = buildRenderableObjects(state.data && state.data.objects, RENDER_TREE_OPTIONS);
    state.haystackById = buildSearchIndex(state.renderObjects);
    populateTypeFilter(state.renderObjects);
    renderOutput();
    if (state.rightTab === "descriptions") {
      renderDeclDescPanelUi();
    } else if (state.rightTab === "template") {
      renderTemplatePreview();
    }
  }

  function resetUi() {
    els.searchInput.value = "";
    els.typeFilter.value = "";
    els.showRaw.checked = true;
    els.showKeywords.checked = true;
    els.showValues.checked = true;
    els.showExtras.checked = false;
    state.collapsedIds.clear();
    state.selectedId = "";
  }

  function collapseAll() {
    state.collapsedIds.clear();
    walkObjects(state.renderObjects, (obj) => {
      const id = normalizeId(obj && obj.id);
      const children = Array.isArray(obj && obj.children) ? obj.children : [];
      if (id && children.length) {
        state.collapsedIds.add(id);
      }
    });
  }

  function init() {
    renderBuildInfo();
    state.descOverrides = loadDescOverrides();
    state.descOverridesLegacy = loadLegacyDescOverrides();
    state.customRules = loadCustomRules();
    state.settings = loadSettings();
    state.templateConfig = loadTemplateConfig();
    state.templatePreviewCache = null;
    applyTheme(loadTheme(), { save: false });
    initLayoutSplitter();

    if (els.templateKeyMode) {
      els.templateKeyMode.textContent = "AUTO: objectType -> DEFAULT";
    }
    syncTemplateEditorFromState();
    setTemplateConfigError("");

    if (els.inputText && !els.inputText.value.trim()) {
      els.inputText.value = SAMPLE_ABAP;
    }

    rebuildInputGutter();

    if (els.inputText) {
      els.inputText.addEventListener("input", rebuildInputGutter);
      els.inputText.addEventListener("scroll", syncInputGutterScroll);
    }

    if (els.inputGutter) {
      els.inputGutter.addEventListener("click", onInputGutterClick);
      els.inputGutter.addEventListener("wheel", (ev) => {
        if (!els.inputText) {
          return;
        }
        els.inputText.scrollTop += ev.deltaY;
        syncInputGutterScroll();
        ev.preventDefault();
      }, { passive: false });
    }

    if (els.themeToggle) {
      els.themeToggle.addEventListener("change", () => {
        applyTheme(els.themeToggle.checked ? "dark" : "light");
      });
    }

    els.parseBtn.addEventListener("click", () => parseFromTextarea("input.abap"));
    els.searchInput.addEventListener("input", renderOutput);
    els.typeFilter.addEventListener("change", renderOutput);
    els.showRaw.addEventListener("change", renderOutput);
    els.showKeywords.addEventListener("change", renderOutput);
    els.showValues.addEventListener("change", renderOutput);
    els.showExtras.addEventListener("change", renderOutput);

    els.expandAllBtn.addEventListener("click", () => {
      state.collapsedIds.clear();
      renderOutput();
    });

    els.collapseAllBtn.addEventListener("click", () => {
      if (!state.data) {
        return;
      }
      collapseAll();
      renderOutput();
    });

    els.clearFiltersBtn.addEventListener("click", () => {
      resetUi();
      renderOutput();
    });

    els.descBtn.addEventListener("click", () => {
      setRightTab("descriptions");
    });

    if (els.rightTabOutputBtn) {
      els.rightTabOutputBtn.addEventListener("click", () => setRightTab("output"));
    }

    if (els.rightTabTemplateBtn) {
      els.rightTabTemplateBtn.addEventListener("click", () => setRightTab("template"));
    }

    if (els.rightTabDescBtn) {
      els.rightTabDescBtn.addEventListener("click", () => setRightTab("descriptions"));
    }

    if (els.templateCopyAllBtn) {
      els.templateCopyAllBtn.addEventListener("click", () => {
        copyAllTemplateBlocks()
          .then(() => setError(""))
          .catch((err) => setError(`Copy failed: ${err && err.message ? err.message : err}`));
      });
    }

    if (els.templateResetBtn) {
      els.templateResetBtn.addEventListener("click", resetTemplateConfig);
    }

    if (els.templateExportBtn) {
      els.templateExportBtn.addEventListener("click", exportTemplateConfig);
    }

    if (els.templateImportBtn && els.templateImportInput) {
      els.templateImportBtn.addEventListener("click", () => {
        els.templateImportInput.click();
      });
    }

    if (els.templateImportInput) {
      els.templateImportInput.addEventListener("change", async (ev) => {
        const file = ev && ev.target && ev.target.files ? ev.target.files[0] : null;
        if (!file) {
          return;
        }
        await importTemplateConfigFromFile(file);
        els.templateImportInput.value = "";
      });
    }

    if (els.templateApplyBtn) {
      els.templateApplyBtn.addEventListener("click", applyTemplateConfigFromEditor);
    }

    if (els.templateConfigJson) {
      els.templateConfigJson.addEventListener("keydown", (ev) => {
        if ((ev.ctrlKey || ev.metaKey) && ev.key === "Enter") {
          ev.preventDefault();
          applyTemplateConfigFromEditor();
        }
      });
    }

    if (els.declDescJsonBtn) {
      els.declDescJsonBtn.addEventListener("click", () => {
        openJsonModal({
          storageKey: DESC_STORAGE_KEY_V2,
          overrides: state.descOverrides,
          legacyStorageKey: DESC_STORAGE_KEY_LEGACY_V1,
          legacyOverrides: state.descOverridesLegacy,
          registry: window.AbapVarDescriptions || {}
        });
      });
    }

    if (els.declDescSearch) {
      els.declDescSearch.addEventListener("input", renderDeclDescPanelUi);
    }

    if (els.declDescMissingOnly) {
      els.declDescMissingOnly.addEventListener("change", renderDeclDescPanelUi);
    }

    if (els.rulesBtn) {
      els.rulesBtn.addEventListener("click", openRulesModal);
    }

    if (els.settingsBtn) {
      els.settingsBtn.addEventListener("click", openSettingsModal);
    }

    if (els.exportXmlBtn) {
      els.exportXmlBtn.addEventListener("click", () => {
        if (!state.data || !Array.isArray(state.data.objects)) {
          setError("No parsed data to export. Click Render first.");
          return;
        }
        setError("");
        openTextModal("Export XML", buildAbapFlowXml(state.data));
      });
    }

    els.fileInput.addEventListener("change", async (ev) => {
      const file = ev.target && ev.target.files ? ev.target.files[0] : null;
      if (!file) {
        return;
      }
      const text = await file.text();
      els.inputText.value = text;
      parseFromTextarea(file.name || "");
    });

    if (els.rulesCloseBtn) {
      els.rulesCloseBtn.addEventListener("click", closeRulesModal);
    }
    if (els.rulesModal) {
      els.rulesModal.addEventListener("click", (ev) => {
        if (ev.target === els.rulesModal) {
          closeRulesModal();
        }
      });
    }

    if (els.settingsCloseBtn) {
      els.settingsCloseBtn.addEventListener("click", closeSettingsModal);
    }
    if (els.settingsSaveBtn) {
      els.settingsSaveBtn.addEventListener("click", () => {
        applySettingsFromModal();
        closeSettingsModal();
      });
    }
    if (els.settingsResetBtn) {
      els.settingsResetBtn.addEventListener("click", resetSettingsToDefault);
    }
    if (els.settingsModal) {
      els.settingsModal.addEventListener("click", (ev) => {
        if (ev.target === els.settingsModal) {
          closeSettingsModal();
        }
      });
    }
    if (els.rulesNewBtn) {
      els.rulesNewBtn.addEventListener("click", startNewRule);
    }
    if (els.rulesSaveBtn) {
      els.rulesSaveBtn.addEventListener("click", saveRuleFromEditor);
    }
    if (els.rulesDeleteBtn) {
      els.rulesDeleteBtn.addEventListener("click", deleteActiveRule);
    }
    if (els.rulesDownloadBtn) {
      els.rulesDownloadBtn.addEventListener("click", downloadRuleFromEditor);
    }
    if (els.rulesSelect) {
      els.rulesSelect.addEventListener("change", () => {
        const id = els.rulesSelect.value || "";
        if (!id) {
          startNewRule();
          return;
        }
        selectRule(id);
      });
    }
    if (els.rulesTemplate) {
      els.rulesTemplate.addEventListener("change", () => {
        if (!state.activeRuleId) {
          startNewRule();
        }
      });
    }
    if (els.rulesJson) {
      els.rulesJson.addEventListener("keydown", (ev) => {
        if ((ev.ctrlKey || ev.metaKey) && ev.key === "Enter") {
          ev.preventDefault();
          saveRuleFromEditor();
        }
      });
    }

    els.jsonCloseBtn.addEventListener("click", closeJsonModal);
    els.jsonModal.addEventListener("click", (ev) => {
      if (ev.target === els.jsonModal) {
        closeJsonModal();
      }
    });
    els.jsonCopyBtn.addEventListener("click", () => {
      copyJsonToClipboard().catch((err) => setError(err && err.message ? err.message : err));
    });

    els.editCancelBtn.addEventListener("click", closeEditModal);
    els.editModal.addEventListener("click", (ev) => {
      if (ev.target === els.editModal) {
        closeEditModal();
      }
    });
    els.editSaveBtn.addEventListener("click", () => {
      applyEditModal("save");
      closeEditModal();
    });
    els.editClearBtn.addEventListener("click", () => {
      applyEditModal("clear");
      closeEditModal();
    });

    const onEditKeydown = (ev) => {
      if ((ev.ctrlKey || ev.metaKey) && ev.key === "Enter") {
        ev.preventDefault();
        applyEditModal("save");
        closeEditModal();
      }
    };

    els.editDesc.addEventListener("keydown", onEditKeydown);
    if (els.editStructDesc) {
      els.editStructDesc.addEventListener("keydown", onEditKeydown);
    }
    if (els.editItemDesc) {
      els.editItemDesc.addEventListener("keydown", onEditKeydown);
    }

    window.addEventListener("keydown", (ev) => {
      if (ev.key !== "Escape") {
        return;
      }

      if (!els.editModal.hidden) {
        closeEditModal();
        return;
      }

      if (els.rulesModal && !els.rulesModal.hidden) {
        closeRulesModal();
        return;
      }

      if (!els.jsonModal.hidden) {
        closeJsonModal();
        return;
      }

      if (state.rightTab === "descriptions" || state.rightTab === "template") {
        setRightTab("output");
        return;
      }
    });

    setRightTab(state.rightTab);
    parseFromTextarea("sample.abap");
  }

window.AbapViewerModules.factories = window.AbapViewerModules.factories || {};
window.AbapViewerModules.factories["05-main"] = function registerMain(runtime) {
  const targetRuntime = runtime || (window.AbapViewerRuntime = window.AbapViewerRuntime || {});
  targetRuntime.api = targetRuntime.api || {};
  targetRuntime.api.parseFromTextarea = parseFromTextarea;
  targetRuntime.api.init = init;

  window.AbapViewerModules.start = function startAbapViewer() {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", init, { once: true });
    } else {
      init();
    }
  };
  window.AbapViewerModules.parts["05-main"] = true;
};
window.AbapViewerModules.factories["05-main"](window.AbapViewerRuntime);
</script>
  <script>
// inlined from: ./app.js
"use strict";

(function () {
  window.AbapViewerModules = window.AbapViewerModules || {};
  window.AbapViewerModules.parts = window.AbapViewerModules.parts || {};
  window.AbapViewerRuntime = window.AbapViewerRuntime || {};
  window.AbapViewerRuntime.api = window.AbapViewerRuntime.api || {};

  const requiredParts = [
    "01-core",
    "02-descriptions",
    "03-template-preview",
    "04-output-render",
    "05-main"
  ];

  const missing = requiredParts.filter((name) => !window.AbapViewerModules.parts[name]);
  if (missing.length) {
    const message = `Viewer modules missing: ${missing.join(", ")}. Check script order in viewer/index.html.`;
    const errorEl = document.getElementById("error");
    if (errorEl) {
      errorEl.textContent = message;
    }
    try {
      console.error(message);
    } catch {
      // ignore
    }
    return;
  }

  const runtime = window.AbapViewerRuntime;
  runtime.els = runtime.els || null;
  runtime.state = runtime.state || null;
  runtime.constants = runtime.constants || {};
  runtime.api = runtime.api || {};

  if (typeof window.AbapViewerModules.start !== "function") {
    const message = "Viewer start function not found (window.AbapViewerModules.start).";
    const errorEl = document.getElementById("error");
    if (errorEl) {
      errorEl.textContent = message;
    }
    try {
      console.error(message);
    } catch {
      // ignore
    }
    return;
  }

  window.AbapViewerModules.start(runtime);
})();
</script>
</body>
</html>

